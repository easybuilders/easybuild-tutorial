{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the official EasyBuild tutorial! \u00b6 Scope \u00b6 This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way. Intended audience \u00b6 This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems Prerequisites \u00b6 We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source EasyBuild requires: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here Contributors \u00b6 Sebastian Achilles ( @SebastianAchilles , J\u00fclich Supercomputing Centre, Germany ) Maxime Boissonneault ( @mboisson , Compute Canada ) Miguel Dias Costa ( @migueldiascosta , National University of Singapore ) Markus Geimer ( @geimer , J\u00fclich Supercomputing Centre, Germany ) Kenneth Hoste ( @boegel , HPC-UGent, Belgium ) Michael Kelsey ( @kelseymh , Texas A&M University, US ) Christian Kniep ( @ChristianKniep , AWS ) Terje Kvernes ( @terjekv , University of Oslo, Norway ) Kurt Lust ( @klust , University of Antwerp, Belgium ) Alan O'Cais ( @ocaisa , J\u00fclich Supercomputing Centre, Germany ) Bart Oldeman ( @bartoldeman , Compute Canada ) \u00c5ke Sandgren ( @akesandgren , Ume\u00e5 University, Sweden ) Additional resources \u00b6 website: https://easybuild.io documentation: https://docs.easybuild.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite via https://easybuild.io/join-slack ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":"Home"},{"location":"#welcome-to-the-official-easybuild-tutorial","text":"","title":"Welcome to the official EasyBuild tutorial!"},{"location":"#scope","text":"This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way.","title":"Scope"},{"location":"#intended-audience","text":"This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems","title":"Intended audience"},{"location":"#prerequisites","text":"We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source EasyBuild requires: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here","title":"Prerequisites"},{"location":"#contributors","text":"Sebastian Achilles ( @SebastianAchilles , J\u00fclich Supercomputing Centre, Germany ) Maxime Boissonneault ( @mboisson , Compute Canada ) Miguel Dias Costa ( @migueldiascosta , National University of Singapore ) Markus Geimer ( @geimer , J\u00fclich Supercomputing Centre, Germany ) Kenneth Hoste ( @boegel , HPC-UGent, Belgium ) Michael Kelsey ( @kelseymh , Texas A&M University, US ) Christian Kniep ( @ChristianKniep , AWS ) Terje Kvernes ( @terjekv , University of Oslo, Norway ) Kurt Lust ( @klust , University of Antwerp, Belgium ) Alan O'Cais ( @ocaisa , J\u00fclich Supercomputing Centre, Germany ) Bart Oldeman ( @bartoldeman , Compute Canada ) \u00c5ke Sandgren ( @akesandgren , Ume\u00e5 University, Sweden )","title":"Contributors"},{"location":"#additional-resources","text":"website: https://easybuild.io documentation: https://docs.easybuild.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite via https://easybuild.io/join-slack ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":"Additional resources"},{"location":"2020-06-isc20/","text":"Welcome to the official EasyBuild tutorial! \u00b6 Notes \u00b6 For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises ( only during the live tutorial on June 23rd 2020! ); A container image is available that can be run using either Docker or Singularity, which provides a prepared environment that can be used for the hands-on exercises in this tutorial. Tutorial contents \u00b6 ( Practical information ) Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild community Contributing to EasyBuild Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises) Recordings \u00b6 This introductory tutorial to EasyBuild was streamed on Tuesday June 23rd 2020. The recordings are available on YouTube. See https://github.com/easybuilders/easybuild/wiki/EasyBuild-tutorial for more information.","title":"Start page"},{"location":"2020-06-isc20/#welcome-to-the-official-easybuild-tutorial","text":"","title":"Welcome to the official EasyBuild tutorial!"},{"location":"2020-06-isc20/#notes","text":"For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises ( only during the live tutorial on June 23rd 2020! ); A container image is available that can be run using either Docker or Singularity, which provides a prepared environment that can be used for the hands-on exercises in this tutorial.","title":"Notes"},{"location":"2020-06-isc20/#tutorial-contents","text":"( Practical information ) Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild community Contributing to EasyBuild Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises)","title":"Tutorial contents"},{"location":"2020-06-isc20/#recordings","text":"This introductory tutorial to EasyBuild was streamed on Tuesday June 23rd 2020. The recordings are available on YouTube. See https://github.com/easybuilders/easybuild/wiki/EasyBuild-tutorial for more information.","title":"Recordings"},{"location":"2020-06-isc20/adding_support_software/","text":"Adding support for additional software \u00b6 We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves! Easyconfigs vs easyblocks \u00b6 Before we dive into writing easyconfig files , let us take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild which specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in a general sense since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a paritcular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; toolchain-specific aspects of the build and installation procedure (e.g., configure options); interactive commands that need to be run; custom (configure) options for dependencies; having to create or adjust specific (configuration) files; 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation . Writing easyconfig files \u00b6 Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them. Mandatory parameters \u00b6 A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 9.3.0 which we used before, or the full toolchain foss 2020a. The name and version of the toolchain can be specified using a Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } Commonly used parameters \u00b6 You will definitely need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation . Sources, patches, and checksums \u00b6 In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported . Easyblock \u00b6 The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together under a single module file; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblock is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock ... \" or just \" eb -a -e ... \", which will result in an additional \" EASYBLOCK-SPECIFIC \" to be added. See the output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ] Dependencies \u00b6 You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.16.4' )] dependencies = [ ( 'Python' , '3.8.2' ), ( 'HDF5' , '1.10.6' ), ( 'SciPy-bundle' , '2020.03' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies. Version suffix \u00b6 In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '3.8.2' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation. Customizing configure, build, test and install commands \u00b6 When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.10.6' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: Adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support (where the ' ... ' represents the path to installation directory where the software should be installed). Specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). Passing the location where the software should be installed to the PREFIX option of the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild defines an $EBROOT* environment variable like this in every module file it generates (see the output of \" module show HDF5 \"). Sanity check \u00b6 One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check however to check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ] Module class \u00b6 Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ). Generating tweaked easyconfigs \u00b6 Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2020a.eb --try-toolchain intel,2020a It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example. Copying easyconfigs \u00b6 One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. That's annoying. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.10-GCC-9.3.0.eb SAMtools.eb ... SAMtools-1.10-GCC-9.3.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files, as long as the target location is an existing directory. Example \u00b6 By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.0 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.0.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.0 . Preparation \u00b6 Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all Mandatory easyconfig parameters \u00b6 Let's start by getting the mandatory easyconfig parameter defined in the easyconfig file: name = 'eb-tutorial' version = '1.0.0' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } We will use GCC/9.3.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment. In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a reasonable value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning. Easyblock \u00b6 Let us see what happens if we take this easyconfig file for a spin: $ eb eb-tutorial.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/eb-tutorial.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for eb-tutorial . Does that mean we have to implement an easyblock? In this simple case it doesn't since we can leverage one of the available generic easyblocks. But, which one? Build instructions are usually shared in the README or documentation, but here were are left to figure things out by ourselves... When inspecting the unpacked sources we see a CMakeLists.txt file. That probably means the installation will involve running cmake to configure the build, which likely will yield a Makefile so we can run make afterwards. We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one). CMake build dependency \u00b6 Does using the CMakeMake generic easyblock help at all? $ eb eb-tutorial.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/eb-tutorial.eb == building and installing eb-tutorial/1.0.0-GCC-9.3.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.0/GCC-9.3.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.16.4-GCCcore-9.3.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 9.3.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.16.4' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D : $ eb eb-tutorial.eb -D ... * [x] /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/c/CMake/CMake-3.16.4-GCCcore-9.3.0.eb (module: CMake/3.16.4-GCCcore-9.3.0) * [x] /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/g/GCC/GCC-9.3.0.eb (module: GCC/9.3.0) * [ ] /home/example/eb-tutorial.eb (module: eb-tutorial/1.0.0-GCC-9.3.0) Sources \u00b6 If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.0/GCC-9.3.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.0/GCC-9.3.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.0/GCC-9.3.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify sources . We might as well also define source_urls , so EasyBuild can download the sources for us. source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ 'eb-tutorial-1.0.0.tar.gz' ] This will work, but we can do better by not hardcoding the software version ( 1.0.0 ) in sources , and use a template value ' %(version)s ' instead: sources = [ 'eb-tutorial- %(version)s .tar.gz' ] That way, we only have the software version specified once in the easyconfig file (via the version easyconfig parameter). That will come in useful later (see Exercise 7.2 )... We can even use the SOURCE_TAR_GZ template constant in this case, since the name of source file adheres to the standard name-version.tar.gz pattern: sources = [ SOURCE_TAR_GZ ] See the output of \" eb --avail-easyconfig-templates \" for a list of known templates. Required configure option \u00b6 With sources defined, we can try again. And yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1 ). Sanity check \u00b6 Hopefully that brings us closer to getting the installation to work... $ eb eb-tutorial.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.0/GCC-9.3.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 (took 2 sec) It got all the way to the sanity check step, yaay! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we will need to customize the sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. Also, by enabling tracing of the module via --trace we can get some more information too: eb eb-tutorial.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial! Complete easyconfig \u00b6 Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.0' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ '87643c9a950d02471fc283b31e8a088da7d5d49bc9e1bebd5c83b52c2e23b4d8' ] toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } builddependencies = [( 'CMake' , '3.16.4' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' Exercises \u00b6 Exercise 7.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the eb-tutorial.eb easyconfig, you will need to use eb --rebuild or eb --force . Exercise 7.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.0. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb eb-tutorial.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-9.3.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.0 doesn't print \" I have a message for you: \") Exercise 7.2 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2020a' } dependencies = [ ( 'Python' , '3.8.2' ), ( 'SciPy-bundle' , '2020.03' , versionsuffix ), ( 'eb-tutorial' , '1.0.0' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by Python package is already pretty decent (it will check for a non-empty lib/python3.8/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.8 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file.","title":"Adding support for additional software"},{"location":"2020-06-isc20/adding_support_software/#adding-support-for-additional-software","text":"We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!","title":"Adding support for additional software"},{"location":"2020-06-isc20/adding_support_software/#easyconfigs-vs-easyblocks","text":"Before we dive into writing easyconfig files , let us take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild which specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in a general sense since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a paritcular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; toolchain-specific aspects of the build and installation procedure (e.g., configure options); interactive commands that need to be run; custom (configure) options for dependencies; having to create or adjust specific (configuration) files; 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation .","title":"Easyconfigs vs easyblocks"},{"location":"2020-06-isc20/adding_support_software/#writing-easyconfig-files","text":"Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.","title":"Writing easyconfig files"},{"location":"2020-06-isc20/adding_support_software/#mandatory-parameters","text":"A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 9.3.0 which we used before, or the full toolchain foss 2020a. The name and version of the toolchain can be specified using a Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' }","title":"Mandatory parameters"},{"location":"2020-06-isc20/adding_support_software/#commonly-used-parameters","text":"You will definitely need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation .","title":"Commonly used parameters"},{"location":"2020-06-isc20/adding_support_software/#sources-patches-and-checksums","text":"In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported .","title":"Sources, patches, and checksums"},{"location":"2020-06-isc20/adding_support_software/#easyblock","text":"The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together under a single module file; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblock is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock ... \" or just \" eb -a -e ... \", which will result in an additional \" EASYBLOCK-SPECIFIC \" to be added. See the output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ]","title":"Easyblock"},{"location":"2020-06-isc20/adding_support_software/#dependencies","text":"You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.16.4' )] dependencies = [ ( 'Python' , '3.8.2' ), ( 'HDF5' , '1.10.6' ), ( 'SciPy-bundle' , '2020.03' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies.","title":"Dependencies"},{"location":"2020-06-isc20/adding_support_software/#version-suffix","text":"In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '3.8.2' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation.","title":"Version suffix"},{"location":"2020-06-isc20/adding_support_software/#customizing-configure-build-test-and-install-commands","text":"When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.10.6' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: Adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support (where the ' ... ' represents the path to installation directory where the software should be installed). Specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). Passing the location where the software should be installed to the PREFIX option of the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild defines an $EBROOT* environment variable like this in every module file it generates (see the output of \" module show HDF5 \").","title":"Customizing configure, build, test and install commands"},{"location":"2020-06-isc20/adding_support_software/#sanity-check","text":"One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check however to check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ]","title":"Sanity check"},{"location":"2020-06-isc20/adding_support_software/#module-class","text":"Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ).","title":"Module class"},{"location":"2020-06-isc20/adding_support_software/#generating-tweaked-easyconfigs","text":"Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2020a.eb --try-toolchain intel,2020a It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.","title":"Generating tweaked easyconfigs"},{"location":"2020-06-isc20/adding_support_software/#copying-easyconfigs","text":"One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. That's annoying. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.10-GCC-9.3.0.eb SAMtools.eb ... SAMtools-1.10-GCC-9.3.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files, as long as the target location is an existing directory.","title":"Copying easyconfigs"},{"location":"2020-06-isc20/adding_support_software/#example","text":"By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.0 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.0.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.0 .","title":"Example"},{"location":"2020-06-isc20/adding_support_software/#preparation","text":"Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all","title":"Preparation"},{"location":"2020-06-isc20/adding_support_software/#mandatory-easyconfig-parameters","text":"Let's start by getting the mandatory easyconfig parameter defined in the easyconfig file: name = 'eb-tutorial' version = '1.0.0' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } We will use GCC/9.3.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment. In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a reasonable value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning.","title":"Mandatory easyconfig parameters"},{"location":"2020-06-isc20/adding_support_software/#easyblock_1","text":"Let us see what happens if we take this easyconfig file for a spin: $ eb eb-tutorial.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/eb-tutorial.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for eb-tutorial . Does that mean we have to implement an easyblock? In this simple case it doesn't since we can leverage one of the available generic easyblocks. But, which one? Build instructions are usually shared in the README or documentation, but here were are left to figure things out by ourselves... When inspecting the unpacked sources we see a CMakeLists.txt file. That probably means the installation will involve running cmake to configure the build, which likely will yield a Makefile so we can run make afterwards. We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).","title":"Easyblock"},{"location":"2020-06-isc20/adding_support_software/#cmake-build-dependency","text":"Does using the CMakeMake generic easyblock help at all? $ eb eb-tutorial.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/eb-tutorial.eb == building and installing eb-tutorial/1.0.0-GCC-9.3.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.0/GCC-9.3.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.16.4-GCCcore-9.3.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 9.3.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.16.4' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D : $ eb eb-tutorial.eb -D ... * [x] /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/c/CMake/CMake-3.16.4-GCCcore-9.3.0.eb (module: CMake/3.16.4-GCCcore-9.3.0) * [x] /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/g/GCC/GCC-9.3.0.eb (module: GCC/9.3.0) * [ ] /home/example/eb-tutorial.eb (module: eb-tutorial/1.0.0-GCC-9.3.0)","title":"CMake build dependency"},{"location":"2020-06-isc20/adding_support_software/#sources","text":"If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.0/GCC-9.3.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.0/GCC-9.3.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.0/GCC-9.3.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify sources . We might as well also define source_urls , so EasyBuild can download the sources for us. source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ 'eb-tutorial-1.0.0.tar.gz' ] This will work, but we can do better by not hardcoding the software version ( 1.0.0 ) in sources , and use a template value ' %(version)s ' instead: sources = [ 'eb-tutorial- %(version)s .tar.gz' ] That way, we only have the software version specified once in the easyconfig file (via the version easyconfig parameter). That will come in useful later (see Exercise 7.2 )... We can even use the SOURCE_TAR_GZ template constant in this case, since the name of source file adheres to the standard name-version.tar.gz pattern: sources = [ SOURCE_TAR_GZ ] See the output of \" eb --avail-easyconfig-templates \" for a list of known templates.","title":"Sources"},{"location":"2020-06-isc20/adding_support_software/#required-configure-option","text":"With sources defined, we can try again. And yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1 ).","title":"Required configure option"},{"location":"2020-06-isc20/adding_support_software/#sanity-check_1","text":"Hopefully that brings us closer to getting the installation to work... $ eb eb-tutorial.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.0/GCC-9.3.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 (took 2 sec) It got all the way to the sanity check step, yaay! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we will need to customize the sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. Also, by enabling tracing of the module via --trace we can get some more information too: eb eb-tutorial.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial!","title":"Sanity check"},{"location":"2020-06-isc20/adding_support_software/#complete-easyconfig","text":"Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.0' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ '87643c9a950d02471fc283b31e8a088da7d5d49bc9e1bebd5c83b52c2e23b4d8' ] toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } builddependencies = [( 'CMake' , '3.16.4' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools'","title":"Complete easyconfig"},{"location":"2020-06-isc20/adding_support_software/#exercises","text":"Exercise 7.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the eb-tutorial.eb easyconfig, you will need to use eb --rebuild or eb --force . Exercise 7.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.0. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb eb-tutorial.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-9.3.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.0 doesn't print \" I have a message for you: \") Exercise 7.2 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2020a' } dependencies = [ ( 'Python' , '3.8.2' ), ( 'SciPy-bundle' , '2020.03' , versionsuffix ), ( 'eb-tutorial' , '1.0.0' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by Python package is already pretty decent (it will check for a non-empty lib/python3.8/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.8 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file.","title":"Exercises"},{"location":"2020-06-isc20/basic_usage/","text":"Basic usage \u00b6 Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention! Workflow \u00b6 Installing software with EasyBuild is as easy (hah!) as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , usually in combination with the --robot option to enable dependency resolution. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration options are what you would expect, for example. Specifying easyconfigs \u00b6 Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here ). Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with ' .eb ', and (try to) use these as easyconfig files. Example command \u00b6 Suppose we have the current situation in our home directory: two (easyconfig) files named example1 and example2 ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1 example2 some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb bzip2-1.0.6.eb example1 $HOME /example2 some_deps EasyBuild will interpret each of these arguments as follows: bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); example1 is the name of a file in the current directory, so it can be used directly; likewise, $HOME/example2 specifies the path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , ignoring the list.txt file since its name does not end with ' .eb '; Easyconfig filenames \u00b6 Note that the eb command does not care how easyconfig files are named, at least to some extent: the ' .eb ' file extension does matter w.r.t. easyconfig files being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ); this part (including the preceding - ) is omitted when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default); Searching for easyconfigs \u00b6 You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package, which you can do by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the search-paths configuration setting, or you can change the robot search path via either the --robot or --robot-paths option. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for TensorFlow 2.2.0: $ eb --search tensorflow-2.2.0 * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb This output is a bit more condensed when using eb -S : $ eb -S tensorflow-2.2.0 CFGS1=/home/example/.local/easybuild/easyconfigs/t/TensorFlow * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install OpenFOAM with the foss/2019b toolchain: $ eb -S 'openfoam-[0-9].*foss-2019b' CFGS1=/home/example/.local/easybuild/easyconfigs/o/OpenFOAM * $CFGS1/OpenFOAM-6-foss-2019b.eb * $CFGS1/OpenFOAM-7-foss-2019b.eb Search index \u00b6 When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information . Inspecting easyconfigs \u00b6 Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later, in the part where we discuss writing easyconfig files . Checking dependencies \u00b6 Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". When using the prepared container image , run this command to make the already installed software stack available: module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ). Dry run \u00b6 To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the dependencies that are required for SAMtools-1.10-GCC-9.3.0.eb are already installed: $ eb SAMtools-1.10-GCC-9.3.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/.local/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb ( module: bzip2/1.0.8-GCCcore-9.3.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb ( module: XZ/5.2.5-GCCcore-9.3.0 ) * [ x ] $CFGS /c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb ( module: cURL/7.69.1-GCCcore-9.3.0 ) * [ x ] $CFGS /g/GCC/GCC-9.3.0.eb ( module: GCC/9.3.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb ( module: ncurses/6.2-GCCcore-9.3.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb ( module: SAMtools/1.10-GCC-9.3.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.10-GCC-9.3.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an ' x ' in [ ] . Missing dependencies \u00b6 If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get h5py version 2.10.0 using the 2020a version of the foss toolchain installed: $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) That should be pretty self-explanatory: out of the 54 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great! Inspecting install procedures \u00b6 Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.72.0-gompi-2020a.eb : $ eb Boost-1.72.0-gompi-2020a.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load gompi/2020a Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-9.3.0 module load zlib/1.2.11-GCCcore-9.3.0 module load XZ/5.2.5-GCCcore-9.3.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\" ( in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0 ) file written: user-config.jam ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_mpi.so * lib/libboost_system.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step and in which directory, and that a file named user-config.jam will be created as well; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless. Installing software \u00b6 You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.10: $ eb SAMtools-1.10-GCC-9.3.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb == building and installing SAMtools/1.10-GCC-9.3.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 11 sec ) == Results of the build can be found in the log file ( s ) /tmp/example/isc20/easybuild/software/SAMtools/1.10-GCC-9.3.0/easybuild/easybuild-SAMtools-1.10-20200610.195601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost... Enabling dependency resolution \u00b6 The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above ). If we try this with the Bowtie2-2.4.1-GCC-9.3.0.eb , for which the required tbb dependency is not available yet, it's less successful: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb -M 2 out of 17 required modules missing: * tbb/2020.1-GCCcore-9.3.0 ( tbb-2020.1-GCCcore-9.3.0.eb ) * Bowtie2/2.4.1-GCC-9.3.0 ( Bowtie2-2.4.1-GCC-9.3.0.eb ) $ eb Bowtie2-2.4.1-GCC-9.3.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : tbb/2020.1-GCCcore-9.3.0 ( took 1 min 57 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-x5ik_8b5/easybuild-Bowtie2-2.4.1-20200610.200056.qfgfI.log ERROR: Build of /home/example/.local/easybuild/easyconfigs/b/Bowtie2/Bowtie2-2.4.1-GCC-9.3.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0 The required dependency tbb/2020.1-GCCcore-9.3.0 is not installed yet, and EasyBuild does not automatically install missing dependencies unless it is configured to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --robot ... == resolving dependencies ... ... == building and installing tbb/2020.1-GCCcore-9.3.0... ... == COMPLETED: Installation ended successfully ( took 1 min 4 sec ) ... == building and installing Bowtie2/2.4.1-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 6 min 39 sec ) ... == Build succeeded for 2 out of 2 With dependency resolution enabled the tbb/2020.1-GCCcore-9.3.0 module gets installed first, before EasyBuild proceeds with installing Bowtie2. Great! Trace output \u00b6 As you may have noticed if you tried the previous example hands-on, the installation of Bowtie2 takes a while. The installation was spending quite a bit of time during the build step, but what was actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of Bowtie2-2.4.1-GCC-9.3.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --rebuild ... == building... >> running command: [ started at: 2020 -06-10 20 :22:13 ] [ working dir: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0/bowtie2-2.4.1 ] [ output logged in /tmp/eb-jx1khbgf/easybuild-run_cmd-frodru6e.log ] make -j 4 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" >> command completed: exit 0 , ran in 00h01m03s That's a bit more comforting to stare at... During the build step the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 4), and passes several options to ensure the right compiler commands and compiler options are used. We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 1 min 3 sec to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bowtie2' found: OK >> file 'bin/bowtie2-build' found: OK >> file 'bin/bowtie2-inspect' found: OK ... >> (non-empty) directory 'doc' found: OK >> (non-empty) directory 'example' found: OK >> (non-empty) directory 'scripts' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary. Using installed software \u00b6 So far, we have already installed 3 different software packages (SAMtools, tbb, and Bowtie2); we even installed Bowtie2 twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, created and populating the installation directory, performing a quick sanity check on the installation, cleaning things up and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio lib The bio and lib directories correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ------------ /home/example/easybuild/modules/all ------------ Bowtie2/2.4.1-GCC-9.3.0 bzip2/1.0.6 SAMtools/1.10-GCC-9.3.0 tbb/2020.1-GCCcore-9.3.0 ------------------- /easybuild/modules/all ------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for Bowtie2. In our current environment, the bowtie2 command is not available yet: $ module list No modules loaded $ bowtie2 bash: bowtie2: command not found Loading the module for Bowtie2 changes that: $ module load Bowtie2/2.4.1-GCC-9.3.0 $ module list Currently Loaded Modules: 1 ) GCCcore/9.3.0 2 ) zlib/1.2.11-GCCcore-9.3.0 3 ) binutils/2.34-GCCcore-9.3.0 4 ) GCC/9.3.0 5 ) tbb/2020.1-GCCcore-9.3.0 6 ) Bowtie2/2.4.1-GCC-9.3.0 $ bowtie2 --version /home/example/easybuild/software/Bowtie2/2.4.1-GCC-9.3.0/bin/bowtie2-align-s version 2 .4.1 64 -bit Built on Wed Jun 10 20 :33:29 UTC 2020 Compiler: gcc version 9 .3.0 ( GCC ) Options: -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -DPOPCNT_CAPABILITY -DWITH_TBB -std = c++11 -DNO_SPINLOCK -DWITH_QUEUELOCK = 1 Sizeof { int, long, long long, void*, size_t, off_t } : { 4 , 8 , 8 , 8 , 8 , 8 } Bowtie 2 version 2 .4.1 Usage: bowtie2 [ options ] * -x <bt2-idx> { -1 <m1> -2 <m2> | -U <r> | --interleaved <i> | -b <bam> } [ -S <sam> ] Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use. Resetting your environment \u00b6 To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \". Stacking software \u00b6 Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed, as long as the module file that provides access to it is available it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here). Hands-on exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. Exercise 4.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. For the easybuilders/tutorial container image , we have installed a small software stack with the 2020a version of the foss toolchain in /easybuild/ . Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2019.4. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2019.4 CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2019.4-foss-2019b.eb Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc version 3.12.4 with the 2020a version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for PETSc version 3.12.4: $ eb -S 'PETSc-3.12.4.*foss-2020a' CFGS1 = /home/example/.local/easybuild/easyconfigs/p/PETSc * $CFGS1 /PETSc-3.12.4-foss-2020a-Python-3.8.2.e To determine which dependencies are missing to install this PETSc easyconfig file, we can use --missing : $ eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing 7 out of 57 required modules missing: * METIS/5.1.0-GCCcore-9.3.0 ( METIS-5.1.0-GCCcore-9.3.0.eb ) * Boost/1.72.0-gompi-2020a ( Boost-1.72.0-gompi-2020a.eb ) * SCOTCH/6.0.9-gompi-2020a ( SCOTCH-6.0.9-gompi-2020a.eb ) * MUMPS/5.2.1-foss-2020a-metis ( MUMPS-5.2.1-foss-2020a-metis.eb ) * SuiteSparse/5.7.1-foss-2020a-METIS-5.1.0 ( SuiteSparse-5.7.1-foss-2020a-METIS-5.1.0.eb ) * Hypre/2.18.2-foss-2020a ( Hypre-2.18.2-foss-2020a.eb ) * PETSc/3.12.4-foss-2020a-Python-3.8.2 ( PETSc-3.12.4-foss-2020a-Python-3.8.2.eb ) eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Figure out which command EasyBuild would use to perform the actual installation of the software provided by the GSL-2.6-GCC-9.3.0.eb easyconfig file, without actually installing GSL . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x GSL-2.6-GCC-9.3.0.eb . The output for the install step shows the actual installation command ( make install ): [ make_installdir method ] directory /home/example/easybuild/software/GSL/2.6-GCC-9.3.0 removed [ install_step method ] >> running command: [ started at: 2020 -06-10 21 :38:14 ] [ working dir: /tmp/eb-u3gkcgvv/__ROOT__/tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ] mp/eb-u3gkcgvv/easybuild-run_cmd-7cl9s7xi.log ] e install running command \"make install\" ( in /tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ) The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/gsl-config * bin/gsl-histogram * bin/gsl-randist Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies on top of Python 3.8.2, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py.*Python-3.8.2' CFGS1 = /home/example/.local/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-2.10.0-foss-2020a-Python-3.8.2.eb Make sure the pre-install software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install h5py : $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2... ... == building and installing h5py/2.10.0-foss-2020a-Python-3.8.2... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/2.10.0/foss-2020a-Python-3.8.2/h5py-2.10.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.2-GCCcore-9.3.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/2.10.0-foss-2020a-Python-3.8.2 module load h5py/2.10.0-foss-2020a-Python-3.8.2 The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course yu can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask question in the #tutorial channel in the EasyBuild Slack , we're happy to help!","title":"Basic usage"},{"location":"2020-06-isc20/basic_usage/#basic-usage","text":"Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!","title":"Basic usage"},{"location":"2020-06-isc20/basic_usage/#workflow","text":"Installing software with EasyBuild is as easy (hah!) as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , usually in combination with the --robot option to enable dependency resolution. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration options are what you would expect, for example.","title":"Workflow"},{"location":"2020-06-isc20/basic_usage/#specifying-easyconfigs","text":"Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here ). Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with ' .eb ', and (try to) use these as easyconfig files.","title":"Specifying easyconfigs"},{"location":"2020-06-isc20/basic_usage/#example-command","text":"Suppose we have the current situation in our home directory: two (easyconfig) files named example1 and example2 ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1 example2 some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb bzip2-1.0.6.eb example1 $HOME /example2 some_deps EasyBuild will interpret each of these arguments as follows: bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); example1 is the name of a file in the current directory, so it can be used directly; likewise, $HOME/example2 specifies the path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , ignoring the list.txt file since its name does not end with ' .eb ';","title":"Example command"},{"location":"2020-06-isc20/basic_usage/#easyconfig-filenames","text":"Note that the eb command does not care how easyconfig files are named, at least to some extent: the ' .eb ' file extension does matter w.r.t. easyconfig files being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ); this part (including the preceding - ) is omitted when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default);","title":"Easyconfig filenames"},{"location":"2020-06-isc20/basic_usage/#searching-for-easyconfigs","text":"You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package, which you can do by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the search-paths configuration setting, or you can change the robot search path via either the --robot or --robot-paths option. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for TensorFlow 2.2.0: $ eb --search tensorflow-2.2.0 * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb This output is a bit more condensed when using eb -S : $ eb -S tensorflow-2.2.0 CFGS1=/home/example/.local/easybuild/easyconfigs/t/TensorFlow * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install OpenFOAM with the foss/2019b toolchain: $ eb -S 'openfoam-[0-9].*foss-2019b' CFGS1=/home/example/.local/easybuild/easyconfigs/o/OpenFOAM * $CFGS1/OpenFOAM-6-foss-2019b.eb * $CFGS1/OpenFOAM-7-foss-2019b.eb","title":"Searching for easyconfigs"},{"location":"2020-06-isc20/basic_usage/#search-index","text":"When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information .","title":"Search index"},{"location":"2020-06-isc20/basic_usage/#inspecting-easyconfigs","text":"Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later, in the part where we discuss writing easyconfig files .","title":"Inspecting easyconfigs"},{"location":"2020-06-isc20/basic_usage/#checking-dependencies","text":"Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". When using the prepared container image , run this command to make the already installed software stack available: module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ).","title":"Checking dependencies"},{"location":"2020-06-isc20/basic_usage/#dry-run","text":"To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the dependencies that are required for SAMtools-1.10-GCC-9.3.0.eb are already installed: $ eb SAMtools-1.10-GCC-9.3.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/.local/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb ( module: bzip2/1.0.8-GCCcore-9.3.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb ( module: XZ/5.2.5-GCCcore-9.3.0 ) * [ x ] $CFGS /c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb ( module: cURL/7.69.1-GCCcore-9.3.0 ) * [ x ] $CFGS /g/GCC/GCC-9.3.0.eb ( module: GCC/9.3.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb ( module: ncurses/6.2-GCCcore-9.3.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb ( module: SAMtools/1.10-GCC-9.3.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.10-GCC-9.3.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an ' x ' in [ ] .","title":"Dry run"},{"location":"2020-06-isc20/basic_usage/#missing-dependencies","text":"If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get h5py version 2.10.0 using the 2020a version of the foss toolchain installed: $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) That should be pretty self-explanatory: out of the 54 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great!","title":"Missing dependencies"},{"location":"2020-06-isc20/basic_usage/#inspecting-install-procedures","text":"Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.72.0-gompi-2020a.eb : $ eb Boost-1.72.0-gompi-2020a.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load gompi/2020a Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-9.3.0 module load zlib/1.2.11-GCCcore-9.3.0 module load XZ/5.2.5-GCCcore-9.3.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\" ( in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0 ) file written: user-config.jam ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_mpi.so * lib/libboost_system.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step and in which directory, and that a file named user-config.jam will be created as well; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.","title":"Inspecting install procedures"},{"location":"2020-06-isc20/basic_usage/#installing-software","text":"You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.10: $ eb SAMtools-1.10-GCC-9.3.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb == building and installing SAMtools/1.10-GCC-9.3.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 11 sec ) == Results of the build can be found in the log file ( s ) /tmp/example/isc20/easybuild/software/SAMtools/1.10-GCC-9.3.0/easybuild/easybuild-SAMtools-1.10-20200610.195601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost...","title":"Installing software"},{"location":"2020-06-isc20/basic_usage/#enabling-dependency-resolution","text":"The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above ). If we try this with the Bowtie2-2.4.1-GCC-9.3.0.eb , for which the required tbb dependency is not available yet, it's less successful: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb -M 2 out of 17 required modules missing: * tbb/2020.1-GCCcore-9.3.0 ( tbb-2020.1-GCCcore-9.3.0.eb ) * Bowtie2/2.4.1-GCC-9.3.0 ( Bowtie2-2.4.1-GCC-9.3.0.eb ) $ eb Bowtie2-2.4.1-GCC-9.3.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : tbb/2020.1-GCCcore-9.3.0 ( took 1 min 57 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-x5ik_8b5/easybuild-Bowtie2-2.4.1-20200610.200056.qfgfI.log ERROR: Build of /home/example/.local/easybuild/easyconfigs/b/Bowtie2/Bowtie2-2.4.1-GCC-9.3.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0 The required dependency tbb/2020.1-GCCcore-9.3.0 is not installed yet, and EasyBuild does not automatically install missing dependencies unless it is configured to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --robot ... == resolving dependencies ... ... == building and installing tbb/2020.1-GCCcore-9.3.0... ... == COMPLETED: Installation ended successfully ( took 1 min 4 sec ) ... == building and installing Bowtie2/2.4.1-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 6 min 39 sec ) ... == Build succeeded for 2 out of 2 With dependency resolution enabled the tbb/2020.1-GCCcore-9.3.0 module gets installed first, before EasyBuild proceeds with installing Bowtie2. Great!","title":"Enabling dependency resolution"},{"location":"2020-06-isc20/basic_usage/#trace-output","text":"As you may have noticed if you tried the previous example hands-on, the installation of Bowtie2 takes a while. The installation was spending quite a bit of time during the build step, but what was actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of Bowtie2-2.4.1-GCC-9.3.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --rebuild ... == building... >> running command: [ started at: 2020 -06-10 20 :22:13 ] [ working dir: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0/bowtie2-2.4.1 ] [ output logged in /tmp/eb-jx1khbgf/easybuild-run_cmd-frodru6e.log ] make -j 4 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" >> command completed: exit 0 , ran in 00h01m03s That's a bit more comforting to stare at... During the build step the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 4), and passes several options to ensure the right compiler commands and compiler options are used. We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 1 min 3 sec to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bowtie2' found: OK >> file 'bin/bowtie2-build' found: OK >> file 'bin/bowtie2-inspect' found: OK ... >> (non-empty) directory 'doc' found: OK >> (non-empty) directory 'example' found: OK >> (non-empty) directory 'scripts' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.","title":"Trace output"},{"location":"2020-06-isc20/basic_usage/#using-installed-software","text":"So far, we have already installed 3 different software packages (SAMtools, tbb, and Bowtie2); we even installed Bowtie2 twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, created and populating the installation directory, performing a quick sanity check on the installation, cleaning things up and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio lib The bio and lib directories correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ------------ /home/example/easybuild/modules/all ------------ Bowtie2/2.4.1-GCC-9.3.0 bzip2/1.0.6 SAMtools/1.10-GCC-9.3.0 tbb/2020.1-GCCcore-9.3.0 ------------------- /easybuild/modules/all ------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for Bowtie2. In our current environment, the bowtie2 command is not available yet: $ module list No modules loaded $ bowtie2 bash: bowtie2: command not found Loading the module for Bowtie2 changes that: $ module load Bowtie2/2.4.1-GCC-9.3.0 $ module list Currently Loaded Modules: 1 ) GCCcore/9.3.0 2 ) zlib/1.2.11-GCCcore-9.3.0 3 ) binutils/2.34-GCCcore-9.3.0 4 ) GCC/9.3.0 5 ) tbb/2020.1-GCCcore-9.3.0 6 ) Bowtie2/2.4.1-GCC-9.3.0 $ bowtie2 --version /home/example/easybuild/software/Bowtie2/2.4.1-GCC-9.3.0/bin/bowtie2-align-s version 2 .4.1 64 -bit Built on Wed Jun 10 20 :33:29 UTC 2020 Compiler: gcc version 9 .3.0 ( GCC ) Options: -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -DPOPCNT_CAPABILITY -DWITH_TBB -std = c++11 -DNO_SPINLOCK -DWITH_QUEUELOCK = 1 Sizeof { int, long, long long, void*, size_t, off_t } : { 4 , 8 , 8 , 8 , 8 , 8 } Bowtie 2 version 2 .4.1 Usage: bowtie2 [ options ] * -x <bt2-idx> { -1 <m1> -2 <m2> | -U <r> | --interleaved <i> | -b <bam> } [ -S <sam> ] Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use.","title":"Using installed software"},{"location":"2020-06-isc20/basic_usage/#resetting-your-environment","text":"To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \".","title":"Resetting your environment"},{"location":"2020-06-isc20/basic_usage/#stacking-software","text":"Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed, as long as the module file that provides access to it is available it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).","title":"Stacking software"},{"location":"2020-06-isc20/basic_usage/#hands-on-exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. Exercise 4.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. For the easybuilders/tutorial container image , we have installed a small software stack with the 2020a version of the foss toolchain in /easybuild/ . Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2019.4. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2019.4 CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2019.4-foss-2019b.eb Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc version 3.12.4 with the 2020a version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for PETSc version 3.12.4: $ eb -S 'PETSc-3.12.4.*foss-2020a' CFGS1 = /home/example/.local/easybuild/easyconfigs/p/PETSc * $CFGS1 /PETSc-3.12.4-foss-2020a-Python-3.8.2.e To determine which dependencies are missing to install this PETSc easyconfig file, we can use --missing : $ eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing 7 out of 57 required modules missing: * METIS/5.1.0-GCCcore-9.3.0 ( METIS-5.1.0-GCCcore-9.3.0.eb ) * Boost/1.72.0-gompi-2020a ( Boost-1.72.0-gompi-2020a.eb ) * SCOTCH/6.0.9-gompi-2020a ( SCOTCH-6.0.9-gompi-2020a.eb ) * MUMPS/5.2.1-foss-2020a-metis ( MUMPS-5.2.1-foss-2020a-metis.eb ) * SuiteSparse/5.7.1-foss-2020a-METIS-5.1.0 ( SuiteSparse-5.7.1-foss-2020a-METIS-5.1.0.eb ) * Hypre/2.18.2-foss-2020a ( Hypre-2.18.2-foss-2020a.eb ) * PETSc/3.12.4-foss-2020a-Python-3.8.2 ( PETSc-3.12.4-foss-2020a-Python-3.8.2.eb ) eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Figure out which command EasyBuild would use to perform the actual installation of the software provided by the GSL-2.6-GCC-9.3.0.eb easyconfig file, without actually installing GSL . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x GSL-2.6-GCC-9.3.0.eb . The output for the install step shows the actual installation command ( make install ): [ make_installdir method ] directory /home/example/easybuild/software/GSL/2.6-GCC-9.3.0 removed [ install_step method ] >> running command: [ started at: 2020 -06-10 21 :38:14 ] [ working dir: /tmp/eb-u3gkcgvv/__ROOT__/tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ] mp/eb-u3gkcgvv/easybuild-run_cmd-7cl9s7xi.log ] e install running command \"make install\" ( in /tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ) The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/gsl-config * bin/gsl-histogram * bin/gsl-randist Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies on top of Python 3.8.2, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py.*Python-3.8.2' CFGS1 = /home/example/.local/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-2.10.0-foss-2020a-Python-3.8.2.eb Make sure the pre-install software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install h5py : $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2... ... == building and installing h5py/2.10.0-foss-2020a-Python-3.8.2... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/2.10.0/foss-2020a-Python-3.8.2/h5py-2.10.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.2-GCCcore-9.3.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/2.10.0-foss-2020a-Python-3.8.2 module load h5py/2.10.0-foss-2020a-Python-3.8.2 The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course yu can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask question in the #tutorial channel in the EasyBuild Slack , we're happy to help!","title":"Hands-on exercises"},{"location":"2020-06-isc20/community/","text":"The EasyBuild community \u00b6 The early years \u00b6 EasyBuild as a project was conceived in 2009 by the HPC team at Ghent University (Belgium) . The codebase was developed in-house, and went through a couple of redesigns as the team gradually learned the ropes of developing a sizeable software project and tried to tackle the never-ending corner cases of the installation procedures of scientific software. During these very early days, several summer interns were invaluable in their assistance in refining EasyBuild. As the project grew and its usefulness became apparent, the HPC-UGent team begun to desire feedback from the HPC community at large. Maybe others would find EasyBuild useful? Or maybe this was actually a solved problem, and they were unknowingly reinventing the wheel... The first step in this process was to pick a license. As many an in-house project, EasyBuild at the time lacked such formalities. This led to a short debate on open source licenses before the team landed on GPLv2. And no, commercial licenses never even made it to the table. Like so many open source projects, the goal was simple enough; scratch HPC-UGent's own itch and get some outside feedback to help in getting it done! The first public release of EasyBuild became available in April 2012 and was tagged as version 0.5. This public release took place mostly out of necessity as the project was about to be presented at the HEPIX Spring Workshop 2012 . Based on early feedback, the EasyBuild team realised others would indeed find EasyBuild useful, so efforts were made to produce a stable version to ensure that others could rely on the project if they wanted to. ( EasyBuild v1.0 ) was released in November 2012, barely seven months after version 0.5 was published. This first stable release coincided with the SC'12 conference in Salt Lake City , where the team handed out stickers and went around asking how everyone else installed scientific software. There was never much of a sales pitch, but the conversations very quickly took on a rather predictable script... EasyBuild team member: How do you install scientific software? HPC staff: We do it manually, and spend a lot of time on it. EasyBuild team member: What if there was a tool that could help? HPC staff: Nobody in their right mind would develop a tool like that. That's madness. EasyBuild team member: What if we have a tool like this that you could use? HPC staff: What does it cost? EasyBuild team member: It's open source. It's free. HPC staff: ... Yeah, cool. What about the hard stuff? When will you support OpenFOAM? EasyBuild team member: We already do. And we support WRF too. And then suddenly everyone was a friend. Beers and snacks started appearing out of nowhere and all the stickers disappeared. Once the beers and snacks had been \"processed\", EasyBuild took its place on the presentation floor. At SC'12, EasyBuild's stage was the PyHPC 2012 workshop . Following the public release and the projects introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. As odd as it might sound, this was quite unexpected. The EasyBuild team was hoping for feedback. Receiving contributions was a big surprising bonus. Early adopters were the University of Luxembourg , the Cyprus Institute , the University of Basel , and the J\u00fclich Supercomputing Centre . A worldwide community \u00b6 Over the years EasyBuild has grown into a community project , which is used and developed by dozens (hundreds?) of HPC centres and consortia worldwide. Starting in 2016, the community has gathered for a yearly EasyBuild User Meeting which typically takes place a week before or after FOSDEM . The EasyBuild User Meeting is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild enthusiasts, discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins , Ansible , CernVM-FS , ReFrame etc. The map below shows from which cities the EasyBuild documentation has been visited in the last year (June 2019 - June 2020), and how often. The community has truly become global. HPC sites, consortia, and companies that use EasyBuild include (but are not limited to): Development \u00b6 The EasyBuild community develops the project through the easybuilders GitHub organisation as set of repositories: easybuild-framework (EasyBuild framework codebase) easybuild-easyblocks (collection of easyblocks) easybuild-easyconfigs (collection of easyconfigs) easybuild (documentation) easybuild-tutorial (this tutorial) Maintainers \u00b6 EasyBuild is maintained by an experienced team of HPC experts, including people from: Ghent University (Belgium) Vrije Universiteit Brussel (Belgium) Compute Canada J\u00fclich Supercomputing Centre (Germany) SURF (Netherlands) National University of Singapore Chalmers University of Technology (Sweden) Ume\u00e5 University (Sweden) sciCORE at the University of Basel (Switzerland) Swiss Data Science Center Big Data Institute Oxford (UK) The EasyBuild maintainers implement additional features and bug fixes, review and test incoming contributions, and frequently release new stable versions.","title":"The EasyBuild community"},{"location":"2020-06-isc20/community/#the-easybuild-community","text":"","title":"The EasyBuild community"},{"location":"2020-06-isc20/community/#the-early-years","text":"EasyBuild as a project was conceived in 2009 by the HPC team at Ghent University (Belgium) . The codebase was developed in-house, and went through a couple of redesigns as the team gradually learned the ropes of developing a sizeable software project and tried to tackle the never-ending corner cases of the installation procedures of scientific software. During these very early days, several summer interns were invaluable in their assistance in refining EasyBuild. As the project grew and its usefulness became apparent, the HPC-UGent team begun to desire feedback from the HPC community at large. Maybe others would find EasyBuild useful? Or maybe this was actually a solved problem, and they were unknowingly reinventing the wheel... The first step in this process was to pick a license. As many an in-house project, EasyBuild at the time lacked such formalities. This led to a short debate on open source licenses before the team landed on GPLv2. And no, commercial licenses never even made it to the table. Like so many open source projects, the goal was simple enough; scratch HPC-UGent's own itch and get some outside feedback to help in getting it done! The first public release of EasyBuild became available in April 2012 and was tagged as version 0.5. This public release took place mostly out of necessity as the project was about to be presented at the HEPIX Spring Workshop 2012 . Based on early feedback, the EasyBuild team realised others would indeed find EasyBuild useful, so efforts were made to produce a stable version to ensure that others could rely on the project if they wanted to. ( EasyBuild v1.0 ) was released in November 2012, barely seven months after version 0.5 was published. This first stable release coincided with the SC'12 conference in Salt Lake City , where the team handed out stickers and went around asking how everyone else installed scientific software. There was never much of a sales pitch, but the conversations very quickly took on a rather predictable script... EasyBuild team member: How do you install scientific software? HPC staff: We do it manually, and spend a lot of time on it. EasyBuild team member: What if there was a tool that could help? HPC staff: Nobody in their right mind would develop a tool like that. That's madness. EasyBuild team member: What if we have a tool like this that you could use? HPC staff: What does it cost? EasyBuild team member: It's open source. It's free. HPC staff: ... Yeah, cool. What about the hard stuff? When will you support OpenFOAM? EasyBuild team member: We already do. And we support WRF too. And then suddenly everyone was a friend. Beers and snacks started appearing out of nowhere and all the stickers disappeared. Once the beers and snacks had been \"processed\", EasyBuild took its place on the presentation floor. At SC'12, EasyBuild's stage was the PyHPC 2012 workshop . Following the public release and the projects introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. As odd as it might sound, this was quite unexpected. The EasyBuild team was hoping for feedback. Receiving contributions was a big surprising bonus. Early adopters were the University of Luxembourg , the Cyprus Institute , the University of Basel , and the J\u00fclich Supercomputing Centre .","title":"The early years"},{"location":"2020-06-isc20/community/#a-worldwide-community","text":"Over the years EasyBuild has grown into a community project , which is used and developed by dozens (hundreds?) of HPC centres and consortia worldwide. Starting in 2016, the community has gathered for a yearly EasyBuild User Meeting which typically takes place a week before or after FOSDEM . The EasyBuild User Meeting is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild enthusiasts, discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins , Ansible , CernVM-FS , ReFrame etc. The map below shows from which cities the EasyBuild documentation has been visited in the last year (June 2019 - June 2020), and how often. The community has truly become global. HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):","title":"A worldwide community"},{"location":"2020-06-isc20/community/#development","text":"The EasyBuild community develops the project through the easybuilders GitHub organisation as set of repositories: easybuild-framework (EasyBuild framework codebase) easybuild-easyblocks (collection of easyblocks) easybuild-easyconfigs (collection of easyconfigs) easybuild (documentation) easybuild-tutorial (this tutorial)","title":"Development"},{"location":"2020-06-isc20/community/#maintainers","text":"EasyBuild is maintained by an experienced team of HPC experts, including people from: Ghent University (Belgium) Vrije Universiteit Brussel (Belgium) Compute Canada J\u00fclich Supercomputing Centre (Germany) SURF (Netherlands) National University of Singapore Chalmers University of Technology (Sweden) Ume\u00e5 University (Sweden) sciCORE at the University of Basel (Switzerland) Swiss Data Science Center Big Data Institute Oxford (UK) The EasyBuild maintainers implement additional features and bug fixes, review and test incoming contributions, and frequently release new stable versions.","title":"Maintainers"},{"location":"2020-06-isc20/comparison_other_tools/","text":"Comparison with other tools \u00b6 The project that most compares with EasyBuild is Spack , a flexible package manager for HPC systems. It was created by Todd Gamblin at Lawrence Livermore National Lab (LLNL) in California, USA. In several ways it looks similar to EasyBuild: implemented in Python, compatible with Python 2.6 and 3.5+ open source software, development on GitHub similar high-level structure (core + packages) supports installing (scientific) software without admin privileges strong focus on HPC and performance highly configurable well documented (see https://spack.readthedocs.io/ ) generates environment modules files worldwide community broad spectrum of supported software (1000s) In other ways, EasyBuild and Spack are quite different. Spack is released under a more permissive open source license (MIT/Apache 2.0 dual license), and whereas EasyBuild supports Linux and Cray PE, Spack also provides good support for macOS out-of-the-box. The Spack command line interface is quite different from EasyBuild: it supports subcommands (like \" spack install \"), and provides a flexible interface for specifying an abstract specification of what to install. Here is an example: spack install mpileaks@3.3 ^mpich@3.2 %gcc@4.9.3 This tells Spack to install mpileaks version 3.3 on top of MPICH version 3.2, using GCC 4.9.3 as compiler. This abstract specification is then passed to a concretization algorithm which fills in the blanks: it will pick versions of other required dependencies, determine which compiler flags to use, and so on. This information is fed to the Spack package (which is the equivalent of an easyblock in EasyBuild) to perform the actual installation. There are many other differences between EasyBuild and Spack as well, too many for this document to cover in detail. See the \"Installing software for scientists on a multi-user HPC system\" recorded talk at FOSDEM'18 and the Spack documentation for more information. Nix and GNU Guix are both purely functional package managers , which strongly focus on the reproducibility of software installations. In Nix packages are expressed as Nix expressions (a custom DSL), and software installations are usually done in the Nix store, a dedicated installation directory, each in a specific subdirectory that includes a unique identifier for that installation. For example: /nix/store/b6gvzjyb2pg0kjfwrjmg1vfhh54ad73z-firefox-33.1/ Guix is very similar to Nix, but is a separate project entirely. There is a dedicated Guix HPC community that focuses on the use of Guix in an HPC context. Packages in Guix are implemented in Guile Scheme, and many advanced features like transactional upgrades and rollbacks are supported. To the best of our knowledge, neither of these tools have seen wide adoption in the HPC community to date. Conda is a package manager that runs on Windows, macOS and Linux, and is very popular in the scientific community. It focuses on quick installation of software and ease of use, and lets users create a conda environment in which they can install one or more packages. These packages are usually pre-built generic binaries however, which significantly impacts the performance of the installations. Despite wide adoption in the scientific community conda is not a good fit for HPC systems for a number of reasons, including poor support for multi-user environments, a lack of focus on performance, heavily relying on the home directory (which usually is limited in size on HPC systems), and more. See this link for a more detailed discussion. In addition, software installed via conda usually does not mix well with software installed through environment modules.","title":"Comparison with other tools"},{"location":"2020-06-isc20/comparison_other_tools/#comparison-with-other-tools","text":"The project that most compares with EasyBuild is Spack , a flexible package manager for HPC systems. It was created by Todd Gamblin at Lawrence Livermore National Lab (LLNL) in California, USA. In several ways it looks similar to EasyBuild: implemented in Python, compatible with Python 2.6 and 3.5+ open source software, development on GitHub similar high-level structure (core + packages) supports installing (scientific) software without admin privileges strong focus on HPC and performance highly configurable well documented (see https://spack.readthedocs.io/ ) generates environment modules files worldwide community broad spectrum of supported software (1000s) In other ways, EasyBuild and Spack are quite different. Spack is released under a more permissive open source license (MIT/Apache 2.0 dual license), and whereas EasyBuild supports Linux and Cray PE, Spack also provides good support for macOS out-of-the-box. The Spack command line interface is quite different from EasyBuild: it supports subcommands (like \" spack install \"), and provides a flexible interface for specifying an abstract specification of what to install. Here is an example: spack install mpileaks@3.3 ^mpich@3.2 %gcc@4.9.3 This tells Spack to install mpileaks version 3.3 on top of MPICH version 3.2, using GCC 4.9.3 as compiler. This abstract specification is then passed to a concretization algorithm which fills in the blanks: it will pick versions of other required dependencies, determine which compiler flags to use, and so on. This information is fed to the Spack package (which is the equivalent of an easyblock in EasyBuild) to perform the actual installation. There are many other differences between EasyBuild and Spack as well, too many for this document to cover in detail. See the \"Installing software for scientists on a multi-user HPC system\" recorded talk at FOSDEM'18 and the Spack documentation for more information. Nix and GNU Guix are both purely functional package managers , which strongly focus on the reproducibility of software installations. In Nix packages are expressed as Nix expressions (a custom DSL), and software installations are usually done in the Nix store, a dedicated installation directory, each in a specific subdirectory that includes a unique identifier for that installation. For example: /nix/store/b6gvzjyb2pg0kjfwrjmg1vfhh54ad73z-firefox-33.1/ Guix is very similar to Nix, but is a separate project entirely. There is a dedicated Guix HPC community that focuses on the use of Guix in an HPC context. Packages in Guix are implemented in Guile Scheme, and many advanced features like transactional upgrades and rollbacks are supported. To the best of our knowledge, neither of these tools have seen wide adoption in the HPC community to date. Conda is a package manager that runs on Windows, macOS and Linux, and is very popular in the scientific community. It focuses on quick installation of software and ease of use, and lets users create a conda environment in which they can install one or more packages. These packages are usually pre-built generic binaries however, which significantly impacts the performance of the installations. Despite wide adoption in the scientific community conda is not a good fit for HPC systems for a number of reasons, including poor support for multi-user environments, a lack of focus on performance, heavily relying on the home directory (which usually is limited in size on HPC systems), and more. See this link for a more detailed discussion. In addition, software installed via conda usually does not mix well with software installed through environment modules.","title":"Comparison with other tools"},{"location":"2020-06-isc20/computecanada/","text":"Compute Canada \u00b6 ( author: Maxime Boissonneault, Compute Canada) General info \u00b6 Compute Canada ( https://www.computecanada.ca ) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US. Staff & user base \u00b6 Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year. Resources \u00b6 Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud. Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs. Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size. B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs. Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, and all identical nodes with nearly 80,000 cores. Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores. Compute Canada software stack \u00b6 Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere. For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here . This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available. Software distribution \u00b6 One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS . This allows any cluster, virtual machine, or event desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here . Some users use it for continuous integration, we also use it in virtual clusters in the cloud. Compatibility layer \u00b6 Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to glibc and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we have used the Nix package manager, but we are now moving toward using Gentoo Prefix instead. Scientific layer and EasyBuild \u00b6 For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2020, we have over 800 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 1,600, 3,200 and 6,000 combinations of builds. Usage of EasyBuild within Compute Canada \u00b6 To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada. Filtering out dependencies \u00b6 Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through yum or apt-get ). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example binutils , Automake , flex , etc. This is configured through our EasyBuild configuration file . Custom toolchains \u00b6 Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the iomkl or gomkl toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common foss and intel toolchains). We therefore make a heavy use of the --try-toolchain option of EasyBuild, to use upstream recipes but with our preferred toolchains. Custom module naming scheme \u00b6 We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops versionsuffix . If we need to have different flavors of a given recipe, we instead use modaltsoftname to add the flavor to the name of the software package. This is enabled through this Python module , which implements our custom module naming scheme. Using RPATH and disabling LD_LIBRARY_PATH \u00b6 Our compatibility layer has a modified linker which ensures that RPATH is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the LD_LIBRARY_PATH from the modules. This is specified in our EasyBuild configuration file . Usage of hooks \u00b6 We make a rather intensive usage of hooks. For example, we use them to inject specific configure options to our OpenMPI builds add compiler and MPI footers to the modules split the installation of the Intel compiler into redistributable and non-redistributable parts strip down the installation of Python to a small set of Python packages Python specific customizations \u00b6 Compute Canada makes heavy usage of the multi_deps feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install PyQt alongside Qt , in the same module. For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments . The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository .","title":"EasyBuild at Compute Canada"},{"location":"2020-06-isc20/computecanada/#compute-canada","text":"( author: Maxime Boissonneault, Compute Canada)","title":"Compute Canada"},{"location":"2020-06-isc20/computecanada/#general-info","text":"Compute Canada ( https://www.computecanada.ca ) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US.","title":"General info"},{"location":"2020-06-isc20/computecanada/#staff-user-base","text":"Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year.","title":"Staff &amp; user base"},{"location":"2020-06-isc20/computecanada/#resources","text":"Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud. Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs. Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size. B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs. Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, and all identical nodes with nearly 80,000 cores. Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores.","title":"Resources"},{"location":"2020-06-isc20/computecanada/#compute-canada-software-stack","text":"Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere. For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here . This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available.","title":"Compute Canada software stack"},{"location":"2020-06-isc20/computecanada/#software-distribution","text":"One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS . This allows any cluster, virtual machine, or event desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here . Some users use it for continuous integration, we also use it in virtual clusters in the cloud.","title":"Software distribution"},{"location":"2020-06-isc20/computecanada/#compatibility-layer","text":"Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to glibc and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we have used the Nix package manager, but we are now moving toward using Gentoo Prefix instead.","title":"Compatibility layer"},{"location":"2020-06-isc20/computecanada/#scientific-layer-and-easybuild","text":"For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2020, we have over 800 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 1,600, 3,200 and 6,000 combinations of builds.","title":"Scientific layer and EasyBuild"},{"location":"2020-06-isc20/computecanada/#usage-of-easybuild-within-compute-canada","text":"To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada.","title":"Usage of EasyBuild within Compute Canada"},{"location":"2020-06-isc20/computecanada/#filtering-out-dependencies","text":"Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through yum or apt-get ). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example binutils , Automake , flex , etc. This is configured through our EasyBuild configuration file .","title":"Filtering out dependencies"},{"location":"2020-06-isc20/computecanada/#custom-toolchains","text":"Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the iomkl or gomkl toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common foss and intel toolchains). We therefore make a heavy use of the --try-toolchain option of EasyBuild, to use upstream recipes but with our preferred toolchains.","title":"Custom toolchains"},{"location":"2020-06-isc20/computecanada/#custom-module-naming-scheme","text":"We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops versionsuffix . If we need to have different flavors of a given recipe, we instead use modaltsoftname to add the flavor to the name of the software package. This is enabled through this Python module , which implements our custom module naming scheme.","title":"Custom module naming scheme"},{"location":"2020-06-isc20/computecanada/#using-rpath-and-disabling-ld_library_path","text":"Our compatibility layer has a modified linker which ensures that RPATH is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the LD_LIBRARY_PATH from the modules. This is specified in our EasyBuild configuration file .","title":"Using RPATH and disabling LD_LIBRARY_PATH"},{"location":"2020-06-isc20/computecanada/#usage-of-hooks","text":"We make a rather intensive usage of hooks. For example, we use them to inject specific configure options to our OpenMPI builds add compiler and MPI footers to the modules split the installation of the Intel compiler into redistributable and non-redistributable parts strip down the installation of Python to a small set of Python packages","title":"Usage of hooks"},{"location":"2020-06-isc20/computecanada/#python-specific-customizations","text":"Compute Canada makes heavy usage of the multi_deps feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install PyQt alongside Qt , in the same module. For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments . The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository .","title":"Python specific customizations"},{"location":"2020-06-isc20/configuration/","text":"Configuration \u00b6 After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here . Available configuration settings \u00b6 One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details. Overall prefix \u00b6 (default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that setting robot also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes . Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always * win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead; Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion... $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would be less than useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which affects the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg Define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ). Exercises \u00b6 Exercise 3.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: the location of the build directories: use /tmp/$USER for this; the locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources Leave other configuration settings set to their defaults. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this: buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise 3.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in the exercise before you continue with the rest of this tutorial.","title":"Configuration"},{"location":"2020-06-isc20/configuration/#configuration","text":"After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here .","title":"Configuration"},{"location":"2020-06-isc20/configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.","title":"Available configuration settings"},{"location":"2020-06-isc20/configuration/#overall-prefix","text":"(default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"2020-06-isc20/configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used.","title":"Install path"},{"location":"2020-06-isc20/configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example.","title":"Build path"},{"location":"2020-06-isc20/configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild.","title":"Source path"},{"location":"2020-06-isc20/configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"2020-06-isc20/configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"2020-06-isc20/configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that setting robot also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"2020-06-isc20/configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes .","title":"Module naming scheme"},{"location":"2020-06-isc20/configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception!","title":"Configuration levels"},{"location":"2020-06-isc20/configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always * win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead;","title":"Configuration level hierarchy"},{"location":"2020-06-isc20/configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"2020-06-isc20/configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion...","title":"EasyBuild configuration files vs easyconfig files"},{"location":"2020-06-isc20/configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"2020-06-isc20/configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would be less than useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"2020-06-isc20/configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which affects the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg Define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ).","title":"Inspecting the current configuration (--show-config)"},{"location":"2020-06-isc20/configuration/#exercises","text":"Exercise 3.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: the location of the build directories: use /tmp/$USER for this; the locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources Leave other configuration settings set to their defaults. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this: buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise 3.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in the exercise before you continue with the rest of this tutorial.","title":"Exercises"},{"location":"2020-06-isc20/contributing/","text":"Contributing to EasyBuild \u00b6 Contribution procedure \u00b6 There are several ways to contribute to EasyBuild, including: providing feedback; reporting bugs; joining the discussions (mailing list, Slack, conf calls); sharing suggestions/ideas for enhancements & additional features; contributing easyconfigs, enhancing easyblocks, adding support for new software, implementing additional features, ...; extending & enhancing documentation; To contribute changes to the code or easyconfigs, you should: 0) Create and setup a GitHub account (and register your SSH public key); 1) First clone and fork the appropriate GitHub repository, for example: git clone git@github.com:easybuilders/easybuild-easyconfigs.git cd easybuild-easyconfigs git remote add my_fork git@github.com:example/easybuild-easyconfigs.git You should change ' example ' in the last line to your own GitHub user name! 2) Create and check out a new branch: git checkout -b example 3) Stage the changes you want to contribute: git add easybuild/easyconfigs/e/example-1.2.3.eb 4) Commit those changes with a sensible commit message: git commit -m \"This is just an example\" 5) Push your branch to your fork of the repository on GitHub: git push my_fork example 6) Open the pull request through the GitHub web interface, making sure that: the target branch is correct (should be develop ); an appropriate title is used; a short description of the changes is provided; the changes are indeed the ones you want to propose; clicking the (correct) green button; In addition, for easyconfig files you should make sure that they have the correct filename , and that they are located in the correct subdirectory. That didn't exactly motivate you to contribute, did it... Github integration features \u00b6 Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute... In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with git you may quickly end up demotivated. This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures. At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running git commands and interacting with the GitHub API . We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation . Requirements & configuration \u00b6 First of all, the GitHub integration features impose a couple of additional requirements and configuration. Additional dependencies Both the GitPython and keyring Python packages as well as the keyrings.cryptfile add-on package must be installed. In the prepared environment, you can do this via: pip3 install --user GitPython keyring keyrings.cryptfile SSH public key in GitHub account You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys ). If you need to generate an SSH key pair, you can run the following command: ssh-keygen -t rsa -b 4096 You can copy the SSH public key from the output of this command: cat .ssh/id_rsa.pub Warning If you are using the prepared tutorial environment, we strongly recommend you: to protect the SSH key pair you create with a password ; to remove the public key from your GitHub account after completing this part of the tutorial; Keep in mind that anyone who obtains your SSH private key and knows the password to unlock it can push changes to your GitHub repositories! Forked repository in GitHub In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs ). EasyBuild configuration, incl. GitHub token You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials. To do this, you should define the github-user configuration option and run the \" eb --install-github-token \" command: # replace 'ebtutorial' with your own GitHub username! $ export EASYBUILD_GITHUB_USER = ebtutorial $ eb --install-github-token To create a GitHub token: Visit https://github.com/settings/tokens . Click \"Personal access tokens\" . Click followed by \"Generate new token\" . Give the token a name (for example \"Token for EasyBuild\" ). Select both the ' repo ' and ' gist ' scopes. Click the green \"Generate token\" button. Copy the generated token. Paste the token when asked by --install-github-token (and hit Enter ). Enter a password to encrypt your GitHub token. The output should look something like this: $ eb --install-github-token == temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log Token: Validating token... Token seems to be valid, installing it. Please set a password for your new keyring: Please confirm the password: Token 'fed..987' installed! Warning If you are using the prepared tutorial environment, we strongly recommend you to revoke the GitHub token again from your GitHub account after completing this part of the tutorial. Anyone who knows the GitHub token can perform actions in your name on GitHub through the GitHub API! Checking status of GitHub integration You can check the status of the GitHub integration using \" eb --check-github \": $ eb --check-github == temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log Checking status of GitHub integration... Making sure we 're online...OK * GitHub user...ebtutorial=> OK Please enter password for encrypted keyring: * GitHub token...fed..987 (len: 40) => OK (validated) * git command...OK (\"git version 1.8.3.1; \") * GitPython module...OK (GitPython version 3.1.3) Enter passphrase for key ' /home/easybuild/.ssh/id_rsa ': Enter passphrase for key ' /home/easybuild/.ssh/id_rsa ': * push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK Enter passphrase for key ' /home/easybuild/.ssh/id_rsa ' : * creating gists...OK * location to Git working dirs... not found ( suboptimal ) All checks PASSed! Status of GitHub integration: * --from-pr: OK * --new-pr: OK * --review-pr: OK * --update-pr: OK * --upload-test-report: OK If you see ' OK ' for each of the status checks, you're all set to try out the GitHub integration features! Note If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \" eb --check-github \". You can avoid this by using an SSH agent . Creating pull requests \u00b6 The GitHub integration in EasyBuild allows you to create pull requests using the eb command , without even leaving your shell environment. How cool is that\u203d To create a pull request to the easybuild-easyconfigs repository, you can either do it in a single go by running \" eb --new-pr \" and passing it one or more easyconfig files to add into the pull request. The more detailed option is to first create a branch in your repository fork in GitHub via \" eb --new-branch-github \" and then later open the pull request via \" eb --new-pr-from-branch \". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork). The --new-pr option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa! You can control the target repository for your pull request using --pr-target-account (default is easybuilders ) and --pr-target-repo . If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \" eb --dry-run --new-pr \" or \" eb -D --new-pr \". Finally, you can use \" eb --preview-pr \" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files. Updating pull requests \u00b6 To update an existing pull request with additional changes you can use \" eb --update-pr \" and pass the pull request ID, alongside the paths to the updated files. If you have only created a branch (for example via eb --new-branch-github ) you can update it via --update-branch-github in the same way, passing the branch name instead of a pull request ID. Using a pull request \u00b6 Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which support is not yet included in the latest EasyBuild release. Using the --from-pr option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the --robot option to ensure that the easyconfig files are installed in the correct order with respect to dependencies. Similarly, using a new or updated easyblock from a pull request is as simple as using the --include-easyblocks-from-pr option. And of course you can combine it with --from-pr ! Via --upload-test-report you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration. Demo \u00b6 That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the eb-tutorial example software to a fork of the easybuild-easyconfigs repository using the eb command, and submit a test report in it. Note Make sure that you have correctly configured the GitHub integration, see above . Creating pull request \u00b6 We first configure EasyBuild to target the boegel GitHub account rather than the default easybuilders GitHub organisation, by defining the pr-target-account configuration setting: export EASYBUILD_PR_TARGET_ACCOUNT = boegel In the output of \" eb --show-config \" you should see a line like this: pr-target-account (E) = boegel We only do this to avoid that lots of pull requests for the eb-tutorial example software are opened in the central easyconfigs repository . Opening a pull request is as simple as running \" eb --new-pr \" and passing the easyconfig file: $ eb --new-pr eb-tutorial.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == fetching branch 'develop' from https://github.com/boegel/easybuild-easyconfigs.git... == copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs... == pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' ( git@github.com:ebtutorial/easybuild-easyconfigs.git ) Enter passphrase for key '/home/example/.ssh/id_rsa' : Please enter password for encrypted keyring: Opening pull request * target: boegel/easybuild-easyconfigs:develop * from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100 * title: \"{tools}[GCC/9.3.0] eb-tutorial v1.0.0\" * labels: new * description: \"\"\" (created using `eb --new-pr`) \"\"\" * overview of changes: easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.0-GCC-9.3.0.eb | 26 ++++++++++++++++++++++++++ 1 file changed, 26 insertions ( + ) Opened pull request: https://github.com/boegel/easybuild-easyconfigs/pull/65 == Temporary log file ( s ) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed. == Temporary directory /tmp/eb-ggr6scbq has been removed. Take a moment to grasp what we did here: we ran a single eb command which took care of the whole contribution procedure for us, including: Cloning the easybuilders/easybuild-easyconfigs repository and checking out the develop branch (in a temporary directory); Picking a sensible name for a branch and creating it; Adding the eb-tutorial easyconfig file to the branch, in the correct location ( easybuild/easyconfigs/e/eb-tutorial/ ) and with the correct filename ( eb-tutorial-1.0.0-GCC-9.3.0.eb ); Pushing the branch to our fork ( example/easybuild-easyconfigs ); Actually opening the pull request, using an informative title. That is so... easy! This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the develop branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to). There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since --new-pr created the branch only in a temporary directory). If many contributions are made via --new-pr it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar. Warning If you are using the prepared tutorial environment, do not forget to remove the GitHub public key and GitHub token that you created earlier for this part of the tutorial from your GitHub account! Uploading test report \u00b6 After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request. First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for eb-tutorial are already installed there: module use /easybuild/modules/all You can verify which dependencies are still missing using --from-pr combined with --missing : # change '65' to the ID of your own pull request (see output of --new-pr) $ eb --from-pr 65 --missing == temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log Please enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... 1 out of 20 required modules missing: * eb-tutorial/1.0.0-GCC-9.3.0 ( eb-tutorial-1.0.0-GCC-9.3.0.eb ) Uploading a test report boils down to combining --from-pr with --upload-test-report : # change '65' to the ID of your own pull request (see output of --new-pr) $ eb --rebuild --from-pr 65 --upload-test-report Please enter password for encrypted keyring: ... == processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.0-GCC-9.3.0.eb == building and installing eb-tutorial/1.0.0-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 2 sec ) ... Adding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial **SUCCESS** Build succeeded for 1 out of 1 ( 1 easyconfigs in this PR ) example - Linux centos linux 7 .8.2003, x86_64, Intel ( R ) Core ( TM ) i5-7360U CPU @ 2 .30GHz ( haswell ) , Python 3 .6.8 See https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report. ' == Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#65 Note that we may need to use --rebuild here since eb-tutorial may already be installed. This results in a comment being added to the pull request: The gist linked from this comment provides more detailed information: Contribution stats \u00b6 To wrap up, let us look at some statistics about the contributions that have been made to EasyBuild over the years. Unique contributors \u00b6 Since EasyBuild went public in 2012 more than 250 different people have made contributions to the easybuild-easyconfigs repository. We also recently passed the threshold of 100 unique contributors in the easyblocks repository, and at the time of writing we were just one contributor short of reaching 100 unique contributors to the EasyBuild framework repository. If we look at unique contributors per year, we see that the number of contributors to the easyconfigs repository has been gradually increasing over the years, while the number of unique contributors to the framework and easyblocks repositories has largely remained stable. Making contributions to the latter two repositories requires significantly more effort, which explains the difference with the easyconfigs repository. Pull requests per year (easyconfigs) \u00b6 Plotting the number of pull requests to the easyconfigs repository per year clearly shows an increase, with almost 2,100 merged contributions in 2019. In total over 2,600 pull requests were merged in 2019 across all EasyBuild repositories. It is also worth noting that in 2019 about two thirds of all contributions were made by people outside of the HPC-UGent team. Looking at the ratio of pull requests that were created using --new-pr versus the ones that were created manually shows a steady increase in adoption since 2016 the GitHub integration feature. Throughout 2019, 77% of all pull requests were made using --new-pr , and we see this increasing further in 2020.","title":"Contributing to EasyBuild"},{"location":"2020-06-isc20/contributing/#contributing-to-easybuild","text":"","title":"Contributing to EasyBuild"},{"location":"2020-06-isc20/contributing/#contribution-procedure","text":"There are several ways to contribute to EasyBuild, including: providing feedback; reporting bugs; joining the discussions (mailing list, Slack, conf calls); sharing suggestions/ideas for enhancements & additional features; contributing easyconfigs, enhancing easyblocks, adding support for new software, implementing additional features, ...; extending & enhancing documentation; To contribute changes to the code or easyconfigs, you should: 0) Create and setup a GitHub account (and register your SSH public key); 1) First clone and fork the appropriate GitHub repository, for example: git clone git@github.com:easybuilders/easybuild-easyconfigs.git cd easybuild-easyconfigs git remote add my_fork git@github.com:example/easybuild-easyconfigs.git You should change ' example ' in the last line to your own GitHub user name! 2) Create and check out a new branch: git checkout -b example 3) Stage the changes you want to contribute: git add easybuild/easyconfigs/e/example-1.2.3.eb 4) Commit those changes with a sensible commit message: git commit -m \"This is just an example\" 5) Push your branch to your fork of the repository on GitHub: git push my_fork example 6) Open the pull request through the GitHub web interface, making sure that: the target branch is correct (should be develop ); an appropriate title is used; a short description of the changes is provided; the changes are indeed the ones you want to propose; clicking the (correct) green button; In addition, for easyconfig files you should make sure that they have the correct filename , and that they are located in the correct subdirectory. That didn't exactly motivate you to contribute, did it...","title":"Contribution procedure"},{"location":"2020-06-isc20/contributing/#github-integration-features","text":"Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute... In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with git you may quickly end up demotivated. This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures. At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running git commands and interacting with the GitHub API . We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation .","title":"Github integration features"},{"location":"2020-06-isc20/contributing/#requirements-configuration","text":"First of all, the GitHub integration features impose a couple of additional requirements and configuration. Additional dependencies Both the GitPython and keyring Python packages as well as the keyrings.cryptfile add-on package must be installed. In the prepared environment, you can do this via: pip3 install --user GitPython keyring keyrings.cryptfile SSH public key in GitHub account You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys ). If you need to generate an SSH key pair, you can run the following command: ssh-keygen -t rsa -b 4096 You can copy the SSH public key from the output of this command: cat .ssh/id_rsa.pub Warning If you are using the prepared tutorial environment, we strongly recommend you: to protect the SSH key pair you create with a password ; to remove the public key from your GitHub account after completing this part of the tutorial; Keep in mind that anyone who obtains your SSH private key and knows the password to unlock it can push changes to your GitHub repositories! Forked repository in GitHub In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs ). EasyBuild configuration, incl. GitHub token You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials. To do this, you should define the github-user configuration option and run the \" eb --install-github-token \" command: # replace 'ebtutorial' with your own GitHub username! $ export EASYBUILD_GITHUB_USER = ebtutorial $ eb --install-github-token To create a GitHub token: Visit https://github.com/settings/tokens . Click \"Personal access tokens\" . Click followed by \"Generate new token\" . Give the token a name (for example \"Token for EasyBuild\" ). Select both the ' repo ' and ' gist ' scopes. Click the green \"Generate token\" button. Copy the generated token. Paste the token when asked by --install-github-token (and hit Enter ). Enter a password to encrypt your GitHub token. The output should look something like this: $ eb --install-github-token == temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log Token: Validating token... Token seems to be valid, installing it. Please set a password for your new keyring: Please confirm the password: Token 'fed..987' installed! Warning If you are using the prepared tutorial environment, we strongly recommend you to revoke the GitHub token again from your GitHub account after completing this part of the tutorial. Anyone who knows the GitHub token can perform actions in your name on GitHub through the GitHub API! Checking status of GitHub integration You can check the status of the GitHub integration using \" eb --check-github \": $ eb --check-github == temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log Checking status of GitHub integration... Making sure we 're online...OK * GitHub user...ebtutorial=> OK Please enter password for encrypted keyring: * GitHub token...fed..987 (len: 40) => OK (validated) * git command...OK (\"git version 1.8.3.1; \") * GitPython module...OK (GitPython version 3.1.3) Enter passphrase for key ' /home/easybuild/.ssh/id_rsa ': Enter passphrase for key ' /home/easybuild/.ssh/id_rsa ': * push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK Enter passphrase for key ' /home/easybuild/.ssh/id_rsa ' : * creating gists...OK * location to Git working dirs... not found ( suboptimal ) All checks PASSed! Status of GitHub integration: * --from-pr: OK * --new-pr: OK * --review-pr: OK * --update-pr: OK * --upload-test-report: OK If you see ' OK ' for each of the status checks, you're all set to try out the GitHub integration features! Note If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \" eb --check-github \". You can avoid this by using an SSH agent .","title":"Requirements &amp; configuration"},{"location":"2020-06-isc20/contributing/#creating-pull-requests","text":"The GitHub integration in EasyBuild allows you to create pull requests using the eb command , without even leaving your shell environment. How cool is that\u203d To create a pull request to the easybuild-easyconfigs repository, you can either do it in a single go by running \" eb --new-pr \" and passing it one or more easyconfig files to add into the pull request. The more detailed option is to first create a branch in your repository fork in GitHub via \" eb --new-branch-github \" and then later open the pull request via \" eb --new-pr-from-branch \". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork). The --new-pr option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa! You can control the target repository for your pull request using --pr-target-account (default is easybuilders ) and --pr-target-repo . If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \" eb --dry-run --new-pr \" or \" eb -D --new-pr \". Finally, you can use \" eb --preview-pr \" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.","title":"Creating pull requests"},{"location":"2020-06-isc20/contributing/#updating-pull-requests","text":"To update an existing pull request with additional changes you can use \" eb --update-pr \" and pass the pull request ID, alongside the paths to the updated files. If you have only created a branch (for example via eb --new-branch-github ) you can update it via --update-branch-github in the same way, passing the branch name instead of a pull request ID.","title":"Updating pull requests"},{"location":"2020-06-isc20/contributing/#using-a-pull-request","text":"Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which support is not yet included in the latest EasyBuild release. Using the --from-pr option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the --robot option to ensure that the easyconfig files are installed in the correct order with respect to dependencies. Similarly, using a new or updated easyblock from a pull request is as simple as using the --include-easyblocks-from-pr option. And of course you can combine it with --from-pr ! Via --upload-test-report you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.","title":"Using a pull request"},{"location":"2020-06-isc20/contributing/#demo","text":"That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the eb-tutorial example software to a fork of the easybuild-easyconfigs repository using the eb command, and submit a test report in it. Note Make sure that you have correctly configured the GitHub integration, see above .","title":"Demo"},{"location":"2020-06-isc20/contributing/#creating-pull-request","text":"We first configure EasyBuild to target the boegel GitHub account rather than the default easybuilders GitHub organisation, by defining the pr-target-account configuration setting: export EASYBUILD_PR_TARGET_ACCOUNT = boegel In the output of \" eb --show-config \" you should see a line like this: pr-target-account (E) = boegel We only do this to avoid that lots of pull requests for the eb-tutorial example software are opened in the central easyconfigs repository . Opening a pull request is as simple as running \" eb --new-pr \" and passing the easyconfig file: $ eb --new-pr eb-tutorial.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == fetching branch 'develop' from https://github.com/boegel/easybuild-easyconfigs.git... == copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs... == pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' ( git@github.com:ebtutorial/easybuild-easyconfigs.git ) Enter passphrase for key '/home/example/.ssh/id_rsa' : Please enter password for encrypted keyring: Opening pull request * target: boegel/easybuild-easyconfigs:develop * from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100 * title: \"{tools}[GCC/9.3.0] eb-tutorial v1.0.0\" * labels: new * description: \"\"\" (created using `eb --new-pr`) \"\"\" * overview of changes: easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.0-GCC-9.3.0.eb | 26 ++++++++++++++++++++++++++ 1 file changed, 26 insertions ( + ) Opened pull request: https://github.com/boegel/easybuild-easyconfigs/pull/65 == Temporary log file ( s ) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed. == Temporary directory /tmp/eb-ggr6scbq has been removed. Take a moment to grasp what we did here: we ran a single eb command which took care of the whole contribution procedure for us, including: Cloning the easybuilders/easybuild-easyconfigs repository and checking out the develop branch (in a temporary directory); Picking a sensible name for a branch and creating it; Adding the eb-tutorial easyconfig file to the branch, in the correct location ( easybuild/easyconfigs/e/eb-tutorial/ ) and with the correct filename ( eb-tutorial-1.0.0-GCC-9.3.0.eb ); Pushing the branch to our fork ( example/easybuild-easyconfigs ); Actually opening the pull request, using an informative title. That is so... easy! This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the develop branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to). There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since --new-pr created the branch only in a temporary directory). If many contributions are made via --new-pr it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar. Warning If you are using the prepared tutorial environment, do not forget to remove the GitHub public key and GitHub token that you created earlier for this part of the tutorial from your GitHub account!","title":"Creating pull request"},{"location":"2020-06-isc20/contributing/#uploading-test-report","text":"After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request. First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for eb-tutorial are already installed there: module use /easybuild/modules/all You can verify which dependencies are still missing using --from-pr combined with --missing : # change '65' to the ID of your own pull request (see output of --new-pr) $ eb --from-pr 65 --missing == temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log Please enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... 1 out of 20 required modules missing: * eb-tutorial/1.0.0-GCC-9.3.0 ( eb-tutorial-1.0.0-GCC-9.3.0.eb ) Uploading a test report boils down to combining --from-pr with --upload-test-report : # change '65' to the ID of your own pull request (see output of --new-pr) $ eb --rebuild --from-pr 65 --upload-test-report Please enter password for encrypted keyring: ... == processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.0-GCC-9.3.0.eb == building and installing eb-tutorial/1.0.0-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 2 sec ) ... Adding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial **SUCCESS** Build succeeded for 1 out of 1 ( 1 easyconfigs in this PR ) example - Linux centos linux 7 .8.2003, x86_64, Intel ( R ) Core ( TM ) i5-7360U CPU @ 2 .30GHz ( haswell ) , Python 3 .6.8 See https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report. ' == Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#65 Note that we may need to use --rebuild here since eb-tutorial may already be installed. This results in a comment being added to the pull request: The gist linked from this comment provides more detailed information:","title":"Uploading test report"},{"location":"2020-06-isc20/contributing/#contribution-stats","text":"To wrap up, let us look at some statistics about the contributions that have been made to EasyBuild over the years.","title":"Contribution stats"},{"location":"2020-06-isc20/contributing/#unique-contributors","text":"Since EasyBuild went public in 2012 more than 250 different people have made contributions to the easybuild-easyconfigs repository. We also recently passed the threshold of 100 unique contributors in the easyblocks repository, and at the time of writing we were just one contributor short of reaching 100 unique contributors to the EasyBuild framework repository. If we look at unique contributors per year, we see that the number of contributors to the easyconfigs repository has been gradually increasing over the years, while the number of unique contributors to the framework and easyblocks repositories has largely remained stable. Making contributions to the latter two repositories requires significantly more effort, which explains the difference with the easyconfigs repository.","title":"Unique contributors"},{"location":"2020-06-isc20/contributing/#pull-requests-per-year-easyconfigs","text":"Plotting the number of pull requests to the easyconfigs repository per year clearly shows an increase, with almost 2,100 merged contributions in 2019. In total over 2,600 pull requests were merged in 2019 across all EasyBuild repositories. It is also worth noting that in 2019 about two thirds of all contributions were made by people outside of the HPC-UGent team. Looking at the ratio of pull requests that were created using --new-pr versus the ones that were created manually shows a steady increase in adoption since 2016 the GitHub integration feature. Throughout 2019, 77% of all pull requests were made using --new-pr , and we see this increasing further in 2020.","title":"Pull requests per year (easyconfigs)"},{"location":"2020-06-isc20/getting_help/","text":"Getting help \u00b6 If you have any questions about EasyBuild, or if you need help, please don't hesitate to reach out to the EasyBuild community through one of these channels. Documentation \u00b6 Make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io . It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful. You can open an issue in one of the EasyBuild repositories in the easybuilders GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements. Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate. You can also use the search box on the top left to see if somebody else has already asked a similar question. Mailing list \u00b6 Feel free to ask any questions or provide feedback via the EasyBuild mailing list easybuild@lists.ugent.be . Keep in mind that you need to be subscribed to the mailing list in order to post messages there! You can subscribe via this link . In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel. The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 275 people have joined it so far, and there is usually somebody awake in there who may be able to help you out. To join the EasyBuild Slack, request an invitation via this link . If you are not a big fan of Slack, you can also consider joining the #easybuild IRC channel (available on the Freenode IRC network ). A bot relays messages between this IRC channel and the #general channel in the EasyBuild Slack. Note A dedicated #tutorial channel was created for this tutorial in the EasyBuild Slack. If you have any questions that are specific to this tutorial, please post them there. Conference calls \u00b6 Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call. These conference calls are open to anyone interested in the EasyBuild project. More information, including the dates and times of the next calls, is available here .","title":"Getting help"},{"location":"2020-06-isc20/getting_help/#getting-help","text":"If you have any questions about EasyBuild, or if you need help, please don't hesitate to reach out to the EasyBuild community through one of these channels.","title":"Getting help"},{"location":"2020-06-isc20/getting_help/#documentation","text":"Make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io . It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful. You can open an issue in one of the EasyBuild repositories in the easybuilders GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements. Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate. You can also use the search box on the top left to see if somebody else has already asked a similar question.","title":"Documentation"},{"location":"2020-06-isc20/getting_help/#mailing-list","text":"Feel free to ask any questions or provide feedback via the EasyBuild mailing list easybuild@lists.ugent.be . Keep in mind that you need to be subscribed to the mailing list in order to post messages there! You can subscribe via this link . In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel. The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 275 people have joined it so far, and there is usually somebody awake in there who may be able to help you out. To join the EasyBuild Slack, request an invitation via this link . If you are not a big fan of Slack, you can also consider joining the #easybuild IRC channel (available on the Freenode IRC network ). A bot relays messages between this IRC channel and the #general channel in the EasyBuild Slack. Note A dedicated #tutorial channel was created for this tutorial in the EasyBuild Slack. If you have any questions that are specific to this tutorial, please post them there.","title":"Mailing list"},{"location":"2020-06-isc20/getting_help/#conference-calls","text":"Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call. These conference calls are open to anyone interested in the EasyBuild project. More information, including the dates and times of the next calls, is available here .","title":"Conference calls"},{"location":"2020-06-isc20/hmns/","text":"Hierarchical module naming schemes \u00b6 Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing Bowtie2-2.4.1-GCC-9.3.0.eb the generated module was named Bowtie2/2.4.1-GCC-9.3.0 . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. Flat vs hierarchical \u00b6 The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . As you will notice, at every level we select the module of the layer we are entering. At core level we select our compiler. When in the compiler level we select our MPI implementation, and within the MPI level we select our software. Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These corresponds to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installing using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy. Pros & cons \u00b6 So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users; Length of module names \u00b6 When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean! Amount of available modules \u00b6 The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can quickly grow into the hundreds or even thousands! Yikes! This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a modest set of modules are available, and relatively small groups of additional modules become available as gateway modules are loaded. Loading compatible modules \u00b6 Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise and you are being very careful... In a module hierarchy this can be prevented, since modules for software that was installed with a different compiler and/or a different MPI library is located in a different part of the module hierarchy, and thus these modules will be prevented from being loaded together. Visibility of existing modules \u00b6 One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file. Semantics of gateway modules \u00b6 An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy. Example \u00b6 Warning This example will not work when running the prepared container image using Singularity , because the /easybuild directory is read-only in this case, and EasyBuild still requires write access to /easybuild/software even when generate module files outside of /easybuild . Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations. Preparing the environment \u00b6 Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/9.3.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 Configuring EasyBuild \u00b6 First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example. Generating modules for HDF5 \u00b6 Let us now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.6-gompi-2020a.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.6-gompi-2020a.eb --robot --module-only ... == building and installing MPI/GCC/9.3.0/OpenMPI/4.0.3/HDF5/1.10.6... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 37 out of 37 This should take about 2 minutes in total, for generating 37 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation... Loading the HDF5 module \u00b6 After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let us see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 flex/2.6.4 help2man/1.47.4 Bison/3.5.3 (D) M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 binutils/2.34 gompi/2020a zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let us see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.6\" module is available to load. GCC/9.3.0 OpenMPI/4.0.3 This tells us we need to load two gateway modules before we can load the module for HDF5. Let us start with loading the GCC compiler module: module load GCC/9.3.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 -------------- OpenMPI/4.0.3 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/9.3.0 ------------ Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 ... Szip/2.1.1 libpciaccess/0.16 zlib/1.2.11 (L,D) UCX/1.8.0 libreadline/8.0 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.5.3 M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 (L) binutils/2.34 gompi/2020a zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/9.3.0 and Compiler/GCC/9.3.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 9.3.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.3 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/9.3.0 and OpenMPI/4.0.3 modules first. So, let us do exactly that (remember that GCC/9.3.0 is already loaded): module load OpenMPI/4.0.3 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.6 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------- HDF5/1.10.6 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 ------------ OpenMPI/4.0.3 (L) ... To use HDF5, we just need to load this module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.6 $ h5dump --version h5dump: Version 1.10.6 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/9.3.0 5 ) numactl/2.0.13 9 ) hwloc/2.2.0 13 ) HDF5/1.10.6 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) UCX/1.8.0 3 ) binutils/2.34 7 ) libxml2/2.9.10 11 ) OpenMPI/4.0.3 4 ) GCC/9.3.0 8 ) libpciaccess/0.16 12 ) Szip/2.1.1 Exercise \u00b6 Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.03-Python-3.8.2 Load the gateway modules: module load GCC/9.3.0 OpenMPI/4.0.3 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------ SciPy-bundle/2020.03-Python-3.8.2 module load SciPy-bundle/2020.03-Python-3.8.2 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.0.3 Warning This exercise will not work when running the prepared container image using Singularity , because the /easybuild directory is read-only in this case, and EasyBuild still requires write access to /easybuild/software even when generate module files outside of /easybuild .","title":"Hierarchical module naming schemes"},{"location":"2020-06-isc20/hmns/#hierarchical-module-naming-schemes","text":"Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing Bowtie2-2.4.1-GCC-9.3.0.eb the generated module was named Bowtie2/2.4.1-GCC-9.3.0 . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild.","title":"Hierarchical module naming schemes"},{"location":"2020-06-isc20/hmns/#flat-vs-hierarchical","text":"The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . As you will notice, at every level we select the module of the layer we are entering. At core level we select our compiler. When in the compiler level we select our MPI implementation, and within the MPI level we select our software. Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These corresponds to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installing using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.","title":"Flat vs hierarchical"},{"location":"2020-06-isc20/hmns/#pros-cons","text":"So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users;","title":"Pros &amp; cons"},{"location":"2020-06-isc20/hmns/#length-of-module-names","text":"When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean!","title":"Length of module names"},{"location":"2020-06-isc20/hmns/#amount-of-available-modules","text":"The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can quickly grow into the hundreds or even thousands! Yikes! This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a modest set of modules are available, and relatively small groups of additional modules become available as gateway modules are loaded.","title":"Amount of available modules"},{"location":"2020-06-isc20/hmns/#loading-compatible-modules","text":"Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise and you are being very careful... In a module hierarchy this can be prevented, since modules for software that was installed with a different compiler and/or a different MPI library is located in a different part of the module hierarchy, and thus these modules will be prevented from being loaded together.","title":"Loading compatible modules"},{"location":"2020-06-isc20/hmns/#visibility-of-existing-modules","text":"One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.","title":"Visibility of existing modules"},{"location":"2020-06-isc20/hmns/#semantics-of-gateway-modules","text":"An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy.","title":"Semantics of gateway modules"},{"location":"2020-06-isc20/hmns/#example","text":"Warning This example will not work when running the prepared container image using Singularity , because the /easybuild directory is read-only in this case, and EasyBuild still requires write access to /easybuild/software even when generate module files outside of /easybuild . Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.","title":"Example"},{"location":"2020-06-isc20/hmns/#preparing-the-environment","text":"Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/9.3.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3","title":"Preparing the environment"},{"location":"2020-06-isc20/hmns/#configuring-easybuild","text":"First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example.","title":"Configuring EasyBuild"},{"location":"2020-06-isc20/hmns/#generating-modules-for-hdf5","text":"Let us now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.6-gompi-2020a.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.6-gompi-2020a.eb --robot --module-only ... == building and installing MPI/GCC/9.3.0/OpenMPI/4.0.3/HDF5/1.10.6... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 37 out of 37 This should take about 2 minutes in total, for generating 37 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...","title":"Generating modules for HDF5"},{"location":"2020-06-isc20/hmns/#loading-the-hdf5-module","text":"After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let us see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 flex/2.6.4 help2man/1.47.4 Bison/3.5.3 (D) M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 binutils/2.34 gompi/2020a zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let us see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.6\" module is available to load. GCC/9.3.0 OpenMPI/4.0.3 This tells us we need to load two gateway modules before we can load the module for HDF5. Let us start with loading the GCC compiler module: module load GCC/9.3.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 -------------- OpenMPI/4.0.3 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/9.3.0 ------------ Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 ... Szip/2.1.1 libpciaccess/0.16 zlib/1.2.11 (L,D) UCX/1.8.0 libreadline/8.0 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.5.3 M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 (L) binutils/2.34 gompi/2020a zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/9.3.0 and Compiler/GCC/9.3.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 9.3.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.3 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/9.3.0 and OpenMPI/4.0.3 modules first. So, let us do exactly that (remember that GCC/9.3.0 is already loaded): module load OpenMPI/4.0.3 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.6 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------- HDF5/1.10.6 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 ------------ OpenMPI/4.0.3 (L) ... To use HDF5, we just need to load this module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.6 $ h5dump --version h5dump: Version 1.10.6 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/9.3.0 5 ) numactl/2.0.13 9 ) hwloc/2.2.0 13 ) HDF5/1.10.6 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) UCX/1.8.0 3 ) binutils/2.34 7 ) libxml2/2.9.10 11 ) OpenMPI/4.0.3 4 ) GCC/9.3.0 8 ) libpciaccess/0.16 12 ) Szip/2.1.1","title":"Loading the HDF5 module"},{"location":"2020-06-isc20/hmns/#exercise","text":"Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.03-Python-3.8.2 Load the gateway modules: module load GCC/9.3.0 OpenMPI/4.0.3 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------ SciPy-bundle/2020.03-Python-3.8.2 module load SciPy-bundle/2020.03-Python-3.8.2 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.0.3 Warning This exercise will not work when running the prepared container image using Singularity , because the /easybuild directory is read-only in this case, and EasyBuild still requires write access to /easybuild/software even when generate module files outside of /easybuild .","title":"Exercise"},{"location":"2020-06-isc20/installation/","text":"Installation \u00b6 Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version and eb --help Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation . Installing EasyBuild \u00b6 We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip (recommended) \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). pip vs pip3 \u00b6 On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH $EB_PYTHON and $EB_VERBOSE If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. For example, to ensure that eb uses python3 : export EB_PYTHON = python3 To get a better view on which python commands are being considered by the eb command, you can (temporarily) define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3 ) >> python3 -m easybuild.main --version This is EasyBuild 4 .2.1 ( framework: 4 .2.1, easyblocks: 4 .2.1 ) on host example Method 2: Bootstrapping EasyBuild \u00b6 Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it. Step 1: Downloading the bootstrap script \u00b6 First, download the latest version of the EasyBuild bootstrap script from GitHub. A common way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py Step 2: Running the bootstrap script \u00b6 To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). Step 3: Loading the EasyBuild module \u00b6 Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands. That is expected behaviour and completely normal. Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial. System information \u00b6 You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Exercise \u00b6 Install EasyBuild in your home directory Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure (or try both installation methods)! perform a bootstrap installation into $HOME/easybuild install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option Check that the installation works by running the verification commands outlined above . (click to show solution using bootstrapping) To perform a bootstrap installation, it suffices to download the bootstrap script and run it using the python3 command. $ curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py ... $ python3 bootstrap_eb.py $HOME/easybuild [[INFO]] EasyBuild bootstrap script (version 20200203.01, MD5: fcb6314d4e0747db9c28a71f8bb2870c) [[INFO]] Found Python 3.6.8 (default, Apr 2 2020, 13:34:55) ; [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] [[INFO]] Installation prefix /home/easybuild/easybuild ... Afterwards we can just load the generated module, which already takes care of correctly setting $EB_PYTHON to ensure the right python command is used: $ module use $HOME/easybuild/modules/all $ module load EasyBuild $ echo $EB_PYTHON /usr/bin/python3 $ eb --version This is EasyBuild 4.2.1 (framework: 4.2.1, easyblocks: 4.2.1) on host example. (click to show solution using pip) To ensure that EasyBuild is installed with Python 3, we need to use the pip3 command rather than just pip . We can install EasyBuild using pip3 install --user , and update $PATH and define $EB_PYTHON to ensure the right python command is used (the order in which we do this doesn't matter): export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 pip3 install --user easybuild Or we can use pip3 install --prefix , but then we need to update both $PATH and $PYTHONPATH (after checking the Python version), and also define $EB_PTYHON : $ python -V Python 3 .6.8 export PATH = $HOME /bin: $PATH export PYTHONPATH = $HOME /lib/python3.6/site-packages: $PATH export EB_PYTHON = python3 pip3 install --prefix $HOME easybuild Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial!","title":"Installation"},{"location":"2020-06-isc20/installation/#installation","text":"Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version and eb --help","title":"Installation"},{"location":"2020-06-isc20/installation/#requirements","text":"","title":"Requirements"},{"location":"2020-06-isc20/installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project.","title":"Linux"},{"location":"2020-06-isc20/installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.","title":"Python"},{"location":"2020-06-isc20/installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"2020-06-isc20/installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"2020-06-isc20/installation/#python-2-or-python-3","text":"For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation .","title":"Python 2 or Python 3?"},{"location":"2020-06-isc20/installation/#installing-easybuild","text":"We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty!","title":"Installing EasyBuild"},{"location":"2020-06-isc20/installation/#method-1-using-pip-recommended","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip (recommended)"},{"location":"2020-06-isc20/installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"2020-06-isc20/installation/#pip-vs-pip3","text":"On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above.","title":"pip vs pip3"},{"location":"2020-06-isc20/installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH $EB_PYTHON and $EB_VERBOSE If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. For example, to ensure that eb uses python3 : export EB_PYTHON = python3 To get a better view on which python commands are being considered by the eb command, you can (temporarily) define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3 ) >> python3 -m easybuild.main --version This is EasyBuild 4 .2.1 ( framework: 4 .2.1, easyblocks: 4 .2.1 ) on host example","title":"Updating your environment"},{"location":"2020-06-isc20/installation/#method-2-bootstrapping-easybuild","text":"Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it.","title":"Method 2: Bootstrapping EasyBuild"},{"location":"2020-06-isc20/installation/#step-1-downloading-the-bootstrap-script","text":"First, download the latest version of the EasyBuild bootstrap script from GitHub. A common way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py","title":"Step 1: Downloading the bootstrap script"},{"location":"2020-06-isc20/installation/#step-2-running-the-bootstrap-script","text":"To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Step 2: Running the bootstrap script"},{"location":"2020-06-isc20/installation/#step-3-loading-the-easybuild-module","text":"Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands. That is expected behaviour and completely normal.","title":"Step 3: Loading the EasyBuild module"},{"location":"2020-06-isc20/installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"2020-06-isc20/installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"2020-06-isc20/installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"2020-06-isc20/installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial.","title":"Showing the default EasyBuild configuration"},{"location":"2020-06-isc20/installation/#system-information","text":"You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info","title":"System information"},{"location":"2020-06-isc20/installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration.","title":"Updating EasyBuild"},{"location":"2020-06-isc20/installation/#exercise","text":"Install EasyBuild in your home directory Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure (or try both installation methods)! perform a bootstrap installation into $HOME/easybuild install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option Check that the installation works by running the verification commands outlined above . (click to show solution using bootstrapping) To perform a bootstrap installation, it suffices to download the bootstrap script and run it using the python3 command. $ curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py ... $ python3 bootstrap_eb.py $HOME/easybuild [[INFO]] EasyBuild bootstrap script (version 20200203.01, MD5: fcb6314d4e0747db9c28a71f8bb2870c) [[INFO]] Found Python 3.6.8 (default, Apr 2 2020, 13:34:55) ; [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] [[INFO]] Installation prefix /home/easybuild/easybuild ... Afterwards we can just load the generated module, which already takes care of correctly setting $EB_PYTHON to ensure the right python command is used: $ module use $HOME/easybuild/modules/all $ module load EasyBuild $ echo $EB_PYTHON /usr/bin/python3 $ eb --version This is EasyBuild 4.2.1 (framework: 4.2.1, easyblocks: 4.2.1) on host example. (click to show solution using pip) To ensure that EasyBuild is installed with Python 3, we need to use the pip3 command rather than just pip . We can install EasyBuild using pip3 install --user , and update $PATH and define $EB_PYTHON to ensure the right python command is used (the order in which we do this doesn't matter): export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 pip3 install --user easybuild Or we can use pip3 install --prefix , but then we need to update both $PATH and $PYTHONPATH (after checking the Python version), and also define $EB_PTYHON : $ python -V Python 3 .6.8 export PATH = $HOME /bin: $PATH export PYTHONPATH = $HOME /lib/python3.6/site-packages: $PATH export EB_PYTHON = python3 pip3 install --prefix $HOME easybuild Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial!","title":"Exercise"},{"location":"2020-06-isc20/introduction/","text":"Introduction \u00b6 What is EasyBuild? \u00b6 EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments. Elevator pitch \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among worldwide HPC sites. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry runs and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you. Implementation \u00b6 EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository. Terminology \u00b6 Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ). Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files ). Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory . The following parameters must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If these parameters are not provided, the corresponding default value will be used. Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules . As you can tell the common terminology here is a mess, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation); Dependencies \u00b6 A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed; The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). System toolchain \u00b6 The system toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation. Common toolchains \u00b6 The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , OpenBLAS , ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation . Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour may be changed via the --optarch configuration setting . Reproducibility \u00b6 In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Introduction"},{"location":"2020-06-isc20/introduction/#introduction","text":"","title":"Introduction"},{"location":"2020-06-isc20/introduction/#what-is-easybuild","text":"EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments.","title":"What is EasyBuild?"},{"location":"2020-06-isc20/introduction/#elevator-pitch","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among worldwide HPC sites.","title":"Elevator pitch"},{"location":"2020-06-isc20/introduction/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry runs and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release.","title":"Key features"},{"location":"2020-06-isc20/introduction/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you.","title":"What EasyBuild is not"},{"location":"2020-06-isc20/introduction/#implementation","text":"EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository.","title":"Implementation"},{"location":"2020-06-isc20/introduction/#terminology","text":"Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms.","title":"Terminology"},{"location":"2020-06-isc20/introduction/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ).","title":"Framework"},{"location":"2020-06-isc20/introduction/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files ).","title":"Easyblocks"},{"location":"2020-06-isc20/introduction/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory . The following parameters must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If these parameters are not provided, the corresponding default value will be used.","title":"Easyconfig files"},{"location":"2020-06-isc20/introduction/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules . As you can tell the common terminology here is a mess, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation);","title":"Extensions"},{"location":"2020-06-isc20/introduction/#dependencies","text":"A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed; The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial.","title":"Dependencies"},{"location":"2020-06-isc20/introduction/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"2020-06-isc20/introduction/#system-toolchain","text":"The system toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.","title":"System toolchain"},{"location":"2020-06-isc20/introduction/#common-toolchains","text":"The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , OpenBLAS , ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation .","title":"Common toolchains"},{"location":"2020-06-isc20/introduction/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"2020-06-isc20/introduction/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.","title":"Bringing it all together"},{"location":"2020-06-isc20/introduction/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"2020-06-isc20/introduction/#performance","text":"EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour may be changed via the --optarch configuration setting .","title":"Performance"},{"location":"2020-06-isc20/introduction/#reproducibility","text":"In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"2020-06-isc20/introduction/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Community effort"},{"location":"2020-06-isc20/jsc/","text":"J\u00fclich Supercomputing Centre \u00b6 ( author: Alan O'Cais, J\u00fclich Supercomputing Centre) General info \u00b6 The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc ) at Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process. Staff & user base \u00b6 About 200 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services. In cooperation with hardware and software vendors like IBM, Intel and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008. Resources \u00b6 JSC currently manages 3 primary systems (in addition to a number of other development clusters): JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance. In the coming months, JUWELS will become the first supercomputer equipped with NVIDIA A100 GPU, when a new GPU module providing an additional 58 Petaflops will be installed. This module will make JUWELS the most powerful supercomputer in Europe. JURECA is the precursor system to JUWELS with 1.8 (CPU) + 0.44 (GPU) + 5 (KNL) Petaflop per second peak performance. It is due to be decommissioned at the end of November 2020. The technical details about the successor system, the JURECA DC (data centric) module, will be announced soon. JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms. Usage of EasyBuild within JSC \u00b6 As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated. JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations. Custom toolchains \u00b6 As of June 2020, there are a total of 15 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers ( GCCcore , GCC , Intel and PGI ), MPI runtimes ( ParaStationMPI , OpenMPI , IntelMPI and MVAPICH2 ) and mathematical libraries ( MKL ). Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the --try-toolchain option and has recently introduced the --try-update-deps experimental option to more easily adopt upstream changes and adapt them to our environment. Custom module naming scheme \u00b6 By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes). Custom easyconfigs \u00b6 The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository). We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild. Hiding dependencies \u00b6 While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the hide-deps configuration setting). There are currently over 200 such hidden dependencies. While hidden dependencies are not visible in the module view by default, users can expose them by the use of the --show-hidden argument in Lmod : module --show-hidden avail Usage of hooks \u00b6 The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely. We are currently integrating a new hook that provides a lot of useful functionality: Facilitates userspace installations alongside system provided installations Restricts users from installing non-supported compilers (in particular we don't want people to install their own GCCcore since this would likely lead to an avalanche of required dependencies) and MPI runtimes (since MPI installations are heavily customised) Restricts users to only resolve dependencies from our Golden repository (as well as from their own installed software) but allows them to search in the upstream repositories if they try to install something from the upstream repository, the hook advises them how to do this correctly for our systems Customises the final module files Customises the names of some modules (such as Intel over iccifort and IntelMPI over impi ) Injects an Lmod family in the modules of our compilers and MPI runtimes Adds Lmod properties for GPU enabled applications and user installed software so that they can be easily identified in the module view Adds a site_contact for all modules Updates the Lmod cache when an installation is made system-wide We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system. Upgrading and retiring software \u00b6 The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package. The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. For this reason, we have chosen six months as our upgrade period and we chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains. We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. We provide a special development stage with the latest toolchains for the support team where they can prepare their easyconfig files for inclusion in the upgrade. Once a software package has been successfully built and tested, it is added to a Golden repository to be used for the stage upgrade. The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage. While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod.","title":"EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"2020-06-isc20/jsc/#julich-supercomputing-centre","text":"( author: Alan O'Cais, J\u00fclich Supercomputing Centre)","title":"J\u00fclich Supercomputing Centre"},{"location":"2020-06-isc20/jsc/#general-info","text":"The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc ) at Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process.","title":"General info"},{"location":"2020-06-isc20/jsc/#staff-user-base","text":"About 200 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services. In cooperation with hardware and software vendors like IBM, Intel and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008.","title":"Staff &amp; user base"},{"location":"2020-06-isc20/jsc/#resources","text":"JSC currently manages 3 primary systems (in addition to a number of other development clusters): JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance. In the coming months, JUWELS will become the first supercomputer equipped with NVIDIA A100 GPU, when a new GPU module providing an additional 58 Petaflops will be installed. This module will make JUWELS the most powerful supercomputer in Europe. JURECA is the precursor system to JUWELS with 1.8 (CPU) + 0.44 (GPU) + 5 (KNL) Petaflop per second peak performance. It is due to be decommissioned at the end of November 2020. The technical details about the successor system, the JURECA DC (data centric) module, will be announced soon. JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms.","title":"Resources"},{"location":"2020-06-isc20/jsc/#usage-of-easybuild-within-jsc","text":"As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated. JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations.","title":"Usage of EasyBuild within JSC"},{"location":"2020-06-isc20/jsc/#custom-toolchains","text":"As of June 2020, there are a total of 15 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers ( GCCcore , GCC , Intel and PGI ), MPI runtimes ( ParaStationMPI , OpenMPI , IntelMPI and MVAPICH2 ) and mathematical libraries ( MKL ). Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the --try-toolchain option and has recently introduced the --try-update-deps experimental option to more easily adopt upstream changes and adapt them to our environment.","title":"Custom toolchains"},{"location":"2020-06-isc20/jsc/#custom-module-naming-scheme","text":"By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes).","title":"Custom module naming scheme"},{"location":"2020-06-isc20/jsc/#custom-easyconfigs","text":"The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository). We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild.","title":"Custom easyconfigs"},{"location":"2020-06-isc20/jsc/#hiding-dependencies","text":"While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the hide-deps configuration setting). There are currently over 200 such hidden dependencies. While hidden dependencies are not visible in the module view by default, users can expose them by the use of the --show-hidden argument in Lmod : module --show-hidden avail","title":"Hiding dependencies"},{"location":"2020-06-isc20/jsc/#usage-of-hooks","text":"The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely. We are currently integrating a new hook that provides a lot of useful functionality: Facilitates userspace installations alongside system provided installations Restricts users from installing non-supported compilers (in particular we don't want people to install their own GCCcore since this would likely lead to an avalanche of required dependencies) and MPI runtimes (since MPI installations are heavily customised) Restricts users to only resolve dependencies from our Golden repository (as well as from their own installed software) but allows them to search in the upstream repositories if they try to install something from the upstream repository, the hook advises them how to do this correctly for our systems Customises the final module files Customises the names of some modules (such as Intel over iccifort and IntelMPI over impi ) Injects an Lmod family in the modules of our compilers and MPI runtimes Adds Lmod properties for GPU enabled applications and user installed software so that they can be easily identified in the module view Adds a site_contact for all modules Updates the Lmod cache when an installation is made system-wide We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system.","title":"Usage of hooks"},{"location":"2020-06-isc20/jsc/#upgrading-and-retiring-software","text":"The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package. The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. For this reason, we have chosen six months as our upgrade period and we chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains. We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. We provide a special development stage with the latest toolchains for the support team where they can prepare their easyconfig files for inclusion in the upgrade. Once a software package has been successfully built and tested, it is added to a Golden repository to be used for the stage upgrade. The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage. While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod.","title":"Upgrading and retiring software"},{"location":"2020-06-isc20/practical_information/","text":"Practical information \u00b6 Contact points, resources, helpful hints, and things to keep in mind for the EasyBuild tutorial. Slack \u00b6 There is a dedicated #tutorial channel in the EasyBuild Slack where you can get in touch with organisers of the tutorial, other participants, and volunteers. Please use this channel to ask questions throughout the tutorial, or for any other assistance related to the tutorial. To access this channel, you will first need to create an account in the EasyBuild Slack. This is done via https://easybuild-slack.herokuapp.com/ . Once you have the account set up, you can join the EasyBuild Slack via https://easybuild.slack.com/ . From there you can join the #tutorial channel. For more information about Slack, please see the official documentation . AWS resources \u00b6 (only available during the tutorial on Tuesday June 23rd 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, or you have not received the email with the connection information, please contact the tutorial organisers via Slack. Prepared container image \u00b6 For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image includes a small software stack that was installed using EasyBuild, which will come in useful for the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub , and can be used with both Docker and Singularity. Make sure you use the container image tagged with \" isc20 \". Note The command you should use to run the container can be copy-pasted below. Requirements for using the container images \u00b6 (only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a system with a processor supporting the AVX instruction set . AVX is supported by Intel Sandy Bridge or AMD Bulldozer (both released in 2011) and onwards. If you are in doubt about your systems compatibility, see Testing host compatibility at the end of this document. Container size \u00b6 The compressed container image is about 1.25GB in size, and will be downloaded automatically from Docker Hub when you run the docker or singularity command shown below. Using Docker \u00b6 If you want to use the prepared container image via Docker, run the following docker command: mkdir -p isc20_easybuild_tutorial chmod 1777 isc20_easybuild_tutorial docker run -ti --rm --mount type=bind,source=$PWD/isc20_easybuild_tutorial,target=/home/easybuild --hostname tutorial easybuilders/tutorial:isc20 Note that we are bind mounting the isc20_easybuild_tutorial directory into the container as home directory ( /home/easybuild ). That way you can easily access the files you create when using the container outside of it as well, for example to edit them. In addition, it allows you to restart the container without losing the contents of your home directory. Output When running the \" docker run \" command shown above, you should see output like is shown below showing that the different layers are being downloaded. Take into account that it will take a while for the container image to be downloaded. Unable to find image 'easybuilders/tutorial:isc20' locally isc20: Pulling from easybuilders/tutorial 9b4ebb48de8d: Pull complete f1933cd5add8: Downloading 73.48MB/125.9MB 7bd84e6bca4a: Download complete 0a4ea0f4d48f: Download complete 503478215221: Download complete c92d5dd0b39f: Download complete f968b6fd8043: Download complete 5bf43b832c15: Download complete 0545f7354a51: Downloading 30.56MB/534.8MB d1a244ce82da: Waiting c14d5fe9b1e6: Waiting b93ec9ec5f20: Waiting 239fd4ac6c1a: Waiting 9f7279164d6c: Waiting 8ee47766d1ab: Waiting followed by: ... 8ee47766d1ab: Pull complete Digest: sha256:25edb356623dde212b256ef23ae17d2b1dc68921094a9c752eac460c78ba9b4c Status: Downloaded newer image for easybuilders/tutorial:isc20 After this, you should see the welcome message . Docker and cgroups v2 If you are using a recent Linux distribution that has switched to cgroups v2 (e.g. Fedora >= 31 ), docker will fail with OCI runtime create failed: this version of runc doesn't work on cgroups v2 since it is not yet compatible with cgroups v2. Possible workarounds include: reverting to cgroups v1 (it can be done via the kernel command-line argument systemd.unified_cgroup_hierarchy=0 ); using Podman instead, which implements the docker CLI; using Singularity instead (see below); Using Singularity \u00b6 (not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: mkdir -p isc20_easybuild_tutorial singularity run --cleanenv --home $PWD /isc20_easybuild_tutorial docker://easybuilders/tutorial:isc20 The additional options are required to: --cleanenv : start with clean environment --home $PWD/isc20_easybuild_tutorial : use the isc20_easybuild_tutorial subdirectory in the current working directory as home directory in the container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises. Limitation: /easybuild is read-only When the Docker container image is being run with Singularity, the /easybuild directory is read-only in the container. This creates problems for the demo and exercise in the Hierarchical module naming schemes part of the tutorial, because EasyBuild still requires write access to /easybuild/software even when generating module files in a different location outside of /easybuild . Output When running the \" singularity run \" command shown above, you should see output like is shown below. Take into account that it will take a while for the container image to be downloaded. INFO: Converting OCI blobs to SIF format INFO: Starting build... Getting image source signatures Copying blob 9b4ebb48de8d done Copying blob f1933cd5add8 done Copying blob 7bd84e6bca4a done Copying blob 0a4ea0f4d48f done Copying blob 503478215221 done Copying blob c92d5dd0b39f done Copying blob f968b6fd8043 done Copying blob 5bf43b832c15 done Copying blob 0545f7354a51 done Copying blob d1a244ce82da done Copying blob c14d5fe9b1e6 done Copying blob b93ec9ec5f20 done Copying blob 239fd4ac6c1a done Copying blob 9f7279164d6c done Copying blob 8ee47766d1ab done Copying config 717b13fece done Writing manifest to image destination Storing signatures ... INFO: Creating SIF file... After this, you should see the welcome message . Singularity cache By default Singularity keeps its cache at $HOME/.singularity/cache . Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup. If your home directory is limited in size you can either make $HOME/.singularity a symbolic link to /tmp/$USER/singularity or a similar spacious volume, or define the $SINGULARITY_CACHEDIR environment variable to make Singulartiy use a different location: export SINGULARITY_CACHEDIR = /tmp/ $USER /singularity Warning messages When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by: warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\" You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unpriviledged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/ . Welcome message \u00b6 If you are correctly logged in to the container, you should see a message like this: You are logged in to the prepared environment for the introductory tutorial to ______ ____ _ _ _ | ____| | _ \\ (_)| | | | | |__ __ _ ___ _ _ | |_) | _ _ _ | | __| | | __| / _` |/ __|| | | || _ < | | | || || | / _` | | |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| | |______|\\__,_||___/ \\__, ||____/ \\__,_||_||_| \\__,_| __/ | |___/ The tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial . OS: CentOS Linux release 7.8.2003 (Core) modules tool: Lmod 8.2.7 To access the pre-installed software run 'module use /easybuild/modules/all', and then check which modules are installed using 'module avail'. In case of questions or problems contact the tutorial organisers via the #tutorial channel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com . Testing host compatibility \u00b6 To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX instructions (Intel Sandy Bridge generation, or newer). You can test the compatibility of your host with the following commands: module use /easybuild/modules/all module load Python python -V If the last command prints a Python version (like Python 3.8.2 ), then your host is compatible. If you see a message like \" Illegal instruction (core dumped) \", the processor in your system is not compatible with the pre-installed software stack, and you will have to use another system to participate in the tutorial. After running this test, you should reset your environment by running \" module purge \", since most of the exercises assume you are starting from a clean environment.","title":"Practical information"},{"location":"2020-06-isc20/practical_information/#practical-information","text":"Contact points, resources, helpful hints, and things to keep in mind for the EasyBuild tutorial.","title":"Practical information"},{"location":"2020-06-isc20/practical_information/#slack","text":"There is a dedicated #tutorial channel in the EasyBuild Slack where you can get in touch with organisers of the tutorial, other participants, and volunteers. Please use this channel to ask questions throughout the tutorial, or for any other assistance related to the tutorial. To access this channel, you will first need to create an account in the EasyBuild Slack. This is done via https://easybuild-slack.herokuapp.com/ . Once you have the account set up, you can join the EasyBuild Slack via https://easybuild.slack.com/ . From there you can join the #tutorial channel. For more information about Slack, please see the official documentation .","title":"Slack"},{"location":"2020-06-isc20/practical_information/#aws-resources","text":"(only available during the tutorial on Tuesday June 23rd 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, or you have not received the email with the connection information, please contact the tutorial organisers via Slack.","title":"AWS resources"},{"location":"2020-06-isc20/practical_information/#prepared-container-image","text":"For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image includes a small software stack that was installed using EasyBuild, which will come in useful for the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub , and can be used with both Docker and Singularity. Make sure you use the container image tagged with \" isc20 \". Note The command you should use to run the container can be copy-pasted below.","title":"Prepared container image"},{"location":"2020-06-isc20/practical_information/#requirements-for-using-the-container-images","text":"(only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a system with a processor supporting the AVX instruction set . AVX is supported by Intel Sandy Bridge or AMD Bulldozer (both released in 2011) and onwards. If you are in doubt about your systems compatibility, see Testing host compatibility at the end of this document.","title":"Requirements for using the container images"},{"location":"2020-06-isc20/practical_information/#container-size","text":"The compressed container image is about 1.25GB in size, and will be downloaded automatically from Docker Hub when you run the docker or singularity command shown below.","title":"Container size"},{"location":"2020-06-isc20/practical_information/#using-docker","text":"If you want to use the prepared container image via Docker, run the following docker command: mkdir -p isc20_easybuild_tutorial chmod 1777 isc20_easybuild_tutorial docker run -ti --rm --mount type=bind,source=$PWD/isc20_easybuild_tutorial,target=/home/easybuild --hostname tutorial easybuilders/tutorial:isc20 Note that we are bind mounting the isc20_easybuild_tutorial directory into the container as home directory ( /home/easybuild ). That way you can easily access the files you create when using the container outside of it as well, for example to edit them. In addition, it allows you to restart the container without losing the contents of your home directory. Output When running the \" docker run \" command shown above, you should see output like is shown below showing that the different layers are being downloaded. Take into account that it will take a while for the container image to be downloaded. Unable to find image 'easybuilders/tutorial:isc20' locally isc20: Pulling from easybuilders/tutorial 9b4ebb48de8d: Pull complete f1933cd5add8: Downloading 73.48MB/125.9MB 7bd84e6bca4a: Download complete 0a4ea0f4d48f: Download complete 503478215221: Download complete c92d5dd0b39f: Download complete f968b6fd8043: Download complete 5bf43b832c15: Download complete 0545f7354a51: Downloading 30.56MB/534.8MB d1a244ce82da: Waiting c14d5fe9b1e6: Waiting b93ec9ec5f20: Waiting 239fd4ac6c1a: Waiting 9f7279164d6c: Waiting 8ee47766d1ab: Waiting followed by: ... 8ee47766d1ab: Pull complete Digest: sha256:25edb356623dde212b256ef23ae17d2b1dc68921094a9c752eac460c78ba9b4c Status: Downloaded newer image for easybuilders/tutorial:isc20 After this, you should see the welcome message . Docker and cgroups v2 If you are using a recent Linux distribution that has switched to cgroups v2 (e.g. Fedora >= 31 ), docker will fail with OCI runtime create failed: this version of runc doesn't work on cgroups v2 since it is not yet compatible with cgroups v2. Possible workarounds include: reverting to cgroups v1 (it can be done via the kernel command-line argument systemd.unified_cgroup_hierarchy=0 ); using Podman instead, which implements the docker CLI; using Singularity instead (see below);","title":"Using Docker"},{"location":"2020-06-isc20/practical_information/#using-singularity","text":"(not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: mkdir -p isc20_easybuild_tutorial singularity run --cleanenv --home $PWD /isc20_easybuild_tutorial docker://easybuilders/tutorial:isc20 The additional options are required to: --cleanenv : start with clean environment --home $PWD/isc20_easybuild_tutorial : use the isc20_easybuild_tutorial subdirectory in the current working directory as home directory in the container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises. Limitation: /easybuild is read-only When the Docker container image is being run with Singularity, the /easybuild directory is read-only in the container. This creates problems for the demo and exercise in the Hierarchical module naming schemes part of the tutorial, because EasyBuild still requires write access to /easybuild/software even when generating module files in a different location outside of /easybuild . Output When running the \" singularity run \" command shown above, you should see output like is shown below. Take into account that it will take a while for the container image to be downloaded. INFO: Converting OCI blobs to SIF format INFO: Starting build... Getting image source signatures Copying blob 9b4ebb48de8d done Copying blob f1933cd5add8 done Copying blob 7bd84e6bca4a done Copying blob 0a4ea0f4d48f done Copying blob 503478215221 done Copying blob c92d5dd0b39f done Copying blob f968b6fd8043 done Copying blob 5bf43b832c15 done Copying blob 0545f7354a51 done Copying blob d1a244ce82da done Copying blob c14d5fe9b1e6 done Copying blob b93ec9ec5f20 done Copying blob 239fd4ac6c1a done Copying blob 9f7279164d6c done Copying blob 8ee47766d1ab done Copying config 717b13fece done Writing manifest to image destination Storing signatures ... INFO: Creating SIF file... After this, you should see the welcome message . Singularity cache By default Singularity keeps its cache at $HOME/.singularity/cache . Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup. If your home directory is limited in size you can either make $HOME/.singularity a symbolic link to /tmp/$USER/singularity or a similar spacious volume, or define the $SINGULARITY_CACHEDIR environment variable to make Singulartiy use a different location: export SINGULARITY_CACHEDIR = /tmp/ $USER /singularity Warning messages When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by: warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\" You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unpriviledged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/ .","title":"Using Singularity"},{"location":"2020-06-isc20/practical_information/#welcome-message","text":"If you are correctly logged in to the container, you should see a message like this: You are logged in to the prepared environment for the introductory tutorial to ______ ____ _ _ _ | ____| | _ \\ (_)| | | | | |__ __ _ ___ _ _ | |_) | _ _ _ | | __| | | __| / _` |/ __|| | | || _ < | | | || || | / _` | | |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| | |______|\\__,_||___/ \\__, ||____/ \\__,_||_||_| \\__,_| __/ | |___/ The tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial . OS: CentOS Linux release 7.8.2003 (Core) modules tool: Lmod 8.2.7 To access the pre-installed software run 'module use /easybuild/modules/all', and then check which modules are installed using 'module avail'. In case of questions or problems contact the tutorial organisers via the #tutorial channel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com .","title":"Welcome message"},{"location":"2020-06-isc20/practical_information/#testing-host-compatibility","text":"To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX instructions (Intel Sandy Bridge generation, or newer). You can test the compatibility of your host with the following commands: module use /easybuild/modules/all module load Python python -V If the last command prints a Python version (like Python 3.8.2 ), then your host is compatible. If you see a message like \" Illegal instruction (core dumped) \", the processor in your system is not compatible with the pre-installed software stack, and you will have to use another system to participate in the tutorial. After running this test, you should reset your environment by running \" module purge \", since most of the exercises assume you are starting from a clean environment.","title":"Testing host compatibility"},{"location":"2020-06-isc20/troubleshooting/","text":"Troubleshooting \u00b6 When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild. In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention! EasyBuild error messages \u00b6 When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, a problem has occurred and the installation will be interrupted. Example \u00b6 Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb trouble.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-39 ) Oh my that's pretty ancient. That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled. EasyBuild log files \u00b6 Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a sensible way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created for every installation, which is located in the unique temporary directory that was created for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.6-gompi-2020a/easybuild/easybuild-HDF5-1.10.6-20200609.131126.log Last log \u00b6 vim $(eb --last-log) Navigating log files \u00b6 Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you'll miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.6/gompi-2020a/hdf5-1.10.6/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there. Inspecting the build directory \u00b6 When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the buildpath directory. Exercise \u00b6 Let's work our way through a less smooth software installation, using the easyconfig file that is provided in /easybuild/tutorial/subread.eb in the tutorial container image. For completeness sake, the contents are shown below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.4.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the easyconfig file to your home directory, so you can make changes to it. cd $HOME cp /easybuild/tutorial/subread.eb . Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise 5.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ In case download is problematic, the source tarball is also available in /easybuild/tutorial/ : cp /easybuild/tutorial/subread-2.0.1-source.tar.gz $HOME /easybuild/sources/s/Subread/ Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate URLs, without the filename of the source file. The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise 5.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.4.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): No module found for toolchain: GCC/8.4.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 9.3.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/9.3.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } Or run the following sed command to change the toolchain version to '9.3.0' : sed -i 's/8.4.0/9.3.0/' subread.eb Exercise 5.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via CFLAGS= to the build command: buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' EasyBuild sets up the build environment so there should be no need to hard specify compiler flags (certainly not incorrect ones), but it's good to keep an eye on it to make sure that the compiler flags specified by EasyBuild are actually being used. In this case we need to get rid of the ' CFLAGS=\"...\" ' part in the buildopts value, but the \" -f Makefile.Linux \" part should stay. The problem can be fixed by changing the easyconfig file as follows: buildopts = '-f Makefile.Linux' You can copy-paste and run this sed command to make the change without using an editor: sed -i \"s/buildopts.*/buildopts = '-f Makefile.Linux'/\" subread.eb Exercise 5.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] Or you can use this sed command to make that change: sed -i 's/featureCounts --version/featureCounts -v/' subread.eb After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 9.3.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1","title":"Troubleshooting"},{"location":"2020-06-isc20/troubleshooting/#troubleshooting","text":"When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild. In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!","title":"Troubleshooting"},{"location":"2020-06-isc20/troubleshooting/#easybuild-error-messages","text":"When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, a problem has occurred and the installation will be interrupted.","title":"EasyBuild error messages"},{"location":"2020-06-isc20/troubleshooting/#example","text":"Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb trouble.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-39 ) Oh my that's pretty ancient. That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.","title":"Example"},{"location":"2020-06-isc20/troubleshooting/#easybuild-log-files","text":"Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a sensible way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created for every installation, which is located in the unique temporary directory that was created for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.6-gompi-2020a/easybuild/easybuild-HDF5-1.10.6-20200609.131126.log","title":"EasyBuild log files"},{"location":"2020-06-isc20/troubleshooting/#last-log","text":"vim $(eb --last-log)","title":"Last log"},{"location":"2020-06-isc20/troubleshooting/#navigating-log-files","text":"Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you'll miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.6/gompi-2020a/hdf5-1.10.6/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there.","title":"Navigating log files"},{"location":"2020-06-isc20/troubleshooting/#inspecting-the-build-directory","text":"When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the buildpath directory.","title":"Inspecting the build directory"},{"location":"2020-06-isc20/troubleshooting/#exercise","text":"Let's work our way through a less smooth software installation, using the easyconfig file that is provided in /easybuild/tutorial/subread.eb in the tutorial container image. For completeness sake, the contents are shown below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.4.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the easyconfig file to your home directory, so you can make changes to it. cd $HOME cp /easybuild/tutorial/subread.eb . Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise 5.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ In case download is problematic, the source tarball is also available in /easybuild/tutorial/ : cp /easybuild/tutorial/subread-2.0.1-source.tar.gz $HOME /easybuild/sources/s/Subread/ Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate URLs, without the filename of the source file. The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise 5.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.4.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): No module found for toolchain: GCC/8.4.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 9.3.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/9.3.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } Or run the following sed command to change the toolchain version to '9.3.0' : sed -i 's/8.4.0/9.3.0/' subread.eb Exercise 5.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via CFLAGS= to the build command: buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' EasyBuild sets up the build environment so there should be no need to hard specify compiler flags (certainly not incorrect ones), but it's good to keep an eye on it to make sure that the compiler flags specified by EasyBuild are actually being used. In this case we need to get rid of the ' CFLAGS=\"...\" ' part in the buildopts value, but the \" -f Makefile.Linux \" part should stay. The problem can be fixed by changing the easyconfig file as follows: buildopts = '-f Makefile.Linux' You can copy-paste and run this sed command to make the change without using an editor: sed -i \"s/buildopts.*/buildopts = '-f Makefile.Linux'/\" subread.eb Exercise 5.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] Or you can use this sed command to make that change: sed -i 's/featureCounts --version/featureCounts -v/' subread.eb After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 9.3.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1","title":"Exercise"},{"location":"2021-isc21/","text":"ISC'21 EasyBuild tutorial \u00b6 Maintaining a Modern Scientific Software Stack Made Easy with EasyBuild \u00b6 The EasyBuild tutorial at ISC'21 takes place on Friday June 25th 2021, 12:00-16:00 UTC . To attend the live tutorial, you must be registered to ISC'21 ( more information here ). All tutorial content, including recorded sessions, will be made available afterwards. Slides \u00b6 The most recent version of the presentation slides are available here . Recording \u00b6 Agenda \u00b6 ( all times are UTC) [12:00-12:10] Practical info [12:10-12:30] Introduction and terminology [12:30-13:00] Installation , configuration , and basic usage [13:00-13:45] Installing software + troubleshooting [13:45-14:15] (coffee break) [14:15-14:45] Module naming schemes [14:45-15:10] Adding support for additional software [15:10-15:20] EasyBuild at J\u00fclich Supercomputing Centre [15:20-15:30] EasyBuild at Compute Canada [15:30-15:45] The EasyBuild community + Contributing to EasyBuild [15:45-16:00] Q&A + closing remarks","title":"(overview)"},{"location":"2021-isc21/#isc21-easybuild-tutorial","text":"","title":"ISC'21 EasyBuild tutorial"},{"location":"2021-isc21/#maintaining-a-modern-scientific-software-stack-made-easy-with-easybuild","text":"The EasyBuild tutorial at ISC'21 takes place on Friday June 25th 2021, 12:00-16:00 UTC . To attend the live tutorial, you must be registered to ISC'21 ( more information here ). All tutorial content, including recorded sessions, will be made available afterwards.","title":"Maintaining a Modern Scientific Software Stack Made Easy with EasyBuild"},{"location":"2021-isc21/#slides","text":"The most recent version of the presentation slides are available here .","title":"Slides"},{"location":"2021-isc21/#recording","text":"","title":"Recording"},{"location":"2021-isc21/#agenda","text":"( all times are UTC) [12:00-12:10] Practical info [12:10-12:30] Introduction and terminology [12:30-13:00] Installation , configuration , and basic usage [13:00-13:45] Installing software + troubleshooting [13:45-14:15] (coffee break) [14:15-14:45] Module naming schemes [14:45-15:10] Adding support for additional software [15:10-15:20] EasyBuild at J\u00fclich Supercomputing Centre [15:20-15:30] EasyBuild at Compute Canada [15:30-15:45] The EasyBuild community + Contributing to EasyBuild [15:45-16:00] Q&A + closing remarks","title":"Agenda"},{"location":"2021-isc21/adding_support_additional_software/","text":"Adding support for additional software \u00b6 We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves! Easyconfigs vs easyblocks \u00b6 Before we dive into writing easyconfig files , let's take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild. It specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module that leverages the EasyBuild framework). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in general, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the implementation of the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; toolchain-specific aspects of the build and installation procedure (e.g., configure options); interactive commands that need to be run; custom (configure) options for dependencies; having to create or adjust specific (configuration) files; 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation , or a more extensive version of the EasyBuild tutorial . Writing easyconfig files \u00b6 Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them. Mandatory parameters \u00b6 A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 10.2.0 which we used before, or the full toolchain foss 2020b. The name and version of the toolchain can be specified using a small Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } Commonly used parameters \u00b6 You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation . Sources, patches, and checksums \u00b6 In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported . Easyblock \u00b6 The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together in a single installation directory; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblocks is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock \" or just \" eb -a -e \", which results in an additional \" EASYBLOCK-SPECIFIC \" section to be added. See the (partial) output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ] Dependencies \u00b6 You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.18.4' )] dependencies = [ ( 'Python' , '3.8.2' ), ( 'HDF5' , '1.10.6' ), ( 'SciPy-bundle' , '2020.03' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies. Version suffix \u00b6 In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '2.7.18' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation. Customizing configure, build, test, and install commands \u00b6 When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.10.6' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support The ' ... ' represents the path to installation directory where the software should be installed. The --prefix option is included automatically by the ConfigureMake easyblock. specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). passing the location where the software should be installed via the PREFIX argument to the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable that we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an $EBROOT* environment variable like this in every environment module file it generates (see the output of \" module show HDF5 \"). Sanity check \u00b6 One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ] Module class \u00b6 Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ). Generating tweaked easyconfigs \u00b6 Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2020b.eb --try-toolchain intel,2020b It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example. Copying easyconfigs \u00b6 One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.11-GCC-10.2.0.eb SAMtools.eb ... SAMtools-1.10-GCC-10.2.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files at once, as long as the target location is an existing directory. Example \u00b6 By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.1 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1 . Preparation \u00b6 Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all Mandatory parameters \u00b6 Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file. We will use GCC/10.2.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment, so we define the toolchain easyconfig parameter: name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a sensible value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning. Easyblock \u00b6 Let us see what happens if we take our current easyconfig file for a spin: $ eb example.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/example.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for installing the software with the name ' eb-tutorial '. Does that mean we have to implement an easyblock? In this simple case it doesn't, since we can leverage one of the available generic easyblocks . But, which one? Build instructions are usually included in a README file, or in the documentation. In this case, there's indeed a minimal README file available, which tells us that we should use the cmake command to configure the installation, followed by make and make install . We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one). CMake build dependency \u00b6 Does using the CMakeMake generic easyblock help at all? $ eb example.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/example.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.18.4-GCCcore-10.2.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 10.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.18.4' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D (equivalent with eb --dry-run ): $ eb example.eb -D ... * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0) * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.18.4-GCCcore-10.2.0.eb (module: CMake/3.18.4-GCCcore-10.2.0) * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-10.2.0) Sources \u00b6 If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-10.2.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify one or more source files that should be used, via the sources easyconfig parameter which specifies a list of names of source files: sources = [ 'eb-tutorial-1.0.1.tar.gz' ] We can avoid hardcoding the version number here by using a template value : sources = [ 'eb-tutorial- %(version)s .tar.gz' ] And since this is a standard way of naming software files, there's even a constant available that we can use: sources = [ SOURCE_TAR_GZ ] That way, we only have the software version specified once in the easyconfig file, via the version easyconfig parameter. That will come in useful later (see Exercise 7.2 )... If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere: Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either... To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via source_urls : source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] Required configure option \u00b6 With sources and source_urls defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1 ). Sanity check \u00b6 Hopefully that brings us closer to getting the installation to work... $ eb example.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 (took 2 sec) It got all the way to the sanity check step, that's great! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we need to customize the standard sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via --trace we can get some more information too: $ eb example.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial! Complete easyconfig \u00b6 Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'd6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9' ] builddependencies = [( 'CMake' , '3.18.4' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' One additional easyconfig parameter we defined here is checksums , which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation. You can let EasyBuild determine and inject these SHA256 checksums automatically via eb --inject-checksums : $ eb example.eb --inject-checksums ... == injecting sha256 checksums for sources & patches in example.eb... == * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9 Exercises \u00b6 Exercise E.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the example.eb easyconfig, you will need to use eb --rebuild or eb --force . Exercise E.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.1. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb example.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-10.2.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.1 doesn't print \" I have a message for you: \") Exercise E.3 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2020b' } dependencies = [ ( 'Python' , '3.8.6' ), ( 'SciPy-bundle' , '2020.11' ), ( 'eb-tutorial' , '1.0.1' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. Even when the default installation mechanism used by PythonPackage (which consists of running python setup.py install ) works fine, it is recommended to instruct EasyBuild to use pip install instead. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by Python package is already pretty decent (it will check for a non-empty lib/python3.8/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.8 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file. next: EasyBuild at J\u00fclich Supercomputing Centre - (back to overview page)","title":"Support for additional software"},{"location":"2021-isc21/adding_support_additional_software/#adding-support-for-additional-software","text":"We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!","title":"Adding support for additional software"},{"location":"2021-isc21/adding_support_additional_software/#easyconfigs-vs-easyblocks","text":"Before we dive into writing easyconfig files , let's take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild. It specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module that leverages the EasyBuild framework). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in general, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the implementation of the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; toolchain-specific aspects of the build and installation procedure (e.g., configure options); interactive commands that need to be run; custom (configure) options for dependencies; having to create or adjust specific (configuration) files; 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation , or a more extensive version of the EasyBuild tutorial .","title":"Easyconfigs vs easyblocks"},{"location":"2021-isc21/adding_support_additional_software/#writing-easyconfig-files","text":"Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.","title":"Writing easyconfig files"},{"location":"2021-isc21/adding_support_additional_software/#mandatory-parameters","text":"A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 10.2.0 which we used before, or the full toolchain foss 2020b. The name and version of the toolchain can be specified using a small Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' }","title":"Mandatory parameters"},{"location":"2021-isc21/adding_support_additional_software/#commonly-used-parameters","text":"You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation .","title":"Commonly used parameters"},{"location":"2021-isc21/adding_support_additional_software/#sources-patches-and-checksums","text":"In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported .","title":"Sources, patches, and checksums"},{"location":"2021-isc21/adding_support_additional_software/#easyblock","text":"The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together in a single installation directory; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblocks is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock \" or just \" eb -a -e \", which results in an additional \" EASYBLOCK-SPECIFIC \" section to be added. See the (partial) output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ]","title":"Easyblock"},{"location":"2021-isc21/adding_support_additional_software/#dependencies","text":"You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.18.4' )] dependencies = [ ( 'Python' , '3.8.2' ), ( 'HDF5' , '1.10.6' ), ( 'SciPy-bundle' , '2020.03' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies.","title":"Dependencies"},{"location":"2021-isc21/adding_support_additional_software/#version-suffix","text":"In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '2.7.18' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation.","title":"Version suffix"},{"location":"2021-isc21/adding_support_additional_software/#customizing-configure-build-test-and-install-commands","text":"When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.10.6' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support The ' ... ' represents the path to installation directory where the software should be installed. The --prefix option is included automatically by the ConfigureMake easyblock. specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). passing the location where the software should be installed via the PREFIX argument to the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable that we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an $EBROOT* environment variable like this in every environment module file it generates (see the output of \" module show HDF5 \").","title":"Customizing configure, build, test, and install commands"},{"location":"2021-isc21/adding_support_additional_software/#sanity-check","text":"One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ]","title":"Sanity check"},{"location":"2021-isc21/adding_support_additional_software/#module-class","text":"Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ).","title":"Module class"},{"location":"2021-isc21/adding_support_additional_software/#generating-tweaked-easyconfigs","text":"Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2020b.eb --try-toolchain intel,2020b It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.","title":"Generating tweaked easyconfigs"},{"location":"2021-isc21/adding_support_additional_software/#copying-easyconfigs","text":"One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.11-GCC-10.2.0.eb SAMtools.eb ... SAMtools-1.10-GCC-10.2.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files at once, as long as the target location is an existing directory.","title":"Copying easyconfigs"},{"location":"2021-isc21/adding_support_additional_software/#example","text":"By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.1 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1 .","title":"Example"},{"location":"2021-isc21/adding_support_additional_software/#preparation","text":"Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all","title":"Preparation"},{"location":"2021-isc21/adding_support_additional_software/#mandatory-parameters_1","text":"Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file. We will use GCC/10.2.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment, so we define the toolchain easyconfig parameter: name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a sensible value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning.","title":"Mandatory parameters"},{"location":"2021-isc21/adding_support_additional_software/#easyblock_1","text":"Let us see what happens if we take our current easyconfig file for a spin: $ eb example.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/example.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for installing the software with the name ' eb-tutorial '. Does that mean we have to implement an easyblock? In this simple case it doesn't, since we can leverage one of the available generic easyblocks . But, which one? Build instructions are usually included in a README file, or in the documentation. In this case, there's indeed a minimal README file available, which tells us that we should use the cmake command to configure the installation, followed by make and make install . We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).","title":"Easyblock"},{"location":"2021-isc21/adding_support_additional_software/#cmake-build-dependency","text":"Does using the CMakeMake generic easyblock help at all? $ eb example.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/example.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.18.4-GCCcore-10.2.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 10.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.18.4' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D (equivalent with eb --dry-run ): $ eb example.eb -D ... * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0) * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.18.4-GCCcore-10.2.0.eb (module: CMake/3.18.4-GCCcore-10.2.0) * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-10.2.0)","title":"CMake build dependency"},{"location":"2021-isc21/adding_support_additional_software/#sources","text":"If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-10.2.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify one or more source files that should be used, via the sources easyconfig parameter which specifies a list of names of source files: sources = [ 'eb-tutorial-1.0.1.tar.gz' ] We can avoid hardcoding the version number here by using a template value : sources = [ 'eb-tutorial- %(version)s .tar.gz' ] And since this is a standard way of naming software files, there's even a constant available that we can use: sources = [ SOURCE_TAR_GZ ] That way, we only have the software version specified once in the easyconfig file, via the version easyconfig parameter. That will come in useful later (see Exercise 7.2 )... If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere: Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either... To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via source_urls : source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ]","title":"Sources"},{"location":"2021-isc21/adding_support_additional_software/#required-configure-option","text":"With sources and source_urls defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1 ).","title":"Required configure option"},{"location":"2021-isc21/adding_support_additional_software/#sanity-check_1","text":"Hopefully that brings us closer to getting the installation to work... $ eb example.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 (took 2 sec) It got all the way to the sanity check step, that's great! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we need to customize the standard sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via --trace we can get some more information too: $ eb example.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial!","title":"Sanity check"},{"location":"2021-isc21/adding_support_additional_software/#complete-easyconfig","text":"Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'd6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9' ] builddependencies = [( 'CMake' , '3.18.4' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' One additional easyconfig parameter we defined here is checksums , which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation. You can let EasyBuild determine and inject these SHA256 checksums automatically via eb --inject-checksums : $ eb example.eb --inject-checksums ... == injecting sha256 checksums for sources & patches in example.eb... == * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9","title":"Complete easyconfig"},{"location":"2021-isc21/adding_support_additional_software/#exercises","text":"Exercise E.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the example.eb easyconfig, you will need to use eb --rebuild or eb --force . Exercise E.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.1. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb example.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-10.2.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.1 doesn't print \" I have a message for you: \") Exercise E.3 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2020b' } dependencies = [ ( 'Python' , '3.8.6' ), ( 'SciPy-bundle' , '2020.11' ), ( 'eb-tutorial' , '1.0.1' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. Even when the default installation mechanism used by PythonPackage (which consists of running python setup.py install ) works fine, it is recommended to instruct EasyBuild to use pip install instead. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by Python package is already pretty decent (it will check for a non-empty lib/python3.8/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.8 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file. next: EasyBuild at J\u00fclich Supercomputing Centre - (back to overview page)","title":"Exercises"},{"location":"2021-isc21/basic_usage/","text":"Basic usage of Easybuild \u00b6 Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention! Overall workflow \u00b6 Installing software with EasyBuild is as easy as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , often combined with the --robot option to let EasyBuild also install missing dependencies. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be. Specifying easyconfigs \u00b6 Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with .eb , and (try to) use these as easyconfig files. Example command \u00b6 Suppose we have the current situation in our home directory: two (easyconfig) files named example1.eb and example2.eb ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1.eb example2.eb some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb example1.eb bzip2-1.0.6.eb $HOME /example2.eb some_deps EasyBuild will interpret each of these arguments as follows: example1.eb is the name of a file in the current directory, so it can be used directly; bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); $HOME/example2.eb specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , The list.txt file will be ignored since its name does not end with .eb . Easyconfig filenames \u00b6 Note that the eb command does not care how easyconfig files are named, at least to some extent: the .eb file extension does matter when easyconfig files are being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ), and which is omitted (including the preceding - ) when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default); Searching for easyconfigs \u00b6 You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package. This can be done by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the search-paths configuration setting, or you can change the robot search path via either the robot or robot-paths configuration options. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for OpenFOAM 8 with a foss toolchain: $ eb --search openfoam-8-foss * /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb * /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb The output is a bit more condensed when using eb -S : $ eb -S openfoam-8-foss CFGS1 = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM * $CFGS1 /OpenFOAM-8-foss-2020a.eb * $CFGS1 /OpenFOAM-8-foss-2020b.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , or other special characters like ^ or $ to mark the start/end of the filename, but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install TensorFlow 2.4.1 with the 2020b version of a toolchain: $ eb -S '^tensorflow-2.4.1.*2020b' CFGS1 = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/t/TensorFlow * $CFGS1 /TensorFlow-2.4.1-foss-2020b.eb * $CFGS1 /TensorFlow-2.4.1-fosscuda-2020b.eb Search index \u00b6 When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information . Inspecting easyconfigs \u00b6 Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later... Checking dependencies \u00b6 Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \" by informing the modules tool about the pre-installed software stack in /easybuild : module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ). Dry run \u00b6 To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the required dependencies for SAMtools-1.11-GCC-10.2.0.eb are already installed: $ eb SAMtools-1.11-GCC-10.2.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-10.2.0.eb ( module: bzip2/1.0.8-GCCcore-10.2.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-10.2.0.eb ( module: XZ/5.2.5-GCCcore-10.2.0 ) * [ x ] $CFGS /c/cURL/cURL-7.72.0-GCCcore-10.2.0.eb ( module: cURL/7.72.0-GCCcore-10.2.0 ) * [ x ] $CFGS /g/GCC/GCC-10.2.0.eb ( module: GCC/10.2.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-10.2.0.eb ( module: ncurses/6.2-GCCcore-10.2.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb ( module: SAMtools/1.11-GCC-10.2.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.11-GCC-10.2.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an x in [ ] . Missing dependencies \u00b6 If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get version 3.1.0 of the h5py Python package installed using the 2020b version of the foss toolchain: $ eb h5py-3.1.0-foss-2020b.eb -M 2 out of 61 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) That should be pretty self-explanatory: out of the 63 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great! Inspecting install procedures \u00b6 Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.74.0-GCC-10.2.0.eb : $ eb Boost-1.74.0-GCC-10.2.0.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load GCC/10.2.0 Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-10.2.0 module load zlib/1.2.11-GCCcore-10.2.0 module load XZ/5.2.5-GCCcore-10.2.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.74.0/GCC-10.2.0/obj --without-libraries=python,mpi\" ( in /tmp/example/build/Boost/1.74.0/GCC-10.2.0/Boost-1.74.0 ) ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_system.so * lib/libboost_thread-mt-x64.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient to explain what all this output means. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step, and in which directory; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless. Exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not share solutions with others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.4.0. Exercise U.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. We will assume that you have a small software stack installed using the 2020b version of the foss toolchain. Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. To verify that the pre-installed software is available, check whether the foss/2020b module is available: $ module avail foss/ --------------------- /easybuild/modules/all --------------------- foss/2020b Exercise U.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2020/5. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2020.5 == found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb * $CFGS1 /GROMACS-2020.5_fix_threads_gpu_Gmxapitests.patch This actually shows one easyconfig file but also a patch file. We can also search specifically for GROMACS 2020.5 in the foss and fosscuda toolchains using $ eb -S gromacs-2020.5-foss == found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb and now we find a single easyconfig file. Exercise U.2 - Checking dependencies Check which dependencies are missing to install QuantumESPRESSO version 6.6 with the 2020b version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: $ eb -S 'QuantumESPRESSO-6.6.*foss-2020b' == found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/q/QuantumESPRESSO * $CFGS1 /QuantumESPRESSO-6.6-foss-2020b.eb To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use --missing : $ eb QuantumESPRESSO-6.6-foss-2020b.eb --missing 3 out of 60 required modules missing: * libxc/4.3.4-GCC-10.2.0 ( libxc-4.3.4-GCC-10.2.0.eb ) * ELPA/2020.11.001-foss-2020b ( ELPA-2020.11.001-foss-2020b.eb ) * QuantumESPRESSO/6.6-foss-2020b ( QuantumESPRESSO-6.6-foss-2020b.eb ) (some nonessential output removed). Exercise U.3 - Performing a dry run Figure out which command EasyBuild would use to compile the software provided by the Bowtie2-2.4.2-GCC-9.3.0.eb easyconfig file, without actually installing Bowtie2 . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x Bowtie2-2.4.2-GCC-9.3.0.eb . The output for the build step shows the actual compilation command that would be performed ( make ... ): [ build_step method ] >> running command: [ started at: 2021 -03-08 20 :15:08 ] [ working dir: /tmp/eb-0006djcd/__ROOT__/tmp/kehoste/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ] [ output logged in /tmp/eb-0006djcd/easybuild-run_cmd-haojzisn.log ] make -j 8 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" ( in /tmp/kehoste/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ) If the output you get is less detailed, you may not have set export EASYBUILD_TRACE=1 . The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/bowtie2 * bin/bowtie2-align-l * bin/bowtie2-align-s * bin/bowtie2-build * bin/bowtie2-build-l * bin/bowtie2-build-s * bin/bowtie2-inspect * bin/bowtie2-inspect-l * bin/bowtie2-inspect-s next: Installing software - (back to overview page)","title":"Basic usage"},{"location":"2021-isc21/basic_usage/#basic-usage-of-easybuild","text":"Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!","title":"Basic usage of Easybuild"},{"location":"2021-isc21/basic_usage/#overall-workflow","text":"Installing software with EasyBuild is as easy as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , often combined with the --robot option to let EasyBuild also install missing dependencies. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be.","title":"Overall workflow"},{"location":"2021-isc21/basic_usage/#specifying-easyconfigs","text":"Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with .eb , and (try to) use these as easyconfig files.","title":"Specifying easyconfigs"},{"location":"2021-isc21/basic_usage/#example-command","text":"Suppose we have the current situation in our home directory: two (easyconfig) files named example1.eb and example2.eb ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1.eb example2.eb some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb example1.eb bzip2-1.0.6.eb $HOME /example2.eb some_deps EasyBuild will interpret each of these arguments as follows: example1.eb is the name of a file in the current directory, so it can be used directly; bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); $HOME/example2.eb specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , The list.txt file will be ignored since its name does not end with .eb .","title":"Example command"},{"location":"2021-isc21/basic_usage/#easyconfig-filenames","text":"Note that the eb command does not care how easyconfig files are named, at least to some extent: the .eb file extension does matter when easyconfig files are being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ), and which is omitted (including the preceding - ) when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default);","title":"Easyconfig filenames"},{"location":"2021-isc21/basic_usage/#searching-for-easyconfigs","text":"You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package. This can be done by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the search-paths configuration setting, or you can change the robot search path via either the robot or robot-paths configuration options. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for OpenFOAM 8 with a foss toolchain: $ eb --search openfoam-8-foss * /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb * /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb The output is a bit more condensed when using eb -S : $ eb -S openfoam-8-foss CFGS1 = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM * $CFGS1 /OpenFOAM-8-foss-2020a.eb * $CFGS1 /OpenFOAM-8-foss-2020b.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , or other special characters like ^ or $ to mark the start/end of the filename, but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install TensorFlow 2.4.1 with the 2020b version of a toolchain: $ eb -S '^tensorflow-2.4.1.*2020b' CFGS1 = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/t/TensorFlow * $CFGS1 /TensorFlow-2.4.1-foss-2020b.eb * $CFGS1 /TensorFlow-2.4.1-fosscuda-2020b.eb","title":"Searching for easyconfigs"},{"location":"2021-isc21/basic_usage/#search-index","text":"When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information .","title":"Search index"},{"location":"2021-isc21/basic_usage/#inspecting-easyconfigs","text":"Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later...","title":"Inspecting easyconfigs"},{"location":"2021-isc21/basic_usage/#checking-dependencies","text":"Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \" by informing the modules tool about the pre-installed software stack in /easybuild : module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ).","title":"Checking dependencies"},{"location":"2021-isc21/basic_usage/#dry-run","text":"To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the required dependencies for SAMtools-1.11-GCC-10.2.0.eb are already installed: $ eb SAMtools-1.11-GCC-10.2.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-10.2.0.eb ( module: bzip2/1.0.8-GCCcore-10.2.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-10.2.0.eb ( module: XZ/5.2.5-GCCcore-10.2.0 ) * [ x ] $CFGS /c/cURL/cURL-7.72.0-GCCcore-10.2.0.eb ( module: cURL/7.72.0-GCCcore-10.2.0 ) * [ x ] $CFGS /g/GCC/GCC-10.2.0.eb ( module: GCC/10.2.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-10.2.0.eb ( module: ncurses/6.2-GCCcore-10.2.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb ( module: SAMtools/1.11-GCC-10.2.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.11-GCC-10.2.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an x in [ ] .","title":"Dry run"},{"location":"2021-isc21/basic_usage/#missing-dependencies","text":"If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get version 3.1.0 of the h5py Python package installed using the 2020b version of the foss toolchain: $ eb h5py-3.1.0-foss-2020b.eb -M 2 out of 61 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) That should be pretty self-explanatory: out of the 63 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great!","title":"Missing dependencies"},{"location":"2021-isc21/basic_usage/#inspecting-install-procedures","text":"Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.74.0-GCC-10.2.0.eb : $ eb Boost-1.74.0-GCC-10.2.0.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load GCC/10.2.0 Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-10.2.0 module load zlib/1.2.11-GCCcore-10.2.0 module load XZ/5.2.5-GCCcore-10.2.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.74.0/GCC-10.2.0/obj --without-libraries=python,mpi\" ( in /tmp/example/build/Boost/1.74.0/GCC-10.2.0/Boost-1.74.0 ) ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_system.so * lib/libboost_thread-mt-x64.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient to explain what all this output means. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step, and in which directory; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.","title":"Inspecting install procedures"},{"location":"2021-isc21/basic_usage/#exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not share solutions with others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.4.0. Exercise U.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. We will assume that you have a small software stack installed using the 2020b version of the foss toolchain. Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. To verify that the pre-installed software is available, check whether the foss/2020b module is available: $ module avail foss/ --------------------- /easybuild/modules/all --------------------- foss/2020b Exercise U.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2020/5. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2020.5 == found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb * $CFGS1 /GROMACS-2020.5_fix_threads_gpu_Gmxapitests.patch This actually shows one easyconfig file but also a patch file. We can also search specifically for GROMACS 2020.5 in the foss and fosscuda toolchains using $ eb -S gromacs-2020.5-foss == found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb and now we find a single easyconfig file. Exercise U.2 - Checking dependencies Check which dependencies are missing to install QuantumESPRESSO version 6.6 with the 2020b version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: $ eb -S 'QuantumESPRESSO-6.6.*foss-2020b' == found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/q/QuantumESPRESSO * $CFGS1 /QuantumESPRESSO-6.6-foss-2020b.eb To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use --missing : $ eb QuantumESPRESSO-6.6-foss-2020b.eb --missing 3 out of 60 required modules missing: * libxc/4.3.4-GCC-10.2.0 ( libxc-4.3.4-GCC-10.2.0.eb ) * ELPA/2020.11.001-foss-2020b ( ELPA-2020.11.001-foss-2020b.eb ) * QuantumESPRESSO/6.6-foss-2020b ( QuantumESPRESSO-6.6-foss-2020b.eb ) (some nonessential output removed). Exercise U.3 - Performing a dry run Figure out which command EasyBuild would use to compile the software provided by the Bowtie2-2.4.2-GCC-9.3.0.eb easyconfig file, without actually installing Bowtie2 . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x Bowtie2-2.4.2-GCC-9.3.0.eb . The output for the build step shows the actual compilation command that would be performed ( make ... ): [ build_step method ] >> running command: [ started at: 2021 -03-08 20 :15:08 ] [ working dir: /tmp/eb-0006djcd/__ROOT__/tmp/kehoste/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ] [ output logged in /tmp/eb-0006djcd/easybuild-run_cmd-haojzisn.log ] make -j 8 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" ( in /tmp/kehoste/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ) If the output you get is less detailed, you may not have set export EASYBUILD_TRACE=1 . The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/bowtie2 * bin/bowtie2-align-l * bin/bowtie2-align-s * bin/bowtie2-build * bin/bowtie2-build-l * bin/bowtie2-build-s * bin/bowtie2-inspect * bin/bowtie2-inspect-l * bin/bowtie2-inspect-s next: Installing software - (back to overview page)","title":"Exercises"},{"location":"2021-isc21/community/","text":"The EasyBuild community \u00b6 EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by hundreds of HPC centres and consortia worldwide. Since 2016, the EasyBuild community has gathered for a yearly EasyBuild User Meeting , which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins , Ansible , CernVM-FS , ReFrame etc. The map below shows from which cities the EasyBuild documentation has been visited in the last year (June 1st 2020 - June 1st 2021), and how often. HPC sites, consortia, and companies that use EasyBuild include (but are not limited to): Getting help \u00b6 Documentation \u00b6 If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io . It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful. GitHub \u00b6 You can open an issue in one of the EasyBuild repositories in the easybuilders GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements. Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate. Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem. Mailing list \u00b6 Feel free to ask any questions or provide feedback via the EasyBuild mailing list easybuild@lists.ugent.be . Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link . In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel. Slack \u00b6 The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 450 people have joined it so far, and there is usually somebody awake in there who may be able to help you out. To join the EasyBuild Slack request an invitation via https://easybuild-slack.herokuapp.com . If you are not a big fan of Slack, you can also consider joining the #easybuild IRC channel (available on the Libera IRC network ). A bot relays messages between this IRC channel and the #general channel in the EasyBuild Slack. Note A dedicated #tutorial-isc21 channel was created for this tutorial in the EasyBuild Slack. If you have any questions that are specific to this tutorial, please post them there! Conference calls \u00b6 Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call. These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013. More information, including the dates and times of the next calls, is available here . next: Contributing to EasyBuild - (back to overview page)","title":"The EasyBuild community"},{"location":"2021-isc21/community/#the-easybuild-community","text":"EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by hundreds of HPC centres and consortia worldwide. Since 2016, the EasyBuild community has gathered for a yearly EasyBuild User Meeting , which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins , Ansible , CernVM-FS , ReFrame etc. The map below shows from which cities the EasyBuild documentation has been visited in the last year (June 1st 2020 - June 1st 2021), and how often. HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):","title":"The EasyBuild community"},{"location":"2021-isc21/community/#getting-help","text":"","title":"Getting help"},{"location":"2021-isc21/community/#documentation","text":"If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io . It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful.","title":"Documentation"},{"location":"2021-isc21/community/#github","text":"You can open an issue in one of the EasyBuild repositories in the easybuilders GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements. Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate. Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem.","title":"GitHub"},{"location":"2021-isc21/community/#mailing-list","text":"Feel free to ask any questions or provide feedback via the EasyBuild mailing list easybuild@lists.ugent.be . Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link . In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel.","title":"Mailing list"},{"location":"2021-isc21/community/#slack","text":"The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 450 people have joined it so far, and there is usually somebody awake in there who may be able to help you out. To join the EasyBuild Slack request an invitation via https://easybuild-slack.herokuapp.com . If you are not a big fan of Slack, you can also consider joining the #easybuild IRC channel (available on the Libera IRC network ). A bot relays messages between this IRC channel and the #general channel in the EasyBuild Slack. Note A dedicated #tutorial-isc21 channel was created for this tutorial in the EasyBuild Slack. If you have any questions that are specific to this tutorial, please post them there!","title":"Slack"},{"location":"2021-isc21/community/#conference-calls","text":"Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call. These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013. More information, including the dates and times of the next calls, is available here . next: Contributing to EasyBuild - (back to overview page)","title":"Conference calls"},{"location":"2021-isc21/computecanada/","text":"EasyBuild at Compute Canada \u00b6 ( authors: Maxime Boissonneault & Bart Oldeman, Compute Canada) General info \u00b6 Compute Canada ( https://www.computecanada.ca ) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US. Staff & user base \u00b6 Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year. Resources \u00b6 Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud. Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs. Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size. B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs. Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, with more than 80,000 cores, all 40 cores per node. Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores. Compute Canada software stack \u00b6 Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere. For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here . This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available. Software distribution \u00b6 One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS . This allows any cluster, virtual machine, or even desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here . Some users use it for continuous integration, and we also use it in virtual clusters in the cloud. Compatibility layer \u00b6 Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to the GNU C Library ( glibc ) and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we started out with the Nix package manager, but have since moved to using Gentoo Prefix instead. Scientific layer and EasyBuild \u00b6 For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2021, we have almost 1000 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 2,000, 4,200 and 8,000 combinations of builds. Usage of EasyBuild within Compute Canada \u00b6 To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada. Filtering out dependencies \u00b6 Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through yum or apt-get ). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example binutils , Automake , flex , etc. This is configured through our EasyBuild configuration file . Custom toolchains \u00b6 Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the iomkl or gomkl toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common foss and intel toolchains). We therefore make a heavy use of the --try-toolchain option of EasyBuild, to use upstream recipes but with our preferred toolchains. Custom module naming scheme \u00b6 We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops versionsuffix . If we need to have different flavors of a given recipe, we instead use modaltsoftname to add the flavor to the name of the software package. This is enabled through this Python module , which implements our custom module naming scheme. Using RPATH and disabling LD_LIBRARY_PATH \u00b6 Our compatibility layer includes a wrapper script for the linker ( ld ) which ensures that RPATH is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the LD_LIBRARY_PATH from the modules. This is specified in our EasyBuild configuration file . Usage of hooks \u00b6 We make a rather intensive usage of hooks. For example, we use them to inject specific configure options to our OpenMPI builds add compiler and MPI footers to the modules split the installation of the Intel compiler into redistributable and non-redistributable parts strip down the installation of Python to a small set of Python packages Python specific customizations \u00b6 Compute Canada makes heavy usage of the multi_deps feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install PyQt alongside Qt , in the same module. For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments . The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository . next: The EasyBuild community - (back to overview page)","title":"EasyBuild at Compute Canada"},{"location":"2021-isc21/computecanada/#easybuild-at-compute-canada","text":"( authors: Maxime Boissonneault & Bart Oldeman, Compute Canada)","title":"EasyBuild at Compute Canada"},{"location":"2021-isc21/computecanada/#general-info","text":"Compute Canada ( https://www.computecanada.ca ) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US.","title":"General info"},{"location":"2021-isc21/computecanada/#staff-user-base","text":"Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year.","title":"Staff &amp; user base"},{"location":"2021-isc21/computecanada/#resources","text":"Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud. Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs. Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size. B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs. Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, with more than 80,000 cores, all 40 cores per node. Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores.","title":"Resources"},{"location":"2021-isc21/computecanada/#compute-canada-software-stack","text":"Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere. For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here . This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available.","title":"Compute Canada software stack"},{"location":"2021-isc21/computecanada/#software-distribution","text":"One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS . This allows any cluster, virtual machine, or even desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here . Some users use it for continuous integration, and we also use it in virtual clusters in the cloud.","title":"Software distribution"},{"location":"2021-isc21/computecanada/#compatibility-layer","text":"Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to the GNU C Library ( glibc ) and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we started out with the Nix package manager, but have since moved to using Gentoo Prefix instead.","title":"Compatibility layer"},{"location":"2021-isc21/computecanada/#scientific-layer-and-easybuild","text":"For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2021, we have almost 1000 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 2,000, 4,200 and 8,000 combinations of builds.","title":"Scientific layer and EasyBuild"},{"location":"2021-isc21/computecanada/#usage-of-easybuild-within-compute-canada","text":"To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada.","title":"Usage of EasyBuild within Compute Canada"},{"location":"2021-isc21/computecanada/#filtering-out-dependencies","text":"Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through yum or apt-get ). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example binutils , Automake , flex , etc. This is configured through our EasyBuild configuration file .","title":"Filtering out dependencies"},{"location":"2021-isc21/computecanada/#custom-toolchains","text":"Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the iomkl or gomkl toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common foss and intel toolchains). We therefore make a heavy use of the --try-toolchain option of EasyBuild, to use upstream recipes but with our preferred toolchains.","title":"Custom toolchains"},{"location":"2021-isc21/computecanada/#custom-module-naming-scheme","text":"We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops versionsuffix . If we need to have different flavors of a given recipe, we instead use modaltsoftname to add the flavor to the name of the software package. This is enabled through this Python module , which implements our custom module naming scheme.","title":"Custom module naming scheme"},{"location":"2021-isc21/computecanada/#using-rpath-and-disabling-ld_library_path","text":"Our compatibility layer includes a wrapper script for the linker ( ld ) which ensures that RPATH is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the LD_LIBRARY_PATH from the modules. This is specified in our EasyBuild configuration file .","title":"Using RPATH and disabling LD_LIBRARY_PATH"},{"location":"2021-isc21/computecanada/#usage-of-hooks","text":"We make a rather intensive usage of hooks. For example, we use them to inject specific configure options to our OpenMPI builds add compiler and MPI footers to the modules split the installation of the Intel compiler into redistributable and non-redistributable parts strip down the installation of Python to a small set of Python packages","title":"Usage of hooks"},{"location":"2021-isc21/computecanada/#python-specific-customizations","text":"Compute Canada makes heavy usage of the multi_deps feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install PyQt alongside Qt , in the same module. For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments . The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository . next: The EasyBuild community - (back to overview page)","title":"Python specific customizations"},{"location":"2021-isc21/configuration/","text":"Configuring EasyBuild \u00b6 After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it. Available configuration settings \u00b6 One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, about 250 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones. We will refer to EasyBuild configuration settings using the names as they appears in the output of eb --help , and omit the leading dashes ( -- ) for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details. Overall prefix \u00b6 (default: $HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which can be useful to test and evaluate software installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default software and modules/all names for the subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is strongly recommend to use the path to a directory on a local filesystem for the value of the buildpath configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like /dev/shm/$USER ) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like noexec ). Use a directory on a local filesystem for buildpath for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set buildpath to /tmp/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in sourcepath only read permissions are required. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation ). For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod (next to Tcl syntax). To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool; see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in Lua syntax. We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command, as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between these two configuration settings is that defining robot also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining robot-paths does not have the side effect of enabling dependency resolution. In addition, you can use the --robot command line option without specifying any paths to it, to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered . There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes . The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Just like with names of easyconfig files , the <-toolchain> part is omitted when the system toolchain is used, and the <versionsuffix> value is empty by default. Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ) is not defined and if the --magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead. Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files (usually *.cfg ) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file ( *.eb ) on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ). Although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Through the --show-config command line option you can easily inspect the currently active EasyBuild configuration. The output of --show-config includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produced by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which affects the value shown for the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ), and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Example Now let us do some basic configuring and inspect the resulting output of eb --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg In addition, define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run eb --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --show-config --installpath = /tmp/ $USER # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with (C) ), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ). Exercises \u00b6 Exercise C.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: The location of the build directories: use /tmp/$USER for this; The locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources . Leave other configuration settings set to their default value. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this (assuming that $USER is set to example ): buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise C.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 EasyBuild $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 EasyBuild $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial. next: Basic usage - (back to overview page)","title":"Configuration"},{"location":"2021-isc21/configuration/#configuring-easybuild","text":"After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it.","title":"Configuring EasyBuild"},{"location":"2021-isc21/configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, about 250 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones. We will refer to EasyBuild configuration settings using the names as they appears in the output of eb --help , and omit the leading dashes ( -- ) for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.","title":"Available configuration settings"},{"location":"2021-isc21/configuration/#overall-prefix","text":"(default: $HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"2021-isc21/configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which can be useful to test and evaluate software installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default software and modules/all names for the subdirectories are used.","title":"Install path"},{"location":"2021-isc21/configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is strongly recommend to use the path to a directory on a local filesystem for the value of the buildpath configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like /dev/shm/$USER ) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like noexec ). Use a directory on a local filesystem for buildpath for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set buildpath to /tmp/$USER , for example.","title":"Build path"},{"location":"2021-isc21/configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in sourcepath only read permissions are required. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere.","title":"Source path"},{"location":"2021-isc21/configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation ). For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"2021-isc21/configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod (next to Tcl syntax). To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool; see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in Lua syntax. We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"2021-isc21/configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command, as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between these two configuration settings is that defining robot also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining robot-paths does not have the side effect of enabling dependency resolution. In addition, you can use the --robot command line option without specifying any paths to it, to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered . There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"2021-isc21/configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes . The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Just like with names of easyconfig files , the <-toolchain> part is omitted when the system toolchain is used, and the <versionsuffix> value is empty by default.","title":"Module naming scheme"},{"location":"2021-isc21/configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception!","title":"Configuration levels"},{"location":"2021-isc21/configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ) is not defined and if the --magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead.","title":"Configuration level hierarchy"},{"location":"2021-isc21/configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"2021-isc21/configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files (usually *.cfg ) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file ( *.eb ) on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.","title":"EasyBuild configuration files vs easyconfig files"},{"location":"2021-isc21/configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"2021-isc21/configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ). Although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"2021-isc21/configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Through the --show-config command line option you can easily inspect the currently active EasyBuild configuration. The output of --show-config includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produced by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which affects the value shown for the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ), and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Example Now let us do some basic configuring and inspect the resulting output of eb --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg In addition, define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run eb --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --show-config --installpath = /tmp/ $USER # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with (C) ), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ).","title":"Inspecting the current configuration (--show-config)"},{"location":"2021-isc21/configuration/#exercises","text":"Exercise C.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: The location of the build directories: use /tmp/$USER for this; The locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources . Leave other configuration settings set to their default value. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this (assuming that $USER is set to example ): buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise C.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 EasyBuild $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 EasyBuild $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial. next: Basic usage - (back to overview page)","title":"Exercises"},{"location":"2021-isc21/contributing/","text":"Contributing to EasyBuild \u00b6 To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not? Manual contribution procedure \u00b6 0) Create and setup a GitHub account (and register your SSH public key); 1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file: git clone git@github.com:easybuilders/easybuild-easyconfigs.git cd easybuild-easyconfigs git remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git You should change ' your_github_account ' in the last line to your own GitHub user name! 2) Create and check out a new branch, starting from the (up-to-date) develop branch: git checkout develop git pull origin develop git checkout -b example 3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename , and that it's located in the appropriate directory. mkdir -p easybuild/easyconfigs/e/example/ mv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb git add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb 4) Commit those changes with a sensible commit message: git commit -m \"This is just an example\" 5) Push your branch to your fork of the repository on GitHub: git push my_fork example 6) Open the pull request through the GitHub web interface, making sure that: the target branch is correct (should be develop ); an appropriate title is used; a short description of the changes is provided; the changes are indeed the ones you want to propose; clicking the (correct) green button; That didn't exactly motivate you to contribute, did it... Github integration features \u00b6 Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute... In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with git you may quickly end up demotivated. This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures. At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running git commands and interacting with the GitHub API . We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation . Requirements & configuration \u00b6 First of all, the GitHub integration features impose a couple of additional requirements and configuration. Additional dependencies Both the GitPython and keyring Python packages as well as the keyrings.cryptfile add-on package must be installed. In the prepared environment, you can do this via: pip3 install --user GitPython keyring keyrings.cryptfile Note You may experiences problems installing the cryptography Python packages, which is a dependency of keyring. The underlying cause is that you need to have the Rust compiler installed to install the latest version of cryptography (see here ). You can work around this issue using: pip3 install --user 'cryptography<3.4' SSH public key in GitHub account You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys ). If you need to generate an SSH key pair, you can run the following command: ssh-keygen -t rsa -b 4096 You can copy the SSH public key from the output of this command: cat .ssh/id_rsa.pub Forked repository in GitHub In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs ). EasyBuild configuration, incl. GitHub token You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials. To do this, you should define the github-user configuration option and run the \" eb --install-github-token \" command: # replace 'ebtutorial' with your own GitHub username! $ export EASYBUILD_GITHUB_USER = ebtutorial $ eb --install-github-token To create a GitHub token: Visit https://github.com/settings/tokens . Click \"Personal access tokens\" . Click followed by \"Generate new token\" . Give the token a name (for example \"Token for EasyBuild\" ). Select both the ' repo ' and ' gist ' scopes. Click the green \"Generate token\" button. Copy the generated token. Paste the token when asked by --install-github-token (and hit Enter ). Enter a password to encrypt your GitHub token. The output should look something like this: $ eb --install-github-token == temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log Token: Validating token... Token seems to be valid, installing it. Please set a password for your new keyring: Please confirm the password: Token 'fed..987' installed! Checking status of GitHub integration You can check the status of the GitHub integration using \" eb --check-github \": $ eb --check-github == temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log Checking status of GitHub integration... Making sure we ' re online...OK * GitHub user...ebtutorial = > OK Please enter password for encrypted keyring: * GitHub token...fed..987 ( len: 40 ) = > OK ( validated ) * git command...OK ( \"git version 1.8.3.1; \" ) * GitPython module...OK ( GitPython version 3 .1.3 ) * push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK * creating gists...OK * location to Git working dirs... not found ( suboptimal ) All checks PASSed! Status of GitHub integration: * --from-pr: OK * --new-pr: OK * --review-pr: OK * --update-pr: OK * --upload-test-report: OK If you see ' OK ' for each of the status checks, you're all set to try out the GitHub integration features! Note If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \" eb --check-github \". You can avoid this by using an SSH agent . Note If you see the push access check fail with Failed to fetch branch 'main' , you will need to rename the master branch in your fork of the easybuild-easyconfigs repository from master to main (this is required since EasyBuild v4.3.3). This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace YOUR_GITHUB_ACCOUNT with the name of your GitHub account in this URL). Creating pull requests \u00b6 The GitHub integration in EasyBuild allows you to create pull requests using the eb command , without even leaving your shell environment. How cool is that\u203d To create a pull request to the easybuild-easyconfigs repository, you can either do it in a single go by running \" eb --new-pr \" and passing it one or more easyconfig files to add into the pull request. The more detailed option is to first create a branch in your repository fork in GitHub via \" eb --new-branch-github \" and then later open the pull request via \" eb --new-pr-from-branch \". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork). The --new-pr option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa! You can control the target repository for your pull request using --pr-target-account (default is easybuilders ) and --pr-target-repo . If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \" eb --dry-run --new-pr \" or \" eb -D --new-pr \". Finally, you can use \" eb --preview-pr \" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files. Updating pull requests \u00b6 To update an existing pull request with additional changes you can use \" eb --update-pr \" and pass the pull request ID, alongside the paths to the updated files. If you have only created a branch (for example via eb --new-branch-github ) you can update it via --update-branch-github in the same way, passing the branch name instead of a pull request ID. Using a pull request \u00b6 Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which support is not yet included in the latest EasyBuild release. Using the --from-pr option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the --robot option to ensure that the easyconfig files are installed in the correct order with respect to dependencies. Similarly, using a new or updated easyblock from a pull request is as simple as using the --include-easyblocks-from-pr option. And of course you can combine it with --from-pr ! Via --upload-test-report you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration. Demo \u00b6 That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the eb-tutorial example software to a fork of the easybuild-easyconfigs repository using the eb command, and submit a test report in it. Note Make sure that you have correctly configured the GitHub integration, see above . Creating pull request \u00b6 We first configure EasyBuild to target the ebtutorial GitHub account rather than the default easybuilders GitHub organisation, by defining the pr-target-account configuration setting: export EASYBUILD_PR_TARGET_ACCOUNT = ebtutorial In the output of \" eb --show-config \" you should see a line like this: pr-target-account (E) = ebtutorial We only do this to avoid that lots of pull requests for the eb-tutorial example software are opened in the central easyconfigs repository . Opening a pull request is as simple as running \" eb --new-pr \" and passing the easyconfig file: $ eb --new-pr example.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git... == copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs... == pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' ( git@github.com:ebtutorial/easybuild-easyconfigs.git ) Enter passphrase for key '/home/example/.ssh/id_rsa' : Please enter password for encrypted keyring: Opening pull request * target: ebtutorial/easybuild-easyconfigs:develop * from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100 * title: \"{tools}[GCC/10.2.0] eb-tutorial v1.0.1\" * labels: new * description: \"\"\" (created using `eb --new-pr`) \"\"\" * overview of changes: easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb | 26 ++++++++++++++++++++++++++ 1 file changed, 26 insertions ( + ) Opened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/ == Temporary log file ( s ) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed. == Temporary directory /tmp/eb-ggr6scbq has been removed. Take a moment to grasp what we did here: we ran a single eb command which took care of the whole contribution procedure for us, including: Cloning the easybuilders/easybuild-easyconfigs repository and checking out the develop branch (in a temporary directory); Picking a sensible name for a branch and creating it; Adding the eb-tutorial easyconfig file to the branch, in the correct location ( easybuild/easyconfigs/e/eb-tutorial/ ) and with the correct filename ( eb-tutorial-1.0.1-GCC-10.2.0.eb ); Pushing the branch to our fork ( example/easybuild-easyconfigs ); Actually opening the pull request, using an informative title. That is so... easy! This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the develop branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to). There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since --new-pr created the branch only in a temporary directory). If many contributions are made via --new-pr it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar. Uploading test report \u00b6 After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request. First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for eb-tutorial are already installed there: module use /easybuild/modules/all You can verify which dependencies are still missing using --from-pr combined with --missing : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --from-pr 123 --missing == temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log Please enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... 1 out of 20 required modules missing: * eb-tutorial/1.0.1-GCC-10.2.0 ( eb-tutorial-1.0.1-GCC-10.2.0.eb ) Uploading a test report boils down to combining --from-pr with --upload-test-report : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --rebuild --from-pr 123 --upload-test-report Please enter password for encrypted keyring: ... == processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 2 sec ) ... Adding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial **SUCCESS** Build succeeded for 1 out of 1 ( 1 easyconfigs in this PR ) example - Linux centos linux 7 .8.2003, x86_64, Intel ( R ) Core ( TM ) i5-7360U CPU @ 2 .30GHz ( haswell ) , Python 3 .6.8 See https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report. ' == Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1 Note that we may need to use --rebuild here since eb-tutorial may already be installed. This results in a comment being added to the pull request: The gist linked from this comment provides more detailed information: (back to start page)","title":"Contributing to EasyBuild"},{"location":"2021-isc21/contributing/#contributing-to-easybuild","text":"To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not?","title":"Contributing to EasyBuild"},{"location":"2021-isc21/contributing/#manual-contribution-procedure","text":"0) Create and setup a GitHub account (and register your SSH public key); 1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file: git clone git@github.com:easybuilders/easybuild-easyconfigs.git cd easybuild-easyconfigs git remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git You should change ' your_github_account ' in the last line to your own GitHub user name! 2) Create and check out a new branch, starting from the (up-to-date) develop branch: git checkout develop git pull origin develop git checkout -b example 3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename , and that it's located in the appropriate directory. mkdir -p easybuild/easyconfigs/e/example/ mv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb git add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb 4) Commit those changes with a sensible commit message: git commit -m \"This is just an example\" 5) Push your branch to your fork of the repository on GitHub: git push my_fork example 6) Open the pull request through the GitHub web interface, making sure that: the target branch is correct (should be develop ); an appropriate title is used; a short description of the changes is provided; the changes are indeed the ones you want to propose; clicking the (correct) green button; That didn't exactly motivate you to contribute, did it...","title":"Manual contribution procedure"},{"location":"2021-isc21/contributing/#github-integration-features","text":"Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute... In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with git you may quickly end up demotivated. This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures. At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running git commands and interacting with the GitHub API . We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation .","title":"Github integration features"},{"location":"2021-isc21/contributing/#requirements-configuration","text":"First of all, the GitHub integration features impose a couple of additional requirements and configuration. Additional dependencies Both the GitPython and keyring Python packages as well as the keyrings.cryptfile add-on package must be installed. In the prepared environment, you can do this via: pip3 install --user GitPython keyring keyrings.cryptfile Note You may experiences problems installing the cryptography Python packages, which is a dependency of keyring. The underlying cause is that you need to have the Rust compiler installed to install the latest version of cryptography (see here ). You can work around this issue using: pip3 install --user 'cryptography<3.4' SSH public key in GitHub account You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys ). If you need to generate an SSH key pair, you can run the following command: ssh-keygen -t rsa -b 4096 You can copy the SSH public key from the output of this command: cat .ssh/id_rsa.pub Forked repository in GitHub In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs ). EasyBuild configuration, incl. GitHub token You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials. To do this, you should define the github-user configuration option and run the \" eb --install-github-token \" command: # replace 'ebtutorial' with your own GitHub username! $ export EASYBUILD_GITHUB_USER = ebtutorial $ eb --install-github-token To create a GitHub token: Visit https://github.com/settings/tokens . Click \"Personal access tokens\" . Click followed by \"Generate new token\" . Give the token a name (for example \"Token for EasyBuild\" ). Select both the ' repo ' and ' gist ' scopes. Click the green \"Generate token\" button. Copy the generated token. Paste the token when asked by --install-github-token (and hit Enter ). Enter a password to encrypt your GitHub token. The output should look something like this: $ eb --install-github-token == temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log Token: Validating token... Token seems to be valid, installing it. Please set a password for your new keyring: Please confirm the password: Token 'fed..987' installed! Checking status of GitHub integration You can check the status of the GitHub integration using \" eb --check-github \": $ eb --check-github == temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log Checking status of GitHub integration... Making sure we ' re online...OK * GitHub user...ebtutorial = > OK Please enter password for encrypted keyring: * GitHub token...fed..987 ( len: 40 ) = > OK ( validated ) * git command...OK ( \"git version 1.8.3.1; \" ) * GitPython module...OK ( GitPython version 3 .1.3 ) * push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK * creating gists...OK * location to Git working dirs... not found ( suboptimal ) All checks PASSed! Status of GitHub integration: * --from-pr: OK * --new-pr: OK * --review-pr: OK * --update-pr: OK * --upload-test-report: OK If you see ' OK ' for each of the status checks, you're all set to try out the GitHub integration features! Note If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \" eb --check-github \". You can avoid this by using an SSH agent . Note If you see the push access check fail with Failed to fetch branch 'main' , you will need to rename the master branch in your fork of the easybuild-easyconfigs repository from master to main (this is required since EasyBuild v4.3.3). This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace YOUR_GITHUB_ACCOUNT with the name of your GitHub account in this URL).","title":"Requirements &amp; configuration"},{"location":"2021-isc21/contributing/#creating-pull-requests","text":"The GitHub integration in EasyBuild allows you to create pull requests using the eb command , without even leaving your shell environment. How cool is that\u203d To create a pull request to the easybuild-easyconfigs repository, you can either do it in a single go by running \" eb --new-pr \" and passing it one or more easyconfig files to add into the pull request. The more detailed option is to first create a branch in your repository fork in GitHub via \" eb --new-branch-github \" and then later open the pull request via \" eb --new-pr-from-branch \". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork). The --new-pr option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa! You can control the target repository for your pull request using --pr-target-account (default is easybuilders ) and --pr-target-repo . If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \" eb --dry-run --new-pr \" or \" eb -D --new-pr \". Finally, you can use \" eb --preview-pr \" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.","title":"Creating pull requests"},{"location":"2021-isc21/contributing/#updating-pull-requests","text":"To update an existing pull request with additional changes you can use \" eb --update-pr \" and pass the pull request ID, alongside the paths to the updated files. If you have only created a branch (for example via eb --new-branch-github ) you can update it via --update-branch-github in the same way, passing the branch name instead of a pull request ID.","title":"Updating pull requests"},{"location":"2021-isc21/contributing/#using-a-pull-request","text":"Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which support is not yet included in the latest EasyBuild release. Using the --from-pr option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the --robot option to ensure that the easyconfig files are installed in the correct order with respect to dependencies. Similarly, using a new or updated easyblock from a pull request is as simple as using the --include-easyblocks-from-pr option. And of course you can combine it with --from-pr ! Via --upload-test-report you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.","title":"Using a pull request"},{"location":"2021-isc21/contributing/#demo","text":"That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the eb-tutorial example software to a fork of the easybuild-easyconfigs repository using the eb command, and submit a test report in it. Note Make sure that you have correctly configured the GitHub integration, see above .","title":"Demo"},{"location":"2021-isc21/contributing/#creating-pull-request","text":"We first configure EasyBuild to target the ebtutorial GitHub account rather than the default easybuilders GitHub organisation, by defining the pr-target-account configuration setting: export EASYBUILD_PR_TARGET_ACCOUNT = ebtutorial In the output of \" eb --show-config \" you should see a line like this: pr-target-account (E) = ebtutorial We only do this to avoid that lots of pull requests for the eb-tutorial example software are opened in the central easyconfigs repository . Opening a pull request is as simple as running \" eb --new-pr \" and passing the easyconfig file: $ eb --new-pr example.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git... == copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs... == pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' ( git@github.com:ebtutorial/easybuild-easyconfigs.git ) Enter passphrase for key '/home/example/.ssh/id_rsa' : Please enter password for encrypted keyring: Opening pull request * target: ebtutorial/easybuild-easyconfigs:develop * from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100 * title: \"{tools}[GCC/10.2.0] eb-tutorial v1.0.1\" * labels: new * description: \"\"\" (created using `eb --new-pr`) \"\"\" * overview of changes: easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb | 26 ++++++++++++++++++++++++++ 1 file changed, 26 insertions ( + ) Opened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/ == Temporary log file ( s ) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed. == Temporary directory /tmp/eb-ggr6scbq has been removed. Take a moment to grasp what we did here: we ran a single eb command which took care of the whole contribution procedure for us, including: Cloning the easybuilders/easybuild-easyconfigs repository and checking out the develop branch (in a temporary directory); Picking a sensible name for a branch and creating it; Adding the eb-tutorial easyconfig file to the branch, in the correct location ( easybuild/easyconfigs/e/eb-tutorial/ ) and with the correct filename ( eb-tutorial-1.0.1-GCC-10.2.0.eb ); Pushing the branch to our fork ( example/easybuild-easyconfigs ); Actually opening the pull request, using an informative title. That is so... easy! This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the develop branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to). There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since --new-pr created the branch only in a temporary directory). If many contributions are made via --new-pr it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar.","title":"Creating pull request"},{"location":"2021-isc21/contributing/#uploading-test-report","text":"After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request. First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for eb-tutorial are already installed there: module use /easybuild/modules/all You can verify which dependencies are still missing using --from-pr combined with --missing : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --from-pr 123 --missing == temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log Please enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... 1 out of 20 required modules missing: * eb-tutorial/1.0.1-GCC-10.2.0 ( eb-tutorial-1.0.1-GCC-10.2.0.eb ) Uploading a test report boils down to combining --from-pr with --upload-test-report : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --rebuild --from-pr 123 --upload-test-report Please enter password for encrypted keyring: ... == processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 2 sec ) ... Adding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial **SUCCESS** Build succeeded for 1 out of 1 ( 1 easyconfigs in this PR ) example - Linux centos linux 7 .8.2003, x86_64, Intel ( R ) Core ( TM ) i5-7360U CPU @ 2 .30GHz ( haswell ) , Python 3 .6.8 See https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report. ' == Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1 Note that we may need to use --rebuild here since eb-tutorial may already be installed. This results in a comment being added to the pull request: The gist linked from this comment provides more detailed information: (back to start page)","title":"Uploading test report"},{"location":"2021-isc21/getting_ready/","text":"The contents of this page was moved to Practical info","title":"Getting ready"},{"location":"2021-isc21/installation/","text":"Installing EasyBuild \u00b6 Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary Requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended). Installation methods : pip install easybuild installing EasyBuild with EasyBuild development setup Verify EasyBuild installation by running eb commands. Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed via $EB_PYTHON . Installing EasyBuild \u00b6 We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip Method 2: installing EasyBuild with EasyBuild Method 3: Development setup Method 1: Using pip \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). pip vs pip3 \u00b6 On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. If you want to ensure that you are using the pip installation that corresponds to the Python 3 installation that you intend to use, you can use python3 -m pip rather than pip3 . Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, or if you installed EasyBuild with a pip version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update the .bashrc shell startup script in your home directory. Updating $PATH \u00b6 Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). This is not required if you installed EasyBuild in a standard system location. You can check with the \" which eb \" command to determine whether or not you need to update the $PATH environment variable. Updating $PYTHONPATH \u00b6 If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 3.6, make sure you are using /python3.6/ in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH Setting $EB_PYTHON \u00b6 If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. This may be required when you installing EasyBuild with a version of pip that does not correspond with the default Python version. For example, to ensure that the eb command uses python3.6 : export EB_PYTHON = python3.6 Setting $EB_VERBOSE \u00b6 To determine which python commands are being considered by the eb command, you can define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3.6' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3.6 ) >> python3.6 -m easybuild.main --version This is EasyBuild 4 .3.3 ( framework: 4 .3.3, easyblocks: 4 .3.3 ) on host example Method 2: Installing EasyBuild with EasyBuild \u00b6 Note This section covers an alternative method for installing EasyBuild. If you already have EasyBuild installed through pip , you can skip ahead to the next section . If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps: Step 1: Installing EasyBuild with pip into a temporary location (only needed if EasyBuild is not installed yet) Step 2: Using EasyBuild to install EasyBuild as a module Step 3: Loading the EasyBuild module Step 1: Installing EasyBuild into a temporary location \u00b6 If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using pip . For example, to install EasyBuild into a subdirectory /tmp/$USER using the default Python 3 version: # pick installation prefix, and install EasyBuild into it export EB_TMPDIR = /tmp/ $USER /eb_tmp python3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild # update environment to use this temporary EasyBuild installation export PATH = $EB_TMPDIR /bin: $PATH export PYTHONPATH = $( /bin/ls -rtd -1 $EB_TMPDIR /lib*/python*/site-packages | tail -1 ) : $PYTHONPATH export EB_PYTHON = python3 Step 2: Using EasyBuild to install EasyBuild \u00b6 Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too. You can use the eb --install-latest-eb-release command for this, combined with the --prefix option to control which directories are used by EasyBuild for the installation. For example, to install the latest version of EasyBuild as a module into $HOME/easybuild : eb --install-latest-eb-release --prefix $HOME /easybuild Note You may see a harmless deprecation warning popping up when performing this installation, just ignore it. Step 3: Loading the EasyBuild module \u00b6 Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' with the path to the directory that you used when running step 2 (for example, $HOME/easybuild ). Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made. Method 3: Development setup \u00b6 If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there. This can be done as follows (into $HOME/easybuild ): mkdir -p $HOME /easybuild cd $HOME /easybuild # clone EasyBuild repositories from GitHub git clone https://github.com/easybuilders/easybuild-framework.git git clone https://github.com/easybuilders/easybuild-easyblocks.git git clone https://github.com/easybuilders/easybuild-easyconfigs.git # update environment for running EasyBuild from there export PATH = $HOME /easybuild/easybuild-framework: $PATH export PYTHONPATH = $HOME /easybuild/easybuild-framework: $HOME /easybuild/easybuild-easyblocks: $HOME /easybuild/easybuild-easyconfigs: $PYTHONPATH # control which Python command is used to run EasyBuild export EB_PYTHON = python3 Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial . System information \u00b6 You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. If you have installed EasyBuild through pip , and you prefer updating that installation, you can use pip install --upgrade easybuild (perhaps with additional options like --user or --prefix ). Exercise \u00b6 Install EasyBuild in your home directory. Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure, or try all these installation methods! install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option; perform a (manual) \"bootstrap\" installation into $HOME/easybuild , as outlined in installation method 2 ; set up a development installation; Check that the installation works by running the verification commands outlined above . Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial! next: Configuration - (back to overview page)","title":"Installation"},{"location":"2021-isc21/installation/#installing-easybuild","text":"Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary Requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended). Installation methods : pip install easybuild installing EasyBuild with EasyBuild development setup Verify EasyBuild installation by running eb commands.","title":"Installing EasyBuild"},{"location":"2021-isc21/installation/#requirements","text":"","title":"Requirements"},{"location":"2021-isc21/installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project.","title":"Linux"},{"location":"2021-isc21/installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.","title":"Python"},{"location":"2021-isc21/installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"2021-isc21/installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"2021-isc21/installation/#python-2-or-python-3","text":"For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed via $EB_PYTHON .","title":"Python 2 or Python 3?"},{"location":"2021-isc21/installation/#installing-easybuild_1","text":"We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip Method 2: installing EasyBuild with EasyBuild Method 3: Development setup","title":"Installing EasyBuild"},{"location":"2021-isc21/installation/#method-1-using-pip","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip"},{"location":"2021-isc21/installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"2021-isc21/installation/#pip-vs-pip3","text":"On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. If you want to ensure that you are using the pip installation that corresponds to the Python 3 installation that you intend to use, you can use python3 -m pip rather than pip3 .","title":"pip vs pip3"},{"location":"2021-isc21/installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, or if you installed EasyBuild with a pip version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update the .bashrc shell startup script in your home directory.","title":"Updating your environment"},{"location":"2021-isc21/installation/#updating-path","text":"Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). This is not required if you installed EasyBuild in a standard system location. You can check with the \" which eb \" command to determine whether or not you need to update the $PATH environment variable.","title":"Updating $PATH"},{"location":"2021-isc21/installation/#updating-pythonpath","text":"If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 3.6, make sure you are using /python3.6/ in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH","title":"Updating $PYTHONPATH"},{"location":"2021-isc21/installation/#setting-eb_python","text":"If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. This may be required when you installing EasyBuild with a version of pip that does not correspond with the default Python version. For example, to ensure that the eb command uses python3.6 : export EB_PYTHON = python3.6","title":"Setting $EB_PYTHON"},{"location":"2021-isc21/installation/#setting-eb_verbose","text":"To determine which python commands are being considered by the eb command, you can define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3.6' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3.6 ) >> python3.6 -m easybuild.main --version This is EasyBuild 4 .3.3 ( framework: 4 .3.3, easyblocks: 4 .3.3 ) on host example","title":"Setting $EB_VERBOSE"},{"location":"2021-isc21/installation/#method-2-installing-easybuild-with-easybuild","text":"Note This section covers an alternative method for installing EasyBuild. If you already have EasyBuild installed through pip , you can skip ahead to the next section . If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps: Step 1: Installing EasyBuild with pip into a temporary location (only needed if EasyBuild is not installed yet) Step 2: Using EasyBuild to install EasyBuild as a module Step 3: Loading the EasyBuild module","title":"Method 2: Installing EasyBuild with EasyBuild"},{"location":"2021-isc21/installation/#step-1-installing-easybuild-into-a-temporary-location","text":"If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using pip . For example, to install EasyBuild into a subdirectory /tmp/$USER using the default Python 3 version: # pick installation prefix, and install EasyBuild into it export EB_TMPDIR = /tmp/ $USER /eb_tmp python3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild # update environment to use this temporary EasyBuild installation export PATH = $EB_TMPDIR /bin: $PATH export PYTHONPATH = $( /bin/ls -rtd -1 $EB_TMPDIR /lib*/python*/site-packages | tail -1 ) : $PYTHONPATH export EB_PYTHON = python3","title":"Step 1: Installing EasyBuild into a temporary location"},{"location":"2021-isc21/installation/#step-2-using-easybuild-to-install-easybuild","text":"Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too. You can use the eb --install-latest-eb-release command for this, combined with the --prefix option to control which directories are used by EasyBuild for the installation. For example, to install the latest version of EasyBuild as a module into $HOME/easybuild : eb --install-latest-eb-release --prefix $HOME /easybuild Note You may see a harmless deprecation warning popping up when performing this installation, just ignore it.","title":"Step 2: Using EasyBuild to install EasyBuild"},{"location":"2021-isc21/installation/#step-3-loading-the-easybuild-module","text":"Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' with the path to the directory that you used when running step 2 (for example, $HOME/easybuild ). Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made.","title":"Step 3: Loading the EasyBuild module"},{"location":"2021-isc21/installation/#method-3-development-setup","text":"If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there. This can be done as follows (into $HOME/easybuild ): mkdir -p $HOME /easybuild cd $HOME /easybuild # clone EasyBuild repositories from GitHub git clone https://github.com/easybuilders/easybuild-framework.git git clone https://github.com/easybuilders/easybuild-easyblocks.git git clone https://github.com/easybuilders/easybuild-easyconfigs.git # update environment for running EasyBuild from there export PATH = $HOME /easybuild/easybuild-framework: $PATH export PYTHONPATH = $HOME /easybuild/easybuild-framework: $HOME /easybuild/easybuild-easyblocks: $HOME /easybuild/easybuild-easyconfigs: $PYTHONPATH # control which Python command is used to run EasyBuild export EB_PYTHON = python3","title":"Method 3: Development setup"},{"location":"2021-isc21/installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"2021-isc21/installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"2021-isc21/installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"2021-isc21/installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial .","title":"Showing the default EasyBuild configuration"},{"location":"2021-isc21/installation/#system-information","text":"You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info","title":"System information"},{"location":"2021-isc21/installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. If you have installed EasyBuild through pip , and you prefer updating that installation, you can use pip install --upgrade easybuild (perhaps with additional options like --user or --prefix ).","title":"Updating EasyBuild"},{"location":"2021-isc21/installation/#exercise","text":"Install EasyBuild in your home directory. Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure, or try all these installation methods! install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option; perform a (manual) \"bootstrap\" installation into $HOME/easybuild , as outlined in installation method 2 ; set up a development installation; Check that the installation works by running the verification commands outlined above . Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial! next: Configuration - (back to overview page)","title":"Exercise"},{"location":"2021-isc21/installing_software/","text":"Installing software with EasyBuild \u00b6 You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.11: $ eb SAMtools-1.11-GCC-10.2.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb == building and installing SAMtools/1.11-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 17 sec ) == Results of the build can be found in the log file ( s ) /home/example/easybuild/software/SAMtools/1.11-GCC-10.2.0/easybuild/easybuild-SAMtools-1.11-20210309.105601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost... Enabling dependency resolution \u00b6 The SAMtools installation worked like a charm, but remember that all required dependencies were already available ( see the section on checking dependencies ). If we try this with the BCFtools-1.11-GCC-10.2.0.eb , for which the required GSL and HTSlib dependencies are not available yet, it's less successful: $ eb BCFtools-1.11-GCC-10.2.0.eb -M 3 out of 23 required modules missing: * GSL/2.6-GCC-10.2.0 ( GSL-2.6-GCC-10.2.0.eb ) * HTSlib/1.11-GCC-10.2.0 ( HTSlib-1.11-GCC-10.2.0.eb ) * BCFtools/1.11-GCC-10.2.0 ( BCFtools-1.11-GCC-10.2.0.eb ) $ eb BCFtools-1.11-GCC-10.2.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/build/BCFtools/1.11/GCC-10.2.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 ( took 2 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-3v1dfvnk/easybuild-BCFtools-1.11-20210308.195024.FlxkH.log ERROR: Build of /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/b/BCFtools/BCFtools-1.11-GCC-10.2.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 The required dependencies HTSlib/1.11-GCC-10.2.0 and GSL/2.6-GCC-10.2.0 are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb BCFtools-1.11-GCC-10.2.0.eb --robot ... == resolving dependencies ... ... == building and installing HTSlib/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 13 sec ) ... == building and installing GSL/2.6-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 1 min 10 sec ) ... == building and installing BCFtools/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 8 sec ) ... == Build succeeded for 3 out of 3 With dependency resolution enabled the HTSlib and GSL modules get installed first, before EasyBuild proceeds with installing BCFtools . Great! Trace output \u00b6 As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of BCFtools-1.11-GCC-10.2.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb BCFtools-1.11-GCC-10.2.0.eb --rebuild ... == configuring... >> running command: [ started at: 2021 -03-08 19 :54:53 ] [ working dir: /tmp/example/build/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-17m_he2x.log ] ./configure --prefix = /home/example/easybuild/software/BCFtools/1.11-GCC-10.2.0 --build = x86_64-pc-linux-gnu --host = x86_64-pc-linux-gnu --with-htslib = $EBROOTHTSLIB --enable-libgsl == building... >> running command: [ started at: 2021 -03-08 19 :54:54 ] [ working dir: /tmp/example/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-bhkgjxi7.log ] make -j 8 >> command completed: exit 0 , ran in 00h00m03s That's a bit more comforting to stare at... During the configure step, the ./configure command is run with option to enable support for leveraging HTSlib and GSL . During the build step, the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 8). We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bcftools' found: OK >> file 'bin/plot-vcfstats' found: OK >> file 'bin/vcfutils.pl' found: OK >> (non-empty) directory 'libexec/bcftools' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary. Using installed software \u00b6 So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio devel numlib tools Directories like bio and numlib correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ---------------------- /home/example/easybuild/modules/all ----------------------- BCFtools/1.11-GCC-10.2.0 GSL/2.6-GCC-10.2.0 SAMtools/1.11-GCC-10.2.0 EasyBuild/4.3.3 HTSlib/1.11-GCC-10.2.0 bzip2/1.0.6 ---------------------------- /easybuild/modules/all ----------------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for BCFtools. In our current environment, the bcftools command is not available yet: $ module list No modules loaded $ bcftools -bash: bcftools: command not found Loading the module for BCFtools changes that: $ module load BCFtools/1.11-GCC-10.2.0 $ module list Currently Loaded Modules: 1 ) EasyBuild/4.4.0 7 ) XZ/5.2.5-GCCcore-10.2.0 2 ) GCCcore/10.2.0 8 ) cURL/7.72.0-GCCcore-10.2.0 3 ) zlib/1.2.11-GCCcore-10.2.0 9 ) HTSlib/1.11-GCC-10.2.0 4 ) binutils/2.35-GCCcore-10.2.0 10 ) GSL/2.6-GCC-10.2.0 5 ) GCC/10.2.0 11 ) BCFtools/1.11-GCC-10.2.0 6 ) bzip2/1.0.8-GCCcore-10.2.0 $ bcftools --version bcftools 1 .11 Using htslib 1 .11 ... Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use. Resetting your environment \u00b6 To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \". Stacking software \u00b6 Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here). Exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions for others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.4.0. Exercise S.1 - Installing software Install version 3.1.0 of the h5py Python package and all missing dependencies, using the foss/2020b toolchain, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py-3.1.0.*foss-2020b' CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-3.1.0-foss-2020b.eb Make sure the pre-installed software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install this h5py easyconfig: $ eb h5py-3.1.0-foss-2020b.eb --missing 2 out of 63 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-3.1.0-foss-2020b.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-10.2.0-python... ... == building and installing h5py/3.1.0-foss-2020b... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/3.1.0/foss-2020b/h5py-3.1.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.6-GCCcore-10.2.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise S.2 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/3.1.0-foss-2020b module load h5py/3.1.0-foss-2020b The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course you can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask questions in the #tutorial-isc21 channel in the EasyBuild Slack , we're happy to help! next: Troubleshooting - (back to overview page)","title":"Installing software"},{"location":"2021-isc21/installing_software/#installing-software-with-easybuild","text":"You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.11: $ eb SAMtools-1.11-GCC-10.2.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb == building and installing SAMtools/1.11-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 17 sec ) == Results of the build can be found in the log file ( s ) /home/example/easybuild/software/SAMtools/1.11-GCC-10.2.0/easybuild/easybuild-SAMtools-1.11-20210309.105601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost...","title":"Installing software with EasyBuild"},{"location":"2021-isc21/installing_software/#enabling-dependency-resolution","text":"The SAMtools installation worked like a charm, but remember that all required dependencies were already available ( see the section on checking dependencies ). If we try this with the BCFtools-1.11-GCC-10.2.0.eb , for which the required GSL and HTSlib dependencies are not available yet, it's less successful: $ eb BCFtools-1.11-GCC-10.2.0.eb -M 3 out of 23 required modules missing: * GSL/2.6-GCC-10.2.0 ( GSL-2.6-GCC-10.2.0.eb ) * HTSlib/1.11-GCC-10.2.0 ( HTSlib-1.11-GCC-10.2.0.eb ) * BCFtools/1.11-GCC-10.2.0 ( BCFtools-1.11-GCC-10.2.0.eb ) $ eb BCFtools-1.11-GCC-10.2.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/build/BCFtools/1.11/GCC-10.2.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 ( took 2 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-3v1dfvnk/easybuild-BCFtools-1.11-20210308.195024.FlxkH.log ERROR: Build of /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/b/BCFtools/BCFtools-1.11-GCC-10.2.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 The required dependencies HTSlib/1.11-GCC-10.2.0 and GSL/2.6-GCC-10.2.0 are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb BCFtools-1.11-GCC-10.2.0.eb --robot ... == resolving dependencies ... ... == building and installing HTSlib/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 13 sec ) ... == building and installing GSL/2.6-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 1 min 10 sec ) ... == building and installing BCFtools/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 8 sec ) ... == Build succeeded for 3 out of 3 With dependency resolution enabled the HTSlib and GSL modules get installed first, before EasyBuild proceeds with installing BCFtools . Great!","title":"Enabling dependency resolution"},{"location":"2021-isc21/installing_software/#trace-output","text":"As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of BCFtools-1.11-GCC-10.2.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb BCFtools-1.11-GCC-10.2.0.eb --rebuild ... == configuring... >> running command: [ started at: 2021 -03-08 19 :54:53 ] [ working dir: /tmp/example/build/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-17m_he2x.log ] ./configure --prefix = /home/example/easybuild/software/BCFtools/1.11-GCC-10.2.0 --build = x86_64-pc-linux-gnu --host = x86_64-pc-linux-gnu --with-htslib = $EBROOTHTSLIB --enable-libgsl == building... >> running command: [ started at: 2021 -03-08 19 :54:54 ] [ working dir: /tmp/example/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-bhkgjxi7.log ] make -j 8 >> command completed: exit 0 , ran in 00h00m03s That's a bit more comforting to stare at... During the configure step, the ./configure command is run with option to enable support for leveraging HTSlib and GSL . During the build step, the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 8). We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bcftools' found: OK >> file 'bin/plot-vcfstats' found: OK >> file 'bin/vcfutils.pl' found: OK >> (non-empty) directory 'libexec/bcftools' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.","title":"Trace output"},{"location":"2021-isc21/installing_software/#using-installed-software","text":"So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio devel numlib tools Directories like bio and numlib correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ---------------------- /home/example/easybuild/modules/all ----------------------- BCFtools/1.11-GCC-10.2.0 GSL/2.6-GCC-10.2.0 SAMtools/1.11-GCC-10.2.0 EasyBuild/4.3.3 HTSlib/1.11-GCC-10.2.0 bzip2/1.0.6 ---------------------------- /easybuild/modules/all ----------------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for BCFtools. In our current environment, the bcftools command is not available yet: $ module list No modules loaded $ bcftools -bash: bcftools: command not found Loading the module for BCFtools changes that: $ module load BCFtools/1.11-GCC-10.2.0 $ module list Currently Loaded Modules: 1 ) EasyBuild/4.4.0 7 ) XZ/5.2.5-GCCcore-10.2.0 2 ) GCCcore/10.2.0 8 ) cURL/7.72.0-GCCcore-10.2.0 3 ) zlib/1.2.11-GCCcore-10.2.0 9 ) HTSlib/1.11-GCC-10.2.0 4 ) binutils/2.35-GCCcore-10.2.0 10 ) GSL/2.6-GCC-10.2.0 5 ) GCC/10.2.0 11 ) BCFtools/1.11-GCC-10.2.0 6 ) bzip2/1.0.8-GCCcore-10.2.0 $ bcftools --version bcftools 1 .11 Using htslib 1 .11 ... Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use.","title":"Using installed software"},{"location":"2021-isc21/installing_software/#resetting-your-environment","text":"To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \".","title":"Resetting your environment"},{"location":"2021-isc21/installing_software/#stacking-software","text":"Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).","title":"Stacking software"},{"location":"2021-isc21/installing_software/#exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions for others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.4.0. Exercise S.1 - Installing software Install version 3.1.0 of the h5py Python package and all missing dependencies, using the foss/2020b toolchain, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py-3.1.0.*foss-2020b' CFGS1 = /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-3.1.0-foss-2020b.eb Make sure the pre-installed software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install this h5py easyconfig: $ eb h5py-3.1.0-foss-2020b.eb --missing 2 out of 63 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-3.1.0-foss-2020b.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-10.2.0-python... ... == building and installing h5py/3.1.0-foss-2020b... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/3.1.0/foss-2020b/h5py-3.1.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.6-GCCcore-10.2.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise S.2 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/3.1.0-foss-2020b module load h5py/3.1.0-foss-2020b The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course you can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask questions in the #tutorial-isc21 channel in the EasyBuild Slack , we're happy to help! next: Troubleshooting - (back to overview page)","title":"Exercises"},{"location":"2021-isc21/introduction/","text":"Introduction to EasyBuild \u00b6 What is EasyBuild? \u00b6 EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. EasyBuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack. History \u00b6 EasyBuild as a project was conceived in 2008 by the HPC team at Ghent University (Belgium) . The first public release of EasyBuild was made available early 2012. EasyBuild v1.0.0 was released in November 2012, during the Supercomputing 2012 conference. Following the public release and the project's introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. Over the years EasyBuild has grown into a community project , which is used and developed by hundreds of HPC centres and consortia worldwide. EasyBuild in a nutshell \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among HPC sites worldwide, and has become an \"expert system\" for installing scientific software on HPC systems. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations. The installation procedure executed by EasyBuild is thoroughly logged , and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed. EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting . Reproducibility \u00b6 In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular compiler toolchain , with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the GitHub repositories or the documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you. next: Terminology - (back to overview page)","title":"Introduction"},{"location":"2021-isc21/introduction/#introduction-to-easybuild","text":"","title":"Introduction to EasyBuild"},{"location":"2021-isc21/introduction/#what-is-easybuild","text":"EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. EasyBuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack.","title":"What is EasyBuild?"},{"location":"2021-isc21/introduction/#history","text":"EasyBuild as a project was conceived in 2008 by the HPC team at Ghent University (Belgium) . The first public release of EasyBuild was made available early 2012. EasyBuild v1.0.0 was released in November 2012, during the Supercomputing 2012 conference. Following the public release and the project's introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. Over the years EasyBuild has grown into a community project , which is used and developed by hundreds of HPC centres and consortia worldwide.","title":"History"},{"location":"2021-isc21/introduction/#easybuild-in-a-nutshell","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among HPC sites worldwide, and has become an \"expert system\" for installing scientific software on HPC systems.","title":"EasyBuild in a nutshell"},{"location":"2021-isc21/introduction/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations. The installation procedure executed by EasyBuild is thoroughly logged , and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed. EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on.","title":"Key features"},{"location":"2021-isc21/introduction/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"2021-isc21/introduction/#performance","text":"EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting .","title":"Performance"},{"location":"2021-isc21/introduction/#reproducibility","text":"In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular compiler toolchain , with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"2021-isc21/introduction/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the GitHub repositories or the documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Community effort"},{"location":"2021-isc21/introduction/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you. next: Terminology - (back to overview page)","title":"What EasyBuild is not"},{"location":"2021-isc21/jsc/","text":"EasyBuild at J\u00fclich Supercomputing Centre \u00b6 ( author: Alan O'Cais, J\u00fclich Supercomputing Centre) General info \u00b6 The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc ) at Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process. Staff & user base \u00b6 About 200 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services. In cooperation with hardware and software vendors like IBM, Intel and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008. Resources \u00b6 JSC currently manages 3 primary systems (in addition to a number of other development clusters): JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance. In the coming months, JUWELS will become the first supercomputer equipped with NVIDIA A100 GPU, when a new GPU module providing an additional 58 Petaflops will be installed. This module will make JUWELS the most powerful supercomputer in Europe. JURECA is the precursor system to JUWELS and currently has 2 modules: the JURECA DC Module with 3.54 (CPU, AMD EPYC) + 14.98 (GPU, NVIDIA A100) Petaflop per second peak performance, and the JURECA Booster Module with 5 (KNL) Petaflop per second peak performance. JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms. Usage of EasyBuild within JSC \u00b6 As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated. JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations. Custom toolchains \u00b6 As of June 2020, there are a total of 15 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers ( GCCcore , GCC , Intel and PGI ), MPI runtimes ( ParaStationMPI , OpenMPI , IntelMPI and MVAPICH2 ) and mathematical libraries ( MKL ). Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the --try-toolchain option and has recently introduced the --try-update-deps experimental option to more easily adopt upstream changes and adapt them to our environment. Custom module naming scheme \u00b6 By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes). Custom easyconfigs \u00b6 The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository). We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild. Hiding dependencies \u00b6 While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the hide-deps configuration setting). There are currently over 200 such hidden dependencies. While hidden dependencies are not visible in the module view by default, users can expose them by the use of the --show-hidden argument in Lmod : module --show-hidden avail Usage of hooks \u00b6 The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely. We are currently integrating a new hook that provides a lot of useful functionality: Facilitates userspace installations alongside system provided installations EasyBuild is configured to allow both shared installations for a group and private installations (group installations are automatically picked up by Lmod for other members of the group) Restricts users from installing non-supported compilers (in particular we don't want people to install their own GCCcore since this would likely lead to an avalanche of required dependencies) and MPI runtimes (since MPI installations are heavily customised) Restricts users to only resolve dependencies from our Golden repository (as well as from their own installed software) but allows them to search in the upstream repositories if they try to install something from the upstream repository, the hook advises them how to do this correctly for our systems Customises the final module files Customises the names of some modules (such as Intel over iccifort and IntelMPI over impi ) Injects an Lmod family in the modules of our compilers and MPI runtimes Adds Lmod properties for GPU enabled applications and user installed software so that they can be easily identified in the module view Adds a site_contact for all modules Updates the Lmod cache when an installation is made system-wide We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system. Upgrading and retiring software \u00b6 The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package. The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. Originally, we had chosen six months as our upgrade period but found this to be cumbersome as the number of supported systems and toolchains grew, our upgrade period is now every 12 months. We chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains. We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. A common workflow is to create a personal installation of a package that can be tweaked, then a group installation for others to try out. Once a software package has been successfully built and tested, it is added to a Golden repository to be used in production. The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage. While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod. next: EasyBuild at Compute Canada - (back to overview page)","title":"EasyBuild at JSC"},{"location":"2021-isc21/jsc/#easybuild-at-julich-supercomputing-centre","text":"( author: Alan O'Cais, J\u00fclich Supercomputing Centre)","title":"EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"2021-isc21/jsc/#general-info","text":"The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc ) at Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process.","title":"General info"},{"location":"2021-isc21/jsc/#staff-user-base","text":"About 200 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services. In cooperation with hardware and software vendors like IBM, Intel and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008.","title":"Staff &amp; user base"},{"location":"2021-isc21/jsc/#resources","text":"JSC currently manages 3 primary systems (in addition to a number of other development clusters): JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance. In the coming months, JUWELS will become the first supercomputer equipped with NVIDIA A100 GPU, when a new GPU module providing an additional 58 Petaflops will be installed. This module will make JUWELS the most powerful supercomputer in Europe. JURECA is the precursor system to JUWELS and currently has 2 modules: the JURECA DC Module with 3.54 (CPU, AMD EPYC) + 14.98 (GPU, NVIDIA A100) Petaflop per second peak performance, and the JURECA Booster Module with 5 (KNL) Petaflop per second peak performance. JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms.","title":"Resources"},{"location":"2021-isc21/jsc/#usage-of-easybuild-within-jsc","text":"As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated. JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations.","title":"Usage of EasyBuild within JSC"},{"location":"2021-isc21/jsc/#custom-toolchains","text":"As of June 2020, there are a total of 15 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers ( GCCcore , GCC , Intel and PGI ), MPI runtimes ( ParaStationMPI , OpenMPI , IntelMPI and MVAPICH2 ) and mathematical libraries ( MKL ). Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the --try-toolchain option and has recently introduced the --try-update-deps experimental option to more easily adopt upstream changes and adapt them to our environment.","title":"Custom toolchains"},{"location":"2021-isc21/jsc/#custom-module-naming-scheme","text":"By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes).","title":"Custom module naming scheme"},{"location":"2021-isc21/jsc/#custom-easyconfigs","text":"The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository). We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild.","title":"Custom easyconfigs"},{"location":"2021-isc21/jsc/#hiding-dependencies","text":"While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the hide-deps configuration setting). There are currently over 200 such hidden dependencies. While hidden dependencies are not visible in the module view by default, users can expose them by the use of the --show-hidden argument in Lmod : module --show-hidden avail","title":"Hiding dependencies"},{"location":"2021-isc21/jsc/#usage-of-hooks","text":"The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely. We are currently integrating a new hook that provides a lot of useful functionality: Facilitates userspace installations alongside system provided installations EasyBuild is configured to allow both shared installations for a group and private installations (group installations are automatically picked up by Lmod for other members of the group) Restricts users from installing non-supported compilers (in particular we don't want people to install their own GCCcore since this would likely lead to an avalanche of required dependencies) and MPI runtimes (since MPI installations are heavily customised) Restricts users to only resolve dependencies from our Golden repository (as well as from their own installed software) but allows them to search in the upstream repositories if they try to install something from the upstream repository, the hook advises them how to do this correctly for our systems Customises the final module files Customises the names of some modules (such as Intel over iccifort and IntelMPI over impi ) Injects an Lmod family in the modules of our compilers and MPI runtimes Adds Lmod properties for GPU enabled applications and user installed software so that they can be easily identified in the module view Adds a site_contact for all modules Updates the Lmod cache when an installation is made system-wide We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system.","title":"Usage of hooks"},{"location":"2021-isc21/jsc/#upgrading-and-retiring-software","text":"The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package. The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. Originally, we had chosen six months as our upgrade period but found this to be cumbersome as the number of supported systems and toolchains grew, our upgrade period is now every 12 months. We chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains. We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. A common workflow is to create a personal installation of a package that can be tweaked, then a group installation for others to try out. Once a software package has been successfully built and tested, it is added to a Golden repository to be used in production. The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage. While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod. next: EasyBuild at Compute Canada - (back to overview page)","title":"Upgrading and retiring software"},{"location":"2021-isc21/module_naming_schemes/","text":"Module naming schemes \u00b6 Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing h5py-3.1.0-foss-2020b.eb the generated module was named h5py/3.1.0-foss-2020b . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. We will also take a quick look at implementing our own custom module naming scheme. Flat vs hierarchical \u00b6 The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These correspond to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a (compiler-only) toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installed using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy. Pros & cons \u00b6 So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users; Length of module names \u00b6 When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean! Amount of available modules \u00b6 The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands... This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded. Loading compatible modules \u00b6 Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful... In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily. Visibility of existing modules \u00b6 One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file. Semantics of gateway modules \u00b6 An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy. Using a custom module naming scheme \u00b6 Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it. Implementation \u00b6 To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general ModuleNamingScheme class. For a flat module naming scheme, it is sufficient to implement the det_full_module_name method, which should return a string value (the full module name). You may also need to customize the is_short_modname_for method, which verifies whether a given (short) module name is for the software with a particular given name (or not). The argument provided to det_full_module_name can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters ( name , version , toolchain , and versionsuffix ), or an EasyConfig instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters. For simple module naming schemes, just have name , version , toolchain , and versionsuffix available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant REQUIRED_KEYS . A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme EasyBuildMNS . For a hierarchical module naming scheme, various additional methods have to be implemented. Some of these, like det_module_subdir and det_short_module_name , determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like det_modpath_extensions , determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the $MODULEPATH ). A typical example of a hierarchical module naming scheme is HierarchicalMNS that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional Core - Compiler - MPI module hierarchy we discussed above. Configuring EasyBuild \u00b6 To let EasyBuild use a custom module naming scheme, you need to: specify the path to the Python module file implementing it via the include-module-naming-schemes EasyBuild configuration option; indicate that you also want to use this custom module naming scheme via the module-naming-scheme EasyBuild configuration option. For example: export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES = $HOME /easybuild/example_mns.py export EASYBUILD_MODULE_NAMING_SCHEME = ExampleMNS Example custom module naming scheme \u00b6 Here is an example of a custom module naming scheme, where: the versionsuffix goes directly after the version ; all dashes are replaced by underscores; all module names are lowercase; Note that we also need to customise the is_short_modname_for method, to make sure it returns True when the EasyBuild framework checks whether scipy_bundle/2020.11_foss_2020b is a module name for SciPy-bundle . import os from easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme class ExampleMNS ( ModuleNamingScheme ): REQUIRED_KEYS = [ 'name' , 'version' , 'versionsuffix' , 'toolchain' ] def det_full_module_name ( self , ec ): \"\"\" Determine full module name: - all lowercase - replace all dashes with underscores \"\"\" parts = [ ec [ 'version' ]] # versionsuffix directly after version (but only if it's not empty) if ec [ 'versionsuffix' ]: parts . append ( ec [ 'versionsuffix' ]) # only add toolchain name/version for non-system toolchain tc = ec [ 'toolchain' ] if tc [ 'name' ] . lower () != 'system' : parts . extend ([ tc [ 'name' ], tc [ 'version' ]]) modname = ec [ 'name' ] + '/' + '_' . join ( parts ) modname = modname . replace ( '-' , '_' ) . replace ( '__' , '_' ) return modname . lower () def is_short_modname_for ( self , short_modname , name ): \"\"\"Determine whether short module name is a module for the software with specified name.\"\"\" return short_modname . startswith ( name . lower () . replace ( '-' , '_' ) + '/' ) We can see what the module names with this module naming scheme would like like via eb -D : $ eb SciPy-bundle-2020.11-foss-2020b-Python-2.7.18.eb -D ... * [ ] $CFGS/g/GCC/GCC-10.2.0.eb (module: gcc/10.2.0) ... * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-10.2.0.eb (module: python/2.7.18_gcccore_10.2.0) ... * [ ] $CFGS/o/OpenMPI/OpenMPI-4.0.5-GCC-10.2.0.eb (module: openmpi/4.0.5_gcc_10.2.0) ... * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2020.03-foss-2020a-Python-2.7.18.eb (module: scipy_bundle/2020.03_python_2.7.18_foss_2020a) Example module hierarchy: HDF5 \u00b6 Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations. Preparing the environment \u00b6 Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/10.2.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: unset PIP_PREFIX pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 Configuring EasyBuild \u00b6 First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example. Generating modules for HDF5 \u00b6 Let's now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.7-gompi-2020b.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.7-gompi-2020b.eb --robot --module-only ... == building and installing MPI/GCC/10.2.0/OpenMPI/4.0.5/HDF5/1.10.7... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 41 out of 41 This should take a couple of minutes in total, for generating 41 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation... Loading the HDF5 module \u00b6 After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let's see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 binutils/2.35 gompi/2020b zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let's see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.7\" module is available to load. GCC/10.2.0 OpenMPI/4.0.5 This tells us we need to load two gateway modules before we can load the module for HDF5. Let's start with loading the GCC compiler module: module load GCC/10.2.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 -------------- OpenMPI/4.0.5 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/10.2.0 ------------ Autoconf/2.69 UCX/1.9.0 libpciaccess/0.16 ... Szip/2.1.1 libfabric/1.11.0 zlib/1.2.11 (L,D) Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 (L) binutils/2.35 gompi/2020b zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/10.2.0 and Compiler/GCC/10.2.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 10.2.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.5 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/10.2.0 and OpenMPI/4.0.5 modules first. So, let us do exactly that (remember that GCC/10.2.0 is already loaded): module load OpenMPI/4.0.5 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.7 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------- HDF5/1.10.7 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 ------------ OpenMPI/4.0.5 (L) ... To use HDF5, we need to load this HDF5/1.10.7 module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.7 $ h5dump --version h5dump: Version 1.10.7 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/10.2.0 5 ) numactl/2.0.13 9 ) hwloc/2.2.0 13 ) PMIx/3.1.5 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) libevent/2.1.12 14 ) OpenMPI/4.0.5 3 ) binutils/2.35 7 ) libxml2/2.9.10 11 ) UCX/1.9.0 15 ) Szip/2.1.1 4 ) GCC/10.2.0 8 ) libpciaccess/0.16 12 ) libfabric/1.11.0 16 ) HDF5/1.10.7 Exercise \u00b6 Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.11-foss-2020b.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.11-foss-2020b.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.11-foss-2020b.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.11 Load the gateway modules: module load GCC/10.2.0 OpenMPI/4.0.5 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------ SciPy-bundle/2020.11 module load SciPy-bundle/2020.11 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.1.4 next: Adding support for additional software - (back to overview page)","title":"Module naming schemes"},{"location":"2021-isc21/module_naming_schemes/#module-naming-schemes","text":"Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing h5py-3.1.0-foss-2020b.eb the generated module was named h5py/3.1.0-foss-2020b . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. We will also take a quick look at implementing our own custom module naming scheme.","title":"Module naming schemes"},{"location":"2021-isc21/module_naming_schemes/#flat-vs-hierarchical","text":"The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These correspond to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a (compiler-only) toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installed using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.","title":"Flat vs hierarchical"},{"location":"2021-isc21/module_naming_schemes/#pros-cons","text":"So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users;","title":"Pros &amp; cons"},{"location":"2021-isc21/module_naming_schemes/#length-of-module-names","text":"When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean!","title":"Length of module names"},{"location":"2021-isc21/module_naming_schemes/#amount-of-available-modules","text":"The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands... This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded.","title":"Amount of available modules"},{"location":"2021-isc21/module_naming_schemes/#loading-compatible-modules","text":"Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful... In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily.","title":"Loading compatible modules"},{"location":"2021-isc21/module_naming_schemes/#visibility-of-existing-modules","text":"One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.","title":"Visibility of existing modules"},{"location":"2021-isc21/module_naming_schemes/#semantics-of-gateway-modules","text":"An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy.","title":"Semantics of gateway modules"},{"location":"2021-isc21/module_naming_schemes/#using-a-custom-module-naming-scheme","text":"Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it.","title":"Using a custom module naming scheme"},{"location":"2021-isc21/module_naming_schemes/#implementation","text":"To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general ModuleNamingScheme class. For a flat module naming scheme, it is sufficient to implement the det_full_module_name method, which should return a string value (the full module name). You may also need to customize the is_short_modname_for method, which verifies whether a given (short) module name is for the software with a particular given name (or not). The argument provided to det_full_module_name can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters ( name , version , toolchain , and versionsuffix ), or an EasyConfig instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters. For simple module naming schemes, just have name , version , toolchain , and versionsuffix available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant REQUIRED_KEYS . A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme EasyBuildMNS . For a hierarchical module naming scheme, various additional methods have to be implemented. Some of these, like det_module_subdir and det_short_module_name , determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like det_modpath_extensions , determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the $MODULEPATH ). A typical example of a hierarchical module naming scheme is HierarchicalMNS that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional Core - Compiler - MPI module hierarchy we discussed above.","title":"Implementation"},{"location":"2021-isc21/module_naming_schemes/#configuring-easybuild","text":"To let EasyBuild use a custom module naming scheme, you need to: specify the path to the Python module file implementing it via the include-module-naming-schemes EasyBuild configuration option; indicate that you also want to use this custom module naming scheme via the module-naming-scheme EasyBuild configuration option. For example: export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES = $HOME /easybuild/example_mns.py export EASYBUILD_MODULE_NAMING_SCHEME = ExampleMNS","title":"Configuring EasyBuild"},{"location":"2021-isc21/module_naming_schemes/#example-custom-module-naming-scheme","text":"Here is an example of a custom module naming scheme, where: the versionsuffix goes directly after the version ; all dashes are replaced by underscores; all module names are lowercase; Note that we also need to customise the is_short_modname_for method, to make sure it returns True when the EasyBuild framework checks whether scipy_bundle/2020.11_foss_2020b is a module name for SciPy-bundle . import os from easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme class ExampleMNS ( ModuleNamingScheme ): REQUIRED_KEYS = [ 'name' , 'version' , 'versionsuffix' , 'toolchain' ] def det_full_module_name ( self , ec ): \"\"\" Determine full module name: - all lowercase - replace all dashes with underscores \"\"\" parts = [ ec [ 'version' ]] # versionsuffix directly after version (but only if it's not empty) if ec [ 'versionsuffix' ]: parts . append ( ec [ 'versionsuffix' ]) # only add toolchain name/version for non-system toolchain tc = ec [ 'toolchain' ] if tc [ 'name' ] . lower () != 'system' : parts . extend ([ tc [ 'name' ], tc [ 'version' ]]) modname = ec [ 'name' ] + '/' + '_' . join ( parts ) modname = modname . replace ( '-' , '_' ) . replace ( '__' , '_' ) return modname . lower () def is_short_modname_for ( self , short_modname , name ): \"\"\"Determine whether short module name is a module for the software with specified name.\"\"\" return short_modname . startswith ( name . lower () . replace ( '-' , '_' ) + '/' ) We can see what the module names with this module naming scheme would like like via eb -D : $ eb SciPy-bundle-2020.11-foss-2020b-Python-2.7.18.eb -D ... * [ ] $CFGS/g/GCC/GCC-10.2.0.eb (module: gcc/10.2.0) ... * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-10.2.0.eb (module: python/2.7.18_gcccore_10.2.0) ... * [ ] $CFGS/o/OpenMPI/OpenMPI-4.0.5-GCC-10.2.0.eb (module: openmpi/4.0.5_gcc_10.2.0) ... * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2020.03-foss-2020a-Python-2.7.18.eb (module: scipy_bundle/2020.03_python_2.7.18_foss_2020a)","title":"Example custom module naming scheme"},{"location":"2021-isc21/module_naming_schemes/#example-module-hierarchy-hdf5","text":"Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.","title":"Example module hierarchy: HDF5"},{"location":"2021-isc21/module_naming_schemes/#preparing-the-environment","text":"Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/10.2.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: unset PIP_PREFIX pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3","title":"Preparing the environment"},{"location":"2021-isc21/module_naming_schemes/#configuring-easybuild_1","text":"First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example.","title":"Configuring EasyBuild"},{"location":"2021-isc21/module_naming_schemes/#generating-modules-for-hdf5","text":"Let's now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.7-gompi-2020b.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.7-gompi-2020b.eb --robot --module-only ... == building and installing MPI/GCC/10.2.0/OpenMPI/4.0.5/HDF5/1.10.7... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 41 out of 41 This should take a couple of minutes in total, for generating 41 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...","title":"Generating modules for HDF5"},{"location":"2021-isc21/module_naming_schemes/#loading-the-hdf5-module","text":"After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let's see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 binutils/2.35 gompi/2020b zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let's see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.7\" module is available to load. GCC/10.2.0 OpenMPI/4.0.5 This tells us we need to load two gateway modules before we can load the module for HDF5. Let's start with loading the GCC compiler module: module load GCC/10.2.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 -------------- OpenMPI/4.0.5 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/10.2.0 ------------ Autoconf/2.69 UCX/1.9.0 libpciaccess/0.16 ... Szip/2.1.1 libfabric/1.11.0 zlib/1.2.11 (L,D) Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 (L) binutils/2.35 gompi/2020b zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/10.2.0 and Compiler/GCC/10.2.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 10.2.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.5 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/10.2.0 and OpenMPI/4.0.5 modules first. So, let us do exactly that (remember that GCC/10.2.0 is already loaded): module load OpenMPI/4.0.5 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.7 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------- HDF5/1.10.7 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 ------------ OpenMPI/4.0.5 (L) ... To use HDF5, we need to load this HDF5/1.10.7 module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.7 $ h5dump --version h5dump: Version 1.10.7 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/10.2.0 5 ) numactl/2.0.13 9 ) hwloc/2.2.0 13 ) PMIx/3.1.5 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) libevent/2.1.12 14 ) OpenMPI/4.0.5 3 ) binutils/2.35 7 ) libxml2/2.9.10 11 ) UCX/1.9.0 15 ) Szip/2.1.1 4 ) GCC/10.2.0 8 ) libpciaccess/0.16 12 ) libfabric/1.11.0 16 ) HDF5/1.10.7","title":"Loading the HDF5 module"},{"location":"2021-isc21/module_naming_schemes/#exercise","text":"Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.11-foss-2020b.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.11-foss-2020b.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.11-foss-2020b.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.11 Load the gateway modules: module load GCC/10.2.0 OpenMPI/4.0.5 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------ SciPy-bundle/2020.11 module load SciPy-bundle/2020.11 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.1.4 next: Adding support for additional software - (back to overview page)","title":"Exercise"},{"location":"2021-isc21/practical_info/","text":"Practical info for the ISC'21 EasyBuild tutorial \u00b6 This page explains how you can prepare for the EasyBuild tutorial that takes place at ISC'21 (registration required!) . Prepared environment \u00b6 Tutorial attendees will be able to log in to a prepared environment where they can follow along with hands-on examples, or solve the tutorial exercises. You can create an account for the prepared environment by filling out the account form . The accounts will not be approved until the day before the event, so please remember to keep a record of your username and password . Once the account is approved, you will be able to access the system at https://isc21.learnhpc.eu/ , or via ssh : ssh isc21.learnhpc.eu Slack \u00b6 We strongly recommend joining the #tutorial-isc21 channel in the EasyBuild Slack . In this channel, you can: raise questions both during the live tutorial session, and afterwards; get help with following the hands-on examples or solving the exercises; The #tutorial-isc21 channel will remain available after the live tutorial session. You can self-request an invitation to join the EasyBuild Slack via https://easybuild.io/join-slack . next: Introduction - (back to overview page)","title":"Practical info"},{"location":"2021-isc21/practical_info/#practical-info-for-the-isc21-easybuild-tutorial","text":"This page explains how you can prepare for the EasyBuild tutorial that takes place at ISC'21 (registration required!) .","title":"Practical info for the ISC'21 EasyBuild tutorial"},{"location":"2021-isc21/practical_info/#prepared-environment","text":"Tutorial attendees will be able to log in to a prepared environment where they can follow along with hands-on examples, or solve the tutorial exercises. You can create an account for the prepared environment by filling out the account form . The accounts will not be approved until the day before the event, so please remember to keep a record of your username and password . Once the account is approved, you will be able to access the system at https://isc21.learnhpc.eu/ , or via ssh : ssh isc21.learnhpc.eu","title":"Prepared environment"},{"location":"2021-isc21/practical_info/#slack","text":"We strongly recommend joining the #tutorial-isc21 channel in the EasyBuild Slack . In this channel, you can: raise questions both during the live tutorial session, and afterwards; get help with following the hands-on examples or solving the exercises; The #tutorial-isc21 channel will remain available after the live tutorial session. You can self-request an invitation to join the EasyBuild Slack via https://easybuild.io/join-slack . next: Introduction - (back to overview page)","title":"Slack"},{"location":"2021-isc21/terminology/","text":"EasyBuild terminology \u00b6 Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms, so we'll briefly cover them one by one. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.toolchains , easybuild.tools , etc.) that collectively form the core of EasyBuild , and is developed in the easybuild-framework repository on GitHub . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this. Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure , and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software package. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , WRF , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file . A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the easybuild-easyblocks repository on GitHub . Easyconfig parameters \u00b6 An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild. Some easyconfig parameters are mandatory . The following parameters must be defined in every easyconfig file: name and version , which specify the name and version of the software to install; homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains section); Other easyconfig parameters are optional : they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock. Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used for the installation; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If no value is specified for an optional easyconfig parameter, the corresponding default value will be used. There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software. Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation. The filename of an easyconfig file usually ends with the .eb extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: name , version , toolchain and versionsuffix . The general format for the filename of an easyconfig file is: <name>-<version><toolchain><versionsuffix>.eb , where the toolchain part is omitted when a system toolchain is used, and the <versionsuffix> can be empty. The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive. In the easybuild-easyconfigs repository on GitHub , the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software. Easystack files \u00b6 Easystack files are a new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild. They are written in YAML syntax , and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels. The support for using easystack files is currently marked as experimental , which means it is subject to change in future EasyBuild releases, and may be prone to errors. Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Common examples are Python packages , R libraries , and Perl modules . As you can tell the common terminology here is a bit messy, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone , as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation); Dependencies \u00b6 A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software (examples: CMake , pkg-config ); a run-time dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package (example: Python ); a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed (example: OpenBLAS ); The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). System toolchain \u00b6 The system toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system , rather than using toolchain components that were installed using EasyBuild. It is used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation. Common toolchains \u00b6 The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , OpenBLAS , ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation . Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files which each define a set of easyconfig parameters . EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. An easystack file can be used to specify a collection of software to install with EasyBuild. next: Installation - (back to overview page)","title":"Terminology"},{"location":"2021-isc21/terminology/#easybuild-terminology","text":"Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms, so we'll briefly cover them one by one.","title":"EasyBuild terminology"},{"location":"2021-isc21/terminology/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.toolchains , easybuild.tools , etc.) that collectively form the core of EasyBuild , and is developed in the easybuild-framework repository on GitHub . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this.","title":"Framework"},{"location":"2021-isc21/terminology/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure , and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software package. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , WRF , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file . A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the easybuild-easyblocks repository on GitHub .","title":"Easyblocks"},{"location":"2021-isc21/terminology/#easyconfig-parameters","text":"An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild. Some easyconfig parameters are mandatory . The following parameters must be defined in every easyconfig file: name and version , which specify the name and version of the software to install; homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains section); Other easyconfig parameters are optional : they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock. Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used for the installation; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If no value is specified for an optional easyconfig parameter, the corresponding default value will be used. There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software.","title":"Easyconfig parameters"},{"location":"2021-isc21/terminology/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation. The filename of an easyconfig file usually ends with the .eb extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: name , version , toolchain and versionsuffix . The general format for the filename of an easyconfig file is: <name>-<version><toolchain><versionsuffix>.eb , where the toolchain part is omitted when a system toolchain is used, and the <versionsuffix> can be empty. The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive. In the easybuild-easyconfigs repository on GitHub , the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software.","title":"Easyconfig files"},{"location":"2021-isc21/terminology/#easystack-files","text":"Easystack files are a new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild. They are written in YAML syntax , and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels. The support for using easystack files is currently marked as experimental , which means it is subject to change in future EasyBuild releases, and may be prone to errors.","title":"Easystack files"},{"location":"2021-isc21/terminology/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Common examples are Python packages , R libraries , and Perl modules . As you can tell the common terminology here is a bit messy, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone , as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation);","title":"Extensions"},{"location":"2021-isc21/terminology/#dependencies","text":"A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software (examples: CMake , pkg-config ); a run-time dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package (example: Python ); a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed (example: OpenBLAS ); The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies.","title":"Dependencies"},{"location":"2021-isc21/terminology/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"2021-isc21/terminology/#system-toolchain","text":"The system toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system , rather than using toolchain components that were installed using EasyBuild. It is used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.","title":"System toolchain"},{"location":"2021-isc21/terminology/#common-toolchains","text":"The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , OpenBLAS , ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation .","title":"Common toolchains"},{"location":"2021-isc21/terminology/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"2021-isc21/terminology/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files which each define a set of easyconfig parameters . EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. An easystack file can be used to specify a collection of software to install with EasyBuild. next: Installation - (back to overview page)","title":"Bringing it all together"},{"location":"2021-isc21/troubleshooting/","text":"Troubleshooting \u00b6 When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild... In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention! EasyBuild error messages \u00b6 When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status of the shell command is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted. Example \u00b6 Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb example.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-44 ) Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a imaginary example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled. EasyBuild log files \u00b6 Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes (only) the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by both the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210616.055237.log Last log \u00b6 The eb command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor: vim $(eb --last-log) Navigating log files \u00b6 Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you will miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there. Inspecting the build directory \u00b6 When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out build directories for failed builds, you will need to eventually manually remove them from the buildpath directory. Exercise \u00b6 Let's work our way through a less smooth software installation, using the easyconfig file that is provided below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.5.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the text above in a file named subread.eb , so you can gradually fix the problem you'll encounter. Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise T.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ If downloading is problematic for some reason, the source tarball is also available in /easybuild/sources/s/Subread . Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate download URLs, without the filename of the source file itself. This way, EasyBuild will download the source file when running eb subread.eb . The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise T.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): No module found for toolchain: GCC/8.5.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 10.2.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/10.2.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } Exercise T.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -fcommon -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via the CFLAGS argument to the build command: # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the buildopts definition makes it clear that the -fcommon flag is required though, because GCC 10 became a bit stricter by using -fno-common by default. Note that we are using -fcommon as an escape mechanism here: it would be better to fix the source code and create a patch file instead. An easy way to fix this problem is to replace the -fast with -Ofast , as the compiler error suggests. In this case it is advised to change the CFLAGS argument that is added to be build command to replace the -fast with $CFLAGS , which is defined in the build environment by EasyBuild. buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"' Note that we need to be careful with quotes here: we use inner double quotes to ensure that $CFLAGS will be expanded to its value when the build command is run. Exercise T.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 10.2.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1 next: Module naming schemes - (back to overview page)","title":"Troubleshooting"},{"location":"2021-isc21/troubleshooting/#troubleshooting","text":"When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild... In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!","title":"Troubleshooting"},{"location":"2021-isc21/troubleshooting/#easybuild-error-messages","text":"When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status of the shell command is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted.","title":"EasyBuild error messages"},{"location":"2021-isc21/troubleshooting/#example","text":"Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb example.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-44 ) Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a imaginary example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.","title":"Example"},{"location":"2021-isc21/troubleshooting/#easybuild-log-files","text":"Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes (only) the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by both the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210616.055237.log","title":"EasyBuild log files"},{"location":"2021-isc21/troubleshooting/#last-log","text":"The eb command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor: vim $(eb --last-log)","title":"Last log"},{"location":"2021-isc21/troubleshooting/#navigating-log-files","text":"Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you will miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there.","title":"Navigating log files"},{"location":"2021-isc21/troubleshooting/#inspecting-the-build-directory","text":"When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out build directories for failed builds, you will need to eventually manually remove them from the buildpath directory.","title":"Inspecting the build directory"},{"location":"2021-isc21/troubleshooting/#exercise","text":"Let's work our way through a less smooth software installation, using the easyconfig file that is provided below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.5.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the text above in a file named subread.eb , so you can gradually fix the problem you'll encounter. Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise T.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ If downloading is problematic for some reason, the source tarball is also available in /easybuild/sources/s/Subread . Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate download URLs, without the filename of the source file itself. This way, EasyBuild will download the source file when running eb subread.eb . The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise T.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): No module found for toolchain: GCC/8.5.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 10.2.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/10.2.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } Exercise T.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -fcommon -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via the CFLAGS argument to the build command: # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the buildopts definition makes it clear that the -fcommon flag is required though, because GCC 10 became a bit stricter by using -fno-common by default. Note that we are using -fcommon as an escape mechanism here: it would be better to fix the source code and create a patch file instead. An easy way to fix this problem is to replace the -fast with -Ofast , as the compiler error suggests. In this case it is advised to change the CFLAGS argument that is added to be build command to replace the -fast with $CFLAGS , which is defined in the build environment by EasyBuild. buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"' Note that we need to be careful with quotes here: we use inner double quotes to ensure that $CFLAGS will be expanded to its value when the build command is run. Exercise T.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 10.2.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1 next: Module naming schemes - (back to overview page)","title":"Exercise"},{"location":"2021-lust/","text":"EasyBuild tutorial for LUST \u00b6 Overview page of the introductory tutorial on EasyBuild for the LUMI User Support team (LUST) . Part I: Introduction to EasyBuild (Tue March 9th 2021, 9am-12 CET) What is EasyBuild? Terminology Installation (hands-on) Configuration (hands-on) Basic usage (hands-on) Part II: Using EasyBuild (Tue March 23rd 2021, 9am-12 CET) Troubleshooting (hands-on) Creating easyconfig files (hands-on) Implementing easyblocks (hands-on) Part III: Advanced topics (Tue March 30th 2021, 9am-12 CEST) Using EasyBuild as a library (hands-on) Using hooks to customise EasyBuild (hands-on) Submitting installations as Slurm jobs (hands-on) Module naming schemes (incl. hierarchical) (hands-on) GitHub integration to facilitate contributing to EasyBuild (hands-on) Part IV: EasyBuild on Cray systems (Friday June 18th 2021, 09-12 CEST) Introduction to Cray Programming Environment (hands-on) Cray External Modules (hands-on) Cray Custom Toolchains (hands-on) EasyBuild at CSCS (hands-on)","title":"(overview)"},{"location":"2021-lust/#easybuild-tutorial-for-lust","text":"Overview page of the introductory tutorial on EasyBuild for the LUMI User Support team (LUST) . Part I: Introduction to EasyBuild (Tue March 9th 2021, 9am-12 CET) What is EasyBuild? Terminology Installation (hands-on) Configuration (hands-on) Basic usage (hands-on) Part II: Using EasyBuild (Tue March 23rd 2021, 9am-12 CET) Troubleshooting (hands-on) Creating easyconfig files (hands-on) Implementing easyblocks (hands-on) Part III: Advanced topics (Tue March 30th 2021, 9am-12 CEST) Using EasyBuild as a library (hands-on) Using hooks to customise EasyBuild (hands-on) Submitting installations as Slurm jobs (hands-on) Module naming schemes (incl. hierarchical) (hands-on) GitHub integration to facilitate contributing to EasyBuild (hands-on) Part IV: EasyBuild on Cray systems (Friday June 18th 2021, 09-12 CEST) Introduction to Cray Programming Environment (hands-on) Cray External Modules (hands-on) Cray Custom Toolchains (hands-on) EasyBuild at CSCS (hands-on)","title":"EasyBuild tutorial for LUST"},{"location":"2021-lust/basic_usage/","text":"Basic usage \u00b6 [back: Configuring EasyBuild] Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention! Overall workflow \u00b6 Installing software with EasyBuild is as easy as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , often combined with the --robot option to let EasyBuild also install missing dependencies. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be. Specifying easyconfigs \u00b6 Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with .eb , and (try to) use these as easyconfig files. Example command \u00b6 Suppose we have the current situation in our home directory: two (easyconfig) files named example1.eb and example2.eb ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1.eb example2.eb some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb example1.eb bzip2-1.0.6.eb $HOME /example2.eb some_deps EasyBuild will interpret each of these arguments as follows: example1.eb is the name of a file in the current directory, so it can be used directly; bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); $HOME/example2.eb specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , The list.txt file will be ignored since its name does not end with .eb . Easyconfig filenames \u00b6 Note that the eb command does not care how easyconfig files are named, at least to some extent: the .eb file extension does matter when easyconfig files are being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ), and which is omitted (including the preceding - ) when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default); Searching for easyconfigs \u00b6 You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package. This can be done by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the search-paths configuration setting, or you can change the robot search path via either the robot or robot-paths configuration options. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for OpenFOAM 8 with a foss toolchain: $ eb --search openfoam-8-foss * /home/example/.local/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb * /home/example/.local/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb The output is a bit more condensed when using eb -S : $ eb -S openfoam-8-foss CFGS1 = /home/example/.local/easybuild/easyconfigs/o/OpenFOAM * $CFGS1 /OpenFOAM-8-foss-2020a.eb * $CFGS1 /OpenFOAM-8-foss-2020b.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , or other special characters like ^ or $ to mark the start/end of the filename, but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install TensorFlow 2.4.1 with the 2020b version of a toolchain: $ eb -S '^tensorflow-2.4.1.*2020b' CFGS1 = /home/example/.local/easybuild/easyconfigs/t/TensorFlow * $CFGS1 /TensorFlow-2.4.1-foss-2020b.eb * $CFGS1 /TensorFlow-2.4.1-fosscuda-2020b.eb Search index \u00b6 When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information . Inspecting easyconfigs \u00b6 Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later... Checking dependencies \u00b6 Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ). Dry run \u00b6 To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the required dependencies for SAMtools-1.11-GCC-10.2.0.eb are already installed: $ eb SAMtools-1.11-GCC-10.2.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/.local/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-10.2.0.eb ( module: bzip2/1.0.8-GCCcore-10.2.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-10.2.0.eb ( module: XZ/5.2.5-GCCcore-10.2.0 ) * [ x ] $CFGS /c/cURL/cURL-7.72.0-GCCcore-10.2.0.eb ( module: cURL/7.72.0-GCCcore-10.2.0 ) * [ x ] $CFGS /g/GCC/GCC-10.2.0.eb ( module: GCC/10.2.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-10.2.0.eb ( module: ncurses/6.2-GCCcore-10.2.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb ( module: SAMtools/1.11-GCC-10.2.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.11-GCC-10.2.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an x in [ ] . Missing dependencies \u00b6 If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get version 3.1.0 of the h5py Python package installed using the 2020b version of the foss toolchain: $ eb h5py-3.1.0-foss-2020b.eb -M 2 out of 61 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) That should be pretty self-explanatory: out of the 63 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great! Inspecting install procedures \u00b6 Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.74.0-GCC-10.2.0.eb : $ eb Boost-1.74.0-GCC-10.2.0.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load GCC/10.2.0 Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-10.2.0 module load zlib/1.2.11-GCCcore-10.2.0 module load XZ/5.2.5-GCCcore-10.2.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.74.0/GCC-10.2.0/obj --without-libraries=python,mpi\" ( in /tmp/example/build/Boost/1.74.0/GCC-10.2.0/Boost-1.74.0 ) ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_system.so * lib/libboost_thread-mt-x64.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step, and in which directory; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless. Installing software \u00b6 You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.11: $ eb SAMtools-1.11-GCC-10.2.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb == building and installing SAMtools/1.11-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 17 sec ) == Results of the build can be found in the log file ( s ) /home/example/easybuild/software/SAMtools/1.11-GCC-10.2.0/easybuild/easybuild-SAMtools-1.11-20210309.105601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost... Enabling dependency resolution \u00b6 The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above ). If we try this with the BCFtools-1.11-GCC-10.2.0.eb , for which the required GSL and HTSlib dependencies are not available yet, it's less successful: $ eb BCFtools-1.11-GCC-10.2.0.eb -M 3 out of 23 required modules missing: * GSL/2.6-GCC-10.2.0 ( GSL-2.6-GCC-10.2.0.eb ) * HTSlib/1.11-GCC-10.2.0 ( HTSlib-1.11-GCC-10.2.0.eb ) * BCFtools/1.11-GCC-10.2.0 ( BCFtools-1.11-GCC-10.2.0.eb ) $ eb BCFtools-1.11-GCC-10.2.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/build/BCFtools/1.11/GCC-10.2.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 ( took 2 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-3v1dfvnk/easybuild-BCFtools-1.11-20210308.195024.FlxkH.log ERROR: Build of /home/example/.local/easybuild/easyconfigs/b/BCFtools/BCFtools-1.11-GCC-10.2.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 The required dependencies HTSlib/1.11-GCC-10.2.0 and GSL/2.6-GCC-10.2.0 are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb BCFtools-1.11-GCC-10.2.0.eb --robot ... == resolving dependencies ... ... == building and installing HTSlib/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 13 sec ) ... == building and installing GSL/2.6-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 1 min 10 sec ) ... == building and installing BCFtools/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 8 sec ) ... == Build succeeded for 3 out of 3 With dependency resolution enabled the HTSlib and GSL modules get installed first, before EasyBuild proceeds with installing BCFtools . Great! Trace output \u00b6 As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of BCFtools-1.11-GCC-10.2.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb BCFtools-1.11-GCC-10.2.0.eb --rebuild ... == configuring... >> running command: [ started at: 2021 -03-08 19 :54:53 ] [ working dir: /tmp/example/build/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-17m_he2x.log ] ./configure --prefix = /home/example/easybuild/software/BCFtools/1.11-GCC-10.2.0 --build = x86_64-pc-linux-gnu --host = x86_64-pc-linux-gnu --with-htslib = $EBROOTHTSLIB --enable-libgsl == building... >> running command: [ started at: 2021 -03-08 19 :54:54 ] [ working dir: /tmp/example/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/example/eb-9u_ac0nv/easybuild-run_cmd-bhkgjxi7.log ] make -j 8 >> command completed: exit 0 , ran in 00h00m03s That's a bit more comforting to stare at... During the configure step, the ./configure command is run with option to enable support for leveraging HTSlib and GSL . During the build step, the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 8). We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bcftools' found: OK >> file 'bin/plot-vcfstats' found: OK >> file 'bin/vcfutils.pl' found: OK >> (non-empty) directory 'libexec/bcftools' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary. Using installed software \u00b6 So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio devel numlib tools Directories like bio and numlib correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ---------------------- /home/example/easybuild/modules/all ----------------------- BCFtools/1.11-GCC-10.2.0 GSL/2.6-GCC-10.2.0 SAMtools/1.11-GCC-10.2.0 EasyBuild/4.3.3 HTSlib/1.11-GCC-10.2.0 bzip2/1.0.6 ---------------------------- /easybuild/modules/all ----------------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for BCFtools. In our current environment, the bcftools command is not available yet: $ module list No modules loaded $ bcftools -bash: bcftools: command not found Loading the module for BCFtools changes that: $ module load BCFtools/1.11-GCC-10.2.0 $ module list Currently Loaded Modules: 1 ) GCCcore/10.2.0 6 ) XZ/5.2.5-GCCcore-10.2.0 2 ) zlib/1.2.11-GCCcore-10.2.0 7 ) cURL/7.72.0-GCCcore-10.2.0 3 ) binutils/2.35-GCCcore-10.2.0 8 ) HTSlib/1.11-GCC-10.2.0 4 ) GCC/10.2.0 9 ) GSL/2.6-GCC-10.2.0 5 ) bzip2/1.0.8-GCCcore-10.2.0 10 ) BCFtools/1.11-GCC-10.2.0 $ bcftools --version bcftools 1 .11 Using htslib 1 .11 ... Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use. Resetting your environment \u00b6 To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \". Stacking software \u00b6 Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here). Exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.3.3. Exercise U.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. We will assume that you have a small software stack installed using the 2020b version of the foss toolchain. Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise U.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2020/5. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2020.5 == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb * $CFGS1 /GROMACS-2020.5_fix_threads_gpu_Gmxapitests.patch This actually shows one easyconfig file but also a patch file. We can also search specifically for GROMACS 2020.5 in the foss and fosscuda toolchains using $ eb -S gromacs-2020.5-foss == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb and now we find a single easyconfig file. Exercise U.2 - Checking dependencies Check which dependencies are missing to install QuantumESPRESSO version 6.6 with the 2020b version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: $ eb -S 'QuantumESPRESSO-6.6.*foss-2020b' == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... CFGS1 = /home/example/.local/easybuild/easyconfigs/q/QuantumESPRESSO * $CFGS1 /QuantumESPRESSO-6.6-foss-2020b.eb To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use --missing : $ eb QuantumESPRESSO-6.6-foss-2020b.eb --missing 3 out of 58 required modules missing: * libxc/4.3.4-GCC-10.2.0 ( libxc-4.3.4-GCC-10.2.0.eb ) * ELPA/2020.11.001-foss-2020b ( ELPA-2020.11.001-foss-2020b.eb ) * QuantumESPRESSO/6.6-foss-2020b ( QuantumESPRESSO-6.6-foss-2020b.eb ) (some nonessential output removed). Exercise U.3 - Performing a dry run Figure out which command EasyBuild would use to compile the software provided by the Bowtie2-2.4.2-GCC-9.3.0.eb easyconfig file, without actually installing Bowtie2 . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x Bowtie2-2.4.2-GCC-9.3.0.eb . The output for the build step shows the actual compilation command that would be performed ( make ... ): [ build_step method ] >> running command: [ started at: 2021 -03-08 20 :15:08 ] [ working dir: /local_scratch/hkenneth/eb-1wodfohg/__ROOT__/local_scratch/hkenneth/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ] [ output logged in /local_scratch/hkenneth/eb-1wodfohg/easybuild-run_cmd-haojzisn.log ] make -j 48 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" ( in /local_scratch/hkenneth/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ) If the output you get is less detailed, you may not have set export EASYBUILD_TRACE=1 . The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/bowtie2 * bin/bowtie2-align-l * bin/bowtie2-align-s * bin/bowtie2-build * bin/bowtie2-build-l * bin/bowtie2-build-s * bin/bowtie2-inspect * bin/bowtie2-inspect-l * bin/bowtie2-inspect-s Exercise U.4 - Installing software Install version 3.1.0 of the h5py Python package and all missing dependencies, using the foss/2020b toolchain, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py-3.1.0.*foss-2020b' CFGS1 = /home/example/.local/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-3.1.0-foss-2020b.eb Make sure the pre-install software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install this h5py easyconfig: $ eb h5py-3.1.0-foss-2020b.eb --missing 2 out of 63 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-3.1.0-foss-2020b.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-10.2.0-python... ... == building and installing h5py/3.1.0-foss-2020b... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/3.1.0/foss-2020b/h5py-3.1.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.6-GCCcore-10.2.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise U.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/3.1.0-foss-2020b module load h5py/3.1.0-foss-2020b The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course you can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask question in the #tutorial channel in the EasyBuild Slack , we're happy to help! [next: Part 2: Using EasyBuild]","title":"Basic usage"},{"location":"2021-lust/basic_usage/#basic-usage","text":"[back: Configuring EasyBuild] Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!","title":"Basic usage"},{"location":"2021-lust/basic_usage/#overall-workflow","text":"Installing software with EasyBuild is as easy as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , often combined with the --robot option to let EasyBuild also install missing dependencies. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be.","title":"Overall workflow"},{"location":"2021-lust/basic_usage/#specifying-easyconfigs","text":"Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with .eb , and (try to) use these as easyconfig files.","title":"Specifying easyconfigs"},{"location":"2021-lust/basic_usage/#example-command","text":"Suppose we have the current situation in our home directory: two (easyconfig) files named example1.eb and example2.eb ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1.eb example2.eb some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb example1.eb bzip2-1.0.6.eb $HOME /example2.eb some_deps EasyBuild will interpret each of these arguments as follows: example1.eb is the name of a file in the current directory, so it can be used directly; bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); $HOME/example2.eb specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , The list.txt file will be ignored since its name does not end with .eb .","title":"Example command"},{"location":"2021-lust/basic_usage/#easyconfig-filenames","text":"Note that the eb command does not care how easyconfig files are named, at least to some extent: the .eb file extension does matter when easyconfig files are being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ), and which is omitted (including the preceding - ) when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default);","title":"Easyconfig filenames"},{"location":"2021-lust/basic_usage/#searching-for-easyconfigs","text":"You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package. This can be done by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the search-paths configuration setting, or you can change the robot search path via either the robot or robot-paths configuration options. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for OpenFOAM 8 with a foss toolchain: $ eb --search openfoam-8-foss * /home/example/.local/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb * /home/example/.local/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb The output is a bit more condensed when using eb -S : $ eb -S openfoam-8-foss CFGS1 = /home/example/.local/easybuild/easyconfigs/o/OpenFOAM * $CFGS1 /OpenFOAM-8-foss-2020a.eb * $CFGS1 /OpenFOAM-8-foss-2020b.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , or other special characters like ^ or $ to mark the start/end of the filename, but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install TensorFlow 2.4.1 with the 2020b version of a toolchain: $ eb -S '^tensorflow-2.4.1.*2020b' CFGS1 = /home/example/.local/easybuild/easyconfigs/t/TensorFlow * $CFGS1 /TensorFlow-2.4.1-foss-2020b.eb * $CFGS1 /TensorFlow-2.4.1-fosscuda-2020b.eb","title":"Searching for easyconfigs"},{"location":"2021-lust/basic_usage/#search-index","text":"When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information .","title":"Search index"},{"location":"2021-lust/basic_usage/#inspecting-easyconfigs","text":"Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later...","title":"Inspecting easyconfigs"},{"location":"2021-lust/basic_usage/#checking-dependencies","text":"Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ).","title":"Checking dependencies"},{"location":"2021-lust/basic_usage/#dry-run","text":"To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the required dependencies for SAMtools-1.11-GCC-10.2.0.eb are already installed: $ eb SAMtools-1.11-GCC-10.2.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/.local/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-10.2.0.eb ( module: bzip2/1.0.8-GCCcore-10.2.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-10.2.0.eb ( module: XZ/5.2.5-GCCcore-10.2.0 ) * [ x ] $CFGS /c/cURL/cURL-7.72.0-GCCcore-10.2.0.eb ( module: cURL/7.72.0-GCCcore-10.2.0 ) * [ x ] $CFGS /g/GCC/GCC-10.2.0.eb ( module: GCC/10.2.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-10.2.0.eb ( module: ncurses/6.2-GCCcore-10.2.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb ( module: SAMtools/1.11-GCC-10.2.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.11-GCC-10.2.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an x in [ ] .","title":"Dry run"},{"location":"2021-lust/basic_usage/#missing-dependencies","text":"If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get version 3.1.0 of the h5py Python package installed using the 2020b version of the foss toolchain: $ eb h5py-3.1.0-foss-2020b.eb -M 2 out of 61 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) That should be pretty self-explanatory: out of the 63 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great!","title":"Missing dependencies"},{"location":"2021-lust/basic_usage/#inspecting-install-procedures","text":"Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.74.0-GCC-10.2.0.eb : $ eb Boost-1.74.0-GCC-10.2.0.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load GCC/10.2.0 Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-10.2.0 module load zlib/1.2.11-GCCcore-10.2.0 module load XZ/5.2.5-GCCcore-10.2.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.74.0/GCC-10.2.0/obj --without-libraries=python,mpi\" ( in /tmp/example/build/Boost/1.74.0/GCC-10.2.0/Boost-1.74.0 ) ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_system.so * lib/libboost_thread-mt-x64.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step, and in which directory; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.","title":"Inspecting install procedures"},{"location":"2021-lust/basic_usage/#installing-software","text":"You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.11: $ eb SAMtools-1.11-GCC-10.2.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb == building and installing SAMtools/1.11-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 17 sec ) == Results of the build can be found in the log file ( s ) /home/example/easybuild/software/SAMtools/1.11-GCC-10.2.0/easybuild/easybuild-SAMtools-1.11-20210309.105601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost...","title":"Installing software"},{"location":"2021-lust/basic_usage/#enabling-dependency-resolution","text":"The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above ). If we try this with the BCFtools-1.11-GCC-10.2.0.eb , for which the required GSL and HTSlib dependencies are not available yet, it's less successful: $ eb BCFtools-1.11-GCC-10.2.0.eb -M 3 out of 23 required modules missing: * GSL/2.6-GCC-10.2.0 ( GSL-2.6-GCC-10.2.0.eb ) * HTSlib/1.11-GCC-10.2.0 ( HTSlib-1.11-GCC-10.2.0.eb ) * BCFtools/1.11-GCC-10.2.0 ( BCFtools-1.11-GCC-10.2.0.eb ) $ eb BCFtools-1.11-GCC-10.2.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/build/BCFtools/1.11/GCC-10.2.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 ( took 2 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-3v1dfvnk/easybuild-BCFtools-1.11-20210308.195024.FlxkH.log ERROR: Build of /home/example/.local/easybuild/easyconfigs/b/BCFtools/BCFtools-1.11-GCC-10.2.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 The required dependencies HTSlib/1.11-GCC-10.2.0 and GSL/2.6-GCC-10.2.0 are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb BCFtools-1.11-GCC-10.2.0.eb --robot ... == resolving dependencies ... ... == building and installing HTSlib/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 13 sec ) ... == building and installing GSL/2.6-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 1 min 10 sec ) ... == building and installing BCFtools/1.11-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 8 sec ) ... == Build succeeded for 3 out of 3 With dependency resolution enabled the HTSlib and GSL modules get installed first, before EasyBuild proceeds with installing BCFtools . Great!","title":"Enabling dependency resolution"},{"location":"2021-lust/basic_usage/#trace-output","text":"As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of BCFtools-1.11-GCC-10.2.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb BCFtools-1.11-GCC-10.2.0.eb --rebuild ... == configuring... >> running command: [ started at: 2021 -03-08 19 :54:53 ] [ working dir: /tmp/example/build/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-17m_he2x.log ] ./configure --prefix = /home/example/easybuild/software/BCFtools/1.11-GCC-10.2.0 --build = x86_64-pc-linux-gnu --host = x86_64-pc-linux-gnu --with-htslib = $EBROOTHTSLIB --enable-libgsl == building... >> running command: [ started at: 2021 -03-08 19 :54:54 ] [ working dir: /tmp/example/BCFtools/1.11/GCC-10.2.0/bcftools-1.11 ] [ output logged in /tmp/example/eb-9u_ac0nv/easybuild-run_cmd-bhkgjxi7.log ] make -j 8 >> command completed: exit 0 , ran in 00h00m03s That's a bit more comforting to stare at... During the configure step, the ./configure command is run with option to enable support for leveraging HTSlib and GSL . During the build step, the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 8). We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bcftools' found: OK >> file 'bin/plot-vcfstats' found: OK >> file 'bin/vcfutils.pl' found: OK >> (non-empty) directory 'libexec/bcftools' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.","title":"Trace output"},{"location":"2021-lust/basic_usage/#using-installed-software","text":"So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio devel numlib tools Directories like bio and numlib correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ---------------------- /home/example/easybuild/modules/all ----------------------- BCFtools/1.11-GCC-10.2.0 GSL/2.6-GCC-10.2.0 SAMtools/1.11-GCC-10.2.0 EasyBuild/4.3.3 HTSlib/1.11-GCC-10.2.0 bzip2/1.0.6 ---------------------------- /easybuild/modules/all ----------------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for BCFtools. In our current environment, the bcftools command is not available yet: $ module list No modules loaded $ bcftools -bash: bcftools: command not found Loading the module for BCFtools changes that: $ module load BCFtools/1.11-GCC-10.2.0 $ module list Currently Loaded Modules: 1 ) GCCcore/10.2.0 6 ) XZ/5.2.5-GCCcore-10.2.0 2 ) zlib/1.2.11-GCCcore-10.2.0 7 ) cURL/7.72.0-GCCcore-10.2.0 3 ) binutils/2.35-GCCcore-10.2.0 8 ) HTSlib/1.11-GCC-10.2.0 4 ) GCC/10.2.0 9 ) GSL/2.6-GCC-10.2.0 5 ) bzip2/1.0.8-GCCcore-10.2.0 10 ) BCFtools/1.11-GCC-10.2.0 $ bcftools --version bcftools 1 .11 Using htslib 1 .11 ... Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use.","title":"Using installed software"},{"location":"2021-lust/basic_usage/#resetting-your-environment","text":"To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \".","title":"Resetting your environment"},{"location":"2021-lust/basic_usage/#stacking-software","text":"Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).","title":"Stacking software"},{"location":"2021-lust/basic_usage/#exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.3.3. Exercise U.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. We will assume that you have a small software stack installed using the 2020b version of the foss toolchain. Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise U.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2020/5. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2020.5 == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb * $CFGS1 /GROMACS-2020.5_fix_threads_gpu_Gmxapitests.patch This actually shows one easyconfig file but also a patch file. We can also search specifically for GROMACS 2020.5 in the foss and fosscuda toolchains using $ eb -S gromacs-2020.5-foss == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb and now we find a single easyconfig file. Exercise U.2 - Checking dependencies Check which dependencies are missing to install QuantumESPRESSO version 6.6 with the 2020b version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: $ eb -S 'QuantumESPRESSO-6.6.*foss-2020b' == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... CFGS1 = /home/example/.local/easybuild/easyconfigs/q/QuantumESPRESSO * $CFGS1 /QuantumESPRESSO-6.6-foss-2020b.eb To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use --missing : $ eb QuantumESPRESSO-6.6-foss-2020b.eb --missing 3 out of 58 required modules missing: * libxc/4.3.4-GCC-10.2.0 ( libxc-4.3.4-GCC-10.2.0.eb ) * ELPA/2020.11.001-foss-2020b ( ELPA-2020.11.001-foss-2020b.eb ) * QuantumESPRESSO/6.6-foss-2020b ( QuantumESPRESSO-6.6-foss-2020b.eb ) (some nonessential output removed). Exercise U.3 - Performing a dry run Figure out which command EasyBuild would use to compile the software provided by the Bowtie2-2.4.2-GCC-9.3.0.eb easyconfig file, without actually installing Bowtie2 . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x Bowtie2-2.4.2-GCC-9.3.0.eb . The output for the build step shows the actual compilation command that would be performed ( make ... ): [ build_step method ] >> running command: [ started at: 2021 -03-08 20 :15:08 ] [ working dir: /local_scratch/hkenneth/eb-1wodfohg/__ROOT__/local_scratch/hkenneth/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ] [ output logged in /local_scratch/hkenneth/eb-1wodfohg/easybuild-run_cmd-haojzisn.log ] make -j 48 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" ( in /local_scratch/hkenneth/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2 ) If the output you get is less detailed, you may not have set export EASYBUILD_TRACE=1 . The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/bowtie2 * bin/bowtie2-align-l * bin/bowtie2-align-s * bin/bowtie2-build * bin/bowtie2-build-l * bin/bowtie2-build-s * bin/bowtie2-inspect * bin/bowtie2-inspect-l * bin/bowtie2-inspect-s Exercise U.4 - Installing software Install version 3.1.0 of the h5py Python package and all missing dependencies, using the foss/2020b toolchain, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py-3.1.0.*foss-2020b' CFGS1 = /home/example/.local/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-3.1.0-foss-2020b.eb Make sure the pre-install software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install this h5py easyconfig: $ eb h5py-3.1.0-foss-2020b.eb --missing 2 out of 63 required modules missing: * pkgconfig/1.5.1-GCCcore-10.2.0-python ( pkgconfig-1.5.1-GCCcore-10.2.0-python.eb ) * h5py/3.1.0-foss-2020b ( h5py-3.1.0-foss-2020b.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-3.1.0-foss-2020b.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-10.2.0-python... ... == building and installing h5py/3.1.0-foss-2020b... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/3.1.0/foss-2020b/h5py-3.1.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.6-GCCcore-10.2.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise U.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/3.1.0-foss-2020b module load h5py/3.1.0-foss-2020b The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course you can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask question in the #tutorial channel in the EasyBuild Slack , we're happy to help! [next: Part 2: Using EasyBuild]","title":"Exercises"},{"location":"2021-lust/configuration/","text":"Configuring EasyBuild \u00b6 [back: Installation] After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it. Available configuration settings \u00b6 One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 240 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones. We will refer to EasyBuild configuration settings using the names as they appears in the output of eb --help , and omit the leading dashes ( -- ) for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details. Overall prefix \u00b6 (default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which is particularly useful to test and evaluate software installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default software and modules/all names for the subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is strongly recommend to use the path to a directory on a local filesystem for the value of the buildpath configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like /dev/shm/$USER ) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like noexec ). Use a directory on a local filesystem for buildpath for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set buildpath to /tmp/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in sourcepath only read permissions are required. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation ). For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod (next to Tcl syntax). To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool; see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in Lua syntax. We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command, as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between these two configuration settings is that defining robot also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining robot-paths does not have the side effect of enabling dependency resolution. In addition, you can use the --robot command line option without specifying any paths to it, to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered . There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes . The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Just like with names of easyconfig files , the <-toolchain> part is omitted when the system toolchain is used, and the <versionsuffix> value is empty by default. Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ) is not defined and if the --magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead. Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files (usually *.cfg ) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file ( *.eb ) on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ). Although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Through the --show-config command line option you can easily inspect the currently active EasyBuild configuration. The output of --show-config includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produced by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which results in the value shown for the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ), and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Example Now let us do some basic configuring and inspect the resulting output of --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg In addition, define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with (C) ), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ). Exercises \u00b6 Exercise C.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: The location of the build directories: use /tmp/$USER for this; The locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources . Leave other configuration settings set to their default value. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this: buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise C.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial. [next: Basic usage]","title":"Configuration"},{"location":"2021-lust/configuration/#configuring-easybuild","text":"[back: Installation] After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it.","title":"Configuring EasyBuild"},{"location":"2021-lust/configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 240 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones. We will refer to EasyBuild configuration settings using the names as they appears in the output of eb --help , and omit the leading dashes ( -- ) for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.","title":"Available configuration settings"},{"location":"2021-lust/configuration/#overall-prefix","text":"(default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"2021-lust/configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which is particularly useful to test and evaluate software installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default software and modules/all names for the subdirectories are used.","title":"Install path"},{"location":"2021-lust/configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is strongly recommend to use the path to a directory on a local filesystem for the value of the buildpath configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like /dev/shm/$USER ) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like noexec ). Use a directory on a local filesystem for buildpath for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set buildpath to /tmp/$USER , for example.","title":"Build path"},{"location":"2021-lust/configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in sourcepath only read permissions are required. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere.","title":"Source path"},{"location":"2021-lust/configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation ). For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"2021-lust/configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod (next to Tcl syntax). To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool; see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in Lua syntax. We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"2021-lust/configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command, as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between these two configuration settings is that defining robot also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining robot-paths does not have the side effect of enabling dependency resolution. In addition, you can use the --robot command line option without specifying any paths to it, to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered . There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"2021-lust/configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes . The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Just like with names of easyconfig files , the <-toolchain> part is omitted when the system toolchain is used, and the <versionsuffix> value is empty by default.","title":"Module naming scheme"},{"location":"2021-lust/configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception!","title":"Configuration levels"},{"location":"2021-lust/configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ) is not defined and if the --magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead.","title":"Configuration level hierarchy"},{"location":"2021-lust/configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"2021-lust/configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files (usually *.cfg ) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file ( *.eb ) on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.","title":"EasyBuild configuration files vs easyconfig files"},{"location":"2021-lust/configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"2021-lust/configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ). Although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"2021-lust/configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Through the --show-config command line option you can easily inspect the currently active EasyBuild configuration. The output of --show-config includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produced by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which results in the value shown for the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ), and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Example Now let us do some basic configuring and inspect the resulting output of --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg In addition, define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with (C) ), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ).","title":"Inspecting the current configuration (--show-config)"},{"location":"2021-lust/configuration/#exercises","text":"Exercise C.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: The location of the build directories: use /tmp/$USER for this; The locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources . Leave other configuration settings set to their default value. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this: buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise C.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial. [next: Basic usage]","title":"Exercises"},{"location":"2021-lust/creating_easyconfig_files/","text":"Creating easyconfig files \u00b6 We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves! Easyconfigs vs easyblocks \u00b6 Before we dive into writing easyconfig files , let us take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild which specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in a general sense, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; toolchain-specific aspects of the build and installation procedure (e.g., configure options); interactive commands that need to be run; custom (configure) options for dependencies; having to create or adjust specific (configuration) files; 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation . Writing easyconfig files \u00b6 Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them. Mandatory parameters \u00b6 A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 10.2.0 which we used before, or the full toolchain foss 2020b. The name and version of the toolchain can be specified using a small Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } Commonly used parameters \u00b6 You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation . Sources, patches, and checksums \u00b6 In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported . Easyblock \u00b6 The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together in a single installation directory; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblocks is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock \" or just \" eb -a -e \", which results in an additional \" EASYBLOCK-SPECIFIC \" section to be added. See the (partial) output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ] Dependencies \u00b6 You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.18.4' )] dependencies = [ ( 'Python' , '3.8.2' ), ( 'HDF5' , '1.10.6' ), ( 'SciPy-bundle' , '2020.03' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies. Version suffix \u00b6 In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '2.7.18' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation. Customizing configure, build, test, and install commands \u00b6 When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.10.6' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: Adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support (where the ' ... ' represents the path to installation directory where the software should be installed). Specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). Passing the location where the software should be installed via the PREFIX argument to the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable that we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an $EBROOT* environment variable like this in every environment module file it generates (see the output of \" module show HDF5 \"). Sanity check \u00b6 One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ] Module class \u00b6 Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ). Generating tweaked easyconfigs \u00b6 Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2020b.eb --try-toolchain intel,2020b It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example. Copying easyconfigs \u00b6 One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.11-GCC-10.2.0.eb SAMtools.eb ... SAMtools-1.10-GCC-10.2.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files at once, as long as the target location is an existing directory. Example \u00b6 By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.1 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1 . Preparation \u00b6 Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all Mandatory parameters \u00b6 Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file: name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" If we try using this (very) minimal easyconfig file, EasyBuild will inform us that we failed to specify one of the mandatory easyconfig parameters: toolchain : $ eb example.eb == Temporary log file in case of crash /tmp/eb-90j723rl/easybuild-q21plqvx.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... ERROR: Failed to process easyconfig /home/example/example.eb: mandatory parameters not provided in pyheader: toolchain We will use GCC/10.2.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment, so we also define the toolchain easyconfig parameter: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a sensible value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning. Easyblock \u00b6 Let us see what happens if we take our current easyconfig file for a spin: $ eb example.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/example.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for installing the software with the name ' eb-tutorial '. Does that mean we have to implement an easyblock? In this simple case it doesn't, since we can leverage one of the available generic easyblocks . But, which one? Build instructions are usually included in a README file, or in the documentation. In this case, there's indeed a minimal README file available, which tells us that we should use the cmake command to configure the installation, followed by make and make install . We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one). CMake build dependency \u00b6 Does using the CMakeMake generic easyblock help at all? $ eb example.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/example.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.18.4-GCCcore-10.2.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 10.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.18.4' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D (equivalent with eb --dry-run ): $ eb example.eb -D ... * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0) * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.18.4-GCCcore-10.2.0.eb (module: CMake/3.18.4-GCCcore-10.2.0) * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-10.2.0) Sources \u00b6 If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-10.2.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify one or more source files that should be used, via the sources easyconfig parameter which specifies a list of names of source files: sources = [ 'eb-tutorial-1.0.1.tar.gz' ] We can avoid hardcoding the version number here by using a template value : sources = [ 'eb-tutorial- %(version)s .tar.gz' ] And since this is a standard way of naming software files, there's even a constant available that we can use: sources = [ SOURCE_TAR_GZ ] That way, we only have the software version specified once in the easyconfig file, via the version easyconfig parameter. That will come in useful later (see Exercise 7.2 )... If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere: Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either... To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via source_urls : source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] Required configure option \u00b6 With sources and source_urls defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1 ). Sanity check \u00b6 Hopefully that brings us closer to getting the installation to work... $ eb example.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 (took 2 sec) It got all the way to the sanity check step, that's great! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we need to customize the standard sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via --trace we can get some more information too: $ eb example.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial! Complete easyconfig \u00b6 Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'd6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9' ] builddependencies = [( 'CMake' , '3.18.4' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' One additional easyconfig parameter we defined here is checksums , which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation. You can let EasyBuild determine and inject these SHA256 checksums automatically via eb --inject-checksums : $ eb example.eb --inject-checksums ... == injecting sha256 checksums for sources & patches in example.eb... == * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9 Exercises \u00b6 Exercise E.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the example.eb easyconfig, you will need to use eb --rebuild or eb --force . Exercise E.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.1. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb example.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-10.2.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.1 doesn't print \" I have a message for you: \") Exercise E.3 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2020b' } dependencies = [ ( 'Python' , '3.8.6' ), ( 'SciPy-bundle' , '2020.11' ), ( 'eb-tutorial' , '1.0.1' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. Even when the default installation mechanism used by PythonPackage (which consists of running python setup.py install ) works fine, it is recommended to instruct EasyBuild to use pip install instead. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by Python package is already pretty decent (it will check for a non-empty lib/python3.8/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.8 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file.","title":"Creating easyconfig files"},{"location":"2021-lust/creating_easyconfig_files/#creating-easyconfig-files","text":"We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!","title":"Creating easyconfig files"},{"location":"2021-lust/creating_easyconfig_files/#easyconfigs-vs-easyblocks","text":"Before we dive into writing easyconfig files , let us take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild which specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in a general sense, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; toolchain-specific aspects of the build and installation procedure (e.g., configure options); interactive commands that need to be run; custom (configure) options for dependencies; having to create or adjust specific (configuration) files; 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation .","title":"Easyconfigs vs easyblocks"},{"location":"2021-lust/creating_easyconfig_files/#writing-easyconfig-files","text":"Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.","title":"Writing easyconfig files"},{"location":"2021-lust/creating_easyconfig_files/#mandatory-parameters","text":"A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 10.2.0 which we used before, or the full toolchain foss 2020b. The name and version of the toolchain can be specified using a small Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' }","title":"Mandatory parameters"},{"location":"2021-lust/creating_easyconfig_files/#commonly-used-parameters","text":"You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation .","title":"Commonly used parameters"},{"location":"2021-lust/creating_easyconfig_files/#sources-patches-and-checksums","text":"In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported .","title":"Sources, patches, and checksums"},{"location":"2021-lust/creating_easyconfig_files/#easyblock","text":"The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together in a single installation directory; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblocks is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock \" or just \" eb -a -e \", which results in an additional \" EASYBLOCK-SPECIFIC \" section to be added. See the (partial) output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ]","title":"Easyblock"},{"location":"2021-lust/creating_easyconfig_files/#dependencies","text":"You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.18.4' )] dependencies = [ ( 'Python' , '3.8.2' ), ( 'HDF5' , '1.10.6' ), ( 'SciPy-bundle' , '2020.03' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies.","title":"Dependencies"},{"location":"2021-lust/creating_easyconfig_files/#version-suffix","text":"In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '2.7.18' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation.","title":"Version suffix"},{"location":"2021-lust/creating_easyconfig_files/#customizing-configure-build-test-and-install-commands","text":"When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.10.6' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: Adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support (where the ' ... ' represents the path to installation directory where the software should be installed). Specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). Passing the location where the software should be installed via the PREFIX argument to the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable that we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an $EBROOT* environment variable like this in every environment module file it generates (see the output of \" module show HDF5 \").","title":"Customizing configure, build, test, and install commands"},{"location":"2021-lust/creating_easyconfig_files/#sanity-check","text":"One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ]","title":"Sanity check"},{"location":"2021-lust/creating_easyconfig_files/#module-class","text":"Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ).","title":"Module class"},{"location":"2021-lust/creating_easyconfig_files/#generating-tweaked-easyconfigs","text":"Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2020b.eb --try-toolchain intel,2020b It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.","title":"Generating tweaked easyconfigs"},{"location":"2021-lust/creating_easyconfig_files/#copying-easyconfigs","text":"One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.11-GCC-10.2.0.eb SAMtools.eb ... SAMtools-1.10-GCC-10.2.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files at once, as long as the target location is an existing directory.","title":"Copying easyconfigs"},{"location":"2021-lust/creating_easyconfig_files/#example","text":"By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.1 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1 .","title":"Example"},{"location":"2021-lust/creating_easyconfig_files/#preparation","text":"Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all","title":"Preparation"},{"location":"2021-lust/creating_easyconfig_files/#mandatory-parameters_1","text":"Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file: name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" If we try using this (very) minimal easyconfig file, EasyBuild will inform us that we failed to specify one of the mandatory easyconfig parameters: toolchain : $ eb example.eb == Temporary log file in case of crash /tmp/eb-90j723rl/easybuild-q21plqvx.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... ERROR: Failed to process easyconfig /home/example/example.eb: mandatory parameters not provided in pyheader: toolchain We will use GCC/10.2.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment, so we also define the toolchain easyconfig parameter: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a sensible value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning.","title":"Mandatory parameters"},{"location":"2021-lust/creating_easyconfig_files/#easyblock_1","text":"Let us see what happens if we take our current easyconfig file for a spin: $ eb example.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/example.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for installing the software with the name ' eb-tutorial '. Does that mean we have to implement an easyblock? In this simple case it doesn't, since we can leverage one of the available generic easyblocks . But, which one? Build instructions are usually included in a README file, or in the documentation. In this case, there's indeed a minimal README file available, which tells us that we should use the cmake command to configure the installation, followed by make and make install . We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).","title":"Easyblock"},{"location":"2021-lust/creating_easyconfig_files/#cmake-build-dependency","text":"Does using the CMakeMake generic easyblock help at all? $ eb example.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/example.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.18.4-GCCcore-10.2.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 10.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.18.4' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D (equivalent with eb --dry-run ): $ eb example.eb -D ... * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0) * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.18.4-GCCcore-10.2.0.eb (module: CMake/3.18.4-GCCcore-10.2.0) * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-10.2.0)","title":"CMake build dependency"},{"location":"2021-lust/creating_easyconfig_files/#sources","text":"If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-10.2.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify one or more source files that should be used, via the sources easyconfig parameter which specifies a list of names of source files: sources = [ 'eb-tutorial-1.0.1.tar.gz' ] We can avoid hardcoding the version number here by using a template value : sources = [ 'eb-tutorial- %(version)s .tar.gz' ] And since this is a standard way of naming software files, there's even a constant available that we can use: sources = [ SOURCE_TAR_GZ ] That way, we only have the software version specified once in the easyconfig file, via the version easyconfig parameter. That will come in useful later (see Exercise 7.2 )... If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere: Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either... To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via source_urls : source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ]","title":"Sources"},{"location":"2021-lust/creating_easyconfig_files/#required-configure-option","text":"With sources and source_urls defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1 ).","title":"Required configure option"},{"location":"2021-lust/creating_easyconfig_files/#sanity-check_1","text":"Hopefully that brings us closer to getting the installation to work... $ eb example.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 (took 2 sec) It got all the way to the sanity check step, that's great! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we need to customize the standard sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via --trace we can get some more information too: $ eb example.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial!","title":"Sanity check"},{"location":"2021-lust/creating_easyconfig_files/#complete-easyconfig","text":"Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'd6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9' ] builddependencies = [( 'CMake' , '3.18.4' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' One additional easyconfig parameter we defined here is checksums , which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation. You can let EasyBuild determine and inject these SHA256 checksums automatically via eb --inject-checksums : $ eb example.eb --inject-checksums ... == injecting sha256 checksums for sources & patches in example.eb... == * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9","title":"Complete easyconfig"},{"location":"2021-lust/creating_easyconfig_files/#exercises","text":"Exercise E.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the example.eb easyconfig, you will need to use eb --rebuild or eb --force . Exercise E.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.1. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb example.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-10.2.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.1 doesn't print \" I have a message for you: \") Exercise E.3 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2020b' } dependencies = [ ( 'Python' , '3.8.6' ), ( 'SciPy-bundle' , '2020.11' ), ( 'eb-tutorial' , '1.0.1' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. Even when the default installation mechanism used by PythonPackage (which consists of running python setup.py install ) works fine, it is recommended to instruct EasyBuild to use pip install instead. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by Python package is already pretty decent (it will check for a non-empty lib/python3.8/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.8 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file.","title":"Exercises"},{"location":"2021-lust/easybuild_library/","text":"Using EasyBuild as a library \u00b6 You can use EasyBuild as a Python library and implement a script to automate a particular task. All the functionality provided by the EasyBuild framework can be leveraged, so you only have to glue things together and add the missing pieces. Setting up the EasyBuild configuration \u00b6 Before you call any of the functions provided by the EasyBuild framework, you should initialize EasyBuild by setting up the configuration . Some of the EasyBuild framework functions assume that EasyBuild has been initialized properly, and calling them without doing so will result in errors. To set up the EasyBuild configuration, you should call the set_up_configuration function that is provided by the easybuild.tools.options module. This function takes a couple of optional arguments that are useful in the context of a Python script that uses EasyBuild as a library: Via args you can provide a list of command line arguments that should be passed to the option parser. By default, the standard command line arguments are picked up via sys.args , which may not be what you want. By passing silent=True you can specify that the set_up_configuration function should not print anything when it is called. By default, it will print the location to the temporary EasyBuild log file. Cleaning up the temporary directory \u00b6 When EasyBuild is configured, a temporary directory specific to that EasyBuild session will be created automatically. You should clean up that directory, especially if you will be creating temporary files, or if the script will be run often. Note that cleaning up the temporary directory implies removes the temporary log files, so you probably only want to do this if no errors occurred. Minimal example script \u00b6 Here is a minimal (and pretty useless) example Python script, which sets up the EasyBuild configuration and cleans up the temporary directory: #!/usr/bin/env python3 from easybuild.tools.filetools import remove_dir from easybuild.tools.options import set_up_configuration opts , _ = set_up_configuration ( args = [], silent = True ) remove_dir ( opts . tmpdir ) Example use cases \u00b6 Once the EasyBuild configuration has been set up, the functions provided by the EasyBuild framework can be called from a Python script (or directly from the Python interpreter). A full overview of all functions is available via the EasyBuild API documentation . We highlight a couple commonly used functions in the sections below. File operations \u00b6 The easybuild.tools.filetools module provides a bunch of functions for performing file operations. That includes straightforward things like reading, writing, and copying files (see read_file , write_file , copy_file ), but also more specific functionality like applying a patch file ( apply_patch ), computing different types of checksums for a file ( compute_checksum ), and downloading files ( download_file ). Here is a trivial example where we download a file from a specified URL to a temporary directory, compute the SHA256 checksum, and then copy the downloaded file to the current working directory: #!/usr/bin/env python3 import os import sys import tempfile from easybuild.tools.filetools import download_file , compute_checksum , copy_file , remove_dir from easybuild.tools.options import set_up_configuration url = sys . argv [ 1 ] opts , _ = set_up_configuration () fn = os . path . basename ( url ) tmp_path = os . path . join ( opts . tmpdir , fn ) download_file ( fn , url , tmp_path ) sha256 = compute_checksum ( tmp_path , checksum_type = 'sha256' ) print ( \"SHA256 checksum for %s : %s \" % ( fn , sha256 )) target_dir = os . getcwd () copy_file ( tmp_path , target_dir ) print ( \" %s copied to %s \" % ( fn , target_dir )) # cleanup temp dir remove_dir ( opts . tmpdir ) Example output: $ export TEST_URL = 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz' $ python3 download_and_copy.py $TEST_URL == Temporary log file in case of crash /tmp/eb-or_xhaw8/easybuild-ewooa00c.log SHA256 checksum for eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9 eb-tutorial-1.0.1.tar.gz copied to /home/example We are deliberately not specifying the args optional argument to the set_up_configuration call here, so we can pass EasyBuild configuration options as command line arguments to this script. Of course, only those configuration options that are taken into account by the EasyBuild framework functions being called have any impact. For example: # wait for max. 1h for the download to complete python3 download_and_copy.py $TEST_URL --download-timeout 3600 Running shell commands \u00b6 To run shell commands, we can leverage the run_cmd functions from the easybuild.tools.run module. Here is a simple example for running the ' make ' command via a Python script: #!/usr/bin/env python3 import sys from easybuild.tools.filetools import remove_dir , which from easybuild.tools.run import run_cmd from easybuild.tools.options import set_up_configuration opts , _ = set_up_configuration ( args = []) cmd = 'make' cmd_path = which ( cmd ) if cmd_path : print ( \">>> ' %s ' command found at %s \" % ( cmd , cmd_path )) else : sys . stderr . write ( \"ERROR: ' %s ' command not found! \\n \" % cmd ) sys . exit ( 1 ) cmd = ' ' . join ([ \"make\" ] + sys . argv [ 1 :]) out , ec = run_cmd ( cmd ) print ( \" \\n >>> Output of ' %s ' (exit code %s ): \\n\\n %s \" % ( cmd , ec , out )) remove_dir ( opts . tmpdir ) Note that in this case it is important to use args=[] when calling set_up_configuration , to avoid that the additional script arguments which are options for the ' make ' command are picked up by the EasyBuild option parser. Example usage: $ python3 run_make.py --version == Temporary log file in case of crash /tmp/eb-zfvbceg6/easybuild-7tynetaj.log >> Output of 'make --version' ( exit code 0 ) : GNU Make 3 .81 Interacting with the modules tool \u00b6 You can interact with the environment modules tool in a Python script using the easybuild.tools.modules Python module that is a part of the EasyBuild framework. The modules tool that will be used is determined by the active EasyBuild configuration. Here is an example script that checks which modules are available and currently loaded, loads the default module file for bzip2 , and inspects the resulting changes to the environment. #!/usr/bin/env python3 import os import sys from easybuild.tools.filetools import remove_dir from easybuild.tools.modules import get_software_root_env_var_name , modules_tool from easybuild.tools.options import set_up_configuration opts , _ = set_up_configuration () # obtain ModulesTool instance for preferred modules tool (determined by active EasyBuild configuration) mod_tool = modules_tool () print ( \"Active modules tool: %s version %s \" % ( mod_tool . NAME , mod_tool . version )) avail_modules = mod_tool . available () print ( \"Found %d available modules in total\" % len ( avail_modules )) avail_eb_modules = mod_tool . available ( 'EasyBuild' ) print ( \"Found %d available modules for EasyBuild: %s \" % ( len ( avail_eb_modules ), ', ' . join ( avail_eb_modules ))) loaded_modules = mod_tool . loaded_modules () print ( \" %d modules are currently loaded: %s \" % ( len ( loaded_modules ), ', ' . join ( loaded_modules ))) # load default module for bzip2, check changes to environment name = 'bzip2' env_var_name = get_software_root_env_var_name ( name ) if any ( m . startswith ( name + '/' ) for m in avail_modules ): print ( \"Current $ %s value: %s \" % ( env_var_name , os . getenv ( env_var_name , '(no set)' ))) print ( \"Loading (default) ' %s ' module...\" % name ) mod_tool . load ([ name ]) print ( \"Loaded modules: %s \" % ', ' . join ( mod_tool . loaded_modules ())) # inspect $_LMFILES_ environment variable to determine path to loaded bzip2 module file for mod_file_path in os . getenv ( '_LMFILES_' ) . split ( ':' ): if name in mod_file_path : print ( \"Path to loaded %s module: %s \" % ( name , mod_file_path )) break # $EBROOTBZIP2 should be set now (if the bzip2 module was installed with EasyBuild) print ( \"Current $ %s value: %s \" % ( env_var_name , os . getenv ( env_var_name , '(no set)' ))) else : sys . stderr . write ( \"No modules available for %s \\n \" % name ) sys . exit ( 1 ) remove_dir ( opts . tmpdir ) Parsing easyconfig files \u00b6 Here is another small example Python script, which uses the EasyBuild framework functionality to locate and parse an easyconfig file, and inspect the value of specific easyconfig parameters. We define a small helper function named parse_easyconfig , because the EasyBuild framework API is a bit awkward to use for this simple use case. #!/usr/bin/env python3 import sys from easybuild.framework.easyconfig.tools import det_easyconfig_paths , parse_easyconfigs from easybuild.tools.options import set_up_configuration def parse_easyconfig ( ec_fn ): \"\"\" Helper function: find and parse easyconfig with specified filename, and return parsed easyconfig file (an EasyConfig instance). \"\"\" # determine path to easyconfig file ec_path = det_easyconfig_paths ([ ec_fn ])[ 0 ] # parse easyconfig file; # the 'parse_easyconfigs' function expects a list of tuples, # where the second item indicates whether or not the easyconfig file was automatically generated or not ec_dicts , _ = parse_easyconfigs ([( ec_path , False )]) # only retain first parsed easyconfig, ignore any others (which are unlikely anyway) return ec_path , ec_dicts [ 0 ][ 'ec' ] # check whether required arguments are provided if len ( sys . argv ) < 3 : sys . stderr . write ( \"ERROR: Usage: %s <name of easyconfig file> <easyconfig parameter name(s)>\" ) sys . exit ( 1 ) ec_fn = sys . argv [ 1 ] keys = sys . argv [ 2 :] set_up_configuration ( args = [], silent = True ) ec_path , ec = parse_easyconfig ( ec_fn ) print ( \"Inspecting %s ...\" % ec_path ) for key in keys : print ( \" %s : %s \" % ( key , ec [ key ])) Example usage: $ ./inspect_easyconfig.py Subread-2.0.0-GCC-8.3.0.eb name version sources sanity_check_paths name: Subread version: 2 .0.0 sources: [ 'subread-2.0.0-source.tar.gz' ] sanity_check_paths: { 'files' : [ 'bin/exactSNP' , 'bin/featureCounts' , 'bin/subindel' , 'bin/subjunc' , 'bin/sublong' , 'bin/subread-align' , 'bin/subread-buildindex' ] , 'dirs' : [ 'bin/utilities' ]}","title":"Using EasyBuild as a library"},{"location":"2021-lust/easybuild_library/#using-easybuild-as-a-library","text":"You can use EasyBuild as a Python library and implement a script to automate a particular task. All the functionality provided by the EasyBuild framework can be leveraged, so you only have to glue things together and add the missing pieces.","title":"Using EasyBuild as a library"},{"location":"2021-lust/easybuild_library/#setting-up-the-easybuild-configuration","text":"Before you call any of the functions provided by the EasyBuild framework, you should initialize EasyBuild by setting up the configuration . Some of the EasyBuild framework functions assume that EasyBuild has been initialized properly, and calling them without doing so will result in errors. To set up the EasyBuild configuration, you should call the set_up_configuration function that is provided by the easybuild.tools.options module. This function takes a couple of optional arguments that are useful in the context of a Python script that uses EasyBuild as a library: Via args you can provide a list of command line arguments that should be passed to the option parser. By default, the standard command line arguments are picked up via sys.args , which may not be what you want. By passing silent=True you can specify that the set_up_configuration function should not print anything when it is called. By default, it will print the location to the temporary EasyBuild log file.","title":"Setting up the EasyBuild configuration"},{"location":"2021-lust/easybuild_library/#cleaning-up-the-temporary-directory","text":"When EasyBuild is configured, a temporary directory specific to that EasyBuild session will be created automatically. You should clean up that directory, especially if you will be creating temporary files, or if the script will be run often. Note that cleaning up the temporary directory implies removes the temporary log files, so you probably only want to do this if no errors occurred.","title":"Cleaning up the temporary directory"},{"location":"2021-lust/easybuild_library/#minimal-example-script","text":"Here is a minimal (and pretty useless) example Python script, which sets up the EasyBuild configuration and cleans up the temporary directory: #!/usr/bin/env python3 from easybuild.tools.filetools import remove_dir from easybuild.tools.options import set_up_configuration opts , _ = set_up_configuration ( args = [], silent = True ) remove_dir ( opts . tmpdir )","title":"Minimal example script"},{"location":"2021-lust/easybuild_library/#example-use-cases","text":"Once the EasyBuild configuration has been set up, the functions provided by the EasyBuild framework can be called from a Python script (or directly from the Python interpreter). A full overview of all functions is available via the EasyBuild API documentation . We highlight a couple commonly used functions in the sections below.","title":"Example use cases"},{"location":"2021-lust/easybuild_library/#file-operations","text":"The easybuild.tools.filetools module provides a bunch of functions for performing file operations. That includes straightforward things like reading, writing, and copying files (see read_file , write_file , copy_file ), but also more specific functionality like applying a patch file ( apply_patch ), computing different types of checksums for a file ( compute_checksum ), and downloading files ( download_file ). Here is a trivial example where we download a file from a specified URL to a temporary directory, compute the SHA256 checksum, and then copy the downloaded file to the current working directory: #!/usr/bin/env python3 import os import sys import tempfile from easybuild.tools.filetools import download_file , compute_checksum , copy_file , remove_dir from easybuild.tools.options import set_up_configuration url = sys . argv [ 1 ] opts , _ = set_up_configuration () fn = os . path . basename ( url ) tmp_path = os . path . join ( opts . tmpdir , fn ) download_file ( fn , url , tmp_path ) sha256 = compute_checksum ( tmp_path , checksum_type = 'sha256' ) print ( \"SHA256 checksum for %s : %s \" % ( fn , sha256 )) target_dir = os . getcwd () copy_file ( tmp_path , target_dir ) print ( \" %s copied to %s \" % ( fn , target_dir )) # cleanup temp dir remove_dir ( opts . tmpdir ) Example output: $ export TEST_URL = 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz' $ python3 download_and_copy.py $TEST_URL == Temporary log file in case of crash /tmp/eb-or_xhaw8/easybuild-ewooa00c.log SHA256 checksum for eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9 eb-tutorial-1.0.1.tar.gz copied to /home/example We are deliberately not specifying the args optional argument to the set_up_configuration call here, so we can pass EasyBuild configuration options as command line arguments to this script. Of course, only those configuration options that are taken into account by the EasyBuild framework functions being called have any impact. For example: # wait for max. 1h for the download to complete python3 download_and_copy.py $TEST_URL --download-timeout 3600","title":"File operations"},{"location":"2021-lust/easybuild_library/#running-shell-commands","text":"To run shell commands, we can leverage the run_cmd functions from the easybuild.tools.run module. Here is a simple example for running the ' make ' command via a Python script: #!/usr/bin/env python3 import sys from easybuild.tools.filetools import remove_dir , which from easybuild.tools.run import run_cmd from easybuild.tools.options import set_up_configuration opts , _ = set_up_configuration ( args = []) cmd = 'make' cmd_path = which ( cmd ) if cmd_path : print ( \">>> ' %s ' command found at %s \" % ( cmd , cmd_path )) else : sys . stderr . write ( \"ERROR: ' %s ' command not found! \\n \" % cmd ) sys . exit ( 1 ) cmd = ' ' . join ([ \"make\" ] + sys . argv [ 1 :]) out , ec = run_cmd ( cmd ) print ( \" \\n >>> Output of ' %s ' (exit code %s ): \\n\\n %s \" % ( cmd , ec , out )) remove_dir ( opts . tmpdir ) Note that in this case it is important to use args=[] when calling set_up_configuration , to avoid that the additional script arguments which are options for the ' make ' command are picked up by the EasyBuild option parser. Example usage: $ python3 run_make.py --version == Temporary log file in case of crash /tmp/eb-zfvbceg6/easybuild-7tynetaj.log >> Output of 'make --version' ( exit code 0 ) : GNU Make 3 .81","title":"Running shell commands"},{"location":"2021-lust/easybuild_library/#interacting-with-the-modules-tool","text":"You can interact with the environment modules tool in a Python script using the easybuild.tools.modules Python module that is a part of the EasyBuild framework. The modules tool that will be used is determined by the active EasyBuild configuration. Here is an example script that checks which modules are available and currently loaded, loads the default module file for bzip2 , and inspects the resulting changes to the environment. #!/usr/bin/env python3 import os import sys from easybuild.tools.filetools import remove_dir from easybuild.tools.modules import get_software_root_env_var_name , modules_tool from easybuild.tools.options import set_up_configuration opts , _ = set_up_configuration () # obtain ModulesTool instance for preferred modules tool (determined by active EasyBuild configuration) mod_tool = modules_tool () print ( \"Active modules tool: %s version %s \" % ( mod_tool . NAME , mod_tool . version )) avail_modules = mod_tool . available () print ( \"Found %d available modules in total\" % len ( avail_modules )) avail_eb_modules = mod_tool . available ( 'EasyBuild' ) print ( \"Found %d available modules for EasyBuild: %s \" % ( len ( avail_eb_modules ), ', ' . join ( avail_eb_modules ))) loaded_modules = mod_tool . loaded_modules () print ( \" %d modules are currently loaded: %s \" % ( len ( loaded_modules ), ', ' . join ( loaded_modules ))) # load default module for bzip2, check changes to environment name = 'bzip2' env_var_name = get_software_root_env_var_name ( name ) if any ( m . startswith ( name + '/' ) for m in avail_modules ): print ( \"Current $ %s value: %s \" % ( env_var_name , os . getenv ( env_var_name , '(no set)' ))) print ( \"Loading (default) ' %s ' module...\" % name ) mod_tool . load ([ name ]) print ( \"Loaded modules: %s \" % ', ' . join ( mod_tool . loaded_modules ())) # inspect $_LMFILES_ environment variable to determine path to loaded bzip2 module file for mod_file_path in os . getenv ( '_LMFILES_' ) . split ( ':' ): if name in mod_file_path : print ( \"Path to loaded %s module: %s \" % ( name , mod_file_path )) break # $EBROOTBZIP2 should be set now (if the bzip2 module was installed with EasyBuild) print ( \"Current $ %s value: %s \" % ( env_var_name , os . getenv ( env_var_name , '(no set)' ))) else : sys . stderr . write ( \"No modules available for %s \\n \" % name ) sys . exit ( 1 ) remove_dir ( opts . tmpdir )","title":"Interacting with the modules tool"},{"location":"2021-lust/easybuild_library/#parsing-easyconfig-files","text":"Here is another small example Python script, which uses the EasyBuild framework functionality to locate and parse an easyconfig file, and inspect the value of specific easyconfig parameters. We define a small helper function named parse_easyconfig , because the EasyBuild framework API is a bit awkward to use for this simple use case. #!/usr/bin/env python3 import sys from easybuild.framework.easyconfig.tools import det_easyconfig_paths , parse_easyconfigs from easybuild.tools.options import set_up_configuration def parse_easyconfig ( ec_fn ): \"\"\" Helper function: find and parse easyconfig with specified filename, and return parsed easyconfig file (an EasyConfig instance). \"\"\" # determine path to easyconfig file ec_path = det_easyconfig_paths ([ ec_fn ])[ 0 ] # parse easyconfig file; # the 'parse_easyconfigs' function expects a list of tuples, # where the second item indicates whether or not the easyconfig file was automatically generated or not ec_dicts , _ = parse_easyconfigs ([( ec_path , False )]) # only retain first parsed easyconfig, ignore any others (which are unlikely anyway) return ec_path , ec_dicts [ 0 ][ 'ec' ] # check whether required arguments are provided if len ( sys . argv ) < 3 : sys . stderr . write ( \"ERROR: Usage: %s <name of easyconfig file> <easyconfig parameter name(s)>\" ) sys . exit ( 1 ) ec_fn = sys . argv [ 1 ] keys = sys . argv [ 2 :] set_up_configuration ( args = [], silent = True ) ec_path , ec = parse_easyconfig ( ec_fn ) print ( \"Inspecting %s ...\" % ec_path ) for key in keys : print ( \" %s : %s \" % ( key , ec [ key ])) Example usage: $ ./inspect_easyconfig.py Subread-2.0.0-GCC-8.3.0.eb name version sources sanity_check_paths name: Subread version: 2 .0.0 sources: [ 'subread-2.0.0-source.tar.gz' ] sanity_check_paths: { 'files' : [ 'bin/exactSNP' , 'bin/featureCounts' , 'bin/subindel' , 'bin/subjunc' , 'bin/sublong' , 'bin/subread-align' , 'bin/subread-buildindex' ] , 'dirs' : [ 'bin/utilities' ]}","title":"Parsing easyconfig files"},{"location":"2021-lust/github_integration/","text":"GitHub integration to facilitate contributing to EasyBuild \u00b6 To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not? Manual contribution procedure \u00b6 0) Create and setup a GitHub account (and register your SSH public key); 1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file: git clone git@github.com:easybuilders/easybuild-easyconfigs.git cd easybuild-easyconfigs git remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git You should change ' your_github_account ' in the last line to your own GitHub user name! 2) Create and check out a new branch, starting from the (up-to-date) develop branch: git checkout develop git pull origin develop git checkout -b example 3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename , and that it's located in the appropriate directory. mkdir -p easybuild/easyconfigs/e/example/ mv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb git add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb 4) Commit those changes with a sensible commit message: git commit -m \"This is just an example\" 5) Push your branch to your fork of the repository on GitHub: git push my_fork example 6) Open the pull request through the GitHub web interface, making sure that: the target branch is correct (should be develop ); an appropriate title is used; a short description of the changes is provided; the changes are indeed the ones you want to propose; clicking the (correct) green button; That didn't exactly motivate you to contribute, did it... Github integration features \u00b6 Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute... In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with git you may quickly end up demotivated. This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures. At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running git commands and interacting with the GitHub API . We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation . Requirements & configuration \u00b6 First of all, the GitHub integration features impose a couple of additional requirements and configuration. Additional dependencies Both the GitPython and keyring Python packages as well as the keyrings.cryptfile add-on package must be installed. In the prepared environment, you can do this via: pip3 install --user GitPython keyring keyrings.cryptfile Note You may experiences problems installing the cryptography Python packages, which is a dependency of keyring. The underlying cause is that you need to have the Rust compiler installed to install the latest version of cryptography (see here ). You can work around this issue using: pip3 install --user 'cryptography<3.4' SSH public key in GitHub account You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys ). If you need to generate an SSH key pair, you can run the following command: ssh-keygen -t rsa -b 4096 You can copy the SSH public key from the output of this command: cat .ssh/id_rsa.pub Forked repository in GitHub In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs ). EasyBuild configuration, incl. GitHub token You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials. To do this, you should define the github-user configuration option and run the \" eb --install-github-token \" command: # replace 'ebtutorial' with your own GitHub username! $ export EASYBUILD_GITHUB_USER = ebtutorial $ eb --install-github-token To create a GitHub token: Visit https://github.com/settings/tokens . Click \"Personal access tokens\" . Click followed by \"Generate new token\" . Give the token a name (for example \"Token for EasyBuild\" ). Select both the ' repo ' and ' gist ' scopes. Click the green \"Generate token\" button. Copy the generated token. Paste the token when asked by --install-github-token (and hit Enter ). Enter a password to encrypt your GitHub token. The output should look something like this: $ eb --install-github-token == temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log Token: Validating token... Token seems to be valid, installing it. Please set a password for your new keyring: Please confirm the password: Token 'fed..987' installed! Checking status of GitHub integration You can check the status of the GitHub integration using \" eb --check-github \": $ eb --check-github == temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log Checking status of GitHub integration... Making sure we ' re online...OK * GitHub user...ebtutorial = > OK Please enter password for encrypted keyring: * GitHub token...fed..987 ( len: 40 ) = > OK ( validated ) * git command...OK ( \"git version 1.8.3.1; \" ) * GitPython module...OK ( GitPython version 3 .1.3 ) * push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK * creating gists...OK * location to Git working dirs... not found ( suboptimal ) All checks PASSed! Status of GitHub integration: * --from-pr: OK * --new-pr: OK * --review-pr: OK * --update-pr: OK * --upload-test-report: OK If you see ' OK ' for each of the status checks, you're all set to try out the GitHub integration features! Note If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \" eb --check-github \". You can avoid this by using an SSH agent . Note If you see the push access check fail with Failed to fetch branch 'main' , you will need to rename the master branch in your fork of the easybuild-easyconfigs repository from master to main (this is required since EasyBuild v4.3.3). This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace YOUR_GITHUB_ACCOUNT with the name of your GitHub account in this URL). Creating pull requests \u00b6 The GitHub integration in EasyBuild allows you to create pull requests using the eb command , without even leaving your shell environment. How cool is that\u203d To create a pull request to the easybuild-easyconfigs repository, you can either do it in a single go by running \" eb --new-pr \" and passing it one or more easyconfig files to add into the pull request. The more detailed option is to first create a branch in your repository fork in GitHub via \" eb --new-branch-github \" and then later open the pull request via \" eb --new-pr-from-branch \". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork). The --new-pr option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa! You can control the target repository for your pull request using --pr-target-account (default is easybuilders ) and --pr-target-repo . If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \" eb --dry-run --new-pr \" or \" eb -D --new-pr \". Finally, you can use \" eb --preview-pr \" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files. Updating pull requests \u00b6 To update an existing pull request with additional changes you can use \" eb --update-pr \" and pass the pull request ID, alongside the paths to the updated files. If you have only created a branch (for example via eb --new-branch-github ) you can update it via --update-branch-github in the same way, passing the branch name instead of a pull request ID. Using a pull request \u00b6 Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which support is not yet included in the latest EasyBuild release. Using the --from-pr option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the --robot option to ensure that the easyconfig files are installed in the correct order with respect to dependencies. Similarly, using a new or updated easyblock from a pull request is as simple as using the --include-easyblocks-from-pr option. And of course you can combine it with --from-pr ! Via --upload-test-report you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration. Demo \u00b6 That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the eb-tutorial example software to a fork of the easybuild-easyconfigs repository using the eb command, and submit a test report in it. Note Make sure that you have correctly configured the GitHub integration, see above . Creating pull request \u00b6 We first configure EasyBuild to target the ebtutorial GitHub account rather than the default easybuilders GitHub organisation, by defining the pr-target-account configuration setting: export EASYBUILD_PR_TARGET_ACCOUNT = ebtutorial In the output of \" eb --show-config \" you should see a line like this: pr-target-account (E) = ebtutorial We only do this to avoid that lots of pull requests for the eb-tutorial example software are opened in the central easyconfigs repository . Opening a pull request is as simple as running \" eb --new-pr \" and passing the easyconfig file: $ eb --new-pr example.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git... == copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs... == pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' ( git@github.com:ebtutorial/easybuild-easyconfigs.git ) Enter passphrase for key '/home/example/.ssh/id_rsa' : Please enter password for encrypted keyring: Opening pull request * target: ebtutorial/easybuild-easyconfigs:develop * from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100 * title: \"{tools}[GCC/10.2.0] eb-tutorial v1.0.1\" * labels: new * description: \"\"\" (created using `eb --new-pr`) \"\"\" * overview of changes: easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb | 26 ++++++++++++++++++++++++++ 1 file changed, 26 insertions ( + ) Opened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/ == Temporary log file ( s ) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed. == Temporary directory /tmp/eb-ggr6scbq has been removed. Take a moment to grasp what we did here: we ran a single eb command which took care of the whole contribution procedure for us, including: Cloning the easybuilders/easybuild-easyconfigs repository and checking out the develop branch (in a temporary directory); Picking a sensible name for a branch and creating it; Adding the eb-tutorial easyconfig file to the branch, in the correct location ( easybuild/easyconfigs/e/eb-tutorial/ ) and with the correct filename ( eb-tutorial-1.0.1-GCC-10.2.0.eb ); Pushing the branch to our fork ( example/easybuild-easyconfigs ); Actually opening the pull request, using an informative title. That is so... easy! This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the develop branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to). There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since --new-pr created the branch only in a temporary directory). If many contributions are made via --new-pr it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar. Uploading test report \u00b6 After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request. First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for eb-tutorial are already installed there: module use /easybuild/modules/all You can verify which dependencies are still missing using --from-pr combined with --missing : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --from-pr 1 --missing == temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log Please enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... 1 out of 20 required modules missing: * eb-tutorial/1.0.1-GCC-10.2.0 ( eb-tutorial-1.0.1-GCC-10.2.0.eb ) Uploading a test report boils down to combining --from-pr with --upload-test-report : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --rebuild --from-pr 1 --upload-test-report Please enter password for encrypted keyring: ... == processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 2 sec ) ... Adding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial **SUCCESS** Build succeeded for 1 out of 1 ( 1 easyconfigs in this PR ) example - Linux centos linux 7 .8.2003, x86_64, Intel ( R ) Core ( TM ) i5-7360U CPU @ 2 .30GHz ( haswell ) , Python 3 .6.8 See https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report. ' == Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1 Note that we may need to use --rebuild here since eb-tutorial may already be installed. This results in a comment being added to the pull request: The gist linked from this comment provides more detailed information:","title":"GitHub integration to facilitate contributing to EasyBuild"},{"location":"2021-lust/github_integration/#github-integration-to-facilitate-contributing-to-easybuild","text":"To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not?","title":"GitHub integration to facilitate contributing to EasyBuild"},{"location":"2021-lust/github_integration/#manual-contribution-procedure","text":"0) Create and setup a GitHub account (and register your SSH public key); 1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file: git clone git@github.com:easybuilders/easybuild-easyconfigs.git cd easybuild-easyconfigs git remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git You should change ' your_github_account ' in the last line to your own GitHub user name! 2) Create and check out a new branch, starting from the (up-to-date) develop branch: git checkout develop git pull origin develop git checkout -b example 3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename , and that it's located in the appropriate directory. mkdir -p easybuild/easyconfigs/e/example/ mv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb git add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb 4) Commit those changes with a sensible commit message: git commit -m \"This is just an example\" 5) Push your branch to your fork of the repository on GitHub: git push my_fork example 6) Open the pull request through the GitHub web interface, making sure that: the target branch is correct (should be develop ); an appropriate title is used; a short description of the changes is provided; the changes are indeed the ones you want to propose; clicking the (correct) green button; That didn't exactly motivate you to contribute, did it...","title":"Manual contribution procedure"},{"location":"2021-lust/github_integration/#github-integration-features","text":"Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute... In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with git you may quickly end up demotivated. This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures. At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running git commands and interacting with the GitHub API . We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation .","title":"Github integration features"},{"location":"2021-lust/github_integration/#requirements-configuration","text":"First of all, the GitHub integration features impose a couple of additional requirements and configuration. Additional dependencies Both the GitPython and keyring Python packages as well as the keyrings.cryptfile add-on package must be installed. In the prepared environment, you can do this via: pip3 install --user GitPython keyring keyrings.cryptfile Note You may experiences problems installing the cryptography Python packages, which is a dependency of keyring. The underlying cause is that you need to have the Rust compiler installed to install the latest version of cryptography (see here ). You can work around this issue using: pip3 install --user 'cryptography<3.4' SSH public key in GitHub account You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys ). If you need to generate an SSH key pair, you can run the following command: ssh-keygen -t rsa -b 4096 You can copy the SSH public key from the output of this command: cat .ssh/id_rsa.pub Forked repository in GitHub In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs ). EasyBuild configuration, incl. GitHub token You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials. To do this, you should define the github-user configuration option and run the \" eb --install-github-token \" command: # replace 'ebtutorial' with your own GitHub username! $ export EASYBUILD_GITHUB_USER = ebtutorial $ eb --install-github-token To create a GitHub token: Visit https://github.com/settings/tokens . Click \"Personal access tokens\" . Click followed by \"Generate new token\" . Give the token a name (for example \"Token for EasyBuild\" ). Select both the ' repo ' and ' gist ' scopes. Click the green \"Generate token\" button. Copy the generated token. Paste the token when asked by --install-github-token (and hit Enter ). Enter a password to encrypt your GitHub token. The output should look something like this: $ eb --install-github-token == temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log Token: Validating token... Token seems to be valid, installing it. Please set a password for your new keyring: Please confirm the password: Token 'fed..987' installed! Checking status of GitHub integration You can check the status of the GitHub integration using \" eb --check-github \": $ eb --check-github == temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log Checking status of GitHub integration... Making sure we ' re online...OK * GitHub user...ebtutorial = > OK Please enter password for encrypted keyring: * GitHub token...fed..987 ( len: 40 ) = > OK ( validated ) * git command...OK ( \"git version 1.8.3.1; \" ) * GitPython module...OK ( GitPython version 3 .1.3 ) * push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK * creating gists...OK * location to Git working dirs... not found ( suboptimal ) All checks PASSed! Status of GitHub integration: * --from-pr: OK * --new-pr: OK * --review-pr: OK * --update-pr: OK * --upload-test-report: OK If you see ' OK ' for each of the status checks, you're all set to try out the GitHub integration features! Note If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \" eb --check-github \". You can avoid this by using an SSH agent . Note If you see the push access check fail with Failed to fetch branch 'main' , you will need to rename the master branch in your fork of the easybuild-easyconfigs repository from master to main (this is required since EasyBuild v4.3.3). This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace YOUR_GITHUB_ACCOUNT with the name of your GitHub account in this URL).","title":"Requirements &amp; configuration"},{"location":"2021-lust/github_integration/#creating-pull-requests","text":"The GitHub integration in EasyBuild allows you to create pull requests using the eb command , without even leaving your shell environment. How cool is that\u203d To create a pull request to the easybuild-easyconfigs repository, you can either do it in a single go by running \" eb --new-pr \" and passing it one or more easyconfig files to add into the pull request. The more detailed option is to first create a branch in your repository fork in GitHub via \" eb --new-branch-github \" and then later open the pull request via \" eb --new-pr-from-branch \". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork). The --new-pr option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa! You can control the target repository for your pull request using --pr-target-account (default is easybuilders ) and --pr-target-repo . If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \" eb --dry-run --new-pr \" or \" eb -D --new-pr \". Finally, you can use \" eb --preview-pr \" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.","title":"Creating pull requests"},{"location":"2021-lust/github_integration/#updating-pull-requests","text":"To update an existing pull request with additional changes you can use \" eb --update-pr \" and pass the pull request ID, alongside the paths to the updated files. If you have only created a branch (for example via eb --new-branch-github ) you can update it via --update-branch-github in the same way, passing the branch name instead of a pull request ID.","title":"Updating pull requests"},{"location":"2021-lust/github_integration/#using-a-pull-request","text":"Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which support is not yet included in the latest EasyBuild release. Using the --from-pr option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the --robot option to ensure that the easyconfig files are installed in the correct order with respect to dependencies. Similarly, using a new or updated easyblock from a pull request is as simple as using the --include-easyblocks-from-pr option. And of course you can combine it with --from-pr ! Via --upload-test-report you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.","title":"Using a pull request"},{"location":"2021-lust/github_integration/#demo","text":"That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the eb-tutorial example software to a fork of the easybuild-easyconfigs repository using the eb command, and submit a test report in it. Note Make sure that you have correctly configured the GitHub integration, see above .","title":"Demo"},{"location":"2021-lust/github_integration/#creating-pull-request","text":"We first configure EasyBuild to target the ebtutorial GitHub account rather than the default easybuilders GitHub organisation, by defining the pr-target-account configuration setting: export EASYBUILD_PR_TARGET_ACCOUNT = ebtutorial In the output of \" eb --show-config \" you should see a line like this: pr-target-account (E) = ebtutorial We only do this to avoid that lots of pull requests for the eb-tutorial example software are opened in the central easyconfigs repository . Opening a pull request is as simple as running \" eb --new-pr \" and passing the easyconfig file: $ eb --new-pr example.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git... == copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs... == pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' ( git@github.com:ebtutorial/easybuild-easyconfigs.git ) Enter passphrase for key '/home/example/.ssh/id_rsa' : Please enter password for encrypted keyring: Opening pull request * target: ebtutorial/easybuild-easyconfigs:develop * from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100 * title: \"{tools}[GCC/10.2.0] eb-tutorial v1.0.1\" * labels: new * description: \"\"\" (created using `eb --new-pr`) \"\"\" * overview of changes: easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb | 26 ++++++++++++++++++++++++++ 1 file changed, 26 insertions ( + ) Opened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/ == Temporary log file ( s ) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed. == Temporary directory /tmp/eb-ggr6scbq has been removed. Take a moment to grasp what we did here: we ran a single eb command which took care of the whole contribution procedure for us, including: Cloning the easybuilders/easybuild-easyconfigs repository and checking out the develop branch (in a temporary directory); Picking a sensible name for a branch and creating it; Adding the eb-tutorial easyconfig file to the branch, in the correct location ( easybuild/easyconfigs/e/eb-tutorial/ ) and with the correct filename ( eb-tutorial-1.0.1-GCC-10.2.0.eb ); Pushing the branch to our fork ( example/easybuild-easyconfigs ); Actually opening the pull request, using an informative title. That is so... easy! This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the develop branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to). There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since --new-pr created the branch only in a temporary directory). If many contributions are made via --new-pr it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar.","title":"Creating pull request"},{"location":"2021-lust/github_integration/#uploading-test-report","text":"After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request. First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for eb-tutorial are already installed there: module use /easybuild/modules/all You can verify which dependencies are still missing using --from-pr combined with --missing : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --from-pr 1 --missing == temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log Please enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... 1 out of 20 required modules missing: * eb-tutorial/1.0.1-GCC-10.2.0 ( eb-tutorial-1.0.1-GCC-10.2.0.eb ) Uploading a test report boils down to combining --from-pr with --upload-test-report : # change '1' to the ID of your own pull request (see output of --new-pr) $ eb --rebuild --from-pr 1 --upload-test-report Please enter password for encrypted keyring: ... == processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb == building and installing eb-tutorial/1.0.1-GCC-10.2.0... ... == COMPLETED: Installation ended successfully ( took 2 sec ) ... Adding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial **SUCCESS** Build succeeded for 1 out of 1 ( 1 easyconfigs in this PR ) example - Linux centos linux 7 .8.2003, x86_64, Intel ( R ) Core ( TM ) i5-7360U CPU @ 2 .30GHz ( haswell ) , Python 3 .6.8 See https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report. ' == Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1 Note that we may need to use --rebuild here since eb-tutorial may already be installed. This results in a comment being added to the pull request: The gist linked from this comment provides more detailed information:","title":"Uploading test report"},{"location":"2021-lust/hooks/","text":"Using hooks to customise EasyBuild \u00b6 Sometimes you may have the need to customise the behaviour of EasyBuild, while you want to avoid copying easyconfig files in order to make small changes (like adding an additional configuration option), having to maintain a set of modified easyblocks, or using a patched version of the EasyBuild framework. EasyBuild provides support for implementing so-called hooks , which are small functions that are triggered automatically at specific times. Through these hook functions you can take additional actions, or even tweak internal data structures, to change the software installation procedure that EasyBuild would normally execute. This is a very powerful feature, but it is important to aware of some details in order to make good use of it. Support for hooks is also covered in detail in the EasyBuild documentation, see here . Implementing and using hooks \u00b6 Using hooks is done by implementing functions with specific names in a Python module, and configuring EasyBuild to use them by specifying the path to the file that contains them via the hooks configuration option. For example, if the file named my_eb_hooks.py in your home directory contains the implementation of your hooks, you can configure EasyBuild to use them by defining the $EASYBUILD_HOOKS environment variable: export EASYBUILD_HOOKS = $HOME /my_eb_hooks.py Available hooks \u00b6 EasyBuild supports various hooks, the full list can be consulted via eb --avail-hooks . There are 3 different types of hooks: start/end hooks parse hook pre/post-step hooks These are discussed in more details in the sections below. Start/end hooks \u00b6 The first type of hooks are the start and end hooks, which are respectively triggered at the very start of the EasyBuild session (right after setting up the EasyBuild configuration), and at the very end of the session (right before stopping the logger and doing final cleanup). These hooks are only called once for every EasyBuild session, no matter how many installations are performed during that session. The end hook is not triggered if an error occurred during one of the installations, only on successful completion of the EasyBuild session. These hooks can be implementing by defining a function named start_hook and end_hook in the Python module file that is provided via the hooks configuration option. No arguments are provided when calling these hooks. Parse hook \u00b6 The parse hook is triggered right after an easyconfig file is being parsed, before EasyBuild sets up its internal data structures based on the parsed easyconfig. If you want to dynamically change one or more easyconfig parameters without changing the corresponding easyconfig files, using this hook may be appropriate. Note that parsing an easyconfig file can happen for a variety of reasons, not only when the easyconfig file will actually be installed. EasyBuild will also parse easyconfig files to check whether they resolve required dependencies, to check whether the corresponding module file is already installed, etc. This hook can be implemented via a function named parse_hook , and exactly one argument is provided when it is called: the EasyConfig instance that represents the parsed easyconfig file. Pre/post-step hooks \u00b6 The third type of hooks are pre/post-step hooks, which are triggered right before or after a particular installation step is executed. EasyBuild performs each software installation by stepping through over a dozen different methods, and for each of these steps there a pre- and post-hook is triggered, which results in over 30 additional hooks. To use any of these hooks, you need to implement a function that follow a strict naming scheme: <pre|post>_<step-name>_hook . For example, the hook that is triggered right before the configure step is run is a function named pre_configure_hook . Every time these hooks are called, a single argument is provided: an EasyBlock instance that represents the easyblock that is being used to perform the installation. The parsed easyconfig file can be accessed via the cfg class variable of the EasyBlock instance. These hooks are useful for influencing the installation procedure at a particular stage. Caveats \u00b6 There are a couple of important caveats to take into account when implementing hooks. Breaking EasyBuild with hooks \u00b6 Since hooks allow you to inject custom code into EasyBuild at runtime, it is also easy to break EasyBuild by using hooks... Make sure to carefully test your hook implementations, and constrain the actions you take a much as possible, for example by adding conditions to control for which software names you will actually modify the installation procedure, etc. Any errors that are triggered or raised while a hook function is running will interrupt the EasyBuild session. So don't forget: with great power comes great responsibility! Template values \u00b6 Depending on the type of hook, you may observe \"raw\" values of easyconfig parameters where template values have not been resolved yet, or values in which template values have been resolved already. In the parse hook, you will always see unresolved template values. In the pre/post-step hooks you will see resolved template values, unless you explicitly disable templating. To obtain easyconfig parameter values with unresolved template values in step hooks, you can use the disable_templating context manager . For example: from easybuild.framework.easyconfig.easyconfig import disable_templating from easybuild.tools.build_log import print_warning def pre_source_hook ( eb ): \"\"\"Print warning when software version was found in 'raw' name of source file.\"\"\" with disable_templating ( eb . cfg ): for src in eb . cfg [ 'sources' ]: if eb . version in src : msg = \"Software version ' %s ' found in name of source file ( %s ), \" % ( eb . version , src ) msg += \"please use %(version)s template value instead!\" print_warning ( msg ) Manipulating easyconfig parameters \u00b6 If you want update a particular easyconfig parameter without overwriting the existing value, a bit of care has to be taken: you should use the update method of the EasyConfig instance for this, unless you disable template resolution. This is particularly important when updating easyconfig parameters that have mutable value (like a list or dict ). Here's a correct example of a pre-install hook: def pre_install_hook ( eb ): if eb . name == 'pigz' : # always copy the README directory too when installing pigz eb . cfg . update ( 'files_to_copy' , 'README' ) This seemingly equivalent implementation will not work (the value of the files_to_copy easyconfig parameter will not be updated): def pre_install_hook ( eb ): if eb . name == 'pigz' : # incorrect way of adding 'README' to 'files_to_copy' (DON'T USE THIS!) eb . cfg [ 'files_to_copy' ] . append ( 'README' ) To use this coding style successfully, you have to disable the templating mechanism when updating the easyconfig parameter: def pre_install_hook ( eb ): if eb . name == 'pigz' : # this works, but it is better to use the 'update' method instead... with disable_templating ( eb . cfg ): eb . cfg [ 'files_to_copy' ] . append ( 'README' )","title":"Using hooks to customise EasyBuild"},{"location":"2021-lust/hooks/#using-hooks-to-customise-easybuild","text":"Sometimes you may have the need to customise the behaviour of EasyBuild, while you want to avoid copying easyconfig files in order to make small changes (like adding an additional configuration option), having to maintain a set of modified easyblocks, or using a patched version of the EasyBuild framework. EasyBuild provides support for implementing so-called hooks , which are small functions that are triggered automatically at specific times. Through these hook functions you can take additional actions, or even tweak internal data structures, to change the software installation procedure that EasyBuild would normally execute. This is a very powerful feature, but it is important to aware of some details in order to make good use of it. Support for hooks is also covered in detail in the EasyBuild documentation, see here .","title":"Using hooks to customise EasyBuild"},{"location":"2021-lust/hooks/#implementing-and-using-hooks","text":"Using hooks is done by implementing functions with specific names in a Python module, and configuring EasyBuild to use them by specifying the path to the file that contains them via the hooks configuration option. For example, if the file named my_eb_hooks.py in your home directory contains the implementation of your hooks, you can configure EasyBuild to use them by defining the $EASYBUILD_HOOKS environment variable: export EASYBUILD_HOOKS = $HOME /my_eb_hooks.py","title":"Implementing and using hooks"},{"location":"2021-lust/hooks/#available-hooks","text":"EasyBuild supports various hooks, the full list can be consulted via eb --avail-hooks . There are 3 different types of hooks: start/end hooks parse hook pre/post-step hooks These are discussed in more details in the sections below.","title":"Available hooks"},{"location":"2021-lust/hooks/#startend-hooks","text":"The first type of hooks are the start and end hooks, which are respectively triggered at the very start of the EasyBuild session (right after setting up the EasyBuild configuration), and at the very end of the session (right before stopping the logger and doing final cleanup). These hooks are only called once for every EasyBuild session, no matter how many installations are performed during that session. The end hook is not triggered if an error occurred during one of the installations, only on successful completion of the EasyBuild session. These hooks can be implementing by defining a function named start_hook and end_hook in the Python module file that is provided via the hooks configuration option. No arguments are provided when calling these hooks.","title":"Start/end hooks"},{"location":"2021-lust/hooks/#parse-hook","text":"The parse hook is triggered right after an easyconfig file is being parsed, before EasyBuild sets up its internal data structures based on the parsed easyconfig. If you want to dynamically change one or more easyconfig parameters without changing the corresponding easyconfig files, using this hook may be appropriate. Note that parsing an easyconfig file can happen for a variety of reasons, not only when the easyconfig file will actually be installed. EasyBuild will also parse easyconfig files to check whether they resolve required dependencies, to check whether the corresponding module file is already installed, etc. This hook can be implemented via a function named parse_hook , and exactly one argument is provided when it is called: the EasyConfig instance that represents the parsed easyconfig file.","title":"Parse hook"},{"location":"2021-lust/hooks/#prepost-step-hooks","text":"The third type of hooks are pre/post-step hooks, which are triggered right before or after a particular installation step is executed. EasyBuild performs each software installation by stepping through over a dozen different methods, and for each of these steps there a pre- and post-hook is triggered, which results in over 30 additional hooks. To use any of these hooks, you need to implement a function that follow a strict naming scheme: <pre|post>_<step-name>_hook . For example, the hook that is triggered right before the configure step is run is a function named pre_configure_hook . Every time these hooks are called, a single argument is provided: an EasyBlock instance that represents the easyblock that is being used to perform the installation. The parsed easyconfig file can be accessed via the cfg class variable of the EasyBlock instance. These hooks are useful for influencing the installation procedure at a particular stage.","title":"Pre/post-step hooks"},{"location":"2021-lust/hooks/#caveats","text":"There are a couple of important caveats to take into account when implementing hooks.","title":"Caveats"},{"location":"2021-lust/hooks/#breaking-easybuild-with-hooks","text":"Since hooks allow you to inject custom code into EasyBuild at runtime, it is also easy to break EasyBuild by using hooks... Make sure to carefully test your hook implementations, and constrain the actions you take a much as possible, for example by adding conditions to control for which software names you will actually modify the installation procedure, etc. Any errors that are triggered or raised while a hook function is running will interrupt the EasyBuild session. So don't forget: with great power comes great responsibility!","title":"Breaking EasyBuild with hooks"},{"location":"2021-lust/hooks/#template-values","text":"Depending on the type of hook, you may observe \"raw\" values of easyconfig parameters where template values have not been resolved yet, or values in which template values have been resolved already. In the parse hook, you will always see unresolved template values. In the pre/post-step hooks you will see resolved template values, unless you explicitly disable templating. To obtain easyconfig parameter values with unresolved template values in step hooks, you can use the disable_templating context manager . For example: from easybuild.framework.easyconfig.easyconfig import disable_templating from easybuild.tools.build_log import print_warning def pre_source_hook ( eb ): \"\"\"Print warning when software version was found in 'raw' name of source file.\"\"\" with disable_templating ( eb . cfg ): for src in eb . cfg [ 'sources' ]: if eb . version in src : msg = \"Software version ' %s ' found in name of source file ( %s ), \" % ( eb . version , src ) msg += \"please use %(version)s template value instead!\" print_warning ( msg )","title":"Template values"},{"location":"2021-lust/hooks/#manipulating-easyconfig-parameters","text":"If you want update a particular easyconfig parameter without overwriting the existing value, a bit of care has to be taken: you should use the update method of the EasyConfig instance for this, unless you disable template resolution. This is particularly important when updating easyconfig parameters that have mutable value (like a list or dict ). Here's a correct example of a pre-install hook: def pre_install_hook ( eb ): if eb . name == 'pigz' : # always copy the README directory too when installing pigz eb . cfg . update ( 'files_to_copy' , 'README' ) This seemingly equivalent implementation will not work (the value of the files_to_copy easyconfig parameter will not be updated): def pre_install_hook ( eb ): if eb . name == 'pigz' : # incorrect way of adding 'README' to 'files_to_copy' (DON'T USE THIS!) eb . cfg [ 'files_to_copy' ] . append ( 'README' ) To use this coding style successfully, you have to disable the templating mechanism when updating the easyconfig parameter: def pre_install_hook ( eb ): if eb . name == 'pigz' : # this works, but it is better to use the 'update' method instead... with disable_templating ( eb . cfg ): eb . cfg [ 'files_to_copy' ] . append ( 'README' )","title":"Manipulating easyconfig parameters"},{"location":"2021-lust/implementing_easyblocks/","text":"Implementing easyblocks \u00b6 The basics \u00b6 An easyblock is a Python module that implements a software build and installation procedure. This concept is essentially implemented as a Python script that plugs into the EasyBuild framework. EasyBuild will leverage easyblocks as needed, depending on which software packages it needs to install. Which easyblock is required is determined by the easyblock easyconfig parameter, if it is present, or by the software name. Generic vs software-specific easyblocks \u00b6 Easyblocks can either be generic or software-specific . Generic easyblocks implement a \"standard\" software build and installation procedure that is used by multiple different software packages. A commonly used example is the ConfigureMake generic easyblock, which implements the standard configure - make - make install installation procedure used by most GNU software packages. Software-specific easyblocks implement the build and installation procedure for a particular software package. Typically this involves highly customised steps, for example specifying dedicated configuration options, creating or adjusting specific files, executing non-standard shell commands, etc. Usually a custom implementation of the sanity check is also included. Using a generic easyblock requires specifying the easyblock parameter in the easyconfig file. If it is not specified, EasyBuild will try and find the software-specific easyblock derived from the software name. The distinction between generic and software-specific easyblocks can be made based on the naming scheme that is used for an easyblock (see below). Naming \u00b6 Easyblocks need to follow a strict naming scheme, to ensure that EasyBuild can pick them up as needed. This involves two aspects: the name of the Python class; the name and location of the Python module file. Python class name \u00b6 The name of the Python class is determined by the software name for software-specific easyblocks. It consists of a prefix ' EB_ ', followed by the (encoded) software name. Because of limitations in Python on characters allowed in names of Python classes, only alphanumeric characters and underscores ( _ ) are allowed. Any other characters are replaced following an encoding scheme: spaces are replaced by underscores ( _ ); dashes - are replaced by _minus_ ; underscores are replaced by _underscore_ ; The encode_class_name function provided in easybuild.tools.filetools returns the expected class name for a given software name; for example: $ python3 -c \"from easybuild.tools.filetools import encode_class_name; print(encode_class_name('netCDF-Fortran'))\" EB_netCDF_minus_Fortran Python class name for generic easyblocks For generic easyblocks, the class name does not include an EB_ prefix (since there is no need for an escaping mechanism) and hence the name is fully free to choose, taking into account the restriction to alphanumeric characters and underscores. For code style reasons, the class name should start with a capital letter and use CamelCasing. Examples include Bundle , ConfigureMake , CMakePythonPackage . Python module name and location \u00b6 The filename of the Python module is directly related to the name of Python class it provides. It should: not include the EB_ prefix of the class name for software-specific easyblocks; consists only of lower-case alphanumeric characters ( [a-z0-9] ) and underscores ( _ ); dashes ( - ) are replaced by underscores ( _ ); any other non-alphanumeric characters (incl. spaces) are simply dropped; Examples include: gcc.py (for GCC ) netcdf_fortran.py (for netCDF-Fortran ) gamess_us.py (for GAMESS (US) ) The get_module_path function provided by the EasyBuild framework in the easybuild.framework.easyconfig.easyconfig module returns the (full) module location for a particular software name or easyblock class name. For example: >>> from easybuild.framework.easyconfig.easyconfig import get_module_path >>> get_module_path ( 'netCDF-Fortran' ) 'easybuild.easyblocks.netcdf_fortran' >>> get_module_path ( 'EB_netCDF_minus_Fortran' ) 'easybuild.easyblocks.netcdf_fortran' The location of the Python module is determined by whether the easyblock is generic or software-specific. Generic easyblocks are located in the easybuid.easyblocks.generic namespace, while software-specific easyblocks live in the easybuild.easyblocks namespace directly. To keep things organised, the actual Python module files for software-specific easyblocks are kept in 'letter' subdirectories, rather than in one large ' easyblocks ' directory (see https://github.com/easybuilders/easybuild-easyblocks/tree/main/easybuild/easyblocks ), but this namespace is collapsed transparently by EasyBuild (you don't need to import from letter subpackages). To let EasyBuild pick up one or more new or customized easyblocks, you can use the --include-easyblocks configuration option. As long as both the filename of the Python module and the name of the Python class are correct, EasyBuild will use these easyblocks when needed. Structure of an easyblock \u00b6 The example below shows the overal structure of an easyblock: from easybuild.framework.easyblock import EasyBlock from easybuild.tools.run import run_cmd class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" # run configure.sh to configure the build run_cmd ( \"./configure.sh --install-prefix= %s \" % self . installdir ) Each easyblock includes an implementation of a class that (directly or indirectly) derives from the abstract EasyBlock class. Typically some useful functions provided by the EasyBuild framework are imported at the top of the Python module. In the class definition, one or more ' *_step ' methods (and perhaps a couple of others) are redefined, to implement the corresponding step in the build and installation procedure. Each easyblock must implement the configure , build and install steps, since these are not implemented in the abstract EasyBlock class. This could be done explicitly by redefining the corresponding *_step methods, or implicitly by deriving from existing (generic) easyblocks. The full list of methods that can be redefined in an easyblock can be consulted in the API documentation . Deriving from existing easyblocks \u00b6 When implementing an easyblock, it is common to derive from an existing (usually generic) easyblock, and to leverage the functionality provided by it. This approach is typically used when only a specific part of the build and installation procedure needs to be customised. In the (fictitious) example below, we derive from the generic ConfigureMake easyblock to redefine the configure step. In this case, we are extending the configure step as implemented by ConfigureMake rather than redefining it entirely, since we call out to the original configure_step method at the end. from easybuild.easyblocks.generic.configuremake import ConfigureMake from easybuild.tools.filetools import copy_file class EB_Example ( ConfigureMake ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" # use example make.cfg for x86-64 copy_file ( 'make.cfg.x86' , 'make.cfg' ) # call out to original configure_step implementation of ConfigureMake easyblock super ( EB_Example , self ) . configure_step () Easyconfig parameters \u00b6 All of the easyconfig parameters that are defined in an easyconfig file are available via the EasyConfig instance that can be accessed through self.cfg in an easyblock. For instance, if the easyconfig file specifies name = 'example' version = '2.5.3' versionsuffix = '-Python-3.7.4' then these three parameters are accessible within an easyblock via self.cfg['name'] , self.cfg['version'] and self.cfg['versionsuffix'] . A few of the most commonly used parameters can be referenced directly: self.name is equivalent with self.cfg['name'] ; self.version is equivalent with self.cfg['version'] ; self.toolchain is equivalent with self.cfg['toolchain'] ; Updating parameters \u00b6 You will often find that you need to update some easyconfig parameters in an easyblock, for example configopts which specifies options for the configure command. Because of implementation details (related to how template values like %(version)s are handled), you need to be a bit careful here... To completely redefine the value of an easyconfig parameter, you can use simple assignment. For example: self . cfg [ 'example' ] = \"A new value for the example easyconfig parameter.\" If want to add to the existing value however, you must use the self.cfg.update method. For example: self . cfg . update ( 'some_list' , 'example' ) This will not work (because self.cfg['some_list'] does not return a reference to the original value, but to a temporary copy thereof): # anti-pattern, this does NOT work as expected! self . cfg [ 'some_list' ] . append ( 'example' ) Custom parameters \u00b6 Additional custom easyconfig parameters can be defined in an easyblock to allowing steering its behaviour. This is done via the extra_options static method. Custom parameters can be specified to be mandatory. The example below shows how this can be implemented: from easybuild.easyblocks.generic.configuremake import ConfigureMake from easybuild.framework.easyconfig import CUSTOM , MANDATORY class EB_Example ( ConfigureMake ): \"\"\"Custom easyblock for Example\"\"\" @staticmethod def extra_options (): \"\"\"Custom easyconfig parameters for Example\"\"\" extra_vars = { 'required_example_param' : [ None , \"Example required custom parameter\" , MANDATORY ], 'optional_example_param' : [ None , \"Example optional custom parameter\" , CUSTOM ], } return ConfigureMake . extra_options ( extra_vars ) The first element in the list of a defined custom parameter corresponds to the default value for that parameter (both None in the example above). The second element provides some informative help text, and the last element indicates whether the parameter is mandatory ( MANDATORY ) or just an optional custom parameter ( CUSTOM ). Easyblock constructor \u00b6 In the class constructor of the easyblock, i.e. the __init__ method, one or more class variables can be initialised. These can be used for sharing information between different *_step methods in the easyblock. For example: from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Constructor for Example easyblock, initialises class variables.\"\"\" # call out to original constructor first, so 'self' (i.e. the class instance) is initialised super ( EB_Example , self ) . __init__ ( * args , ** kwargs ) # initialise class variables self . example_value = None self . example_list = [] File operations \u00b6 File operations is a common use case for implementing easyblocks, hence the EasyBuild framework provides a number of useful functions related to this, including: read_file(<path>) : read file at a specified location and returns its contents; write_file(<path>, <text>) at a specified location with provided contents; to append to an existing file, use append=True as an extra argument; copy_file(<src>, <dest>) to copy an existing file; apply_regex_substitutions(<path>, <list of regex substitutions>) to patch an existing file; All of these functions are provided by the easybuild.tools.filetools module. Executing shell commands \u00b6 For executing shell commands two functions are provided by the easybuild.tools.run module: run_cmd(<cmd>) to run a non-interactive shell command; run_cmd_qa(<cmd>, <dict with questions & answers>) to run an interactive shell command; Both of these accept a number of optional arguments: simple=True to just return True or False to indicate a successful execution, rather than the default return value, i.e., a tuple that provides the command output and the exit code (in that order); path=<path> to run the command in a specific subdirectory; The run_cmd_qa function takes two additional specific arguments: no_qa=<list> to specify a list of patterns to recognize non-questions; std_qa=<dict> to specify regular expression patterns for common questions, and the matching answer; Manipulating environment variables \u00b6 To (re)define environment variables, the setvar function provided by the easybuild.tools.environment module should be used. This makes sure that the changes being made to the specified environment variable are kept track of, and that they are handled correctly under --extended-dry-run . Logging and errors \u00b6 It is good practice to include meaningful log messages in the *_step methods being customised in the easyblock, to enrich the EasyBuild log with useful information for later debugging or diagnostics. For logging, the provided self.log logger class should be used. You can use the self.log.info method to log an informative message. Similar methods are available for logging debug messages ( self.log.debug ), which are only emitted when eb is run with debugging mode enabled ( --debug or -d ), and for logging warning messages ( self.log.warning ). If something goes wrong, you can raise an EasyBuildError instance to report the error. For example: from easybuild.framework.easyblock import EasyBlock from easybuild.tools.build_log import EasyBuildError from easybuild.tools.run import run_cmd class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" cmd = \"./configure --prefix %s \" % self . installdir ) out , ec = run_cmd ( cmd ) success = 'SUCCESS' if success in out : self . log . info ( \"Configuration command ' %s ' completed with success.\" % cmd ) else : raise EasyBuildError ( \"Pattern ' %s ' was not found in output of ' %s '.\" % ( success , cmd )) Custom sanity check \u00b6 For software-specific easyblocks, a custom sanity check is usually included to verify that the installation was successful or not. This is done by redefining the sanity_check_step method in the easyblock. For example: from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def sanity_check_step ( self ): \"\"\"Custom sanity check for Example.\"\"\" custom_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'lib/examples/' ], } custom_commands = [ 'example --version' ] # call out to parent to do the actual sanity checking, pass through custom paths and commands super ( EB_Example , self ) . sanity_check_step ( custom_paths = custom_paths , custom_commands = custom_commands ) You can both specify file paths and subdirectories to check for, which are specified relative to the installation directory, as well as simple commands that should execute successfully after completing the installation and loading the generated module file. It is up to you how extensive you make the sanity check, but it is recommended to make the check as complete as possible to catch any potential build or installation problems that may occur, while ensuring that it can run relatively quickly (in seconds, or at most a couple of minutes). Version-specific parts \u00b6 In some cases version-specific actions or checks need to be included in an easyblock. For this, it is recommended to use LooseVersion rather than directly comparing version numbers using string values. For example: from distutils.version import LooseVersion from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def sanity_check_step ( self ): \"\"\"Custom sanity check for Example.\"\"\" custom_paths = { 'files' : [], 'dirs' : [], } # in older versions, the binary used to be named 'EXAMPLE' rather than 'example' if LooseVersion ( self . version ) < LooseVersion ( '1.0' ): custom_paths [ 'files' ] . append ( 'bin/EXAMPLE' ) else : custom_paths [ 'files' ] . append ( 'bin/example' ) super ( EB_Example , self ) . sanity_check_step ( custom_paths = custom_paths ) Compatibility with --extended-dry-run and --module-only \u00b6 Some special care must be taken to ensure that an easyblock is fully compatible with --extended-dry-run / -x (see Inspecting install procedures ) and --module-only . For compatibility with --extended-dry-run , you need to take into account that specified operations like manipulating files or running shell commands will not actually be executed. You can check whether an easyblock is being run in dry run mode via self.dry_run . For example: from easybuild.framework.easyblock import EasyBlock from easybuild.tools.build_log import EasyBuildError from easybuild.tools.run import run_cmd class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" cmd = \"./configure --prefix %s \" % self . installdir ) out , ec = run_cmd ( cmd ) success = 'SUCCESS' if success in out : self . log . info ( \"Configuration command ' %s ' completed with success.\" % cmd ) # take into account that in dry run mode we won't get any output at all elif self . dry_run : self . log . info ( \"Ignoring missing ' %s ' pattern since we're running in dry run mode.\" % success ) else : raise EasyBuildError ( \"Pattern ' %s ' was not found in output of ' %s '.\" % ( success , cmd )) For --module-only , you should make sure that both the make_module_step , including the make_module_* submethods, and the sanity_check_step methods do not make any assumptions about the presence of certain environment variables, or that class variables have been defined already. This is required because under --module-only the large majority of the *_step functions are simply skipped entirely. So, if the configure_step method is responsible for defining class variables that are picked up in sanity_check_step , the latter may run into unexpected initial values like None . A possible workaround is to define a separate custom method to define the class variables, and to call out to this method from configure_step and sanity_check_step (for the latter, conditionally, i.e., only if the class variables still have the initial values). For example: from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Easyblock constructor.\"\"\" super ( EB_Example , self ) . __init__ ( * args , ** kwargs ) self . command = None def set_command ( self ): \"\"\"Initialize 'command' class variable.\"\"\" # $CC environment variable set by 'prepare' step determines exact command self . command = self . name + '-' + os . getenv ( 'CC' ) def configure_step ( self ): \"\"\"Custom configure step for Example.\"\"\" self . set_command () self . cfg . update ( 'configopts' , \"COMMAND= %s \" % self . command ) super ( EB_Example , self ) . configure_step () def sanity_check_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" if self . command is None : self . set_command () super ( EB_Example , self ) . sanity_check_step ( custom_commands = [ self . command ]) Exercise \u00b6 Exercise I.1 \u00b6 Try implementing a new custom easyblock for eb-tutorial , which derives directly from the base EasyBlock class. Your easyblock should: define a custom mandatory easyconfig parameter named message ; run cmake to configure the installation, which includes at least: specifying the correct installation prefix (using the -DCMAKE_INSTALL_PREFIX=... option); passing down the value of message easyconfig parameter via -DEBTUTORIAL_MSG=... run make to build eb-tutorial ; run make install to install the generated binary; perform a custom sanity check to ensure the installation is correct; pick up on commonly used easyconfig parameters like configopts and preinstallopts where appropriate; (click to show solution) Here's a complete custom easyblock for eb-tutorial that derives from the base EasyBlock class, which should be included in a file named eb_tutorial.py . We need to implement the configure_step , build_step , and install_step methods in order to have a fully functional easyblock. The configure, build, and install steps take into account the corresponding easyconfig parameters that allow customizing these commands from an easyconfig file. from easybuild.framework.easyblock import EasyBlock from easybuild.framework.easyconfig import MANDATORY from easybuild.tools.run import run_cmd class EB_eb_minus_tutorial ( EasyBlock ): \"\"\"Custom easyblock for eb-tutorial.\"\"\" @staticmethod def extra_options (): extra = EasyBlock . extra_options () extra . update ({ 'message' : [ None , \"Message that eb-tutorial command should print\" , MANDATORY ], }) return extra def configure_step ( self ): \"\"\"Custom configure step for eb-tutorial: define EBTUTORIAL_MSG configuration option.\"\"\" cmd = ' ' . join ([ self . cfg [ 'preconfigopts' ], \"cmake\" , \"-DCMAKE_INSTALL_PREFIX=' %s '\" % self . installdir , \"-DEBTUTORIAL_MSG=' %s '\" % self . cfg [ 'message' ], self . cfg [ 'configopts' ], ]) run_cmd ( cmd ) def build_step ( self ): \"\"\"Build step for eb-tutorial\"\"\" cmd = ' ' . join ([ self . cfg [ 'prebuildopts' ], \"make\" , self . cfg [ 'buildopts' ], ]) run_cmd ( cmd ) def install_step ( self ): \"\"\"Install step for eb-tutorial\"\"\" cmd = ' ' . join ([ self . cfg [ 'preinstallopts' ], \"make install\" , self . cfg [ 'installopts' ], ]) run_cmd ( cmd ) def sanity_check_step ( self ): custom_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } custom_commands = [ 'eb-tutorial' ] return super ( EB_eb_minus_tutorial , self ) . sanity_check_step ( custom_paths = custom_paths , custom_commands = custom_commands ) Exercise I.2 \u00b6 Try implementing another new custom easyblock for eb-tutorial , which derives from the generic CMakeMake easyblock. Your easyblock should only: define a custom mandatory easyconfig parameter named message ; pass down the value of message easyconfig parameter via -DEBTUTORIAL_MSG=... perform a custom sanity check to ensure the installation is correct; (click to show solution) When deriving from the CMakeMake generic easyblock, there is a lot less to worry about. We only need to customize the configure_step method to ensure that the -DEBTUTORIAL_MSG configuration option is specified; the CMakeMake easyblock already takes care of specifying the location of the installation directory (and a bunch of other configuration options, like compiler commands and flags, etc.). Implementing the build_step and install_step methods is no longer needed, the standard procedure that is run by the CMakeMake generic easyblock is fine, and even goes beyond what we did in the previous exercise (like building in parallel with make -j ). from easybuild.easyblocks.generic.cmakemake import CMakeMake from easybuild.framework.easyconfig import MANDATORY from easybuild.tools.run import run_cmd class EB_eb_minus_tutorial ( CMakeMake ): \"\"\"Custom easyblock for eb-tutorial.\"\"\" @staticmethod def extra_options (): extra = CMakeMake . extra_options () extra . update ({ 'message' : [ None , \"Message that eb-tutorial command should print\" , MANDATORY ], }) return extra def configure_step ( self ): \"\"\"Custom configure step for eb-tutorial: define EBTUTORIAL_MSG configuration option.\"\"\" self . cfg . update ( 'configopts' , \"-DEBTUTORIAL_MSG=' %s '\" % self . cfg [ 'message' ]) super ( EB_eb_minus_tutorial , self ) . configure_step () def sanity_check_step ( self ): custom_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } custom_commands = [ 'eb-tutorial' ] return super ( EB_eb_minus_tutorial , self ) . sanity_check_step ( custom_paths = custom_paths , custom_commands = custom_commands )","title":"Implementing easyblocks"},{"location":"2021-lust/implementing_easyblocks/#implementing-easyblocks","text":"","title":"Implementing easyblocks"},{"location":"2021-lust/implementing_easyblocks/#the-basics","text":"An easyblock is a Python module that implements a software build and installation procedure. This concept is essentially implemented as a Python script that plugs into the EasyBuild framework. EasyBuild will leverage easyblocks as needed, depending on which software packages it needs to install. Which easyblock is required is determined by the easyblock easyconfig parameter, if it is present, or by the software name.","title":"The basics"},{"location":"2021-lust/implementing_easyblocks/#generic-vs-software-specific-easyblocks","text":"Easyblocks can either be generic or software-specific . Generic easyblocks implement a \"standard\" software build and installation procedure that is used by multiple different software packages. A commonly used example is the ConfigureMake generic easyblock, which implements the standard configure - make - make install installation procedure used by most GNU software packages. Software-specific easyblocks implement the build and installation procedure for a particular software package. Typically this involves highly customised steps, for example specifying dedicated configuration options, creating or adjusting specific files, executing non-standard shell commands, etc. Usually a custom implementation of the sanity check is also included. Using a generic easyblock requires specifying the easyblock parameter in the easyconfig file. If it is not specified, EasyBuild will try and find the software-specific easyblock derived from the software name. The distinction between generic and software-specific easyblocks can be made based on the naming scheme that is used for an easyblock (see below).","title":"Generic vs software-specific easyblocks"},{"location":"2021-lust/implementing_easyblocks/#naming","text":"Easyblocks need to follow a strict naming scheme, to ensure that EasyBuild can pick them up as needed. This involves two aspects: the name of the Python class; the name and location of the Python module file.","title":"Naming"},{"location":"2021-lust/implementing_easyblocks/#python-class-name","text":"The name of the Python class is determined by the software name for software-specific easyblocks. It consists of a prefix ' EB_ ', followed by the (encoded) software name. Because of limitations in Python on characters allowed in names of Python classes, only alphanumeric characters and underscores ( _ ) are allowed. Any other characters are replaced following an encoding scheme: spaces are replaced by underscores ( _ ); dashes - are replaced by _minus_ ; underscores are replaced by _underscore_ ; The encode_class_name function provided in easybuild.tools.filetools returns the expected class name for a given software name; for example: $ python3 -c \"from easybuild.tools.filetools import encode_class_name; print(encode_class_name('netCDF-Fortran'))\" EB_netCDF_minus_Fortran Python class name for generic easyblocks For generic easyblocks, the class name does not include an EB_ prefix (since there is no need for an escaping mechanism) and hence the name is fully free to choose, taking into account the restriction to alphanumeric characters and underscores. For code style reasons, the class name should start with a capital letter and use CamelCasing. Examples include Bundle , ConfigureMake , CMakePythonPackage .","title":"Python class name"},{"location":"2021-lust/implementing_easyblocks/#python-module-name-and-location","text":"The filename of the Python module is directly related to the name of Python class it provides. It should: not include the EB_ prefix of the class name for software-specific easyblocks; consists only of lower-case alphanumeric characters ( [a-z0-9] ) and underscores ( _ ); dashes ( - ) are replaced by underscores ( _ ); any other non-alphanumeric characters (incl. spaces) are simply dropped; Examples include: gcc.py (for GCC ) netcdf_fortran.py (for netCDF-Fortran ) gamess_us.py (for GAMESS (US) ) The get_module_path function provided by the EasyBuild framework in the easybuild.framework.easyconfig.easyconfig module returns the (full) module location for a particular software name or easyblock class name. For example: >>> from easybuild.framework.easyconfig.easyconfig import get_module_path >>> get_module_path ( 'netCDF-Fortran' ) 'easybuild.easyblocks.netcdf_fortran' >>> get_module_path ( 'EB_netCDF_minus_Fortran' ) 'easybuild.easyblocks.netcdf_fortran' The location of the Python module is determined by whether the easyblock is generic or software-specific. Generic easyblocks are located in the easybuid.easyblocks.generic namespace, while software-specific easyblocks live in the easybuild.easyblocks namespace directly. To keep things organised, the actual Python module files for software-specific easyblocks are kept in 'letter' subdirectories, rather than in one large ' easyblocks ' directory (see https://github.com/easybuilders/easybuild-easyblocks/tree/main/easybuild/easyblocks ), but this namespace is collapsed transparently by EasyBuild (you don't need to import from letter subpackages). To let EasyBuild pick up one or more new or customized easyblocks, you can use the --include-easyblocks configuration option. As long as both the filename of the Python module and the name of the Python class are correct, EasyBuild will use these easyblocks when needed.","title":"Python module name and location"},{"location":"2021-lust/implementing_easyblocks/#structure-of-an-easyblock","text":"The example below shows the overal structure of an easyblock: from easybuild.framework.easyblock import EasyBlock from easybuild.tools.run import run_cmd class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" # run configure.sh to configure the build run_cmd ( \"./configure.sh --install-prefix= %s \" % self . installdir ) Each easyblock includes an implementation of a class that (directly or indirectly) derives from the abstract EasyBlock class. Typically some useful functions provided by the EasyBuild framework are imported at the top of the Python module. In the class definition, one or more ' *_step ' methods (and perhaps a couple of others) are redefined, to implement the corresponding step in the build and installation procedure. Each easyblock must implement the configure , build and install steps, since these are not implemented in the abstract EasyBlock class. This could be done explicitly by redefining the corresponding *_step methods, or implicitly by deriving from existing (generic) easyblocks. The full list of methods that can be redefined in an easyblock can be consulted in the API documentation .","title":"Structure of an easyblock"},{"location":"2021-lust/implementing_easyblocks/#deriving-from-existing-easyblocks","text":"When implementing an easyblock, it is common to derive from an existing (usually generic) easyblock, and to leverage the functionality provided by it. This approach is typically used when only a specific part of the build and installation procedure needs to be customised. In the (fictitious) example below, we derive from the generic ConfigureMake easyblock to redefine the configure step. In this case, we are extending the configure step as implemented by ConfigureMake rather than redefining it entirely, since we call out to the original configure_step method at the end. from easybuild.easyblocks.generic.configuremake import ConfigureMake from easybuild.tools.filetools import copy_file class EB_Example ( ConfigureMake ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" # use example make.cfg for x86-64 copy_file ( 'make.cfg.x86' , 'make.cfg' ) # call out to original configure_step implementation of ConfigureMake easyblock super ( EB_Example , self ) . configure_step ()","title":"Deriving from existing easyblocks"},{"location":"2021-lust/implementing_easyblocks/#easyconfig-parameters","text":"All of the easyconfig parameters that are defined in an easyconfig file are available via the EasyConfig instance that can be accessed through self.cfg in an easyblock. For instance, if the easyconfig file specifies name = 'example' version = '2.5.3' versionsuffix = '-Python-3.7.4' then these three parameters are accessible within an easyblock via self.cfg['name'] , self.cfg['version'] and self.cfg['versionsuffix'] . A few of the most commonly used parameters can be referenced directly: self.name is equivalent with self.cfg['name'] ; self.version is equivalent with self.cfg['version'] ; self.toolchain is equivalent with self.cfg['toolchain'] ;","title":"Easyconfig parameters"},{"location":"2021-lust/implementing_easyblocks/#updating-parameters","text":"You will often find that you need to update some easyconfig parameters in an easyblock, for example configopts which specifies options for the configure command. Because of implementation details (related to how template values like %(version)s are handled), you need to be a bit careful here... To completely redefine the value of an easyconfig parameter, you can use simple assignment. For example: self . cfg [ 'example' ] = \"A new value for the example easyconfig parameter.\" If want to add to the existing value however, you must use the self.cfg.update method. For example: self . cfg . update ( 'some_list' , 'example' ) This will not work (because self.cfg['some_list'] does not return a reference to the original value, but to a temporary copy thereof): # anti-pattern, this does NOT work as expected! self . cfg [ 'some_list' ] . append ( 'example' )","title":"Updating parameters"},{"location":"2021-lust/implementing_easyblocks/#custom-parameters","text":"Additional custom easyconfig parameters can be defined in an easyblock to allowing steering its behaviour. This is done via the extra_options static method. Custom parameters can be specified to be mandatory. The example below shows how this can be implemented: from easybuild.easyblocks.generic.configuremake import ConfigureMake from easybuild.framework.easyconfig import CUSTOM , MANDATORY class EB_Example ( ConfigureMake ): \"\"\"Custom easyblock for Example\"\"\" @staticmethod def extra_options (): \"\"\"Custom easyconfig parameters for Example\"\"\" extra_vars = { 'required_example_param' : [ None , \"Example required custom parameter\" , MANDATORY ], 'optional_example_param' : [ None , \"Example optional custom parameter\" , CUSTOM ], } return ConfigureMake . extra_options ( extra_vars ) The first element in the list of a defined custom parameter corresponds to the default value for that parameter (both None in the example above). The second element provides some informative help text, and the last element indicates whether the parameter is mandatory ( MANDATORY ) or just an optional custom parameter ( CUSTOM ).","title":"Custom parameters"},{"location":"2021-lust/implementing_easyblocks/#easyblock-constructor","text":"In the class constructor of the easyblock, i.e. the __init__ method, one or more class variables can be initialised. These can be used for sharing information between different *_step methods in the easyblock. For example: from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Constructor for Example easyblock, initialises class variables.\"\"\" # call out to original constructor first, so 'self' (i.e. the class instance) is initialised super ( EB_Example , self ) . __init__ ( * args , ** kwargs ) # initialise class variables self . example_value = None self . example_list = []","title":"Easyblock constructor"},{"location":"2021-lust/implementing_easyblocks/#file-operations","text":"File operations is a common use case for implementing easyblocks, hence the EasyBuild framework provides a number of useful functions related to this, including: read_file(<path>) : read file at a specified location and returns its contents; write_file(<path>, <text>) at a specified location with provided contents; to append to an existing file, use append=True as an extra argument; copy_file(<src>, <dest>) to copy an existing file; apply_regex_substitutions(<path>, <list of regex substitutions>) to patch an existing file; All of these functions are provided by the easybuild.tools.filetools module.","title":"File operations"},{"location":"2021-lust/implementing_easyblocks/#executing-shell-commands","text":"For executing shell commands two functions are provided by the easybuild.tools.run module: run_cmd(<cmd>) to run a non-interactive shell command; run_cmd_qa(<cmd>, <dict with questions & answers>) to run an interactive shell command; Both of these accept a number of optional arguments: simple=True to just return True or False to indicate a successful execution, rather than the default return value, i.e., a tuple that provides the command output and the exit code (in that order); path=<path> to run the command in a specific subdirectory; The run_cmd_qa function takes two additional specific arguments: no_qa=<list> to specify a list of patterns to recognize non-questions; std_qa=<dict> to specify regular expression patterns for common questions, and the matching answer;","title":"Executing shell commands"},{"location":"2021-lust/implementing_easyblocks/#manipulating-environment-variables","text":"To (re)define environment variables, the setvar function provided by the easybuild.tools.environment module should be used. This makes sure that the changes being made to the specified environment variable are kept track of, and that they are handled correctly under --extended-dry-run .","title":"Manipulating environment variables"},{"location":"2021-lust/implementing_easyblocks/#logging-and-errors","text":"It is good practice to include meaningful log messages in the *_step methods being customised in the easyblock, to enrich the EasyBuild log with useful information for later debugging or diagnostics. For logging, the provided self.log logger class should be used. You can use the self.log.info method to log an informative message. Similar methods are available for logging debug messages ( self.log.debug ), which are only emitted when eb is run with debugging mode enabled ( --debug or -d ), and for logging warning messages ( self.log.warning ). If something goes wrong, you can raise an EasyBuildError instance to report the error. For example: from easybuild.framework.easyblock import EasyBlock from easybuild.tools.build_log import EasyBuildError from easybuild.tools.run import run_cmd class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" cmd = \"./configure --prefix %s \" % self . installdir ) out , ec = run_cmd ( cmd ) success = 'SUCCESS' if success in out : self . log . info ( \"Configuration command ' %s ' completed with success.\" % cmd ) else : raise EasyBuildError ( \"Pattern ' %s ' was not found in output of ' %s '.\" % ( success , cmd ))","title":"Logging and errors"},{"location":"2021-lust/implementing_easyblocks/#custom-sanity-check","text":"For software-specific easyblocks, a custom sanity check is usually included to verify that the installation was successful or not. This is done by redefining the sanity_check_step method in the easyblock. For example: from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def sanity_check_step ( self ): \"\"\"Custom sanity check for Example.\"\"\" custom_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'lib/examples/' ], } custom_commands = [ 'example --version' ] # call out to parent to do the actual sanity checking, pass through custom paths and commands super ( EB_Example , self ) . sanity_check_step ( custom_paths = custom_paths , custom_commands = custom_commands ) You can both specify file paths and subdirectories to check for, which are specified relative to the installation directory, as well as simple commands that should execute successfully after completing the installation and loading the generated module file. It is up to you how extensive you make the sanity check, but it is recommended to make the check as complete as possible to catch any potential build or installation problems that may occur, while ensuring that it can run relatively quickly (in seconds, or at most a couple of minutes).","title":"Custom sanity check"},{"location":"2021-lust/implementing_easyblocks/#version-specific-parts","text":"In some cases version-specific actions or checks need to be included in an easyblock. For this, it is recommended to use LooseVersion rather than directly comparing version numbers using string values. For example: from distutils.version import LooseVersion from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def sanity_check_step ( self ): \"\"\"Custom sanity check for Example.\"\"\" custom_paths = { 'files' : [], 'dirs' : [], } # in older versions, the binary used to be named 'EXAMPLE' rather than 'example' if LooseVersion ( self . version ) < LooseVersion ( '1.0' ): custom_paths [ 'files' ] . append ( 'bin/EXAMPLE' ) else : custom_paths [ 'files' ] . append ( 'bin/example' ) super ( EB_Example , self ) . sanity_check_step ( custom_paths = custom_paths )","title":"Version-specific parts"},{"location":"2021-lust/implementing_easyblocks/#compatibility-with-extended-dry-run-and-module-only","text":"Some special care must be taken to ensure that an easyblock is fully compatible with --extended-dry-run / -x (see Inspecting install procedures ) and --module-only . For compatibility with --extended-dry-run , you need to take into account that specified operations like manipulating files or running shell commands will not actually be executed. You can check whether an easyblock is being run in dry run mode via self.dry_run . For example: from easybuild.framework.easyblock import EasyBlock from easybuild.tools.build_log import EasyBuildError from easybuild.tools.run import run_cmd class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def configure_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" cmd = \"./configure --prefix %s \" % self . installdir ) out , ec = run_cmd ( cmd ) success = 'SUCCESS' if success in out : self . log . info ( \"Configuration command ' %s ' completed with success.\" % cmd ) # take into account that in dry run mode we won't get any output at all elif self . dry_run : self . log . info ( \"Ignoring missing ' %s ' pattern since we're running in dry run mode.\" % success ) else : raise EasyBuildError ( \"Pattern ' %s ' was not found in output of ' %s '.\" % ( success , cmd )) For --module-only , you should make sure that both the make_module_step , including the make_module_* submethods, and the sanity_check_step methods do not make any assumptions about the presence of certain environment variables, or that class variables have been defined already. This is required because under --module-only the large majority of the *_step functions are simply skipped entirely. So, if the configure_step method is responsible for defining class variables that are picked up in sanity_check_step , the latter may run into unexpected initial values like None . A possible workaround is to define a separate custom method to define the class variables, and to call out to this method from configure_step and sanity_check_step (for the latter, conditionally, i.e., only if the class variables still have the initial values). For example: from easybuild.framework.easyblock import EasyBlock class EB_Example ( EasyBlock ): \"\"\"Custom easyblock for Example\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Easyblock constructor.\"\"\" super ( EB_Example , self ) . __init__ ( * args , ** kwargs ) self . command = None def set_command ( self ): \"\"\"Initialize 'command' class variable.\"\"\" # $CC environment variable set by 'prepare' step determines exact command self . command = self . name + '-' + os . getenv ( 'CC' ) def configure_step ( self ): \"\"\"Custom configure step for Example.\"\"\" self . set_command () self . cfg . update ( 'configopts' , \"COMMAND= %s \" % self . command ) super ( EB_Example , self ) . configure_step () def sanity_check_step ( self ): \"\"\"Custom implementation of configure step for Example\"\"\" if self . command is None : self . set_command () super ( EB_Example , self ) . sanity_check_step ( custom_commands = [ self . command ])","title":"Compatibility with --extended-dry-run and --module-only"},{"location":"2021-lust/implementing_easyblocks/#exercise","text":"","title":"Exercise"},{"location":"2021-lust/implementing_easyblocks/#exercise-i1","text":"Try implementing a new custom easyblock for eb-tutorial , which derives directly from the base EasyBlock class. Your easyblock should: define a custom mandatory easyconfig parameter named message ; run cmake to configure the installation, which includes at least: specifying the correct installation prefix (using the -DCMAKE_INSTALL_PREFIX=... option); passing down the value of message easyconfig parameter via -DEBTUTORIAL_MSG=... run make to build eb-tutorial ; run make install to install the generated binary; perform a custom sanity check to ensure the installation is correct; pick up on commonly used easyconfig parameters like configopts and preinstallopts where appropriate; (click to show solution) Here's a complete custom easyblock for eb-tutorial that derives from the base EasyBlock class, which should be included in a file named eb_tutorial.py . We need to implement the configure_step , build_step , and install_step methods in order to have a fully functional easyblock. The configure, build, and install steps take into account the corresponding easyconfig parameters that allow customizing these commands from an easyconfig file. from easybuild.framework.easyblock import EasyBlock from easybuild.framework.easyconfig import MANDATORY from easybuild.tools.run import run_cmd class EB_eb_minus_tutorial ( EasyBlock ): \"\"\"Custom easyblock for eb-tutorial.\"\"\" @staticmethod def extra_options (): extra = EasyBlock . extra_options () extra . update ({ 'message' : [ None , \"Message that eb-tutorial command should print\" , MANDATORY ], }) return extra def configure_step ( self ): \"\"\"Custom configure step for eb-tutorial: define EBTUTORIAL_MSG configuration option.\"\"\" cmd = ' ' . join ([ self . cfg [ 'preconfigopts' ], \"cmake\" , \"-DCMAKE_INSTALL_PREFIX=' %s '\" % self . installdir , \"-DEBTUTORIAL_MSG=' %s '\" % self . cfg [ 'message' ], self . cfg [ 'configopts' ], ]) run_cmd ( cmd ) def build_step ( self ): \"\"\"Build step for eb-tutorial\"\"\" cmd = ' ' . join ([ self . cfg [ 'prebuildopts' ], \"make\" , self . cfg [ 'buildopts' ], ]) run_cmd ( cmd ) def install_step ( self ): \"\"\"Install step for eb-tutorial\"\"\" cmd = ' ' . join ([ self . cfg [ 'preinstallopts' ], \"make install\" , self . cfg [ 'installopts' ], ]) run_cmd ( cmd ) def sanity_check_step ( self ): custom_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } custom_commands = [ 'eb-tutorial' ] return super ( EB_eb_minus_tutorial , self ) . sanity_check_step ( custom_paths = custom_paths , custom_commands = custom_commands )","title":"Exercise I.1"},{"location":"2021-lust/implementing_easyblocks/#exercise-i2","text":"Try implementing another new custom easyblock for eb-tutorial , which derives from the generic CMakeMake easyblock. Your easyblock should only: define a custom mandatory easyconfig parameter named message ; pass down the value of message easyconfig parameter via -DEBTUTORIAL_MSG=... perform a custom sanity check to ensure the installation is correct; (click to show solution) When deriving from the CMakeMake generic easyblock, there is a lot less to worry about. We only need to customize the configure_step method to ensure that the -DEBTUTORIAL_MSG configuration option is specified; the CMakeMake easyblock already takes care of specifying the location of the installation directory (and a bunch of other configuration options, like compiler commands and flags, etc.). Implementing the build_step and install_step methods is no longer needed, the standard procedure that is run by the CMakeMake generic easyblock is fine, and even goes beyond what we did in the previous exercise (like building in parallel with make -j ). from easybuild.easyblocks.generic.cmakemake import CMakeMake from easybuild.framework.easyconfig import MANDATORY from easybuild.tools.run import run_cmd class EB_eb_minus_tutorial ( CMakeMake ): \"\"\"Custom easyblock for eb-tutorial.\"\"\" @staticmethod def extra_options (): extra = CMakeMake . extra_options () extra . update ({ 'message' : [ None , \"Message that eb-tutorial command should print\" , MANDATORY ], }) return extra def configure_step ( self ): \"\"\"Custom configure step for eb-tutorial: define EBTUTORIAL_MSG configuration option.\"\"\" self . cfg . update ( 'configopts' , \"-DEBTUTORIAL_MSG=' %s '\" % self . cfg [ 'message' ]) super ( EB_eb_minus_tutorial , self ) . configure_step () def sanity_check_step ( self ): custom_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } custom_commands = [ 'eb-tutorial' ] return super ( EB_eb_minus_tutorial , self ) . sanity_check_step ( custom_paths = custom_paths , custom_commands = custom_commands )","title":"Exercise I.2"},{"location":"2021-lust/installation/","text":"Installing EasyBuild \u00b6 [back: Terminology] Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary Requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended). Installation methods : pip install easybuild installing EasyBuild with EasyBuild development setup Verify EasyBuild installation using eb --version and eb --help . Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed via $EB_PYTHON . Installing EasyBuild \u00b6 We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip Method 2: installing EasyBuild with EasyBuild Method 3: Development setup Method 1: Using pip \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). pip vs pip3 \u00b6 On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. If you want to ensure that you are using the pip installation that corresponds to the Python 3 installation that you intend to use, you can use python3 -m pip rather than pip3 . Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, or if you installed EasyBuild with a pip version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). Updating $PATH \u00b6 Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). This is not required if you installing EasyBuild in a standard system location. You can check with the which eb command to determine whether or not you need to update the $PATH environment variable. Updating $PYTHONPATH \u00b6 If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 3.6, make sure you are using /python3.6/ in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH Setting $EB_PYTHON \u00b6 If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. This may be required when you installing EasyBuild with a version of pip that does not correspond with the default Python version. For example, to ensure that eb uses python3.6 : export EB_PYTHON = python3.6 Setting $EB_VERBOSE \u00b6 To determine which python commands are being considered by the eb command, you can define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3.6' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3.6 ) >> python3.6 -m easybuild.main --version This is EasyBuild 4 .3.3 ( framework: 4 .3.3, easyblocks: 4 .3.3 ) on host example Method 2: Installing EasyBuild with EasyBuild \u00b6 Note This section covers an alternative method for installing EasyBuild. If you already have EasyBuild installed through pip , you can skip ahead to the next section . If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps: Step 1: Installing EasyBuild with pip into a temporary location (only needed if EasyBuild is not installed yet) Step 2: Using EasyBuild to install EasyBuild as a module Step 3: Loading the EasyBuild module Note A bootstrap script is available that automates this procedure, but is known to be problematic in some contexts, and is not being actively maintained anymore. As a result, we do not recommend using the bootstrap script anymore. Step 1: Installing EasyBuild into a temporary location \u00b6 If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using pip . For example, to install EasyBuild into a subdirectory /tmp/$USER using the default Python 3 version: # pick installation prefix, and install EasyBuild into it export EB_TMPDIR = /tmp/ $USER /eb_tmp python3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild # update environment to use this temporary EasyBuild installation export PATH = $EB_TMPDIR /bin: $PATH export PYTHONPATH = $( /bin/ls -rtd -1 $EB_TMPDIR /lib*/python*/site-packages | tail -1 ) : $PYTHONPATH export EB_PYTHON = python3 Step 2: Using EasyBuild to install EasyBuild \u00b6 Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too. You can use the eb --install-latest-eb-release command for this, combined with the --prefix option to control which directories are used by EasyBuild for the installation. For example, to install the latest version of EasyBuild as a module into $HOME/easybuild : eb --install-latest-eb-release --prefix $HOME /easybuild Note You may see a harmless deprecation warning popping up when performing this installation, just ignore it. Step 3: Loading the EasyBuild module \u00b6 Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' with the path to the directory that you used when running step 2 (for example, $HOME/easybuild ). Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made. Method 3: Development setup \u00b6 If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there. This can be done as follows (into $HOME/easybuild ): mkdir -p $HOME /easybuild cd $HOME /easybuild # clone EasyBuild repositories from GitHub git clone https://github.com/easybuilders/easybuild-framework.git git clone https://github.com/easybuilders/easybuild-easyblocks.git git clone https://github.com/easybuilders/easybuild-easyconfigs.git # update environment for running EasyBuild from there export PATH = $HOME /easybuild/easybuild-framework: $PATH export PYTHONPATH = $HOME /easybuild/easybuild-framework: $HOME /easybuild/easybuild-easyblocks: $HOME /easybuild/easybuild-easyconfigs: $PYTHONPATH # control which Python command is used to run EasyBuild export EB_PYTHON = python3 Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial . System information \u00b6 You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. If you have installed EasyBuild through pip , and you prefer updating that installation, you can use pip install --upgrade easybuild (perhaps with additional options like --user or --prefix ). Exercise \u00b6 Install EasyBuild in your home directory. Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure, or try all these installation methods! install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option; perform a (manual) \"bootstrap\" installation into $HOME/easybuild , as outlined in installation method 2 ; set up a development installation; Check that the installation works by running the verification commands outlined above . Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial! [next: Configuring EasyBuild]","title":"Installation"},{"location":"2021-lust/installation/#installing-easybuild","text":"[back: Terminology] Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary Requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended). Installation methods : pip install easybuild installing EasyBuild with EasyBuild development setup Verify EasyBuild installation using eb --version and eb --help .","title":"Installing EasyBuild"},{"location":"2021-lust/installation/#requirements","text":"","title":"Requirements"},{"location":"2021-lust/installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project.","title":"Linux"},{"location":"2021-lust/installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.","title":"Python"},{"location":"2021-lust/installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"2021-lust/installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"2021-lust/installation/#python-2-or-python-3","text":"For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed via $EB_PYTHON .","title":"Python 2 or Python 3?"},{"location":"2021-lust/installation/#installing-easybuild_1","text":"We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip Method 2: installing EasyBuild with EasyBuild Method 3: Development setup","title":"Installing EasyBuild"},{"location":"2021-lust/installation/#method-1-using-pip","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip"},{"location":"2021-lust/installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"2021-lust/installation/#pip-vs-pip3","text":"On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. If you want to ensure that you are using the pip installation that corresponds to the Python 3 installation that you intend to use, you can use python3 -m pip rather than pip3 .","title":"pip vs pip3"},{"location":"2021-lust/installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, or if you installed EasyBuild with a pip version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example).","title":"Updating your environment"},{"location":"2021-lust/installation/#updating-path","text":"Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). This is not required if you installing EasyBuild in a standard system location. You can check with the which eb command to determine whether or not you need to update the $PATH environment variable.","title":"Updating $PATH"},{"location":"2021-lust/installation/#updating-pythonpath","text":"If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 3.6, make sure you are using /python3.6/ in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH","title":"Updating $PYTHONPATH"},{"location":"2021-lust/installation/#setting-eb_python","text":"If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. This may be required when you installing EasyBuild with a version of pip that does not correspond with the default Python version. For example, to ensure that eb uses python3.6 : export EB_PYTHON = python3.6","title":"Setting $EB_PYTHON"},{"location":"2021-lust/installation/#setting-eb_verbose","text":"To determine which python commands are being considered by the eb command, you can define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3.6' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3.6 ) >> python3.6 -m easybuild.main --version This is EasyBuild 4 .3.3 ( framework: 4 .3.3, easyblocks: 4 .3.3 ) on host example","title":"Setting $EB_VERBOSE"},{"location":"2021-lust/installation/#method-2-installing-easybuild-with-easybuild","text":"Note This section covers an alternative method for installing EasyBuild. If you already have EasyBuild installed through pip , you can skip ahead to the next section . If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps: Step 1: Installing EasyBuild with pip into a temporary location (only needed if EasyBuild is not installed yet) Step 2: Using EasyBuild to install EasyBuild as a module Step 3: Loading the EasyBuild module Note A bootstrap script is available that automates this procedure, but is known to be problematic in some contexts, and is not being actively maintained anymore. As a result, we do not recommend using the bootstrap script anymore.","title":"Method 2: Installing EasyBuild with EasyBuild"},{"location":"2021-lust/installation/#step-1-installing-easybuild-into-a-temporary-location","text":"If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using pip . For example, to install EasyBuild into a subdirectory /tmp/$USER using the default Python 3 version: # pick installation prefix, and install EasyBuild into it export EB_TMPDIR = /tmp/ $USER /eb_tmp python3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild # update environment to use this temporary EasyBuild installation export PATH = $EB_TMPDIR /bin: $PATH export PYTHONPATH = $( /bin/ls -rtd -1 $EB_TMPDIR /lib*/python*/site-packages | tail -1 ) : $PYTHONPATH export EB_PYTHON = python3","title":"Step 1: Installing EasyBuild into a temporary location"},{"location":"2021-lust/installation/#step-2-using-easybuild-to-install-easybuild","text":"Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too. You can use the eb --install-latest-eb-release command for this, combined with the --prefix option to control which directories are used by EasyBuild for the installation. For example, to install the latest version of EasyBuild as a module into $HOME/easybuild : eb --install-latest-eb-release --prefix $HOME /easybuild Note You may see a harmless deprecation warning popping up when performing this installation, just ignore it.","title":"Step 2: Using EasyBuild to install EasyBuild"},{"location":"2021-lust/installation/#step-3-loading-the-easybuild-module","text":"Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' with the path to the directory that you used when running step 2 (for example, $HOME/easybuild ). Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made.","title":"Step 3: Loading the EasyBuild module"},{"location":"2021-lust/installation/#method-3-development-setup","text":"If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there. This can be done as follows (into $HOME/easybuild ): mkdir -p $HOME /easybuild cd $HOME /easybuild # clone EasyBuild repositories from GitHub git clone https://github.com/easybuilders/easybuild-framework.git git clone https://github.com/easybuilders/easybuild-easyblocks.git git clone https://github.com/easybuilders/easybuild-easyconfigs.git # update environment for running EasyBuild from there export PATH = $HOME /easybuild/easybuild-framework: $PATH export PYTHONPATH = $HOME /easybuild/easybuild-framework: $HOME /easybuild/easybuild-easyblocks: $HOME /easybuild/easybuild-easyconfigs: $PYTHONPATH # control which Python command is used to run EasyBuild export EB_PYTHON = python3","title":"Method 3: Development setup"},{"location":"2021-lust/installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"2021-lust/installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"2021-lust/installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"2021-lust/installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial .","title":"Showing the default EasyBuild configuration"},{"location":"2021-lust/installation/#system-information","text":"You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info","title":"System information"},{"location":"2021-lust/installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. If you have installed EasyBuild through pip , and you prefer updating that installation, you can use pip install --upgrade easybuild (perhaps with additional options like --user or --prefix ).","title":"Updating EasyBuild"},{"location":"2021-lust/installation/#exercise","text":"Install EasyBuild in your home directory. Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure, or try all these installation methods! install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option; perform a (manual) \"bootstrap\" installation into $HOME/easybuild , as outlined in installation method 2 ; set up a development installation; Check that the installation works by running the verification commands outlined above . Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial! [next: Configuring EasyBuild]","title":"Exercise"},{"location":"2021-lust/module_naming_schemes/","text":"Module naming schemes \u00b6 Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing h5py-3.1.0-foss-2020b.eb the generated module was named h5py/3.1.0-foss-2020b . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. We will also take a quick look at implementing our own custom module naming scheme. Flat vs hierarchical \u00b6 The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These correspond to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a (compiler-only) toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installed using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy. Pros & cons \u00b6 So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users; Length of module names \u00b6 When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean! Amount of available modules \u00b6 The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands... This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded. Loading compatible modules \u00b6 Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful... In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily. Visibility of existing modules \u00b6 One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file. Semantics of gateway modules \u00b6 An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy. Using a custom module naming scheme \u00b6 Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it. Implementation \u00b6 To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general ModuleNamingScheme class. For a flat module naming scheme, it is sufficient to implement the det_full_module_name method, which should return a string value (the full module name). You may also need to customize the is_short_modname_for method, which verifies whether a given (short) module name is for the software with a particular given name (or not). The argument provided to det_full_module_name can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters ( name , version , toolchain , and versionsuffix ), or an EasyConfig instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters. For simple module naming schemes, just have name , version , toolchain , and versionsuffix available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant REQUIRED_KEYS . A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme EasyBuildMNS . For a hierarchical module naming scheme, various additional methods have to be implemented. Some of these, like det_module_subdir and det_short_module_name , determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like det_modpath_extensions , determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the $MODULEPATH ). A typical example of a hierarchical module naming scheme is HierarchicalMNS that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional Core - Compiler - MPI module hierarchy we discussed above. Configuring EasyBuild \u00b6 To let EasyBuild use a custom module naming scheme, you need to: specify the path to the Python module file implementing it via the include-module-naming-schemes EasyBuild configuration option; indicate that you also want to use this custom module naming scheme via the module-naming-scheme EasyBuild configuration option. For example: export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES = $HOME /easybuild/example_mns.py export EASYBUILD_MODULE_NAMING_SCHEME = ExampleMNS Example custom module naming scheme \u00b6 Here is an example of a custom module naming scheme, where: the versionsuffix goes directly after the version ; all dashes are replaced by underscores; all module names are lowercase; Note that we also need to customise the is_short_modname_for method, to make sure it returns True when the EasyBuild framework checks whether scipy_bundle/2020.11_foss_2020b is a module name for SciPy-bundle . import os from easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme class ExampleMNS ( ModuleNamingScheme ): REQUIRED_KEYS = [ 'name' , 'version' , 'versionsuffix' , 'toolchain' ] def det_full_module_name ( self , ec ): \"\"\" Determine full module name: - all lowercase - replace all dashes with underscores \"\"\" parts = [ ec [ 'version' ]] # versionsuffix directly after version (but only if it's not empty) if ec [ 'versionsuffix' ]: parts . append ( ec [ 'versionsuffix' ]) # only add toolchain name/version for non-system toolchain tc = ec [ 'toolchain' ] if tc [ 'name' ] . lower () != 'system' : parts . extend ([ tc [ 'name' ], tc [ 'version' ]]) modname = ec [ 'name' ] + '/' + '_' . join ( parts ) modname = modname . replace ( '-' , '_' ) . replace ( '__' , '_' ) return modname . lower () def is_short_modname_for ( self , short_modname , name ): \"\"\"Determine whether short module name is a module for the software with specified name.\"\"\" return short_modname . startswith ( name . lower () . replace ( '-' , '_' ) + '/' ) We can see what the module names with this module naming scheme would like like via eb -D : $ eb SciPy-bundle-2020.11-foss-2020b-Python-2.7.18.eb -D ... * [ ] $CFGS/g/GCC/GCC-10.2.0.eb (module: gcc/10.2.0) ... * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-10.2.0.eb (module: python/2.7.18_gcccore_10.2.0) ... * [ ] $CFGS/o/OpenMPI/OpenMPI-4.0.5-GCC-10.2.0.eb (module: openmpi/4.0.5_gcc_10.2.0) ... * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2020.03-foss-2020a-Python-2.7.18.eb (module: scipy_bundle/2020.03_python_2.7.18_foss_2020a) Example module hierarchy: HDF5 \u00b6 Warning This exercise will only work if you have write access to the software installation prefix , because EasyBuild will try to copy the installation log file to each installlation directory. Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations. Preparing the environment \u00b6 Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/10.2.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 Configuring EasyBuild \u00b6 First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example. Generating modules for HDF5 \u00b6 Let us now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.7-gompi-2020b.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.7-gompi-2020b.eb --robot --module-only ... == building and installing MPI/GCC/10.2.0/OpenMPI/4.0.5/HDF5/1.10.7... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 41 out of 41 This should take a couple of minutes in total, for generating 41 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation... Loading the HDF5 module \u00b6 After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let us see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 binutils/2.35 gompi/2020b zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let us see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.7\" module is available to load. GCC/10.2.0 OpenMPI/4.0.5 This tells us we need to load two gateway modules before we can load the module for HDF5. Let us start with loading the GCC compiler module: module load GCC/10.2.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 -------------- OpenMPI/4.0.5 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/10.2.0 ------------ Autoconf/2.69 UCX/1.9.0 libpciaccess/0.16 ... Szip/2.1.1 libfabric/1.11.0 zlib/1.2.11 (L,D) Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 (L) binutils/2.35 gompi/2020b zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/10.2.0 and Compiler/GCC/10.2.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 10.2.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.5 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/10.2.0 and OpenMPI/4.0.5 modules first. So, let us do exactly that (remember that GCC/10.2.0 is already loaded): module load OpenMPI/4.0.5 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.7 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------- HDF5/1.10.7 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 ------------ OpenMPI/4.0.5 (L) ... To use HDF5, we need to load this HDF5/1.10.7 module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.7 $ h5dump --version h5dump: Version 1.10.7 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/10.2.0 5 ) numactl/2.0.13 9 ) hwloc/2.2.0 13 ) PMIx/3.1.5 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) libevent/2.1.12 14 ) OpenMPI/4.0.5 3 ) binutils/2.35 7 ) libxml2/2.9.10 11 ) UCX/1.9.0 15 ) Szip/2.1.1 4 ) GCC/10.2.0 8 ) libpciaccess/0.16 12 ) libfabric/1.11.0 16 ) HDF5/1.10.7 Exercise \u00b6 Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.11-foss-2020b.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.11-foss-2020b.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.11-foss-2020b.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.11 Load the gateway modules: module load GCC/10.2.0 OpenMPI/4.0.5 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------ SciPy-bundle/2020.11 module load SciPy-bundle/2020.11 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.1.4 Warning This exercise will only work if you have write access to the software installation prefix , because EasyBuild will try to copy the installation log file to each installlation directory.","title":"Module naming schemes (incl. hierarchical)"},{"location":"2021-lust/module_naming_schemes/#module-naming-schemes","text":"Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing h5py-3.1.0-foss-2020b.eb the generated module was named h5py/3.1.0-foss-2020b . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. We will also take a quick look at implementing our own custom module naming scheme.","title":"Module naming schemes"},{"location":"2021-lust/module_naming_schemes/#flat-vs-hierarchical","text":"The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These correspond to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a (compiler-only) toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installed using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.","title":"Flat vs hierarchical"},{"location":"2021-lust/module_naming_schemes/#pros-cons","text":"So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users;","title":"Pros &amp; cons"},{"location":"2021-lust/module_naming_schemes/#length-of-module-names","text":"When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean!","title":"Length of module names"},{"location":"2021-lust/module_naming_schemes/#amount-of-available-modules","text":"The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands... This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded.","title":"Amount of available modules"},{"location":"2021-lust/module_naming_schemes/#loading-compatible-modules","text":"Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful... In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily.","title":"Loading compatible modules"},{"location":"2021-lust/module_naming_schemes/#visibility-of-existing-modules","text":"One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.","title":"Visibility of existing modules"},{"location":"2021-lust/module_naming_schemes/#semantics-of-gateway-modules","text":"An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy.","title":"Semantics of gateway modules"},{"location":"2021-lust/module_naming_schemes/#using-a-custom-module-naming-scheme","text":"Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it.","title":"Using a custom module naming scheme"},{"location":"2021-lust/module_naming_schemes/#implementation","text":"To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general ModuleNamingScheme class. For a flat module naming scheme, it is sufficient to implement the det_full_module_name method, which should return a string value (the full module name). You may also need to customize the is_short_modname_for method, which verifies whether a given (short) module name is for the software with a particular given name (or not). The argument provided to det_full_module_name can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters ( name , version , toolchain , and versionsuffix ), or an EasyConfig instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters. For simple module naming schemes, just have name , version , toolchain , and versionsuffix available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant REQUIRED_KEYS . A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme EasyBuildMNS . For a hierarchical module naming scheme, various additional methods have to be implemented. Some of these, like det_module_subdir and det_short_module_name , determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like det_modpath_extensions , determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the $MODULEPATH ). A typical example of a hierarchical module naming scheme is HierarchicalMNS that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional Core - Compiler - MPI module hierarchy we discussed above.","title":"Implementation"},{"location":"2021-lust/module_naming_schemes/#configuring-easybuild","text":"To let EasyBuild use a custom module naming scheme, you need to: specify the path to the Python module file implementing it via the include-module-naming-schemes EasyBuild configuration option; indicate that you also want to use this custom module naming scheme via the module-naming-scheme EasyBuild configuration option. For example: export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES = $HOME /easybuild/example_mns.py export EASYBUILD_MODULE_NAMING_SCHEME = ExampleMNS","title":"Configuring EasyBuild"},{"location":"2021-lust/module_naming_schemes/#example-custom-module-naming-scheme","text":"Here is an example of a custom module naming scheme, where: the versionsuffix goes directly after the version ; all dashes are replaced by underscores; all module names are lowercase; Note that we also need to customise the is_short_modname_for method, to make sure it returns True when the EasyBuild framework checks whether scipy_bundle/2020.11_foss_2020b is a module name for SciPy-bundle . import os from easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme class ExampleMNS ( ModuleNamingScheme ): REQUIRED_KEYS = [ 'name' , 'version' , 'versionsuffix' , 'toolchain' ] def det_full_module_name ( self , ec ): \"\"\" Determine full module name: - all lowercase - replace all dashes with underscores \"\"\" parts = [ ec [ 'version' ]] # versionsuffix directly after version (but only if it's not empty) if ec [ 'versionsuffix' ]: parts . append ( ec [ 'versionsuffix' ]) # only add toolchain name/version for non-system toolchain tc = ec [ 'toolchain' ] if tc [ 'name' ] . lower () != 'system' : parts . extend ([ tc [ 'name' ], tc [ 'version' ]]) modname = ec [ 'name' ] + '/' + '_' . join ( parts ) modname = modname . replace ( '-' , '_' ) . replace ( '__' , '_' ) return modname . lower () def is_short_modname_for ( self , short_modname , name ): \"\"\"Determine whether short module name is a module for the software with specified name.\"\"\" return short_modname . startswith ( name . lower () . replace ( '-' , '_' ) + '/' ) We can see what the module names with this module naming scheme would like like via eb -D : $ eb SciPy-bundle-2020.11-foss-2020b-Python-2.7.18.eb -D ... * [ ] $CFGS/g/GCC/GCC-10.2.0.eb (module: gcc/10.2.0) ... * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-10.2.0.eb (module: python/2.7.18_gcccore_10.2.0) ... * [ ] $CFGS/o/OpenMPI/OpenMPI-4.0.5-GCC-10.2.0.eb (module: openmpi/4.0.5_gcc_10.2.0) ... * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2020.03-foss-2020a-Python-2.7.18.eb (module: scipy_bundle/2020.03_python_2.7.18_foss_2020a)","title":"Example custom module naming scheme"},{"location":"2021-lust/module_naming_schemes/#example-module-hierarchy-hdf5","text":"Warning This exercise will only work if you have write access to the software installation prefix , because EasyBuild will try to copy the installation log file to each installlation directory. Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.","title":"Example module hierarchy: HDF5"},{"location":"2021-lust/module_naming_schemes/#preparing-the-environment","text":"Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/10.2.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3","title":"Preparing the environment"},{"location":"2021-lust/module_naming_schemes/#configuring-easybuild_1","text":"First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example.","title":"Configuring EasyBuild"},{"location":"2021-lust/module_naming_schemes/#generating-modules-for-hdf5","text":"Let us now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.7-gompi-2020b.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.7-gompi-2020b.eb --robot --module-only ... == building and installing MPI/GCC/10.2.0/OpenMPI/4.0.5/HDF5/1.10.7... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 41 out of 41 This should take a couple of minutes in total, for generating 41 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...","title":"Generating modules for HDF5"},{"location":"2021-lust/module_naming_schemes/#loading-the-hdf5-module","text":"After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let us see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 binutils/2.35 gompi/2020b zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let us see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.7\" module is available to load. GCC/10.2.0 OpenMPI/4.0.5 This tells us we need to load two gateway modules before we can load the module for HDF5. Let us start with loading the GCC compiler module: module load GCC/10.2.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 -------------- OpenMPI/4.0.5 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/10.2.0 ------------ Autoconf/2.69 UCX/1.9.0 libpciaccess/0.16 ... Szip/2.1.1 libfabric/1.11.0 zlib/1.2.11 (L,D) Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.5.3 GCCcore/10.2.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.7.1 (D) M4/1.4.18 gettext/0.21 ncurses/6.2 GCC/10.2.0 (L) binutils/2.35 gompi/2020b zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/10.2.0 and Compiler/GCC/10.2.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 10.2.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.5 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/10.2.0 and OpenMPI/4.0.5 modules first. So, let us do exactly that (remember that GCC/10.2.0 is already loaded): module load OpenMPI/4.0.5 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.7 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------- HDF5/1.10.7 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 ------------ OpenMPI/4.0.5 (L) ... To use HDF5, we need to load this HDF5/1.10.7 module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.7 $ h5dump --version h5dump: Version 1.10.7 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/10.2.0 5 ) numactl/2.0.13 9 ) hwloc/2.2.0 13 ) PMIx/3.1.5 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) libevent/2.1.12 14 ) OpenMPI/4.0.5 3 ) binutils/2.35 7 ) libxml2/2.9.10 11 ) UCX/1.9.0 15 ) Szip/2.1.1 4 ) GCC/10.2.0 8 ) libpciaccess/0.16 12 ) libfabric/1.11.0 16 ) HDF5/1.10.7","title":"Loading the HDF5 module"},{"location":"2021-lust/module_naming_schemes/#exercise","text":"Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.11-foss-2020b.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.11-foss-2020b.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.11-foss-2020b.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.11 Load the gateway modules: module load GCC/10.2.0 OpenMPI/4.0.5 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------ SciPy-bundle/2020.11 module load SciPy-bundle/2020.11 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.1.4 Warning This exercise will only work if you have write access to the software installation prefix , because EasyBuild will try to copy the installation log file to each installlation directory.","title":"Exercise"},{"location":"2021-lust/part1_intro/","text":"Part I: Introduction to EasyBuild \u00b6 [back to start page] (Tue March 4th 2021, 9am-12 CET) What is EasyBuild? Terminology Installation (hands-on) Configuration (hands-on) Basic usage (hands-on)","title":"(overview)"},{"location":"2021-lust/part1_intro/#part-i-introduction-to-easybuild","text":"[back to start page] (Tue March 4th 2021, 9am-12 CET) What is EasyBuild? Terminology Installation (hands-on) Configuration (hands-on) Basic usage (hands-on)","title":"Part I: Introduction to EasyBuild"},{"location":"2021-lust/part2_using/","text":"Part II: Using EasyBuild \u00b6 [back to start page] (Tue March 23rd 2021, 9am-12 CET) Troubleshooting (hands-on) Creating easyconfig files (hands-on) Implementing easyblocks (hands-on)","title":"(overview)"},{"location":"2021-lust/part2_using/#part-ii-using-easybuild","text":"[back to start page] (Tue March 23rd 2021, 9am-12 CET) Troubleshooting (hands-on) Creating easyconfig files (hands-on) Implementing easyblocks (hands-on)","title":"Part II: Using EasyBuild"},{"location":"2021-lust/part3_advanced/","text":"Part III: Advanced topics \u00b6 [back to start page] (Tue March 30th 2021, 9am-12 CET) Using EasyBuild as a library (hands-on) Using hooks to customise EasyBuild (hands-on) Submitting installations as Slurm jobs (hands-on) Module naming schemes (incl. hierarchical) (hands-on) GitHub integration to facilitate contributing to EasyBuild (hands-on)","title":"(overview)"},{"location":"2021-lust/part3_advanced/#part-iii-advanced-topics","text":"[back to start page] (Tue March 30th 2021, 9am-12 CET) Using EasyBuild as a library (hands-on) Using hooks to customise EasyBuild (hands-on) Submitting installations as Slurm jobs (hands-on) Module naming schemes (incl. hierarchical) (hands-on) GitHub integration to facilitate contributing to EasyBuild (hands-on)","title":"Part III: Advanced topics"},{"location":"2021-lust/part4_cray/","text":"Part IV: EasyBuild on Cray systems \u00b6 [back to start page] How to use EasyBuild on Cray systems (Friday June 18th 2021, 09-12 CEST) Introduction to Cray Programming Environment (hands-on) Using external modules (hands-on) Custom Cray toolchains (hands-on) EasyBuild at CSCS (hands-on)","title":"(overview)"},{"location":"2021-lust/part4_cray/#part-iv-easybuild-on-cray-systems","text":"[back to start page] How to use EasyBuild on Cray systems (Friday June 18th 2021, 09-12 CEST) Introduction to Cray Programming Environment (hands-on) Using external modules (hands-on) Custom Cray toolchains (hands-on) EasyBuild at CSCS (hands-on)","title":"Part IV: EasyBuild on Cray systems"},{"location":"2021-lust/slurm_jobs/","text":"Submitting installations as Slurm jobs \u00b6 EasyBuild can submit jobs to different backends including Slurm to install software, to distribute the often time-consuming installation of a set of software applications and the dependencies they require to a cluster. This is done via the --job command line option. It is important to be aware of some details before you start using this, which we'll cover here. Configuration \u00b6 The EasyBuild configuration that is active at the time that eb --job is used will be passed down into the submitted job automatically, via command line options to the eb command that is run in the job script. This includes not only command line options used next to --job , but also configuration settings that are specified via an EasyBuild configuration file or through $EASYBUILD_* environment variables . This implies that any EasyBuild configuration files or $EASYBUILD_* environment variables that are in place in the job environment are most likely irrelevant , since configuration settings they specify they will most likely be overruled by the corresponding command line options. Using eb --job \u00b6 Job backend \u00b6 The default job backend in EasyBuild v4.x is GC3Pie . To let EasyBuild submit jobs to Slurm instead, you should set the job-backend configuration setting to Slurm , for example by setting the corresponding environment variable: export EASYBUILD_JOB_BACKEND = 'Slurm' Job resources \u00b6 To submit an installation as a job, simply use eb --job : eb example.eb --job By default, EasyBuild will submit single-core jobs requesting for 24 hours of walltime. You can tweak the requested resources via the job-cores and job-max-walltime configuration options. For example: # submit job to install example, using 5 cores and 2 hours of max. walltime eb example.eb --job --job-cores 5 --job-max-walltime 2 Note that not all job-* configuration settings apply to all job backends, see the EasyBuild documentation for more details. Controlling Slurm submission options \u00b6 When using Slurm as a job backend, EasyBuild will automatically generate job scripts which use the eb command to perform a single installation. These scripts will be submitted using the sbatch command. EasyBuild currently doesn't provide away to customize the Slurm submission options, for example to submit to a particular partition, or to use a particular account, build you can set the corresponding $SBATCH_* environment variables prior to running eb --job . For example, to specify a particular account that should be used for the jobs submitted by EasyBuild (equivalent with using the -A or --account command line option for sbatch ): export SBATCH_ACCOUNT = 'example_project' Or to submit to a particular Slurm partition (equivalent with the -p or --partition option for sbatch ): export SBATCH_PARTITION = 'example_partition' For more information about supported $SBATCH_* environment variables, see the Slurm documentation . Combining --job and --robot \u00b6 If one or more dependencies are still missing for the software you want to install, you can combine --job and --robot to get EasyBuild to submit a separate job for each of the installations. These jobs will not --robot , they will each only perform a single installation. Dependencies between jobs will be \"registered\" at submission time, so Slurm will put jobs on hold until the jobs that install the required (build) dependencies have completed successfully, and cancel jobs if the job to install a dependency failed for some reason. Attention points \u00b6 There are a couple of important things to keep an eye on when submitting installations as jobs... Differences on cluster workernodes \u00b6 Sometimes the resources available on the login nodes and cluster workernodes are slightly different, and you may need to take this into account in your EasyBuild configuration. For example, plenty of disk space may be available in the /tmp temporary filesystem on a login node, while the workernodes require you to use a different location for temporary files and directories. As a result, you may need to slightly change your EasyBuild configuration when submitting installations as jobs, to avoid that they fail almost instantly due to a lack of disk space. Keep in mind that the active EasyBuild configuration is passed down into the submitted jobs, so any configuration that is present on the workernodes may not have any effect. For example, if you commonly use /tmp/$USER for build directories on a login node, you may need to tweak that when submitting jobs to use a different location: # EasByuild is configured to use /tmp/$USER on the login node login01 $ eb --show-config | grep buildpath buildpath ( E ) = /tmp/example # use /localdisk/$USER for build directories when submitting installations as jobs login01 $ eb --job --buildpath /localdisk/ $USER example.eb --robot Temporary log files and build directories \u00b6 The temporary log file that EasyBuild creates is most likely going to end up on the local disk of the workernode on which the job was started (by default in $TMPDIR or /tmp ). If an installation fails, the job will finish and temporary files will likely be cleaned up instantly, which may leave you wondering about the actual cause of the failing installation... To remedy this, there are a couple of EasyBuild configuration options you can use: You can use --tmp-logdir to specify a different location where EasyBuild should store temporary log files, for example: $ eb --job example.eb --tmp-logdir $HOME /eb_tmplogs If you prefer having the entire log file stored in the Slurm job output files, you can use --logtostdout when submitting the jobs. This will result in extensive logging to your terminal window when submitting the jobs, but it will also make EasyBuild log to stdout when the installation is running in the job, and hence the log messages will be captured in the job output files. The same remark applies to build directories: they should be on a local filesystem (to avoid problems that often occur when building software on a parallel filesystem like GPFS or Lustre), which will probably be cleaned up automatically when a job fails. Here it is less easy to provide general advice on how to deal with this, but one thing you can consider is retrying the installation in an interactive job, so you can inspect the build directory after the installation fails. Lock files \u00b6 EasyBuild creates locks to prevent that the same installation is started multiple times on different system to the same installation directory. If an installation fails or gets interrupted, EasyBuild cleans up those locks automatically. However, if a Slurm job that is using EasyBuild to install software gets cancelled (because it ran out of walltime, tried to consume too much memory, through an scancel command, etc.), EasyBuild will not get the chance to clean up the lock file. If this occurs you will need to either clean up the lock file (which is located in the software/.locks subdirectory of installpath ) manually, or re-submit the job with eb --job --ignore-locks . Example \u00b6 As an example, we will let EasyBuild submit jobs to install AUGUSTUS with the foss/2020b toolchain. Configuration \u00b6 Before using --job , let's make sure that EasyBuild is properly configured: # use $HOME/easybuild for software, modules, sources, etc. export EASYBUILD_PREFIX = $HOME /easybuild # use ramdisk for build directories export EASYBUILD_BUILDPATH = /dev/shm/ $USER # use Slurm as job backend export EASYBUILD_JOB_BACKEND = Slurm In addition, add the path to the centrally installed software to $MODULEPATH via module use : module use /easybuild/modules/all Load the EasyBuild module: module load EasyBuild Let's assume that we also need to inform Slurm that jobs should be submitted into a particular account: export SBATCH_ACCOUNT = example_project This will be picked up by the sbatch commands that EasyBuild will run to submit the software installation jobs. Submitting jobs to install AUGUSTUS \u00b6 Now we can let EasyBuild submit jobs for AUGUSTUS. Let's first check what is still missing: $ eb AUGUSTUS-3.4.0-foss-2020b.eb --missing ... 11 out of 61 required modules missing: * HTSlib/1.11-GCC-10.2.0 ( HTSlib-1.11-GCC-10.2.0.eb ) * lpsolve/5.5.2.11-GCC-10.2.0 ( lpsolve-5.5.2.11-GCC-10.2.0.eb ) * Boost/1.74.0-GCC-10.2.0 ( Boost-1.74.0-GCC-10.2.0.eb ) * GSL/2.6-GCC-10.2.0 ( GSL-2.6-GCC-10.2.0.eb ) * SAMtools/1.11-GCC-10.2.0 ( SAMtools-1.11-GCC-10.2.0.eb ) * BCFtools/1.11-GCC-10.2.0 ( BCFtools-1.11-GCC-10.2.0.eb ) * METIS/5.1.0-GCCcore-10.2.0 ( METIS-5.1.0-GCCcore-10.2.0.eb ) * BamTools/2.5.1-GCC-10.2.0 ( BamTools-2.5.1-GCC-10.2.0.eb ) * MPFR/4.1.0-GCCcore-10.2.0 ( MPFR-4.1.0-GCCcore-10.2.0.eb ) * SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0 ( SuiteSparse-5.8.1-foss-2020b-METIS-5.1.0.eb ) * AUGUSTUS/3.4.0-foss-2020b ( AUGUSTUS-3.4.0-foss-2020b.eb ) Several dependencies are not installed yet, so we will need to use --robot to ensure that EasyBuild also submits jobs to install these first. To speed up the installations a bit, we will request 10 cores for each submitted job (via --job-cores ). That should be sufficient to let each installation finish in (well) under 1 hour, so we only request 1 hour of walltime per job (via --job-max-walltime ). In order to have some meaningful job output files, we also enable trace mode (via --trace ). $ eb AUGUSTUS-3.4.0-foss-2020b.eb --job --job-cores 10 --job-max-walltime 1 --robot --trace ... == resolving dependencies ... ... == List of submitted jobs (11): Boost-1.74.0-GCC-10.2.0 (Boost/1.74.0-GCC-10.2.0): 1000011; GSL-2.6-GCC-10.2.0 (GSL/2.6-GCC-10.2.0): 1000004; SAMtools-1.11-GCC-10.2.0 (SAMtools/1.11-GCC-10.2.0): 1000005; HTSlib-1.11-GCC-10.2.0 (HTSlib/1.11-GCC-10.2.0): 1000006; BCFtools-1.11-GCC-10.2.0 (BCFtools/1.11-GCC-10.2.0): 1000001; lpsolve-5.5.2.11-GCC-10.2.0 (lpsolve/5.5.2.11-GCC-10.2.0): 1000007; BamTools-2.5.1-GCC-10.2.0 (BamTools/2.5.1-GCC-10.2.0): 1000008; METIS-5.1.0-GCCcore-10.2.0 (METIS/5.1.0-GCCcore-10.2.0): 1000009; MPFR-4.1.0-GCCcore-10.2.0 (MPFR/4.1.0-GCCcore-10.2.0): 1000010; SuiteSparse-5.8.1-foss-2020b-METIS-5.1.0 (SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0): 1000002; AUGUSTUS-3.4.0-foss-2020b (AUGUSTUS/3.4.0-foss-2020b): 1000003 == Submitted parallel build jobs, exiting now Inspecting the submitted jobs \u00b6 Once EasyBuild has submitted the jobs, we can inspect them via Slurm's squeue command: $ squeue -u $USER -la JOBID PARTITION NAME USER STATE TIME TIME_LIMI NODES NODELIST(REASON) 1000001 small BCFtools user123 PENDING 0:00 2:00:00 1 (Dependency) 1000002 small SuiteSpa user123 PENDING 0:00 2:00:00 1 (Dependency) 1000003 small AUGUSTUS user123 PENDING 0:00 2:00:00 1 (Dependency) 1000004 small GSL-2.6- user123 RUNNING 0:21 2:00:00 1 node003 1000005 small SAMtools user123 RUNNING 0:21 2:00:00 1 node007 1000006 small HTSlib-1 user123 RUNNING 0:21 2:00:00 1 node007 1000007 small lpsolve- user123 RUNNING 0:21 2:00:00 1 node011 1000008 small BamTools user123 RUNNING 0:21 2:00:00 1 node011 1000009 small METIS-5. user123 RUNNING 0:21 2:00:00 1 node013 1000010 small MPFR-4.1 user123 RUNNING 0:21 2:00:00 1 node029 1000011 small Boost-1. user123 RUNNING 0:24 2:00:00 1 node029 Note that 3 jobs can not be started yet, because those installations require on one or more missing dependencies. As soon as the jobs for those dependencies (successfully) complete, these jobs will be able to start. Final result \u00b6 After about 20 minutes, AUGUSTUS and all missing dependencies should be installed: $ ls -lrt $HOME/easybuild/modules/all/*/*.lua | tail -11 -rw-rw----. 1 example example 1634 Mar 29 10:13 /users/example/easybuild/modules/all/HTSlib/1.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1792 Mar 29 10:13 /users/example/easybuild/modules/all/SAMtools/1.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1147 Mar 29 10:13 /users/example/easybuild/modules/all/BamTools/2.5.1-GCC-10.2.0.lua -rw-rw----. 1 example example 957 Mar 29 10:13 /users/example/easybuild/modules/all/lpsolve/5.5.2.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1549 Mar 29 10:13 /users/example/easybuild/modules/all/METIS/5.1.0-GCCcore-10.2.0.lua -rw-rw----. 1 example example 1525 Mar 29 10:14 /users/example/easybuild/modules/all/GSL/2.6-GCC-10.2.0.lua -rw-rw----. 1 example example 1221 Mar 29 10:15 /users/example/easybuild/modules/all/MPFR/4.1.0-GCCcore-10.2.0.lua -rw-rw----. 1 example example 1678 Mar 29 10:15 /users/example/easybuild/modules/all/BCFtools/1.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1292 Mar 29 10:21 /users/example/easybuild/modules/all/Boost/1.74.0-GCC-10.2.0.lua -rw-rw----. 1 example example 1365 Mar 29 10:28 /users/example/easybuild/modules/all/SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0.lua -rw-rw----. 1 example example 2233 Mar 29 10:30 /users/example/easybuild/modules/all/AUGUSTUS/3.4.0-foss-2020b.lua $ module use $HOME/easybuild/modules/all $ module avail AUGUSTUS -------- /users/hkenneth/easybuild/modules/all -------- AUGUSTUS/3.4.0-foss-2020b","title":"Submitting installations as Slurm jobs"},{"location":"2021-lust/slurm_jobs/#submitting-installations-as-slurm-jobs","text":"EasyBuild can submit jobs to different backends including Slurm to install software, to distribute the often time-consuming installation of a set of software applications and the dependencies they require to a cluster. This is done via the --job command line option. It is important to be aware of some details before you start using this, which we'll cover here.","title":"Submitting installations as Slurm jobs"},{"location":"2021-lust/slurm_jobs/#configuration","text":"The EasyBuild configuration that is active at the time that eb --job is used will be passed down into the submitted job automatically, via command line options to the eb command that is run in the job script. This includes not only command line options used next to --job , but also configuration settings that are specified via an EasyBuild configuration file or through $EASYBUILD_* environment variables . This implies that any EasyBuild configuration files or $EASYBUILD_* environment variables that are in place in the job environment are most likely irrelevant , since configuration settings they specify they will most likely be overruled by the corresponding command line options.","title":"Configuration"},{"location":"2021-lust/slurm_jobs/#using-eb-job","text":"","title":"Using eb --job"},{"location":"2021-lust/slurm_jobs/#job-backend","text":"The default job backend in EasyBuild v4.x is GC3Pie . To let EasyBuild submit jobs to Slurm instead, you should set the job-backend configuration setting to Slurm , for example by setting the corresponding environment variable: export EASYBUILD_JOB_BACKEND = 'Slurm'","title":"Job backend"},{"location":"2021-lust/slurm_jobs/#job-resources","text":"To submit an installation as a job, simply use eb --job : eb example.eb --job By default, EasyBuild will submit single-core jobs requesting for 24 hours of walltime. You can tweak the requested resources via the job-cores and job-max-walltime configuration options. For example: # submit job to install example, using 5 cores and 2 hours of max. walltime eb example.eb --job --job-cores 5 --job-max-walltime 2 Note that not all job-* configuration settings apply to all job backends, see the EasyBuild documentation for more details.","title":"Job resources"},{"location":"2021-lust/slurm_jobs/#controlling-slurm-submission-options","text":"When using Slurm as a job backend, EasyBuild will automatically generate job scripts which use the eb command to perform a single installation. These scripts will be submitted using the sbatch command. EasyBuild currently doesn't provide away to customize the Slurm submission options, for example to submit to a particular partition, or to use a particular account, build you can set the corresponding $SBATCH_* environment variables prior to running eb --job . For example, to specify a particular account that should be used for the jobs submitted by EasyBuild (equivalent with using the -A or --account command line option for sbatch ): export SBATCH_ACCOUNT = 'example_project' Or to submit to a particular Slurm partition (equivalent with the -p or --partition option for sbatch ): export SBATCH_PARTITION = 'example_partition' For more information about supported $SBATCH_* environment variables, see the Slurm documentation .","title":"Controlling Slurm submission options"},{"location":"2021-lust/slurm_jobs/#combining-job-and-robot","text":"If one or more dependencies are still missing for the software you want to install, you can combine --job and --robot to get EasyBuild to submit a separate job for each of the installations. These jobs will not --robot , they will each only perform a single installation. Dependencies between jobs will be \"registered\" at submission time, so Slurm will put jobs on hold until the jobs that install the required (build) dependencies have completed successfully, and cancel jobs if the job to install a dependency failed for some reason.","title":"Combining --job and --robot"},{"location":"2021-lust/slurm_jobs/#attention-points","text":"There are a couple of important things to keep an eye on when submitting installations as jobs...","title":"Attention points"},{"location":"2021-lust/slurm_jobs/#differences-on-cluster-workernodes","text":"Sometimes the resources available on the login nodes and cluster workernodes are slightly different, and you may need to take this into account in your EasyBuild configuration. For example, plenty of disk space may be available in the /tmp temporary filesystem on a login node, while the workernodes require you to use a different location for temporary files and directories. As a result, you may need to slightly change your EasyBuild configuration when submitting installations as jobs, to avoid that they fail almost instantly due to a lack of disk space. Keep in mind that the active EasyBuild configuration is passed down into the submitted jobs, so any configuration that is present on the workernodes may not have any effect. For example, if you commonly use /tmp/$USER for build directories on a login node, you may need to tweak that when submitting jobs to use a different location: # EasByuild is configured to use /tmp/$USER on the login node login01 $ eb --show-config | grep buildpath buildpath ( E ) = /tmp/example # use /localdisk/$USER for build directories when submitting installations as jobs login01 $ eb --job --buildpath /localdisk/ $USER example.eb --robot","title":"Differences on cluster workernodes"},{"location":"2021-lust/slurm_jobs/#temporary-log-files-and-build-directories","text":"The temporary log file that EasyBuild creates is most likely going to end up on the local disk of the workernode on which the job was started (by default in $TMPDIR or /tmp ). If an installation fails, the job will finish and temporary files will likely be cleaned up instantly, which may leave you wondering about the actual cause of the failing installation... To remedy this, there are a couple of EasyBuild configuration options you can use: You can use --tmp-logdir to specify a different location where EasyBuild should store temporary log files, for example: $ eb --job example.eb --tmp-logdir $HOME /eb_tmplogs If you prefer having the entire log file stored in the Slurm job output files, you can use --logtostdout when submitting the jobs. This will result in extensive logging to your terminal window when submitting the jobs, but it will also make EasyBuild log to stdout when the installation is running in the job, and hence the log messages will be captured in the job output files. The same remark applies to build directories: they should be on a local filesystem (to avoid problems that often occur when building software on a parallel filesystem like GPFS or Lustre), which will probably be cleaned up automatically when a job fails. Here it is less easy to provide general advice on how to deal with this, but one thing you can consider is retrying the installation in an interactive job, so you can inspect the build directory after the installation fails.","title":"Temporary log files and build directories"},{"location":"2021-lust/slurm_jobs/#lock-files","text":"EasyBuild creates locks to prevent that the same installation is started multiple times on different system to the same installation directory. If an installation fails or gets interrupted, EasyBuild cleans up those locks automatically. However, if a Slurm job that is using EasyBuild to install software gets cancelled (because it ran out of walltime, tried to consume too much memory, through an scancel command, etc.), EasyBuild will not get the chance to clean up the lock file. If this occurs you will need to either clean up the lock file (which is located in the software/.locks subdirectory of installpath ) manually, or re-submit the job with eb --job --ignore-locks .","title":"Lock files"},{"location":"2021-lust/slurm_jobs/#example","text":"As an example, we will let EasyBuild submit jobs to install AUGUSTUS with the foss/2020b toolchain.","title":"Example"},{"location":"2021-lust/slurm_jobs/#configuration_1","text":"Before using --job , let's make sure that EasyBuild is properly configured: # use $HOME/easybuild for software, modules, sources, etc. export EASYBUILD_PREFIX = $HOME /easybuild # use ramdisk for build directories export EASYBUILD_BUILDPATH = /dev/shm/ $USER # use Slurm as job backend export EASYBUILD_JOB_BACKEND = Slurm In addition, add the path to the centrally installed software to $MODULEPATH via module use : module use /easybuild/modules/all Load the EasyBuild module: module load EasyBuild Let's assume that we also need to inform Slurm that jobs should be submitted into a particular account: export SBATCH_ACCOUNT = example_project This will be picked up by the sbatch commands that EasyBuild will run to submit the software installation jobs.","title":"Configuration"},{"location":"2021-lust/slurm_jobs/#submitting-jobs-to-install-augustus","text":"Now we can let EasyBuild submit jobs for AUGUSTUS. Let's first check what is still missing: $ eb AUGUSTUS-3.4.0-foss-2020b.eb --missing ... 11 out of 61 required modules missing: * HTSlib/1.11-GCC-10.2.0 ( HTSlib-1.11-GCC-10.2.0.eb ) * lpsolve/5.5.2.11-GCC-10.2.0 ( lpsolve-5.5.2.11-GCC-10.2.0.eb ) * Boost/1.74.0-GCC-10.2.0 ( Boost-1.74.0-GCC-10.2.0.eb ) * GSL/2.6-GCC-10.2.0 ( GSL-2.6-GCC-10.2.0.eb ) * SAMtools/1.11-GCC-10.2.0 ( SAMtools-1.11-GCC-10.2.0.eb ) * BCFtools/1.11-GCC-10.2.0 ( BCFtools-1.11-GCC-10.2.0.eb ) * METIS/5.1.0-GCCcore-10.2.0 ( METIS-5.1.0-GCCcore-10.2.0.eb ) * BamTools/2.5.1-GCC-10.2.0 ( BamTools-2.5.1-GCC-10.2.0.eb ) * MPFR/4.1.0-GCCcore-10.2.0 ( MPFR-4.1.0-GCCcore-10.2.0.eb ) * SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0 ( SuiteSparse-5.8.1-foss-2020b-METIS-5.1.0.eb ) * AUGUSTUS/3.4.0-foss-2020b ( AUGUSTUS-3.4.0-foss-2020b.eb ) Several dependencies are not installed yet, so we will need to use --robot to ensure that EasyBuild also submits jobs to install these first. To speed up the installations a bit, we will request 10 cores for each submitted job (via --job-cores ). That should be sufficient to let each installation finish in (well) under 1 hour, so we only request 1 hour of walltime per job (via --job-max-walltime ). In order to have some meaningful job output files, we also enable trace mode (via --trace ). $ eb AUGUSTUS-3.4.0-foss-2020b.eb --job --job-cores 10 --job-max-walltime 1 --robot --trace ... == resolving dependencies ... ... == List of submitted jobs (11): Boost-1.74.0-GCC-10.2.0 (Boost/1.74.0-GCC-10.2.0): 1000011; GSL-2.6-GCC-10.2.0 (GSL/2.6-GCC-10.2.0): 1000004; SAMtools-1.11-GCC-10.2.0 (SAMtools/1.11-GCC-10.2.0): 1000005; HTSlib-1.11-GCC-10.2.0 (HTSlib/1.11-GCC-10.2.0): 1000006; BCFtools-1.11-GCC-10.2.0 (BCFtools/1.11-GCC-10.2.0): 1000001; lpsolve-5.5.2.11-GCC-10.2.0 (lpsolve/5.5.2.11-GCC-10.2.0): 1000007; BamTools-2.5.1-GCC-10.2.0 (BamTools/2.5.1-GCC-10.2.0): 1000008; METIS-5.1.0-GCCcore-10.2.0 (METIS/5.1.0-GCCcore-10.2.0): 1000009; MPFR-4.1.0-GCCcore-10.2.0 (MPFR/4.1.0-GCCcore-10.2.0): 1000010; SuiteSparse-5.8.1-foss-2020b-METIS-5.1.0 (SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0): 1000002; AUGUSTUS-3.4.0-foss-2020b (AUGUSTUS/3.4.0-foss-2020b): 1000003 == Submitted parallel build jobs, exiting now","title":"Submitting jobs to install AUGUSTUS"},{"location":"2021-lust/slurm_jobs/#inspecting-the-submitted-jobs","text":"Once EasyBuild has submitted the jobs, we can inspect them via Slurm's squeue command: $ squeue -u $USER -la JOBID PARTITION NAME USER STATE TIME TIME_LIMI NODES NODELIST(REASON) 1000001 small BCFtools user123 PENDING 0:00 2:00:00 1 (Dependency) 1000002 small SuiteSpa user123 PENDING 0:00 2:00:00 1 (Dependency) 1000003 small AUGUSTUS user123 PENDING 0:00 2:00:00 1 (Dependency) 1000004 small GSL-2.6- user123 RUNNING 0:21 2:00:00 1 node003 1000005 small SAMtools user123 RUNNING 0:21 2:00:00 1 node007 1000006 small HTSlib-1 user123 RUNNING 0:21 2:00:00 1 node007 1000007 small lpsolve- user123 RUNNING 0:21 2:00:00 1 node011 1000008 small BamTools user123 RUNNING 0:21 2:00:00 1 node011 1000009 small METIS-5. user123 RUNNING 0:21 2:00:00 1 node013 1000010 small MPFR-4.1 user123 RUNNING 0:21 2:00:00 1 node029 1000011 small Boost-1. user123 RUNNING 0:24 2:00:00 1 node029 Note that 3 jobs can not be started yet, because those installations require on one or more missing dependencies. As soon as the jobs for those dependencies (successfully) complete, these jobs will be able to start.","title":"Inspecting the submitted jobs"},{"location":"2021-lust/slurm_jobs/#final-result","text":"After about 20 minutes, AUGUSTUS and all missing dependencies should be installed: $ ls -lrt $HOME/easybuild/modules/all/*/*.lua | tail -11 -rw-rw----. 1 example example 1634 Mar 29 10:13 /users/example/easybuild/modules/all/HTSlib/1.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1792 Mar 29 10:13 /users/example/easybuild/modules/all/SAMtools/1.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1147 Mar 29 10:13 /users/example/easybuild/modules/all/BamTools/2.5.1-GCC-10.2.0.lua -rw-rw----. 1 example example 957 Mar 29 10:13 /users/example/easybuild/modules/all/lpsolve/5.5.2.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1549 Mar 29 10:13 /users/example/easybuild/modules/all/METIS/5.1.0-GCCcore-10.2.0.lua -rw-rw----. 1 example example 1525 Mar 29 10:14 /users/example/easybuild/modules/all/GSL/2.6-GCC-10.2.0.lua -rw-rw----. 1 example example 1221 Mar 29 10:15 /users/example/easybuild/modules/all/MPFR/4.1.0-GCCcore-10.2.0.lua -rw-rw----. 1 example example 1678 Mar 29 10:15 /users/example/easybuild/modules/all/BCFtools/1.11-GCC-10.2.0.lua -rw-rw----. 1 example example 1292 Mar 29 10:21 /users/example/easybuild/modules/all/Boost/1.74.0-GCC-10.2.0.lua -rw-rw----. 1 example example 1365 Mar 29 10:28 /users/example/easybuild/modules/all/SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0.lua -rw-rw----. 1 example example 2233 Mar 29 10:30 /users/example/easybuild/modules/all/AUGUSTUS/3.4.0-foss-2020b.lua $ module use $HOME/easybuild/modules/all $ module avail AUGUSTUS -------- /users/hkenneth/easybuild/modules/all -------- AUGUSTUS/3.4.0-foss-2020b","title":"Final result"},{"location":"2021-lust/terminology/","text":"Terminology \u00b6 [back: What is EasyBuild?] Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms, so we'll briefly cover them one by one. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.toolchains , easybuild.tools , etc.) that collectively form the core of EasyBuild , and is developed in the easybuild-framework repository on GitHub . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this. Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure , and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , WRF , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file . A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the easybuild-easyblocks repository on GitHub . Easyconfig parameters \u00b6 An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild. Some easyconfig parameters are mandatory . The following parameters must be defined in every easyconfig file: name and version , which specify the name and version of the software to install; homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional : they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock. Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used for the installation; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If no value is specified for an optional easyconfig parameter, the corresponding default value will be used. There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software. Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation. The filename of an easyconfig file usually ends with the .eb extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: name , version , toolchain and versionsuffix . The general format for the filename of an easyconfig file is: <name>-<version><toolchain>-<versionsuffix>.eb , where the toolchain part is omitted when a system toolchain is used, and the <versionsuffix> can be empty. The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive. In the easybuild-easyconfigs repository on GitHub , the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software. Easystack files \u00b6 Easystack files are a new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild. They are written in YAML syntax , and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels. The support for using easystack files is currently marked as experimental , which means it is subject to change in future EasyBuild releases, and may be prone to errors. Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Common examples are Python packages , R libraries , and Perl modules . As you can tell the common terminology here is a bit messy, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone , as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation); Dependencies \u00b6 A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software (examples: CMake , pkg-config ); a run-time dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package (example: Python ); a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed (example: OpenBLAS ); The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). System toolchain \u00b6 The system toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system , rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation. Common toolchains \u00b6 The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , OpenBLAS , ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation . Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files which each define a set of easyconfig parameters . EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. An easystack file can be used to specify a collection of software to install with EasyBuild. [next: Installation]","title":"Terminology"},{"location":"2021-lust/terminology/#terminology","text":"[back: What is EasyBuild?] Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms, so we'll briefly cover them one by one.","title":"Terminology"},{"location":"2021-lust/terminology/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.toolchains , easybuild.tools , etc.) that collectively form the core of EasyBuild , and is developed in the easybuild-framework repository on GitHub . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this.","title":"Framework"},{"location":"2021-lust/terminology/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure , and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , WRF , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file . A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the easybuild-easyblocks repository on GitHub .","title":"Easyblocks"},{"location":"2021-lust/terminology/#easyconfig-parameters","text":"An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild. Some easyconfig parameters are mandatory . The following parameters must be defined in every easyconfig file: name and version , which specify the name and version of the software to install; homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional : they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock. Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used for the installation; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If no value is specified for an optional easyconfig parameter, the corresponding default value will be used. There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software.","title":"Easyconfig parameters"},{"location":"2021-lust/terminology/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation. The filename of an easyconfig file usually ends with the .eb extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: name , version , toolchain and versionsuffix . The general format for the filename of an easyconfig file is: <name>-<version><toolchain>-<versionsuffix>.eb , where the toolchain part is omitted when a system toolchain is used, and the <versionsuffix> can be empty. The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive. In the easybuild-easyconfigs repository on GitHub , the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software.","title":"Easyconfig files"},{"location":"2021-lust/terminology/#easystack-files","text":"Easystack files are a new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild. They are written in YAML syntax , and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels. The support for using easystack files is currently marked as experimental , which means it is subject to change in future EasyBuild releases, and may be prone to errors.","title":"Easystack files"},{"location":"2021-lust/terminology/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Common examples are Python packages , R libraries , and Perl modules . As you can tell the common terminology here is a bit messy, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone , as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation);","title":"Extensions"},{"location":"2021-lust/terminology/#dependencies","text":"A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software (examples: CMake , pkg-config ); a run-time dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package (example: Python ); a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed (example: OpenBLAS ); The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies.","title":"Dependencies"},{"location":"2021-lust/terminology/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"2021-lust/terminology/#system-toolchain","text":"The system toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system , rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.","title":"System toolchain"},{"location":"2021-lust/terminology/#common-toolchains","text":"The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , OpenBLAS , ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation .","title":"Common toolchains"},{"location":"2021-lust/terminology/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"2021-lust/terminology/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files which each define a set of easyconfig parameters . EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. An easystack file can be used to specify a collection of software to install with EasyBuild. [next: Installation]","title":"Bringing it all together"},{"location":"2021-lust/troubleshooting/","text":"Troubleshooting \u00b6 When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild. In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention! EasyBuild error messages \u00b6 When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted. Example \u00b6 Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb example.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-39 ) Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled. EasyBuild log files \u00b6 Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by both the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210308.214453.log Last log \u00b6 The eb command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor: vim $(eb --last-log) Navigating log files \u00b6 Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you'll miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there. Inspecting the build directory \u00b6 When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the buildpath directory. Exercise \u00b6 Let's work our way through a less smooth software installation, using the easyconfig file that is provided below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.5.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the text above in a file named subread.eb , so you can gradually fix the problem you'll encounter. Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise T.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ If downloading is problematic for some reason, the source tarball is also available in /easybuild/sources/s/Subread . Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate download URLs, without the filename of the source file itself. This way, EasyBuild will download the source file when running eb subread.eb . The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise T.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): No module found for toolchain: GCC/8.5.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 10.2.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/10.2.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } Exercise T.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -fcommon -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via the CFLAGS argument to the build command: # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the buildopts definition makes it clear that the -fcommon flag is required though, because GCC 10 became a bit stricter by using -fno-common by default. Note that we are using -fcommon as an escape mechanism here: it would be better to fix the source code and create a patch file instead. An easy way to fix this problem is to replace the -fast with -Ofast , as the compiler error suggests. In this case it is advised to change the CFLAGS argument that is added to be build command to replace the -fast with $CFLAGS , which is defined in the build environment by EasyBuild. buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"' Note that we need to be careful with quotes here: we use inner double quotes to ensure that $CFLAGS will be expanded to its value when the build command is run. Exercise T.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 10.2.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1","title":"Troubleshooting"},{"location":"2021-lust/troubleshooting/#troubleshooting","text":"When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild. In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!","title":"Troubleshooting"},{"location":"2021-lust/troubleshooting/#easybuild-error-messages","text":"When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted.","title":"EasyBuild error messages"},{"location":"2021-lust/troubleshooting/#example","text":"Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb example.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-39 ) Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.","title":"Example"},{"location":"2021-lust/troubleshooting/#easybuild-log-files","text":"Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by both the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210308.214453.log","title":"EasyBuild log files"},{"location":"2021-lust/troubleshooting/#last-log","text":"The eb command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor: vim $(eb --last-log)","title":"Last log"},{"location":"2021-lust/troubleshooting/#navigating-log-files","text":"Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you'll miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there.","title":"Navigating log files"},{"location":"2021-lust/troubleshooting/#inspecting-the-build-directory","text":"When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the buildpath directory.","title":"Inspecting the build directory"},{"location":"2021-lust/troubleshooting/#exercise","text":"Let's work our way through a less smooth software installation, using the easyconfig file that is provided below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.5.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the text above in a file named subread.eb , so you can gradually fix the problem you'll encounter. Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise T.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ If downloading is problematic for some reason, the source tarball is also available in /easybuild/sources/s/Subread . Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate download URLs, without the filename of the source file itself. This way, EasyBuild will download the source file when running eb subread.eb . The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise T.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars): No module found for toolchain: GCC/8.5.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 10.2.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/10.2.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '10.2.0' } Exercise T.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -fcommon -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via the CFLAGS argument to the build command: # -fcommon is required to compile Subread 2.0.1 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the buildopts definition makes it clear that the -fcommon flag is required though, because GCC 10 became a bit stricter by using -fno-common by default. Note that we are using -fcommon as an escape mechanism here: it would be better to fix the source code and create a patch file instead. An easy way to fix this problem is to replace the -fast with -Ofast , as the compiler error suggests. In this case it is advised to change the CFLAGS argument that is added to be build command to replace the -fast with $CFLAGS , which is defined in the build environment by EasyBuild. buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"' Note that we need to be careful with quotes here: we use inner double quotes to ensure that $CFLAGS will be expanded to its value when the build command is run. Exercise T.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 10.2.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1","title":"Exercise"},{"location":"2021-lust/what_is_easybuild/","text":"What is EasyBuild? \u00b6 [back: Overview] EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. Easybuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack. Elevator pitch \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among HPC sites worldwide. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations. The installation procedure executed by EasyBuild is thoroughly logged , and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed. EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting . Reproducibility \u00b6 In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular compiler toolchain , with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the GitHub repositories or the documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you. Requirements \u00b6 Since EasyBuild is primarily intended for installing (scientific) software on HPC systems, the main target is systems running some flavor of GNU/Linux . EasyBuild also works on macOS , but significant effort would be required to use it extensively there. EasyBuild is implemented in Python , and is compatible with Python 2.7 and 3.5+. Since Python 2 is no longer maintained , it is recommended to use a recent version of Python 3 for running EasyBuild. An environment modules tool is required for running EasyBuild. The modern Lua-based implementation Lmod is strongly recommended, but other (Tcl-based) implementations are also supported. Both Tcl and Lua are supported as syntax for environment module files. Development \u00b6 EasyBuild is actively developed by a worldwide community under the GPLv2 open source license via the easybuilders organisation on GitHub , in the following repositories: easybuild-framework easybuild-easyblocks easybuild-easyconfigs easybuild (website, documentation) easybuild-tutorial (this tutorial) Stable versions of EasyBuild have been released roughly every 6-8 weeks since 2012, and are published via the Python Package Index (PyPI) , see https://pypi.org/project/easybuild . Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment (GitHub Actions), consistent testing of incoming contributions (pull requests), and thorough regression testing before every release. A worldwide community \u00b6 EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by dozens (hundreds?) of HPC centres and consortia worldwide. Since 2016 the EasyBuild community has gathered for a yearly EasyBuild User Meeting , which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it, and integrate it with other tools like Jenkins , Ansible , CernVM-FS , ReFrame etc. The map below shows from which cities the EasyBuild documentation has been visited in the last year (March 1st 2020 - March 1st 2021), and how often. HPC sites, consortia, and companies that use EasyBuild include (but are not limited to): Getting help \u00b6 Documentation \u00b6 If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io . It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful. GitHub \u00b6 You can open an issue in one of the EasyBuild repositories in the easybuilders GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements. Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate. Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem. Mailing list \u00b6 Feel free to ask any questions or provide feedback via the EasyBuild mailing list easybuild@lists.ugent.be . Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link . In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel. Slack \u00b6 The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 400 people have joined it so far, and there is usually somebody awake in there who may be able to help you out. To join the EasyBuild Slack request an invitation via https://easybuild-slack.herokuapp.com . If you are not a big fan of Slack, you can also consider joining the #easybuild IRC channel (available on the Freenode IRC network ). A bot relays messages between this IRC channel and the #general channel in the EasyBuild Slack. Note A dedicated #tutorial channel was created for this tutorial in the EasyBuild Slack. If you have any questions that are specific to this tutorial, please post them there. Conference calls \u00b6 Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call. These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013. More information, including the dates and times of the next calls, is available here . [next: Terminology]","title":"What is EasyBuild?"},{"location":"2021-lust/what_is_easybuild/#what-is-easybuild","text":"[back: Overview] EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. Easybuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack.","title":"What is EasyBuild?"},{"location":"2021-lust/what_is_easybuild/#elevator-pitch","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among HPC sites worldwide.","title":"Elevator pitch"},{"location":"2021-lust/what_is_easybuild/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations. The installation procedure executed by EasyBuild is thoroughly logged , and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed. EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on.","title":"Key features"},{"location":"2021-lust/what_is_easybuild/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"2021-lust/what_is_easybuild/#performance","text":"EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting .","title":"Performance"},{"location":"2021-lust/what_is_easybuild/#reproducibility","text":"In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular compiler toolchain , with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"2021-lust/what_is_easybuild/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the GitHub repositories or the documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Community effort"},{"location":"2021-lust/what_is_easybuild/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you.","title":"What EasyBuild is not"},{"location":"2021-lust/what_is_easybuild/#requirements","text":"Since EasyBuild is primarily intended for installing (scientific) software on HPC systems, the main target is systems running some flavor of GNU/Linux . EasyBuild also works on macOS , but significant effort would be required to use it extensively there. EasyBuild is implemented in Python , and is compatible with Python 2.7 and 3.5+. Since Python 2 is no longer maintained , it is recommended to use a recent version of Python 3 for running EasyBuild. An environment modules tool is required for running EasyBuild. The modern Lua-based implementation Lmod is strongly recommended, but other (Tcl-based) implementations are also supported. Both Tcl and Lua are supported as syntax for environment module files.","title":"Requirements"},{"location":"2021-lust/what_is_easybuild/#development","text":"EasyBuild is actively developed by a worldwide community under the GPLv2 open source license via the easybuilders organisation on GitHub , in the following repositories: easybuild-framework easybuild-easyblocks easybuild-easyconfigs easybuild (website, documentation) easybuild-tutorial (this tutorial) Stable versions of EasyBuild have been released roughly every 6-8 weeks since 2012, and are published via the Python Package Index (PyPI) , see https://pypi.org/project/easybuild . Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment (GitHub Actions), consistent testing of incoming contributions (pull requests), and thorough regression testing before every release.","title":"Development"},{"location":"2021-lust/what_is_easybuild/#a-worldwide-community","text":"EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by dozens (hundreds?) of HPC centres and consortia worldwide. Since 2016 the EasyBuild community has gathered for a yearly EasyBuild User Meeting , which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it, and integrate it with other tools like Jenkins , Ansible , CernVM-FS , ReFrame etc. The map below shows from which cities the EasyBuild documentation has been visited in the last year (March 1st 2020 - March 1st 2021), and how often. HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):","title":"A worldwide community"},{"location":"2021-lust/what_is_easybuild/#getting-help","text":"","title":"Getting help"},{"location":"2021-lust/what_is_easybuild/#documentation","text":"If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io . It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful.","title":"Documentation"},{"location":"2021-lust/what_is_easybuild/#github","text":"You can open an issue in one of the EasyBuild repositories in the easybuilders GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements. Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate. Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem.","title":"GitHub"},{"location":"2021-lust/what_is_easybuild/#mailing-list","text":"Feel free to ask any questions or provide feedback via the EasyBuild mailing list easybuild@lists.ugent.be . Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link . In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel.","title":"Mailing list"},{"location":"2021-lust/what_is_easybuild/#slack","text":"The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 400 people have joined it so far, and there is usually somebody awake in there who may be able to help you out. To join the EasyBuild Slack request an invitation via https://easybuild-slack.herokuapp.com . If you are not a big fan of Slack, you can also consider joining the #easybuild IRC channel (available on the Freenode IRC network ). A bot relays messages between this IRC channel and the #general channel in the EasyBuild Slack. Note A dedicated #tutorial channel was created for this tutorial in the EasyBuild Slack. If you have any questions that are specific to this tutorial, please post them there.","title":"Slack"},{"location":"2021-lust/what_is_easybuild/#conference-calls","text":"Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call. These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013. More information, including the dates and times of the next calls, is available here . [next: Terminology]","title":"Conference calls"},{"location":"2021-lust/cray/custom_toolchains/","text":"Custom Cray toolchains \u00b6 EasyBuild Cray and CPE toolchains have been created to address the Cray PE on different Cray systems. Cray toolchains were designed for the Cray PE on the Cray XC system, while the CPE toolchains targeted specifically the Cray PE on the Cray EX system. As of Cray PE 21.04 though, the difference between the Cray PE on the XC and the EX systems is not relevant any longer, since they rely both on PrgEnv meta-modules. Nonetheless, the versions of the CPE components that come with a Cray PE release might change depending on the target system, therefore a different external metadata file is required: see https://github.com/eth-cscs/production/tree/master/easybuild to inspect the difference between two metadata file referring to the same version E.g.: cpe_external_modules_metadata-21.05.cfg vs. cray_external_modules_metadata-20.05.cfg Furthermore, different easyconfig files might be needed to build the same software on the two systems even with the same Cray PE, therefore the maintainers would need to provide anyway two versions of the easyconfig file. Cray Toolchains \u00b6 EasyBuild supports Cray systems as of version 2.7.0, enabling building and installing software using the Programming Environment modulefiles provided by Cray. The EasyBuild Cray toolchains currently supported in the GitHub repository are the following ones: CrayCCE CrayGNU CrayIntel CrayPGI Each Cray toolchain comes with a version matching the corresponding Cray Development Toolkit (CDT) modulefile on the Cray XC system. Therefore, the toolchain will load the corresponding Cray Programming Environment, together with the compiler, the Cray MPICH library and the Cray mathematical library with versions matching the definition of the CDT. Please note that the toolchains follow the naming convention of the Cray Programming Environment, that is released on a monthly basis: as a consequence, the version of the toolchain modules has the format YY.MM (two digits for the year, two digits for the month). CPE Toolchains \u00b6 The CPE toolchains were created initially to match the modules of the Cray EX system up to Cray PE 21.03: cpe-cray cpe-aocc cpe-gnu cpe-intel As of CPE 21.04 though, the Cray PE of the Cray EX system features PrgEnv meta-modules too, therefore the difference with respect to the standard Cray toolchain has disappeared. The CPE toolchains are defined by the custom easyblock cpetoolchain.py : KNOWN_PRGENVS = ['PrgEnv-aocc', 'PrgEnv-cray', 'PrgEnv-gnu', 'PrgEnv-intel'] The file is available in the CSCS production repository on GitHub , that is also mirrored under the EasyBuilders GitHub project at https://github.com/easybuilders/CSCS . CPE Compilers \u00b6 The CPE toolchains rely on specific files of the local EasyBuild framework: cpeamd.py cpecray.py cpegnu.py cpeintel.py The first one will look for the custom compiler aocc.py , while the other ones are compatible with the compilers defined by the Cray toolchains initially defined on the XC system. The custom toolchains above will look for the file cpe.py supporting the Cray PE compiler drivers. Please note that as well as the custom easyblock cpetoolchain.py , the custom files are available in the toolchains and the compiler folders of the CSCS production repository on GitHub . Target Architecture \u00b6 The module craype-<target> matching the target architecture must be specified using the EasyBuild flag --optarch . E.g.: --optarch=x86-rome results in module craype-x86-rome` being loaded in the build environment used by EasyBuild. You can also export this option as a shell variable. Example for AMD EPYC 7742 (\"Rome\"): export $EASYBUILD_OPTARCH=x86-rome The definition of the correct module to load with the --optarch is also given by the environment variable CRAY_CPU_TARGET : this variable is defined as well by the corresponding module craype-<target> , already available at the login. Note The custom EasyBuild modulefile used on CSCS systems will look for CRAY_CPU_TARGET to define --optarch , therefore users are strongly discouraged from purging the modules already available at login on the system Easyconfig for custom toolchains \u00b6 The easyconfig files of the current default custom toolchains were using a footer to address two issues that have been fixed in the latest EasyBuild release 4.4.0. Therefore, when using the latest EasyBuild release one could write a much shorter easyconfig file for the custom toolchains. For instance, the cpeGNU custom toolchain easyconfig file would like the following: # Compiler toolchain for Cray EX Programming Environment GNU compiler (cpe-gnu) easyblock = 'cpeToolchain' name = 'cpeGNU' version = \"21.04\" homepage = 'https://pubs.cray.com' description = \"\"\"Toolchain using Cray compiler wrapper with gcc module (CPE release: %s).\\n\"\"\" % version toolchain = SYSTEM dependencies = [ ('cpe/%(version)s', EXTERNAL_MODULE), ('PrgEnv-gnu', EXTERNAL_MODULE) ] The meta-module cpe will ensure that the additional modules loaded by a user will be compatible with the default CPE selected. The advantage of the approach is to avoid pinning directly the versions of CPE components in the custom toolchain definitions. Of course the maintainers could also decide to pin directl the version of each CPE component in the easyconfig, however this approach is less easy to fit in an automated pipeline for updating recipes when new CPEs are installed. [next: EasyBuild at CSCS]","title":"Custom Cray toolchains"},{"location":"2021-lust/cray/custom_toolchains/#custom-cray-toolchains","text":"EasyBuild Cray and CPE toolchains have been created to address the Cray PE on different Cray systems. Cray toolchains were designed for the Cray PE on the Cray XC system, while the CPE toolchains targeted specifically the Cray PE on the Cray EX system. As of Cray PE 21.04 though, the difference between the Cray PE on the XC and the EX systems is not relevant any longer, since they rely both on PrgEnv meta-modules. Nonetheless, the versions of the CPE components that come with a Cray PE release might change depending on the target system, therefore a different external metadata file is required: see https://github.com/eth-cscs/production/tree/master/easybuild to inspect the difference between two metadata file referring to the same version E.g.: cpe_external_modules_metadata-21.05.cfg vs. cray_external_modules_metadata-20.05.cfg Furthermore, different easyconfig files might be needed to build the same software on the two systems even with the same Cray PE, therefore the maintainers would need to provide anyway two versions of the easyconfig file.","title":"Custom Cray toolchains"},{"location":"2021-lust/cray/custom_toolchains/#cray-toolchains","text":"EasyBuild supports Cray systems as of version 2.7.0, enabling building and installing software using the Programming Environment modulefiles provided by Cray. The EasyBuild Cray toolchains currently supported in the GitHub repository are the following ones: CrayCCE CrayGNU CrayIntel CrayPGI Each Cray toolchain comes with a version matching the corresponding Cray Development Toolkit (CDT) modulefile on the Cray XC system. Therefore, the toolchain will load the corresponding Cray Programming Environment, together with the compiler, the Cray MPICH library and the Cray mathematical library with versions matching the definition of the CDT. Please note that the toolchains follow the naming convention of the Cray Programming Environment, that is released on a monthly basis: as a consequence, the version of the toolchain modules has the format YY.MM (two digits for the year, two digits for the month).","title":"Cray Toolchains"},{"location":"2021-lust/cray/custom_toolchains/#cpe-toolchains","text":"The CPE toolchains were created initially to match the modules of the Cray EX system up to Cray PE 21.03: cpe-cray cpe-aocc cpe-gnu cpe-intel As of CPE 21.04 though, the Cray PE of the Cray EX system features PrgEnv meta-modules too, therefore the difference with respect to the standard Cray toolchain has disappeared. The CPE toolchains are defined by the custom easyblock cpetoolchain.py : KNOWN_PRGENVS = ['PrgEnv-aocc', 'PrgEnv-cray', 'PrgEnv-gnu', 'PrgEnv-intel'] The file is available in the CSCS production repository on GitHub , that is also mirrored under the EasyBuilders GitHub project at https://github.com/easybuilders/CSCS .","title":"CPE Toolchains"},{"location":"2021-lust/cray/custom_toolchains/#cpe-compilers","text":"The CPE toolchains rely on specific files of the local EasyBuild framework: cpeamd.py cpecray.py cpegnu.py cpeintel.py The first one will look for the custom compiler aocc.py , while the other ones are compatible with the compilers defined by the Cray toolchains initially defined on the XC system. The custom toolchains above will look for the file cpe.py supporting the Cray PE compiler drivers. Please note that as well as the custom easyblock cpetoolchain.py , the custom files are available in the toolchains and the compiler folders of the CSCS production repository on GitHub .","title":"CPE Compilers"},{"location":"2021-lust/cray/custom_toolchains/#target-architecture","text":"The module craype-<target> matching the target architecture must be specified using the EasyBuild flag --optarch . E.g.: --optarch=x86-rome results in module craype-x86-rome` being loaded in the build environment used by EasyBuild. You can also export this option as a shell variable. Example for AMD EPYC 7742 (\"Rome\"): export $EASYBUILD_OPTARCH=x86-rome The definition of the correct module to load with the --optarch is also given by the environment variable CRAY_CPU_TARGET : this variable is defined as well by the corresponding module craype-<target> , already available at the login. Note The custom EasyBuild modulefile used on CSCS systems will look for CRAY_CPU_TARGET to define --optarch , therefore users are strongly discouraged from purging the modules already available at login on the system","title":"Target Architecture"},{"location":"2021-lust/cray/custom_toolchains/#easyconfig-for-custom-toolchains","text":"The easyconfig files of the current default custom toolchains were using a footer to address two issues that have been fixed in the latest EasyBuild release 4.4.0. Therefore, when using the latest EasyBuild release one could write a much shorter easyconfig file for the custom toolchains. For instance, the cpeGNU custom toolchain easyconfig file would like the following: # Compiler toolchain for Cray EX Programming Environment GNU compiler (cpe-gnu) easyblock = 'cpeToolchain' name = 'cpeGNU' version = \"21.04\" homepage = 'https://pubs.cray.com' description = \"\"\"Toolchain using Cray compiler wrapper with gcc module (CPE release: %s).\\n\"\"\" % version toolchain = SYSTEM dependencies = [ ('cpe/%(version)s', EXTERNAL_MODULE), ('PrgEnv-gnu', EXTERNAL_MODULE) ] The meta-module cpe will ensure that the additional modules loaded by a user will be compatible with the default CPE selected. The advantage of the approach is to avoid pinning directly the versions of CPE components in the custom toolchain definitions. Of course the maintainers could also decide to pin directl the version of each CPE component in the easyconfig, however this approach is less easy to fit in an automated pipeline for updating recipes when new CPEs are installed. [next: EasyBuild at CSCS]","title":"Easyconfig for custom toolchains"},{"location":"2021-lust/cray/easybuild_at_cscs/","text":"EasyBuild at CSCS \u00b6 EasyBuild has been used at CSCS since 2015 on multiple systems, using both Cray and standard toolchains. CSCS staff has integrated EasyBuild within the automated pipelines used to maintain supported applications and libraries for CSCS users. The pipelines are stored on GitHub and are currently launched on a Jenkins server. CSCS Production Repository on GitHub: https://github.com/eth-cscs/production Jenkins Pipelines: https://github.com/eth-cscs/production/tree/master/jenkins How to use EasyBuild at CSCS: https://user.cscs.ch/computing/compilation/easybuild Custom EasyBuild module \u00b6 The EasyBuild framework is available at CSCS through the custom module EasyBuild-custom . This module defines the location of the EasyBuild configuration files, recipes and installation directories. module load EasyBuild-custom The default installation folder is instead the following: $HOME/easybuild/<system-name> Where <system-name> is the lowercase name of the system, e.g.: eiger . The custom EasyBuild modulefile is available both in Tcl and Lua syntax on the CSCS production repository : a system using Lmod for module management will load the Lua modulefile, which is ignored by systems using Environment modules instead. The modulefile defines the location of the EasyBuild configuration files, the recipes and the installation directories. Once you have loaded the EasyBuild modulefile, you can check the EasyBuild version loaded and the default configuration executing the EasyBuild command eb with the options --version or --show-config as usual. How to use EasyBuild at CSCS \u00b6 Example on the Cray EX supercomputing system Eiger: ml show EasyBuild-custom --------------------------------------------------------------------------------------------------------------------------------- /apps/eiger/UES/modulefiles/EasyBuild-custom/cscs.lua: --------------------------------------------------------------------------------------------------------------------------------- help([[ Description =========== Production EasyBuild @ CSCS More information ================ - Homepage: https://github.com/eth-cscs/production/wiki ]]) whatis(\"Description: Production EasyBuild @ CSCS \") whatis(\"Homepage: https://github.com/eth-cscs/production/wiki\") conflict(\"EasyBuild-custom\") setenv(\"EBROOTEASYBUILDMINCUSTOM\",\"/apps/common/UES/jenkins/easybuild/software/EasyBuild-custom/cscs\") setenv(\"EBVERSIONEASYBUILDMINCUSTOM\",\"cscs\") setenv(\"EBDEVELEASYBUILDMINCUSTOM\",\"/apps/common/UES/jenkins/easybuild/software/EasyBuild-custom/cscs/easybuild/EasyBuild-custom-cscs-easybuild-devel\") setenv(\"XDG_CONFIG_DIRS\",\"/apps/common/UES/jenkins/production/easybuild\") setenv(\"EASYBUILD_ROBOT_PATHS\",\"/apps/common/UES/jenkins/production/easybuild/easyconfigs/:\") setenv(\"EASYBUILD_INCLUDE_EASYBLOCKS\",\"/apps/common/UES/jenkins/production/easybuild/easyblocks/*.py\") setenv(\"EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES\",\"/apps/common/UES/jenkins/production/easybuild/tools/module_naming_scheme/*.py\") setenv(\"EASYBUILD_INCLUDE_TOOLCHAINS\",\"/apps/common/UES/jenkins/production/easybuild/toolchains/*.py,/apps/common/UES/jenkins/production/easybuild/toolchains/compiler/*.py\") setenv(\"EASYBUILD_BUILDPATH\",\"/run/user/21827/build\") setenv(\"EASYBUILD_TMPDIR\",\"/run/user/21827/tmp\") setenv(\"EASYBUILD_SOURCEPATH\",\"/apps/common/UES/easybuild/sources\") setenv(\"EASYBUILD_EXTERNAL_MODULES_METADATA\",\"/apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg\") setenv(\"EASYBUILD_MODULE_NAMING_SCHEME\",\"HierarchicalMNS\") setenv(\"EASYBUILD_MODULE_SYNTAX\",\"Lua\") setenv(\"EASYBUILD_MODULES_TOOL\",\"Lmod\") setenv(\"EASYBUILD_OPTARCH\",\"x86-rome\") setenv(\"EASYBUILD_RECURSIVE_MODULE_UNLOAD\",\"0\") setenv(\"EASYBUILD_PREFIX\",\"/users/lucamar/easybuild/eiger\") CSCS EasyBuild configuration \u00b6 eb --version This is EasyBuild 4.4.0 (framework: 4.4.0, easyblocks: 4.4.0) on host uan01. eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # allow-loaded-modules (F) = ddt, EasyBuild-custom, EasyBuild, xalt buildpath (E) = /run/user/21827/build containerpath (E) = /users/lucamar/easybuild/eiger/containers external-modules-metadata (E) = /apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg hide-deps (F) = absl, ANTLR, APR, APR-util, arpack-ng, Autoconf, Automake, Autotools, backports.weakref, Bazel, binutils, Bison, bokeh, byacc, bzip2, cairo, cloudpickle, configurable-http-proxy, Coreutils, Cube, CUDA, cuDNN, cURL, DB, Doxygen, Eigen, expat, flex, FLTK, fontconfig, freetype, funcsigs, gc, GCCcore, gettext, GL2PS, GLib, glmnet, GLPK, GMP, gnuplot, go, gperf, GPGME, GraphicsMagick, groff, GTS, guile, help2man, hwloc, inputproto, IPython, JasPer, jemalloc, kbproto, Libassuan, libcerf, libdrm, libevent, libfabric, libffi, libgd, libGLU, libgpuarray, libiberty, libjpeg-turbo, libjpeg-turbo, libpciaccess, Libpgp-error, libpng, libpthread-stubs, libQGLViewer, libreadline, libsodium, libspatialindex, LibTIFF, libtool, libunistring, libunwind, libutempter, libX11, libXau, libxcb, libXdmcp, libXext, libxml2, libXrender, libxshmfence, libyaml, LLVM, LOKI, Loki, LVM2, M4, make, makeinfo, Mako, Mesa, minieigen, mock, mxml, NASM, NASM, ncurses, nettle, networkx, nodejs, nose-parameterized, numactl, OPARI2, OpenMPI, OpenPGM, parameterized, PCRE, PDT, Perl, PIL, Pillow, pixman, pkg-config, ploticus, PMIx, popt, prereq, protobuf, protobuf-core, PyGTS, PyQt, Python-bare, Python-Xlib, PyYAML, PyZMQ, Qhull, qrupdate, Qt, renderproto, runc, scikit-image, scikit-learn, SCons, SCOTCH, Serf, SIP, SQLite, SWIG, Szip, Tcl, Tk, UCX, UDUNITS, UnZip, util-linux, Werkzeug, wheel, X11, xcb-proto, xextproto, xorg-macros, xproto, xtrans, XZ, ZeroMQ, zlib, zstd hide-toolchains (F) = CrayCCE, CrayGNU, CrayIntel, CrayPGI, GCCcore, gmvapich2, gmvolf, foss, fosscuda, gompi include-easyblocks (E) = /apps/common/UES/jenkins/production/easybuild/easyblocks/*.py include-module-naming-schemes (E) = /apps/common/UES/jenkins/production/easybuild/tools/module_naming_scheme/*.py include-toolchains (E) = /apps/common/UES/jenkins/production/easybuild/toolchains/*.py, /apps/common/UES/jenkins/production/easybuild/toolchains/compiler/*.py installpath (E) = /users/lucamar/easybuild/eiger module-naming-scheme (E) = HierarchicalMNS optarch (E) = x86-rome packagepath (E) = /users/lucamar/easybuild/eiger/packages prefix (E) = /users/lucamar/easybuild/eiger repositorypath (E) = /users/lucamar/easybuild/eiger/ebfiles_repo robot-paths (E) = /apps/common/UES/jenkins/production/easybuild/easyconfigs/, /apps/common/UES/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs sourcepath (E) = /apps/common/UES/easybuild/sources tmpdir (E) = /run/user/21827/tmp Configuration options \u00b6 As reported in the output of the command eb --show-config , the configuration items labeled with (E) are defined by an environment variable of the form EASYBUILD_<item> , where item is in uppercase letters. Therefore the buildpath is defined by the variable EASYBUILD_BUILDPATH , whereas the prefix that defines the installpath of the modules created by EasyBuild is defined by EASYBUILD_PREFIX . You can change these configuration items editing the corresponding environment variable. Please note that in general the prefix might be different with respect to the installpath: special care is required in particular when users would like to build additional modules in their local folders on top of EasyBuild modules already provided by the HPC centre staff. Choosing your custom folders \u00b6 You can override the default installation folder by exporting the environment variables listed below, before loading the EasyBuild modulefile: export EASYBUILD_PREFIX=/your/preferred/installation/folder export EB_CUSTOM_REPOSITORY=/your/local/repository/easybuild module load EasyBuild-custom The first environment variable is generally set before loading the EasyBuild modulefiles. The second one is instead specific to the CSCS EasyBuild-custom modulefile and corresponds to the EasyBuild variable XDG_CONFIG_DIRS : therefore, the custom modulefile expects to find the subfolders of the easybuild directory under the CSCS GitHub production repository. Note The variable XDG_CONFIG_DIRS might be used by other programs as well: in this case, you might consider alternative ways to provide EasyBuild configuration files The following environment variables depend on EB_CUSTOM_REPOSITORY : setenv XDG_CONFIG_DIRS $::env(EB_CUSTOM_REPOSITORY) setenv EASYBUILD_ROBOT_PATHS $::env(EB_CUSTOM_REPOSITORY)/easyconfigs/: setenv EASYBUILD_INCLUDE_EASYBLOCKS $::env(EB_CUSTOM_REPOSITORY)/easyblocks/*.py setenv EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES $::env(EB_CUSTOM_REPOSITORY)/tools/module_naming_scheme/*.py setenv EASYBUILD_INCLUDE_TOOLCHAINS $::env(EB_CUSTOM_REPOSITORY)/toolchains/*.py,$::env(EB_CUSTOM_REPOSITORY)/toolchains/compiler/*.py Users will find the CSCS EasyBuild configuration file under the folder easybuild.d of the EB_CUSTOM_REPOSITORY and the CSCS custom recipes under the easyconfigs folder, listed as usual in alphabetical order. Customizing your build recipes \u00b6 If you wish to extend or customize the CSCS EasyBuild recipes, you can clone the CSCS production project from GitHub and have your private repository: git clone https://github.com/eth-cscs/production.git The command will download the project files under a newly created folder production. If you wish to use it as your custom repository, you need to export the corresponding EasyBuild environment variable: export EB_CUSTOM_REPOSITORY=/<your_local_path>/production/easybuild module load EasyBuild-custom You will find the CSCS EasyBuild build recipes files under /<your_local_path>/production/easybuild/easyconfigs , with application folders listed in alphabetical order. Site wide configuration file \u00b6 The custom configuration of EasyBuild at CSCS is completed by the site wide configuration file available in the folder easybuild.d under XDG_CONFIG_DIRS , referenced in the modulefile EasyBuild-custom . The file defines the following: the list of hidden dependencies the list of hidden toolchains the list of allowed loaded modules The current content of the file is reported below: [override] # Comma separated list of dependencies that you want automatically hidden, (e.g. --hide-deps=zlib,ncurses) (type comma-separated list) hide-deps=absl,ANTLR,APR,APR-util,arpack-ng,Autoconf,Automake,Autotools,backports.weakref,Bazel,binutils,Bison,bokeh,byacc,bzip2,cairo,cloudpickle,configurable-http-proxy,Coreutils,Cube,CUDA,cuDNN,cURL,DB,Doxygen,Eigen,expat,flex,FLTK,fontconfig,freetype,funcsigs,gc,GCCcore,gettext,GL2PS,GLib,glmnet,GLPK,GMP,gnuplot,go,gperf,GPGME,GraphicsMagick,groff,GTS,guile,help2man,hwloc,inputproto,IPython,JasPer,jemalloc,kbproto,Libassuan,libcerf,libdrm,libevent,libfabric,libffi,libgd,libGLU,libgpuarray,libiberty,libjpeg-turbo,libjpeg-turbo,libpciaccess,Libpgp-error,libpng,libpthread-stubs,libQGLViewer,libreadline,libsodium,libspatialindex,LibTIFF,libtool,libunistring,libunwind,libutempter,libX11,libXau,libxcb,libXdmcp,libXext,libxml2,libXrender,libxshmfence,libyaml,LLVM,LOKI,Loki,LVM2,M4,make,makeinfo,Mako,Mesa,minieigen,mock,mxml,NASM,NASM,ncurses,nettle,networkx,nodejs,nose-parameterized,numactl,OPARI2,OpenMPI,OpenPGM,parameterized,PCRE,PDT,Perl,PIL,Pillow,pixman,pkg-config,ploticus,PMIx,popt,prereq,protobuf,protobuf-core,PyGTS,PyQt,Python-bare,Python-Xlib,PyYAML,PyZMQ,Qhull,qrupdate,Qt,renderproto,runc,scikit-image,scikit-learn,SCons,SCOTCH,Serf,SIP,SQLite,SWIG,Szip,Tcl,Tk,UCX,UDUNITS,UnZip,util-linux,Werkzeug,wheel,X11,xcb-proto,xextproto,xorg-macros,xproto,xtrans,XZ,ZeroMQ,zlib,zstd module-syntax=Tcl hide-toolchains=CrayCCE,CrayGNU,CrayIntel,CrayPGI,GCCcore,gmvapich2,gmvolf,foss,fosscuda,gompi allow-loaded-modules=ddt,EasyBuild-custom,EasyBuild,xalt EasyBuild on Piz Daint \u00b6 On Piz Daint, which is a heterogeneous system, you need to select which architecture should be targeted when building software. You can target the Intel Haswell architecture accessing the gpu software stack using the command: module load daint-gpu EasyBuild-custom Alternatively, you can target the Intel Broadwell architecture and the mc (multicore) software stack: module load daint-mc EasyBuild-custom On Piz Daint, EasyBuild software and modules will be installed by default under the following folder: $HOME/easybuild/<system-name>/<architecture> Here <architecture> will be either haswell or broadwell . Building your Program \u00b6 After you load the EasyBuild environment as explained in the section above, you will have the command eb available to build your code using EasyBuild. If you want to build the code using a given configuration <filename>.eb and resolving dependencies, you will use the flag -r as in the example below: eb <filename>.eb -r The build command just needs the configuration file name with the extension .eb and not the full path, provided that the configuration file is in your search path: the command eb --show-config will print the variable robot-paths that holds the search path. More options are available, please have a look at the short help message typing eb -h . For instance, you can check if any EasyBuild configuration file already exists for a given program name, using the search flag -S: eb -S <program_name> Please note that on Cray systems you can use the configuration files that rely of a Cray toolchain, which you will find in the configuration filename ( eb -S <name> | grep Cray ). You will be able to load the modules created by EasyBuild in the folder defined by the EASYBUILD_PREFIX variable using the following commands: module use $EASYBUILD_PREFIX/modules/all module load <modulename>/version The command module use will prepend the selected folder to your MODULEPATH environment variable, therefore you will see the new modules with module avail. Please note that by default EASYBUILD_PREFIX is set to a folder inside your $HOME , however the $HOME folder is by default not readable by other users. Therefore if you want to make your builds available to your group, then you need to allow read-only access to other members of your group using the command chmod g+rx $HOME .","title":"EasyBuild at CSCS"},{"location":"2021-lust/cray/easybuild_at_cscs/#easybuild-at-cscs","text":"EasyBuild has been used at CSCS since 2015 on multiple systems, using both Cray and standard toolchains. CSCS staff has integrated EasyBuild within the automated pipelines used to maintain supported applications and libraries for CSCS users. The pipelines are stored on GitHub and are currently launched on a Jenkins server. CSCS Production Repository on GitHub: https://github.com/eth-cscs/production Jenkins Pipelines: https://github.com/eth-cscs/production/tree/master/jenkins How to use EasyBuild at CSCS: https://user.cscs.ch/computing/compilation/easybuild","title":"EasyBuild at CSCS"},{"location":"2021-lust/cray/easybuild_at_cscs/#custom-easybuild-module","text":"The EasyBuild framework is available at CSCS through the custom module EasyBuild-custom . This module defines the location of the EasyBuild configuration files, recipes and installation directories. module load EasyBuild-custom The default installation folder is instead the following: $HOME/easybuild/<system-name> Where <system-name> is the lowercase name of the system, e.g.: eiger . The custom EasyBuild modulefile is available both in Tcl and Lua syntax on the CSCS production repository : a system using Lmod for module management will load the Lua modulefile, which is ignored by systems using Environment modules instead. The modulefile defines the location of the EasyBuild configuration files, the recipes and the installation directories. Once you have loaded the EasyBuild modulefile, you can check the EasyBuild version loaded and the default configuration executing the EasyBuild command eb with the options --version or --show-config as usual.","title":"Custom EasyBuild module"},{"location":"2021-lust/cray/easybuild_at_cscs/#how-to-use-easybuild-at-cscs","text":"Example on the Cray EX supercomputing system Eiger: ml show EasyBuild-custom --------------------------------------------------------------------------------------------------------------------------------- /apps/eiger/UES/modulefiles/EasyBuild-custom/cscs.lua: --------------------------------------------------------------------------------------------------------------------------------- help([[ Description =========== Production EasyBuild @ CSCS More information ================ - Homepage: https://github.com/eth-cscs/production/wiki ]]) whatis(\"Description: Production EasyBuild @ CSCS \") whatis(\"Homepage: https://github.com/eth-cscs/production/wiki\") conflict(\"EasyBuild-custom\") setenv(\"EBROOTEASYBUILDMINCUSTOM\",\"/apps/common/UES/jenkins/easybuild/software/EasyBuild-custom/cscs\") setenv(\"EBVERSIONEASYBUILDMINCUSTOM\",\"cscs\") setenv(\"EBDEVELEASYBUILDMINCUSTOM\",\"/apps/common/UES/jenkins/easybuild/software/EasyBuild-custom/cscs/easybuild/EasyBuild-custom-cscs-easybuild-devel\") setenv(\"XDG_CONFIG_DIRS\",\"/apps/common/UES/jenkins/production/easybuild\") setenv(\"EASYBUILD_ROBOT_PATHS\",\"/apps/common/UES/jenkins/production/easybuild/easyconfigs/:\") setenv(\"EASYBUILD_INCLUDE_EASYBLOCKS\",\"/apps/common/UES/jenkins/production/easybuild/easyblocks/*.py\") setenv(\"EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES\",\"/apps/common/UES/jenkins/production/easybuild/tools/module_naming_scheme/*.py\") setenv(\"EASYBUILD_INCLUDE_TOOLCHAINS\",\"/apps/common/UES/jenkins/production/easybuild/toolchains/*.py,/apps/common/UES/jenkins/production/easybuild/toolchains/compiler/*.py\") setenv(\"EASYBUILD_BUILDPATH\",\"/run/user/21827/build\") setenv(\"EASYBUILD_TMPDIR\",\"/run/user/21827/tmp\") setenv(\"EASYBUILD_SOURCEPATH\",\"/apps/common/UES/easybuild/sources\") setenv(\"EASYBUILD_EXTERNAL_MODULES_METADATA\",\"/apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg\") setenv(\"EASYBUILD_MODULE_NAMING_SCHEME\",\"HierarchicalMNS\") setenv(\"EASYBUILD_MODULE_SYNTAX\",\"Lua\") setenv(\"EASYBUILD_MODULES_TOOL\",\"Lmod\") setenv(\"EASYBUILD_OPTARCH\",\"x86-rome\") setenv(\"EASYBUILD_RECURSIVE_MODULE_UNLOAD\",\"0\") setenv(\"EASYBUILD_PREFIX\",\"/users/lucamar/easybuild/eiger\")","title":"How to use EasyBuild at CSCS"},{"location":"2021-lust/cray/easybuild_at_cscs/#cscs-easybuild-configuration","text":"eb --version This is EasyBuild 4.4.0 (framework: 4.4.0, easyblocks: 4.4.0) on host uan01. eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # allow-loaded-modules (F) = ddt, EasyBuild-custom, EasyBuild, xalt buildpath (E) = /run/user/21827/build containerpath (E) = /users/lucamar/easybuild/eiger/containers external-modules-metadata (E) = /apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg hide-deps (F) = absl, ANTLR, APR, APR-util, arpack-ng, Autoconf, Automake, Autotools, backports.weakref, Bazel, binutils, Bison, bokeh, byacc, bzip2, cairo, cloudpickle, configurable-http-proxy, Coreutils, Cube, CUDA, cuDNN, cURL, DB, Doxygen, Eigen, expat, flex, FLTK, fontconfig, freetype, funcsigs, gc, GCCcore, gettext, GL2PS, GLib, glmnet, GLPK, GMP, gnuplot, go, gperf, GPGME, GraphicsMagick, groff, GTS, guile, help2man, hwloc, inputproto, IPython, JasPer, jemalloc, kbproto, Libassuan, libcerf, libdrm, libevent, libfabric, libffi, libgd, libGLU, libgpuarray, libiberty, libjpeg-turbo, libjpeg-turbo, libpciaccess, Libpgp-error, libpng, libpthread-stubs, libQGLViewer, libreadline, libsodium, libspatialindex, LibTIFF, libtool, libunistring, libunwind, libutempter, libX11, libXau, libxcb, libXdmcp, libXext, libxml2, libXrender, libxshmfence, libyaml, LLVM, LOKI, Loki, LVM2, M4, make, makeinfo, Mako, Mesa, minieigen, mock, mxml, NASM, NASM, ncurses, nettle, networkx, nodejs, nose-parameterized, numactl, OPARI2, OpenMPI, OpenPGM, parameterized, PCRE, PDT, Perl, PIL, Pillow, pixman, pkg-config, ploticus, PMIx, popt, prereq, protobuf, protobuf-core, PyGTS, PyQt, Python-bare, Python-Xlib, PyYAML, PyZMQ, Qhull, qrupdate, Qt, renderproto, runc, scikit-image, scikit-learn, SCons, SCOTCH, Serf, SIP, SQLite, SWIG, Szip, Tcl, Tk, UCX, UDUNITS, UnZip, util-linux, Werkzeug, wheel, X11, xcb-proto, xextproto, xorg-macros, xproto, xtrans, XZ, ZeroMQ, zlib, zstd hide-toolchains (F) = CrayCCE, CrayGNU, CrayIntel, CrayPGI, GCCcore, gmvapich2, gmvolf, foss, fosscuda, gompi include-easyblocks (E) = /apps/common/UES/jenkins/production/easybuild/easyblocks/*.py include-module-naming-schemes (E) = /apps/common/UES/jenkins/production/easybuild/tools/module_naming_scheme/*.py include-toolchains (E) = /apps/common/UES/jenkins/production/easybuild/toolchains/*.py, /apps/common/UES/jenkins/production/easybuild/toolchains/compiler/*.py installpath (E) = /users/lucamar/easybuild/eiger module-naming-scheme (E) = HierarchicalMNS optarch (E) = x86-rome packagepath (E) = /users/lucamar/easybuild/eiger/packages prefix (E) = /users/lucamar/easybuild/eiger repositorypath (E) = /users/lucamar/easybuild/eiger/ebfiles_repo robot-paths (E) = /apps/common/UES/jenkins/production/easybuild/easyconfigs/, /apps/common/UES/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs sourcepath (E) = /apps/common/UES/easybuild/sources tmpdir (E) = /run/user/21827/tmp","title":"CSCS EasyBuild configuration"},{"location":"2021-lust/cray/easybuild_at_cscs/#configuration-options","text":"As reported in the output of the command eb --show-config , the configuration items labeled with (E) are defined by an environment variable of the form EASYBUILD_<item> , where item is in uppercase letters. Therefore the buildpath is defined by the variable EASYBUILD_BUILDPATH , whereas the prefix that defines the installpath of the modules created by EasyBuild is defined by EASYBUILD_PREFIX . You can change these configuration items editing the corresponding environment variable. Please note that in general the prefix might be different with respect to the installpath: special care is required in particular when users would like to build additional modules in their local folders on top of EasyBuild modules already provided by the HPC centre staff.","title":"Configuration options"},{"location":"2021-lust/cray/easybuild_at_cscs/#choosing-your-custom-folders","text":"You can override the default installation folder by exporting the environment variables listed below, before loading the EasyBuild modulefile: export EASYBUILD_PREFIX=/your/preferred/installation/folder export EB_CUSTOM_REPOSITORY=/your/local/repository/easybuild module load EasyBuild-custom The first environment variable is generally set before loading the EasyBuild modulefiles. The second one is instead specific to the CSCS EasyBuild-custom modulefile and corresponds to the EasyBuild variable XDG_CONFIG_DIRS : therefore, the custom modulefile expects to find the subfolders of the easybuild directory under the CSCS GitHub production repository. Note The variable XDG_CONFIG_DIRS might be used by other programs as well: in this case, you might consider alternative ways to provide EasyBuild configuration files The following environment variables depend on EB_CUSTOM_REPOSITORY : setenv XDG_CONFIG_DIRS $::env(EB_CUSTOM_REPOSITORY) setenv EASYBUILD_ROBOT_PATHS $::env(EB_CUSTOM_REPOSITORY)/easyconfigs/: setenv EASYBUILD_INCLUDE_EASYBLOCKS $::env(EB_CUSTOM_REPOSITORY)/easyblocks/*.py setenv EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES $::env(EB_CUSTOM_REPOSITORY)/tools/module_naming_scheme/*.py setenv EASYBUILD_INCLUDE_TOOLCHAINS $::env(EB_CUSTOM_REPOSITORY)/toolchains/*.py,$::env(EB_CUSTOM_REPOSITORY)/toolchains/compiler/*.py Users will find the CSCS EasyBuild configuration file under the folder easybuild.d of the EB_CUSTOM_REPOSITORY and the CSCS custom recipes under the easyconfigs folder, listed as usual in alphabetical order.","title":"Choosing your custom folders"},{"location":"2021-lust/cray/easybuild_at_cscs/#customizing-your-build-recipes","text":"If you wish to extend or customize the CSCS EasyBuild recipes, you can clone the CSCS production project from GitHub and have your private repository: git clone https://github.com/eth-cscs/production.git The command will download the project files under a newly created folder production. If you wish to use it as your custom repository, you need to export the corresponding EasyBuild environment variable: export EB_CUSTOM_REPOSITORY=/<your_local_path>/production/easybuild module load EasyBuild-custom You will find the CSCS EasyBuild build recipes files under /<your_local_path>/production/easybuild/easyconfigs , with application folders listed in alphabetical order.","title":"Customizing your build recipes"},{"location":"2021-lust/cray/easybuild_at_cscs/#site-wide-configuration-file","text":"The custom configuration of EasyBuild at CSCS is completed by the site wide configuration file available in the folder easybuild.d under XDG_CONFIG_DIRS , referenced in the modulefile EasyBuild-custom . The file defines the following: the list of hidden dependencies the list of hidden toolchains the list of allowed loaded modules The current content of the file is reported below: [override] # Comma separated list of dependencies that you want automatically hidden, (e.g. --hide-deps=zlib,ncurses) (type comma-separated list) hide-deps=absl,ANTLR,APR,APR-util,arpack-ng,Autoconf,Automake,Autotools,backports.weakref,Bazel,binutils,Bison,bokeh,byacc,bzip2,cairo,cloudpickle,configurable-http-proxy,Coreutils,Cube,CUDA,cuDNN,cURL,DB,Doxygen,Eigen,expat,flex,FLTK,fontconfig,freetype,funcsigs,gc,GCCcore,gettext,GL2PS,GLib,glmnet,GLPK,GMP,gnuplot,go,gperf,GPGME,GraphicsMagick,groff,GTS,guile,help2man,hwloc,inputproto,IPython,JasPer,jemalloc,kbproto,Libassuan,libcerf,libdrm,libevent,libfabric,libffi,libgd,libGLU,libgpuarray,libiberty,libjpeg-turbo,libjpeg-turbo,libpciaccess,Libpgp-error,libpng,libpthread-stubs,libQGLViewer,libreadline,libsodium,libspatialindex,LibTIFF,libtool,libunistring,libunwind,libutempter,libX11,libXau,libxcb,libXdmcp,libXext,libxml2,libXrender,libxshmfence,libyaml,LLVM,LOKI,Loki,LVM2,M4,make,makeinfo,Mako,Mesa,minieigen,mock,mxml,NASM,NASM,ncurses,nettle,networkx,nodejs,nose-parameterized,numactl,OPARI2,OpenMPI,OpenPGM,parameterized,PCRE,PDT,Perl,PIL,Pillow,pixman,pkg-config,ploticus,PMIx,popt,prereq,protobuf,protobuf-core,PyGTS,PyQt,Python-bare,Python-Xlib,PyYAML,PyZMQ,Qhull,qrupdate,Qt,renderproto,runc,scikit-image,scikit-learn,SCons,SCOTCH,Serf,SIP,SQLite,SWIG,Szip,Tcl,Tk,UCX,UDUNITS,UnZip,util-linux,Werkzeug,wheel,X11,xcb-proto,xextproto,xorg-macros,xproto,xtrans,XZ,ZeroMQ,zlib,zstd module-syntax=Tcl hide-toolchains=CrayCCE,CrayGNU,CrayIntel,CrayPGI,GCCcore,gmvapich2,gmvolf,foss,fosscuda,gompi allow-loaded-modules=ddt,EasyBuild-custom,EasyBuild,xalt","title":"Site wide configuration file"},{"location":"2021-lust/cray/easybuild_at_cscs/#easybuild-on-piz-daint","text":"On Piz Daint, which is a heterogeneous system, you need to select which architecture should be targeted when building software. You can target the Intel Haswell architecture accessing the gpu software stack using the command: module load daint-gpu EasyBuild-custom Alternatively, you can target the Intel Broadwell architecture and the mc (multicore) software stack: module load daint-mc EasyBuild-custom On Piz Daint, EasyBuild software and modules will be installed by default under the following folder: $HOME/easybuild/<system-name>/<architecture> Here <architecture> will be either haswell or broadwell .","title":"EasyBuild on Piz Daint"},{"location":"2021-lust/cray/easybuild_at_cscs/#building-your-program","text":"After you load the EasyBuild environment as explained in the section above, you will have the command eb available to build your code using EasyBuild. If you want to build the code using a given configuration <filename>.eb and resolving dependencies, you will use the flag -r as in the example below: eb <filename>.eb -r The build command just needs the configuration file name with the extension .eb and not the full path, provided that the configuration file is in your search path: the command eb --show-config will print the variable robot-paths that holds the search path. More options are available, please have a look at the short help message typing eb -h . For instance, you can check if any EasyBuild configuration file already exists for a given program name, using the search flag -S: eb -S <program_name> Please note that on Cray systems you can use the configuration files that rely of a Cray toolchain, which you will find in the configuration filename ( eb -S <name> | grep Cray ). You will be able to load the modules created by EasyBuild in the folder defined by the EASYBUILD_PREFIX variable using the following commands: module use $EASYBUILD_PREFIX/modules/all module load <modulename>/version The command module use will prepend the selected folder to your MODULEPATH environment variable, therefore you will see the new modules with module avail. Please note that by default EASYBUILD_PREFIX is set to a folder inside your $HOME , however the $HOME folder is by default not readable by other users. Therefore if you want to make your builds available to your group, then you need to allow read-only access to other members of your group using the command chmod g+rx $HOME .","title":"Building your Program"},{"location":"2021-lust/cray/external_modules/","text":"Using external modules from the Cray PE \u00b6 EasyBuild supports the use of modules that were not installed via EasyBuild is available. We refer to such modules as external modules . This feature is used extensively on Cray systems, since several software modules are already provided by the Cray PE: external modules can be used as dependencies , by including the module name in the dependencies list, along with the EXTERNAL_MODULE constant marker. For example, to specify the module cray-fftw as a dependency, you should write the following in your easyconfig file: dependencies = [('cray-fftw', EXTERNAL_MODULE)] For such dependencies, EasyBuild will: load the module before initiating the software build and install procedure include a module load statement in the generated module file (for runtime dependencies) Note The default version of the external module will be loaded unless a specific version is given as dependency If the specified module is not available, EasyBuild will exit with an error message stating that the dependency can not be resolved because the module could not be found, without searching for a matching easyconfig file. We show in the next sections the main external modules used as dependencies in the Cray PE. Note Component specific manpages are available only when the associated module is loaded. Compilers \u00b6 Cray PE supports multiple compilers, Cray and third party compilers as well: AOCC, Cray, Intel, GNU. Users can access the compilers loading the modules PrgEnv-cray (loaded by default at login), PrgEnv-gnu , PrgEnv-intel and PrgEnv-aocc . The corresponding compilers and their respective dependencies will be available, including wrappers and mapping (for example, mapping cc to gcc in PrgEnv-gnu ). The commands to invoke compiler wrappers are ftn (Fortran), cc (C), CC (C++). The online help can be accessed with the -help option. E.g.: cc -help , CC -help . One of the most frequently used options of the compiler wrappers is -craype-verbose : ftn -help | grep verbose -A 1 -craype-verbose Print the command which is forwarded to compiler invocation More information is available with the info or man commands. E.g.: both info cc or man cc will display the man page of the C compiler wrapper. The compiler wrappers call the correct compiler in the currently loaded programming environment, with appropriate options to build and link applications with relevant libraries, as required by the modules loaded. Therefore compiler wrappers should replace direct calls to compiler drivers in Makefiles and build scripts. Note Only dynamic linking is supported by compiler wrappers on the Cray EX system Cray Compiling Environment (CCE) \u00b6 The Cray Compiling Environment is set by the module PrgEnv-cray , which is loaded by default at login. Compiler-specific manpages can be accessed on the system with man crayftn , man craycc or man crayCC . More details are given in the Cray Fortran Reference Manual and the Cray Compiling Environment Release available on Cray Pubs . The Clang Compiler User\u2019s Manual is another source of information for the Cray C and C++ Clang compilers. The Cray Compiling Environment (CCE) provides Fortran, C and C++ compilers that perform substantial analysis during compilation and automatically generate highly optimized code. For more information about compiler pragmas and directives, see man intro_directives on the system. Third-Party Compilers \u00b6 AOCC \u00b6 The module PrgEnv-aocc loads the default AMD Optimizing C/C++ Compiler and sets the corresponding programming environment. Compiler-specific documentation is available in the AOCC User Guide . Cray provides a bundled package of support libraries to install into the PE environment to enable AOCC, and Cray PE utilities such as debuggers and performance tools work with AOCC. GNU \u00b6 The module PrgEnv-gnu loads the default GNU Compiler and sets the corresponding programming environment: the Cray PE bundles and enables the open-source GNU Compiler Collection (GCC). Compiler-specific manpages can be accessed on the system with man gfortran , man gcc or man g++ . More details are provided by the GCC online documentation . Intel \u00b6 The module PrgEnv-intel loads the default Intel Compiler and sets the corresponding programming environment: the Cray PE enables the Intel\u00ae oneAPI compiler and tools. The documentation is available in the Intel\u00ae oneAPI Programming Guide Cray provides a bundled package of support libraries to install into the Cray PE to enable the Intel compiler, allowing utilities such as debuggers and performance tools to work with it. Cray Scientific and Math Library \u00b6 Modules: cray-libsci , cray-fftw Manpages: intro_libsci , intro_fftw3 The Cray Scientific and Math Libraries (CSML, also known as LibSci) are a collection of numerical routines optimized for best performance on Cray systems. These libraries satisfy dependencies for many commonly used applications on Cray systems for a wide variety of domains. When the module for a CSML package (such as cray-libsci or cray-fftw ) is loaded, all relevant headers and libraries for these packages are added to the compile and link lines of the cc , ftn , and CC compiler wrappers. Scientific Libraries provided by CSML \u00b6 The CSML collection contains the following Scientific Libraries: BLAS (Basic Linear Algebra Subroutines) BLACS (Basic Linear Algebra Communication Subprograms) CBLAS (Collection of wrappers providing a C interface to the Fortran BLAS library) IRT (Iterative Refinement Toolkit) LAPACK (Linear Algebra Routines) LAPACKE (C interfaces to LAPACK Routines) ScaLAPACK (Scalable LAPACK) libsci_acc (library of Cray-optimized BLAS, LAPACK, and ScaLAPACK routines) NetCDF (Network Common Data Format) FFTW3 (the Fastest Fourier Transforms in the West, release 3) Cray MPICH \u00b6 Modules: cray-mpich Manpages: intro_mpi Website: https://www.mpi-forum.org MPI is a widely used parallel programming model that establishes a practical, portable, efficient, and flexible standard for passing messages between ranks in parallel processes. Cray MPI is derived from Argonne National Laboratory MPICH and implements the MPI-3.1 standard as documented by the MPI Forum in MPI: A Message Passing Interface Standard, Version 3.1. Support for MPI varies depending on system hardware. To see which functions and environment variables the system supports, please have a look at the corresponding man pages with man intro_mpi on the system. DSMML \u00b6 Modules: cray-dsmml Manpages: intro_dsmml Website: https://pe-cray.github.io/cray-dsmml Distributed Symmetric Memory Management Library (DSMML) is a HPE Cray proprietary memory management library. DSMML is a standalone memory management library for maintaining distributed shared symmetric memory heaps for top-level PGAS languages and libraries like Coarray Fortran, UPC, and OpenSHMEM. DSMML allows user libraries to create multiple symmetric heaps and share information with other libraries. Through DSMML, interoperability can be extracted between PGAS programming models. Further details are available in the man page on the system with man intro_dsmml . EasyBuild Metadata \u00b6 Metadata can be supplied to EasyBuild for external modules: using the --external-modules-metadata configuration option, the location of one or more metadata files can be specified. The files are expected to be in INI format, with a section per module name and key-value assignments specific to that module. The external modules metadata file can be also defined with the corresponding environment variable: echo $EASYBUILD_EXTERNAL_MODULES_METADATA /apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg The following keys are supported by EasyBuild : name: software name(s) provided by the module version: software version(s) provided by the module prefix: installation prefix of the software provided by the module For instance, the external module version loaded by the dependency cray-fftw can be specified as follows: [cray-fftw] name = FFTW prefix = FFTW_DIR/.. version = 3.3.8.10 The environment variable $EBROOTFFTW will also be defined according to the prefix specified in the metadata file. CPE meta-module \u00b6 The Cray PE on the EX system provides the meta-module cpe : the purpose of the meta-module is similar to the scope of the cdt and cdt-cuda meta-modules available on the XC systems. $ module show cpe -------------------------------------------------------------------------------------------------------------------------------- /opt/cray/pe/lmod/modulefiles/core/cpe/21.04.lua: -------------------------------------------------------------------------------------------------------------------------------- setenv(\"LMOD_MODULERCFILE\",\"/opt/cray/pe/cpe/21.04/modulerc.lua\") unload(\"PrgEnv-cray\") load(\"PrgEnv-cray/8.0.0\") unload(\"craype\") load(\"craype/2.7.6\") unload(\"cray-libsci\") load(\"cray-libsci/21.04.1.1\") unload(\"cce\") load(\"cce/11.0.4\") unload(\"cray-mpich\") load(\"cray-mpich/8.1.4\") unload(\"perftools-base\") load(\"perftools-base/21.02.0\") unload(\"cray-dsmml\") load(\"cray-dsmml/0.1.4\") The meta-module loads the correct default versions of the modules with the selected Cray PE version, as defined by the corresponding LMOD_MODULERCFILE referenced in the module. A site can create custom versions of the meta-module, in order to to override the module defaults. [next: Custom Toolchains]","title":"Using external modules"},{"location":"2021-lust/cray/external_modules/#using-external-modules-from-the-cray-pe","text":"EasyBuild supports the use of modules that were not installed via EasyBuild is available. We refer to such modules as external modules . This feature is used extensively on Cray systems, since several software modules are already provided by the Cray PE: external modules can be used as dependencies , by including the module name in the dependencies list, along with the EXTERNAL_MODULE constant marker. For example, to specify the module cray-fftw as a dependency, you should write the following in your easyconfig file: dependencies = [('cray-fftw', EXTERNAL_MODULE)] For such dependencies, EasyBuild will: load the module before initiating the software build and install procedure include a module load statement in the generated module file (for runtime dependencies) Note The default version of the external module will be loaded unless a specific version is given as dependency If the specified module is not available, EasyBuild will exit with an error message stating that the dependency can not be resolved because the module could not be found, without searching for a matching easyconfig file. We show in the next sections the main external modules used as dependencies in the Cray PE. Note Component specific manpages are available only when the associated module is loaded.","title":"Using external modules from the Cray PE"},{"location":"2021-lust/cray/external_modules/#compilers","text":"Cray PE supports multiple compilers, Cray and third party compilers as well: AOCC, Cray, Intel, GNU. Users can access the compilers loading the modules PrgEnv-cray (loaded by default at login), PrgEnv-gnu , PrgEnv-intel and PrgEnv-aocc . The corresponding compilers and their respective dependencies will be available, including wrappers and mapping (for example, mapping cc to gcc in PrgEnv-gnu ). The commands to invoke compiler wrappers are ftn (Fortran), cc (C), CC (C++). The online help can be accessed with the -help option. E.g.: cc -help , CC -help . One of the most frequently used options of the compiler wrappers is -craype-verbose : ftn -help | grep verbose -A 1 -craype-verbose Print the command which is forwarded to compiler invocation More information is available with the info or man commands. E.g.: both info cc or man cc will display the man page of the C compiler wrapper. The compiler wrappers call the correct compiler in the currently loaded programming environment, with appropriate options to build and link applications with relevant libraries, as required by the modules loaded. Therefore compiler wrappers should replace direct calls to compiler drivers in Makefiles and build scripts. Note Only dynamic linking is supported by compiler wrappers on the Cray EX system","title":"Compilers"},{"location":"2021-lust/cray/external_modules/#cray-compiling-environment-cce","text":"The Cray Compiling Environment is set by the module PrgEnv-cray , which is loaded by default at login. Compiler-specific manpages can be accessed on the system with man crayftn , man craycc or man crayCC . More details are given in the Cray Fortran Reference Manual and the Cray Compiling Environment Release available on Cray Pubs . The Clang Compiler User\u2019s Manual is another source of information for the Cray C and C++ Clang compilers. The Cray Compiling Environment (CCE) provides Fortran, C and C++ compilers that perform substantial analysis during compilation and automatically generate highly optimized code. For more information about compiler pragmas and directives, see man intro_directives on the system.","title":"Cray Compiling Environment (CCE)"},{"location":"2021-lust/cray/external_modules/#third-party-compilers","text":"","title":"Third-Party Compilers"},{"location":"2021-lust/cray/external_modules/#aocc","text":"The module PrgEnv-aocc loads the default AMD Optimizing C/C++ Compiler and sets the corresponding programming environment. Compiler-specific documentation is available in the AOCC User Guide . Cray provides a bundled package of support libraries to install into the PE environment to enable AOCC, and Cray PE utilities such as debuggers and performance tools work with AOCC.","title":"AOCC"},{"location":"2021-lust/cray/external_modules/#gnu","text":"The module PrgEnv-gnu loads the default GNU Compiler and sets the corresponding programming environment: the Cray PE bundles and enables the open-source GNU Compiler Collection (GCC). Compiler-specific manpages can be accessed on the system with man gfortran , man gcc or man g++ . More details are provided by the GCC online documentation .","title":"GNU"},{"location":"2021-lust/cray/external_modules/#intel","text":"The module PrgEnv-intel loads the default Intel Compiler and sets the corresponding programming environment: the Cray PE enables the Intel\u00ae oneAPI compiler and tools. The documentation is available in the Intel\u00ae oneAPI Programming Guide Cray provides a bundled package of support libraries to install into the Cray PE to enable the Intel compiler, allowing utilities such as debuggers and performance tools to work with it.","title":"Intel"},{"location":"2021-lust/cray/external_modules/#cray-scientific-and-math-library","text":"Modules: cray-libsci , cray-fftw Manpages: intro_libsci , intro_fftw3 The Cray Scientific and Math Libraries (CSML, also known as LibSci) are a collection of numerical routines optimized for best performance on Cray systems. These libraries satisfy dependencies for many commonly used applications on Cray systems for a wide variety of domains. When the module for a CSML package (such as cray-libsci or cray-fftw ) is loaded, all relevant headers and libraries for these packages are added to the compile and link lines of the cc , ftn , and CC compiler wrappers.","title":"Cray Scientific and Math Library"},{"location":"2021-lust/cray/external_modules/#scientific-libraries-provided-by-csml","text":"The CSML collection contains the following Scientific Libraries: BLAS (Basic Linear Algebra Subroutines) BLACS (Basic Linear Algebra Communication Subprograms) CBLAS (Collection of wrappers providing a C interface to the Fortran BLAS library) IRT (Iterative Refinement Toolkit) LAPACK (Linear Algebra Routines) LAPACKE (C interfaces to LAPACK Routines) ScaLAPACK (Scalable LAPACK) libsci_acc (library of Cray-optimized BLAS, LAPACK, and ScaLAPACK routines) NetCDF (Network Common Data Format) FFTW3 (the Fastest Fourier Transforms in the West, release 3)","title":"Scientific Libraries provided by CSML"},{"location":"2021-lust/cray/external_modules/#cray-mpich","text":"Modules: cray-mpich Manpages: intro_mpi Website: https://www.mpi-forum.org MPI is a widely used parallel programming model that establishes a practical, portable, efficient, and flexible standard for passing messages between ranks in parallel processes. Cray MPI is derived from Argonne National Laboratory MPICH and implements the MPI-3.1 standard as documented by the MPI Forum in MPI: A Message Passing Interface Standard, Version 3.1. Support for MPI varies depending on system hardware. To see which functions and environment variables the system supports, please have a look at the corresponding man pages with man intro_mpi on the system.","title":"Cray MPICH"},{"location":"2021-lust/cray/external_modules/#dsmml","text":"Modules: cray-dsmml Manpages: intro_dsmml Website: https://pe-cray.github.io/cray-dsmml Distributed Symmetric Memory Management Library (DSMML) is a HPE Cray proprietary memory management library. DSMML is a standalone memory management library for maintaining distributed shared symmetric memory heaps for top-level PGAS languages and libraries like Coarray Fortran, UPC, and OpenSHMEM. DSMML allows user libraries to create multiple symmetric heaps and share information with other libraries. Through DSMML, interoperability can be extracted between PGAS programming models. Further details are available in the man page on the system with man intro_dsmml .","title":"DSMML"},{"location":"2021-lust/cray/external_modules/#easybuild-metadata","text":"Metadata can be supplied to EasyBuild for external modules: using the --external-modules-metadata configuration option, the location of one or more metadata files can be specified. The files are expected to be in INI format, with a section per module name and key-value assignments specific to that module. The external modules metadata file can be also defined with the corresponding environment variable: echo $EASYBUILD_EXTERNAL_MODULES_METADATA /apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg The following keys are supported by EasyBuild : name: software name(s) provided by the module version: software version(s) provided by the module prefix: installation prefix of the software provided by the module For instance, the external module version loaded by the dependency cray-fftw can be specified as follows: [cray-fftw] name = FFTW prefix = FFTW_DIR/.. version = 3.3.8.10 The environment variable $EBROOTFFTW will also be defined according to the prefix specified in the metadata file.","title":"EasyBuild Metadata"},{"location":"2021-lust/cray/external_modules/#cpe-meta-module","text":"The Cray PE on the EX system provides the meta-module cpe : the purpose of the meta-module is similar to the scope of the cdt and cdt-cuda meta-modules available on the XC systems. $ module show cpe -------------------------------------------------------------------------------------------------------------------------------- /opt/cray/pe/lmod/modulefiles/core/cpe/21.04.lua: -------------------------------------------------------------------------------------------------------------------------------- setenv(\"LMOD_MODULERCFILE\",\"/opt/cray/pe/cpe/21.04/modulerc.lua\") unload(\"PrgEnv-cray\") load(\"PrgEnv-cray/8.0.0\") unload(\"craype\") load(\"craype/2.7.6\") unload(\"cray-libsci\") load(\"cray-libsci/21.04.1.1\") unload(\"cce\") load(\"cce/11.0.4\") unload(\"cray-mpich\") load(\"cray-mpich/8.1.4\") unload(\"perftools-base\") load(\"perftools-base/21.02.0\") unload(\"cray-dsmml\") load(\"cray-dsmml/0.1.4\") The meta-module loads the correct default versions of the modules with the selected Cray PE version, as defined by the corresponding LMOD_MODULERCFILE referenced in the module. A site can create custom versions of the meta-module, in order to to override the module defaults. [next: Custom Toolchains]","title":"CPE meta-module"},{"location":"2021-lust/cray/introduction/","text":"Introduction to the Cray Programming Environment \u00b6 The Cray Programming Environment (PE) provides tools designed to maximize developer productivity, application scalability, and code performance, including compilers, analyzers, optimized libraries, and debuggers. Cray PE Components \u00b6 Cray Compiling Environment (CCE) : CCE consists of Cray compilers performing code analysis during compilation to generate highly optimized code. Supported languages include Fortran, C and C++, and UPC (Unified Parallel C). Cray Scientific and Mathematical Libraries : A set of high performance libraries providing portability for scientific applications, sparse and dense linear algebra (BLAS, LAPACK, ScaLAPACK) and fast Fourier transforms (FFTW). Cray Message Passing Toolkit : A collection of software libraries used to perform data transfers between nodes running in parallel applications. It includes the Message Passing Interface (MPI) and OpenSHMEM parallel programming models. Cray Environment Setup and Compiling Support : Libraries supporting code compilation and setting up the development environment, including compiler drivers. Cray Performance and Analysis Tools : Tools to analyze the performance and behavior of programs that are run on Cray systems, and a Performance API (PAPI). Cray Debugging Support Tools : Debugging tools, including gdb4hpc and Valgrind4hpc . Modules \u00b6 Modules enable users to modify their environment dynamically by using modulefiles: the module command provides a user interface to the Environment Modules package. The module command interprets modulefiles, which contain Tool Command Language (Tcl) code, and dynamically modifies shell environment variables such as PATH and MANPATH . Cray sites can alternately enable Lmod to handle modules with the Cray Programming Environment on Cray EX Systems. Both module systems use the same module names and syntax shown in command-line examples. Note Environment Modules and Lmod are mutually exclusive and cannot both run on the same system. The configuration files /etc/cray-pe.d/cray-pe-configuration.sh and /etc/cray-pe.d/cray-pe-configuration.csh allow sites to customize the default environment. To support customer-specific needs, the system administrator can create modulefiles for a product set for the users: for more information about the Environment Modules software package see the help screen module -h . Programming Environment meta-modules \u00b6 Programming Environment modules are organized into meta-modules, where each supports a different compiler suite. These modules are PrgEnv-aocc , PrgEnv-cray , PrgEnv-gnu and PrgEnv-intel . Meta-modules provide wrappers ( cc , CC , ftn ) for both Cray and third-party compiler drivers. The main purposes of using the Cray wrappers are the following: call the correct compiler with appropriate options to build and link applications link relevant libraries as required by modules loaded, with only dynamic linking supported replace direct calls to compiler drivers in Makefiles and build scripts Lmod \u00b6 In addition to the default Environment Modules system, Cray PE offers support for Lmod as an alternative module management system. Lmod is a Lua-based module system that loads and unloads modulefiles, handles path variables, and manages library and header files. The Cray PE implementation of Lmod is hierarchical, managing module dependencies and ensuring any module a user has access to is compatible with other loaded modules. Lmod loads related compiler, network, CPU, and MPI modules adding dynamic module paths to the Lmod hierarchy: \"families\" of modules are used to flag circular conflicts, for instance: when module details are displayed through module show when users attempt to load conflicting modules a default set of modules is loaded automatically: the default set includes compiler, network, CPU and MPI modules Users may choose to load a different module set, defining user collections Environment Modules and Lmod modules use the same names in the Cray Programming Environment, therefore all command examples work the same whether using Environment Modules or Lmod. For more information, please refer to the User Guide for Lmod . Documentation \u00b6 Cray Pubs is the documentation portal of HPE/Cray and the main source of the information provided in this tutorial. Documentation on the Cray Programming Environment (PE) can be found under the PE-Tile . The page provides links to the following content: PE Release Announcements PE Installation & Configuration Cray Compiling Environment (CCE) PE User Procedures (including Cray Programming Environment User Guides) The GitHub project PE-Cray provides additional documentation: Whitepapers are available at https://github.com/PE-Cray/whitepapers Documentation for cray-openshmemx Information on cray-dsmml [next: External Modules]","title":"Introduction to the Cray PE"},{"location":"2021-lust/cray/introduction/#introduction-to-the-cray-programming-environment","text":"The Cray Programming Environment (PE) provides tools designed to maximize developer productivity, application scalability, and code performance, including compilers, analyzers, optimized libraries, and debuggers.","title":"Introduction to the Cray Programming Environment"},{"location":"2021-lust/cray/introduction/#cray-pe-components","text":"Cray Compiling Environment (CCE) : CCE consists of Cray compilers performing code analysis during compilation to generate highly optimized code. Supported languages include Fortran, C and C++, and UPC (Unified Parallel C). Cray Scientific and Mathematical Libraries : A set of high performance libraries providing portability for scientific applications, sparse and dense linear algebra (BLAS, LAPACK, ScaLAPACK) and fast Fourier transforms (FFTW). Cray Message Passing Toolkit : A collection of software libraries used to perform data transfers between nodes running in parallel applications. It includes the Message Passing Interface (MPI) and OpenSHMEM parallel programming models. Cray Environment Setup and Compiling Support : Libraries supporting code compilation and setting up the development environment, including compiler drivers. Cray Performance and Analysis Tools : Tools to analyze the performance and behavior of programs that are run on Cray systems, and a Performance API (PAPI). Cray Debugging Support Tools : Debugging tools, including gdb4hpc and Valgrind4hpc .","title":"Cray PE Components"},{"location":"2021-lust/cray/introduction/#modules","text":"Modules enable users to modify their environment dynamically by using modulefiles: the module command provides a user interface to the Environment Modules package. The module command interprets modulefiles, which contain Tool Command Language (Tcl) code, and dynamically modifies shell environment variables such as PATH and MANPATH . Cray sites can alternately enable Lmod to handle modules with the Cray Programming Environment on Cray EX Systems. Both module systems use the same module names and syntax shown in command-line examples. Note Environment Modules and Lmod are mutually exclusive and cannot both run on the same system. The configuration files /etc/cray-pe.d/cray-pe-configuration.sh and /etc/cray-pe.d/cray-pe-configuration.csh allow sites to customize the default environment. To support customer-specific needs, the system administrator can create modulefiles for a product set for the users: for more information about the Environment Modules software package see the help screen module -h .","title":"Modules"},{"location":"2021-lust/cray/introduction/#programming-environment-meta-modules","text":"Programming Environment modules are organized into meta-modules, where each supports a different compiler suite. These modules are PrgEnv-aocc , PrgEnv-cray , PrgEnv-gnu and PrgEnv-intel . Meta-modules provide wrappers ( cc , CC , ftn ) for both Cray and third-party compiler drivers. The main purposes of using the Cray wrappers are the following: call the correct compiler with appropriate options to build and link applications link relevant libraries as required by modules loaded, with only dynamic linking supported replace direct calls to compiler drivers in Makefiles and build scripts","title":"Programming Environment meta-modules"},{"location":"2021-lust/cray/introduction/#lmod","text":"In addition to the default Environment Modules system, Cray PE offers support for Lmod as an alternative module management system. Lmod is a Lua-based module system that loads and unloads modulefiles, handles path variables, and manages library and header files. The Cray PE implementation of Lmod is hierarchical, managing module dependencies and ensuring any module a user has access to is compatible with other loaded modules. Lmod loads related compiler, network, CPU, and MPI modules adding dynamic module paths to the Lmod hierarchy: \"families\" of modules are used to flag circular conflicts, for instance: when module details are displayed through module show when users attempt to load conflicting modules a default set of modules is loaded automatically: the default set includes compiler, network, CPU and MPI modules Users may choose to load a different module set, defining user collections Environment Modules and Lmod modules use the same names in the Cray Programming Environment, therefore all command examples work the same whether using Environment Modules or Lmod. For more information, please refer to the User Guide for Lmod .","title":"Lmod"},{"location":"2021-lust/cray/introduction/#documentation","text":"Cray Pubs is the documentation portal of HPE/Cray and the main source of the information provided in this tutorial. Documentation on the Cray Programming Environment (PE) can be found under the PE-Tile . The page provides links to the following content: PE Release Announcements PE Installation & Configuration Cray Compiling Environment (CCE) PE User Procedures (including Cray Programming Environment User Guides) The GitHub project PE-Cray provides additional documentation: Whitepapers are available at https://github.com/PE-Cray/whitepapers Documentation for cray-openshmemx Information on cray-dsmml [next: External Modules]","title":"Documentation"},{"location":"2022-isc22/","text":"ISC'22 EasyBuild tutorial \u00b6 Maintaining a Modern Scientific Software Stack Made Easy with EasyBuild \u00b6 The EasyBuild tutorial at ISC'22 takes place on Sunday 29 May 2022, 14:00-18:00 CEST . To attend the live tutorial, you must be registered to ISC'22 ( more information here ). All tutorial content will remain afterwards. Slides \u00b6 The most recent version of the presentation slides are available here . Agenda \u00b6 ( all times are CEST) [14:00-14:10] Practical info w.r.t. prepared environment for hands-on [14:10-14:30] Introduction to EasyBuild : scope and terminology [14:30-14:50] Installing , configuring and basic usage of EasyBuild [14:50-15:30] Installing software + troubleshooting [15:30-16:00] Adding support for additional software [16:00-16:30] (coffee break) [16:30-16:50] Module naming schemes (incl. hierarchical) [16:50-17:30] Integration of EasyBuild in JSC , EESSI , and LUMI [17:30-17:45] The EasyBuild community + contributing to EasyBuild [17:45-18:00] Q&A + closing remarks (incl. quick comparison with other tools )","title":"ISC'22 EasyBuild tutorial"},{"location":"2022-isc22/#isc22-easybuild-tutorial","text":"","title":"ISC'22 EasyBuild tutorial"},{"location":"2022-isc22/#maintaining-a-modern-scientific-software-stack-made-easy-with-easybuild","text":"The EasyBuild tutorial at ISC'22 takes place on Sunday 29 May 2022, 14:00-18:00 CEST . To attend the live tutorial, you must be registered to ISC'22 ( more information here ). All tutorial content will remain afterwards.","title":"Maintaining a Modern Scientific Software Stack Made Easy with EasyBuild"},{"location":"2022-isc22/#slides","text":"The most recent version of the presentation slides are available here .","title":"Slides"},{"location":"2022-isc22/#agenda","text":"( all times are CEST) [14:00-14:10] Practical info w.r.t. prepared environment for hands-on [14:10-14:30] Introduction to EasyBuild : scope and terminology [14:30-14:50] Installing , configuring and basic usage of EasyBuild [14:50-15:30] Installing software + troubleshooting [15:30-16:00] Adding support for additional software [16:00-16:30] (coffee break) [16:30-16:50] Module naming schemes (incl. hierarchical) [16:50-17:30] Integration of EasyBuild in JSC , EESSI , and LUMI [17:30-17:45] The EasyBuild community + contributing to EasyBuild [17:45-18:00] Q&A + closing remarks (incl. quick comparison with other tools )","title":"Agenda"},{"location":"2022-isc22/adding_support_additional_software/","text":"Adding support for additional software \u00b6 We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves! Easyconfigs vs easyblocks \u00b6 Before we dive into writing easyconfig files , let's take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild. It specifies the details of the installation (which software version, toolchain, dependencies including their versions, etc.), while the installation procedure is implemented in an easyblock (a Python module that leverages the EasyBuild framework). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in general, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the implementation of the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; For example, the easyblock for bowtie2 defines a number of variables used in the Makefile on the make command line to ensure that the right compilers are used (look for the build_step in the easyblock). toolchain-specific aspects of the build and installation procedure (e.g., configure options); For example, the easyblock for CP2K will add several compiler options when compiling with gcc and gfortran, including the infamous -fallow-argument-mismatch which is required from gfortran 10 on for many older codes. custom (configure) options for dependencies; For example, the easyblock for VMD will add configure options depending on the dependency list of the package. interactive commands that need to be run; For example: The easyblock for maple responds to a number of interactive questions. having to create or adjust specific (configuration) files; For example, the easyblock for Siesta edits one of the configuration files through regular expressions. 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; For example, the easyblock to install the gcc compilers from source , bootstrapping with the system compiler and then re-installing with itself. Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation , or a more extensive version of the EasyBuild tutorial . Writing easyconfig files \u00b6 Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (EasyBuild will then derive the name of the easyconfig from the name, version, version suffix and toolchain specified for the dependency so the file name needs to adhere to a specific convention as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them. Mandatory parameters \u00b6 A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 11.2.0 which we used before, or the full toolchain foss 2021b. The name and version of the toolchain can be specified using a small Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } Commonly used parameters \u00b6 You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, in the order in which you would usually specify them in the easyconfig file, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation . Easyblock \u00b6 The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together in a single installation directory; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblocks is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock \" or just \" eb -a -e \", which results in an additional \" EASYBLOCK-SPECIFIC \" section to be added. See the (partial) output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ] Version suffix \u00b6 In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '2.7.18' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation. Sources, patches, and checksums \u00b6 In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported . Dependencies \u00b6 You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.22.1' )] dependencies = [ ( 'Python' , '3.9.6' ), ( 'HDF5' , '1.12.1' ), ( 'SciPy-bundle' , '2021.10' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies. Customizing configure, build, test, and install commands \u00b6 When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.12.1' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support The ' ... ' represents the path to installation directory where the software should be installed. The --prefix option is included automatically by the ConfigureMake easyblock. specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). passing the location where the software should be installed via the PREFIX argument to the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable that we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an $EBROOT* environment variable like this in every environment module file it generates (see the output of \" module show HDF5 \"). Sanity check \u00b6 One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ] Module class \u00b6 Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ). Generating tweaked easyconfigs \u00b6 Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2021b.eb --try-toolchain intel,2021b There is also an option to change other eashyconfig parameters, --try-amend=VAR=Value[,VALUE] . eb example-123-foss-2021b-DP.eb --try-amend = versionsuffix = '-test' This option can be used multiple times to make additional amendments. It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example. The easyconfig files modified in this way will be stored in the easybuild subdirectory of the software installation directory and in the easyconfig archive that EasyBuild creates. Copying easyconfigs \u00b6 One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.11-GCC-11.2.0.eb SAMtools.eb ... SAMtools-1.10-GCC-11.2.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files at once, as long as the target location is an existing directory. Example \u00b6 By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.1 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1 . Preparation \u00b6 Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all Mandatory parameters \u00b6 Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file. We will use GCC/11.2.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment, so we define the toolchain easyconfig parameter: name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a sensible value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning. Easyblock \u00b6 Let us see what happens if we take our current easyconfig file for a spin: $ eb example.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/example.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for installing the software with the name ' eb-tutorial '. Does that mean we have to implement an easyblock? In this simple case it doesn't, since we can leverage one of the available generic easyblocks . But, which one? Build instructions are usually included in a README file, or in the documentation. In this case, there's indeed a minimal README file available, which tells us that we should use the cmake command to configure the installation, followed by make and make install . We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one). CMake build dependency \u00b6 Does using the CMakeMake generic easyblock help at all? $ eb example.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/example.eb == building and installing eb-tutorial/1.0.1-GCC-11.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-11.2.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.22.1-GCCcore-11.2.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 11.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.22.1' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D (equivalent with eb --dry-run ): $ eb example.eb -D ... * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-11.2.0.eb (module: GCC/11.2.0) * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.22.1-GCCcore-11.2.0.eb (module: CMake/3.22.1-GCCcore-11.2.0) * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-11.2.0) Sources \u00b6 If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-11.2.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-11.2.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-11.2.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify one or more source files that should be used, via the sources easyconfig parameter which specifies a list of names of source files: sources = [ 'eb-tutorial-1.0.1.tar.gz' ] We can avoid hardcoding the version number here by using a template value : sources = [ 'eb-tutorial- %(version)s .tar.gz' ] And since this is a standard way of naming software files, there's even a constant available that we can use: sources = [ SOURCE_TAR_GZ ] That way, we only have the software version specified once in the easyconfig file, via the version easyconfig parameter. That will come in useful later (see Exercise E.2 )... If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere: Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either... To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via source_urls : source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] Required configure option \u00b6 With sources and source_urls defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise E.1 ). Sanity check \u00b6 Hopefully that brings us closer to getting the installation to work... $ eb example.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-11.2.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 (took 2 sec) It got all the way to the sanity check step, that's great! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we need to customize the standard sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via --trace we can get some more information too: $ eb example.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial! Complete easyconfig \u00b6 Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'd6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9' ] builddependencies = [( 'CMake' , '3.22.1' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' One additional easyconfig parameter we defined here is checksums , which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation. You can let EasyBuild determine and inject these SHA256 checksums automatically via eb --inject-checksums : $ eb example.eb --inject-checksums ... == injecting sha256 checksums for sources & patches in example.eb... == * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9 Exercises \u00b6 Exercise E.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the example.eb easyconfig, you will need to use eb --rebuild or eb --force (or the short form eb -f ). Exercise E.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.1. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb example.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-11.2.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.1 doesn't print \" I have a message for you: \") If you check the easyconfig file that was generated (which is saved as $EASYBUILD_PREFIX/ebfiles_repo/eb-tutorial/eb-tutorial-1.1.0-GCC-11.2.0.eb ), you will see that that file now contains a lot of data from the build. This can be safely deleted, but EasyBuild will also simply ignore it if you try to build from that file. You will also notice that the checksum went missing. EasyBuild was clever enough to delete the checksum when it changed the version to ensure that the build would not fail after downloading the new sources. You can always copy the generated easyconfig to your working directory, clean up the mess at the end, and then add a checksum again using eb eb-tutorial-1.1.0-GCC-11.2.0.eb --inject-checksums to get a fully-featured easyconfig again. Exercise E.3 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when installing Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2021b' } dependencies = [ ( 'Python' , '3.9.6' ), ( 'SciPy-bundle' , '2021.10' ), ( 'eb-tutorial' , '1.0.1' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. Even when the default installation mechanism used by PythonPackage (which consists of running python setup.py install ) works fine, it is recommended to instruct EasyBuild to use pip install instead. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by the PythonPackage easyblock is already pretty decent (it will check for a non-empty lib/python3.9/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.9 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file. next: Module naming schemes - (back to overview page)","title":"Adding support for additional software"},{"location":"2022-isc22/adding_support_additional_software/#adding-support-for-additional-software","text":"We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet? To do this we will need to create additional easyconfig files , since every software installation performed by EasyBuild is done based on an easyconfig file. In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!","title":"Adding support for additional software"},{"location":"2022-isc22/adding_support_additional_software/#easyconfigs-vs-easyblocks","text":"Before we dive into writing easyconfig files , let's take a brief look at how they relate to easyblocks . As we discussed earlier , an easyconfig file ( *.eb ) is required for each installation performed by EasyBuild. It specifies the details of the installation (which software version, toolchain, dependencies including their versions, etc.), while the installation procedure is implemented in an easyblock (a Python module that leverages the EasyBuild framework). When can we leverage a generic easyblock , perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock? This is not an easy question to answer in general, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the implementation of the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc. In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package. Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include: 'critical' values for easyconfig parameters required to make installation succeed; For example, the easyblock for bowtie2 defines a number of variables used in the Makefile on the make command line to ensure that the right compilers are used (look for the build_step in the easyblock). toolchain-specific aspects of the build and installation procedure (e.g., configure options); For example, the easyblock for CP2K will add several compiler options when compiling with gcc and gfortran, including the infamous -fallow-argument-mismatch which is required from gfortran 10 on for many older codes. custom (configure) options for dependencies; For example, the easyblock for VMD will add configure options depending on the dependency list of the package. interactive commands that need to be run; For example: The easyblock for maple responds to a number of interactive questions. having to create or adjust specific (configuration) files; For example, the easyblock for Siesta edits one of the configuration files through regular expressions. 'hackish' usage of a generic easyblock; complex or very non-standard installation procedure; For example, the easyblock to install the gcc compilers from source , bootstrapping with the system compiler and then re-installing with itself. Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation , or a more extensive version of the EasyBuild tutorial .","title":"Easyconfigs vs easyblocks"},{"location":"2022-isc22/adding_support_additional_software/#writing-easyconfig-files","text":"Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a ' .eb ' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (EasyBuild will then derive the name of the easyconfig from the name, version, version suffix and toolchain specified for the dependency so the file name needs to adhere to a specific convention as we discussed earlier ). The syntax for easyconfig files is Python syntax : you are basically defining a bunch of Python variables that correspond to easyconfig parameters. The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.","title":"Writing easyconfig files"},{"location":"2022-isc22/adding_support_additional_software/#mandatory-parameters","text":"A limited number of easyconfig parameters are mandatory , they must be defined in every easyconfig file: name : the name of the software to install; version : the version of the software to install; homepage : a URL to the website of the software; description : a short description of the software; toolchain : the compiler toolchain to use for the installation; name , version It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install. name = 'example' version = '1.0' homepage , description The homepage and description are included in the generated module file for the installation. That way the \" module show \" command provides some useful high-level information about the installation. homepage = 'https://example.org' description = \"This is just an example.\" Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!). For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax): description = \"\"\"This is an example of a multi-line description. It is spread across multiple lines.\"\"\" toolchain EasyBuild also requires that the compiler toolchain is specified, via the toolchain easyconfig parameter. This can either be the system toolchain , for which a constant named SYSTEM is available: toolchain = SYSTEM Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 11.2.0 which we used before, or the full toolchain foss 2021b. The name and version of the toolchain can be specified using a small Python dictionary, for example: toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' }","title":"Mandatory parameters"},{"location":"2022-isc22/adding_support_additional_software/#commonly-used-parameters","text":"You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, in the order in which you would usually specify them in the easyconfig file, but keep in mind that these are not mandatory. A full overview of all known easyconfig parameters can be obtained via \" eb --avail-easyconfig-params \" or just \" eb -a \" for short, or can be consulted in the EasyBuild documentation .","title":"Commonly used parameters"},{"location":"2022-isc22/adding_support_additional_software/#easyblock","text":"The easyblock that should be used for the installation can be specified via the easyblock easyconfig parameter. This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If ' example ' is specified as software name, EasyBuild will try to locate a software-specific easyblock named EB_example (in a Python module named example.py ). Software-specific easyblocks follow the convention that the class name starts with 'EB_ ', followed by the software name (where some characters are replaced, like ' - ' with ' _minus_ '). Generic easyblocks Usually the easyblock value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with ' EB_ ', so you can easily distinguish it from a software-specific easyblock. Here are a couple of commonly used generic easyblocks: ConfigureMake : implements the standard ./configure , make , make install installation procedure; CMakeMake : same as ConfigureMake , but with ./configure replaced with cmake for the configuration step; PythonPackage : implements the installation procedure for a single Python package, by default using \" python setup.py install \" but other methods like using \" pip install \" are also supported; Bundle : a simple generic easyblock to bundle a set of software packages together in a single installation directory; PythonBundle : a customized version of the Bundle generic easyblock to install a bundle of Python packages in a single installation directory; A full overview of the available generic easyblocks is available in the EasyBuild documentation . You can also consult the output of eb --list-easyblocks , which gives an overview of all known easyblocks, and how they relate to each other. Custom easyconfig parameters Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \" eb -a --easyblock \" or just \" eb -a -e \", which results in an additional \" EASYBLOCK-SPECIFIC \" section to be added. See the (partial) output of this command for example: $ eb -a -e ConfigureMake Available easyconfig parameters ( * indicates specific to the ConfigureMake easyblock ) : ... EASYBLOCK-SPECIFIC ------------------ build_cmd* Build command to use [ default: \"make\" ] build_type* Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] configure_cmd* Configure command to use [ default: \"./configure\" ] configure_cmd_prefix* Prefix to be glued before ./configure [ default: \"\" ] host_type* Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu ( determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script ) [ default: None ] install_cmd* Build command to use [ default: \"make install\" ] prefix_opt* Prefix command line option for configure script ( '--prefix=' if None ) [ default: None ] tar_config_opts* Override tar settings as determined by configure. [ default: False ]","title":"Easyblock"},{"location":"2022-isc22/adding_support_additional_software/#version-suffix","text":"In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation. The versionsuffix easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme. If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example: versionsuffix = '-example-label' This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the %(pyver)s template comes in useful again: versionsuffix = '-Python- %(pyver)s ' ... dependencies = [( 'Python' , '2.7.18' )] Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The versionsuffix label is helpful to inform the user that a particular Python version is required by the installation.","title":"Version suffix"},{"location":"2022-isc22/adding_support_additional_software/#sources-patches-and-checksums","text":"In most easyconfig files you will see that a list of source files is specified via the sources easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via source_urls . There also may be patch files listed (specified via patches ), and checksums for both the source files and patches (specified via checksums ). The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. Here is an example of how these easyconfig parameters can be specified: source_urls = [ 'https://example.org/download/' , 'https://example.org/download/archive/' , ] sources = [ 'example-1.0-src.tar.gz' ] patches = [ 'example-fix.patch' ] checksums = [ '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa' , '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c' , ] Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list ( [] ). Some things worth pointing out here: The download URLs specified via source_urls do not include the name of the file, that is added automatically by EasyBuild when it tries to download the file (only if it's not available already.) If multiple download URLs are specified, they are each tried once in order until the download of the source file was successful. This can be useful to include backup locations where source files can be downloaded from. Names of source files and patches should not include hardcoded software versions, they usually use a template value like %(version)s instead: sources = [ 'example- %(version)s -src.tar.gz' ] EasyBuild will use the value of the version easyconfig parameter to determine the actual name of the source file. This way the software version is only specified in one place and the easyconfig file is easier to update to other software versions. A list of template values can be consulted via the EasyBuild command line via the --avail-easyconfig-templates option, or in the EasyBuild documentation . Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information. Specified checksums are usually SHA256 checksum values, but other types are also supported .","title":"Sources, patches, and checksums"},{"location":"2022-isc22/adding_support_additional_software/#dependencies","text":"You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies. Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the dependencies easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file. Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the builddependencies easyconfig parameter. One typical example of a build dependency is CMake , which is only needed for configuring the build. Here is a simple example of specifying dependencies: builddependencies = [( 'CMake' , '3.22.1' )] dependencies = [ ( 'Python' , '3.9.6' ), ( 'HDF5' , '1.12.1' ), ( 'SciPy-bundle' , '2021.10' , '-Python- %(pyver)s ' ), ] Both builddependencies and dependencies require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values). In some cases additional information may have to be provided, as is shown in the example above for the SciPy-bundle dependency where a 3rd value is specified corresponding to the versionsuffix value of this dependency. If this is not specified, it is assumed to be the empty string ( '' ). Note how we use the ' %(pyver)s' template value in the SciPy-bundle dependency specification, to avoid hardcoding the Python version in different places. See also the EasyBuild documentation for additional options on specifying dependencies.","title":"Dependencies"},{"location":"2022-isc22/adding_support_additional_software/#customizing-configure-build-test-and-install-commands","text":"When using a generic easyblock like ConfigureMake or CMakeMake , you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them. For this the following standard easyconfig parameters are available: preconfigopts : string value that is glued before the configure command; configopts : string value that is added after the configure command, which can be used to specify configuration options; Equivalent easyconfig parameters are available for the build , test and install steps: prebuildopts , buildopts , pretestopts , testopts , preinstallopts , and installopts . Here is a fictitious example of how they can be used: easyblock = 'ConfigureMake' ... dependencies = [( 'HDF5' , '1.12.1' )] ... configopts = '--enable-hdf5-support' prebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" && ' installopts = \"PREFIX=' %(installdir)s '\" Here we are: adding the --enable-hdf5-support configure option, to convince the ConfigureMake easyblock to run the following command during the configure step: ./configure --prefix ... --enable-hdf5-support The ' ... ' represents the path to installation directory where the software should be installed. The --prefix option is included automatically by the ConfigureMake easyblock. specifying that an additional command has to be run before running make in the build step. We use ' && ' to glue the command to the make command, so make will only be run if the command we specified ran correctly. So, the build step will run something like: export HDF5_PREFIX = \" $EBROOTHDF5 \" && make -j 4 The ' 4 ' value passed to the -j option shown here, which specifies how many commands make can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account ulimit settings, and cpuset and cgroup restrictions). passing the location where the software should be installed via the PREFIX argument to the make install command during the installation step. This results in the following command being run: make install PREFIX = ... (where the ' ... ' again represents the path to installation directory). Even though the installation directory is already specified in the configure command, it is apparently blatantly ignored by the software we are installing here, and we are expected to specify it this way instead. How rude! The $EBROOTHDF5 environment variable that we are using in prebuildopts corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an $EBROOT* environment variable like this in every environment module file it generates (see the output of \" module show HDF5 \").","title":"Customizing configure, build, test, and install commands"},{"location":"2022-isc22/adding_support_additional_software/#sanity-check","text":"One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step. By default EasyBuild does a simple sanity check that verifies whether there is a non-empty bin subdirectory in the installation, next to a non-empty lib or lib64 directory (either is sufficient). It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like example -V or example --help ) runs correctly. To specify a custom set of files and/or directories to check, you can use the sanity_check_paths easyconfig parameter. The expected value is Python dictionary with two keys: files and dirs . For example: sanity_check_paths = { 'files' : [ 'bin/example' ], 'dirs' : [ 'examples/one' , 'examples/two' ], } In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the sanity_check_commands easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example: sanity_check_commands = [ \"example --version\" , \"example --help\" , ]","title":"Sanity check"},{"location":"2022-isc22/adding_support_additional_software/#module-class","text":"Finally, you will usually see the moduleclass easyconfig parameter to be defined as well, for example: moduleclass = 'lib' This is done to categorize software, and it is used to group the generated module files into smaller sets ( remember what we saw when installing software earlier ).","title":"Module class"},{"location":"2022-isc22/adding_support_additional_software/#generating-tweaked-easyconfigs","text":"Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too? We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the --try-* options provided by the eb command to make EasyBuild generate a new easyconfig file based on an existing one. For example, to try installing a different software version you can use the --try-software-version option: eb example-1.2.3.eb --try-software-version 1 .2.4 Or, to try using a different compiler toolchain you can use --try-toolchain : eb example-1.2.3-foss-2021b.eb --try-toolchain intel,2021b There is also an option to change other eashyconfig parameters, --try-amend=VAR=Value[,VALUE] . eb example-123-foss-2021b-DP.eb --try-amend = versionsuffix = '-test' This option can be used multiple times to make additional amendments. It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a --try-* option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example. The easyconfig files modified in this way will be stored in the easybuild subdirectory of the software installation directory and in the easyconfig archive that EasyBuild creates.","title":"Generating tweaked easyconfigs"},{"location":"2022-isc22/adding_support_additional_software/#copying-easyconfigs","text":"One additional handy command line option we want to highlight is --copy-ec , which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the eb command using only the filename, and letting the robot search mechanism locate them. So to copy an easyconfig file, we would have to use eb --search first to get the full location to it, copy-paste that, and then use the cp command. It is a lot easier with --copy-ec : $ eb --copy-ec SAMtools-1.11-GCC-11.2.0.eb SAMtools.eb ... SAMtools-1.10-GCC-11.2.0.eb copied to SAMtools.eb If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename. You can copy multiple easyconfig files at once, as long as the target location is an existing directory.","title":"Copying easyconfigs"},{"location":"2022-isc22/adding_support_additional_software/#example","text":"By means of example, we are going to puzzle together an easyconfig file to install the example software package eb-tutorial . The sources for eb-tutorial version 1.0.1 are available at: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1 .","title":"Example"},{"location":"2022-isc22/adding_support_additional_software/#preparation","text":"Make sure EasyBuild is properly configured before you start: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER and that the installed software in /easybuild is available: module use /easybuild/modules/all","title":"Preparation"},{"location":"2022-isc22/adding_support_additional_software/#mandatory-parameters_1","text":"Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file. We will use GCC/11.2.0 as toolchain, since we know it is already installed in /easybuild in the prepared environment, so we define the toolchain easyconfig parameter: name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } In addition, we'll also specify the moduleclass . This is not required, but it is usually set to a sensible value: moduleclass = 'tools' The default value is ' base ', at least ' tools ' has some meaning.","title":"Mandatory parameters"},{"location":"2022-isc22/adding_support_additional_software/#easyblock_1","text":"Let us see what happens if we take our current easyconfig file for a spin: $ eb example.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log ERROR: Failed to process easyconfig /home/example/example.eb: No software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial That didn't get us very far... The error shows that there is no software-specific easyblock available for installing the software with the name ' eb-tutorial '. Does that mean we have to implement an easyblock? In this simple case it doesn't, since we can leverage one of the available generic easyblocks . But, which one? Build instructions are usually included in a README file, or in the documentation. In this case, there's indeed a minimal README file available, which tells us that we should use the cmake command to configure the installation, followed by make and make install . We briefly discussed a generic easyblock that does exactly this: CMakeMake . easyblock = 'CMakeMake' The \" easyblock = \" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).","title":"Easyblock"},{"location":"2022-isc22/adding_support_additional_software/#cmake-build-dependency","text":"Does using the CMakeMake generic easyblock help at all? $ eb example.eb == temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log == found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/example.eb == building and installing eb-tutorial/1.0.1-GCC-11.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-11.2.0): build failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native (took 0 sec) It did help: EasyBuild made an attempt to configure the build using the cmake command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message: /bin/bash: cmake: command not found Ah, that explains it, cmake isn't even installed on this system. Or is it? $ module avail CMake --------------------------- /easybuild/modules/all ---------------------------- CMake/3.22.1-GCCcore-11.2.0 Since a module is available for CMake that is compatible with the toolchain we are using (GCC 11.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency: builddependencies = [( 'CMake' , '3.22.1' )] There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies. You can verify this via eb -D (equivalent with eb --dry-run ): $ eb example.eb -D ... * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-11.2.0.eb (module: GCC/11.2.0) * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.22.1-GCCcore-11.2.0.eb (module: CMake/3.22.1-GCCcore-11.2.0) * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-11.2.0)","title":"CMake build dependency"},{"location":"2022-isc22/adding_support_additional_software/#sources","text":"If you try again after adding CMake as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this: CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-11.2.0\" does not appear to contain CMakeLists.txt. Wait, but there is a CMakeLists.txt , we can see it in the unpacked sources ! Let's inspect the build directory: $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-11.2.0 easybuild_obj $ ls /tmp/$USER/ebtutorial/1.0.1/GCC-11.2.0/easybuild_obj $ There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file... The sources easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file. So we need to specify one or more source files that should be used, via the sources easyconfig parameter which specifies a list of names of source files: sources = [ 'eb-tutorial-1.0.1.tar.gz' ] We can avoid hardcoding the version number here by using a template value : sources = [ 'eb-tutorial- %(version)s .tar.gz' ] And since this is a standard way of naming software files, there's even a constant available that we can use: sources = [ SOURCE_TAR_GZ ] That way, we only have the software version specified once in the easyconfig file, via the version easyconfig parameter. That will come in useful later (see Exercise E.2 )... If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere: Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either... To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via source_urls : source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ]","title":"Sources"},{"location":"2022-isc22/adding_support_additional_software/#required-configure-option","text":"With sources and source_urls defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe... Here's what we find in the log file: CMake Error at CMakeLists.txt:7 (message): EBTUTORIAL_MSG is not set! Apparently the eb-tutorial software has a required configure option. It's almost as if that was done on purpose, how silly! Options to the configure command can be specified by the configopts easyconfig parameter. To define the value of a CMake option, we need to use -DNAME_OF_OPTION , so: configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the EBTUTORIAL_MSG configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise E.1 ).","title":"Required configure option"},{"location":"2022-isc22/adding_support_additional_software/#sanity-check_1","text":"Hopefully that brings us closer to getting the installation to work... $ eb example.eb .... == sanity checking... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-11.2.0): build failed (first 300 chars): Sanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 (took 2 sec) It got all the way to the sanity check step, that's great! The sanity check failed because no ' lib ' or 'lib64' directory was found. Indeed: $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 bin $ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0/bin eb-tutorial There is only a binary named eb-tutorial in the bin subdirectory. So we need to customize the standard sanity check: sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } Since we want to obtain a working installation, we might as well try to run this eb-tutorial command as well: sanity_check_commands = [ 'eb-tutorial' ] Let us now retry, but use --module-only rather than redoing the whole installation. --module-only still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via --trace we can get some more information too: $ eb example.eb --module-only --trace ... == sanity checking... >> file 'bin/eb-tutorial' found: OK >> running command 'eb-tutorial' ... >> result for command 'eb-tutorial' : OK ... == COMPLETED: Installation ended successfully ( took 4 sec ) Yes, great success! To convince yourself that the installation works as intended, try to load the eb-tutorial module and run the eb-tutorial command yourself: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial $ eb-tutorial Hello from the EasyBuild tutorial!","title":"Sanity check"},{"location":"2022-isc22/adding_support_additional_software/#complete-easyconfig","text":"Here is the complete easyconfig we puzzled together for this example: easyblock = 'CMakeMake' name = 'eb-tutorial' version = '1.0.1' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial example\" toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'd6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9' ] builddependencies = [( 'CMake' , '3.22.1' )] configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \" sanity_check_paths = { 'files' : [ 'bin/eb-tutorial' ], 'dirs' : [], } sanity_check_commands = [ 'eb-tutorial' ] moduleclass = 'tools' One additional easyconfig parameter we defined here is checksums , which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation. You can let EasyBuild determine and inject these SHA256 checksums automatically via eb --inject-checksums : $ eb example.eb --inject-checksums ... == injecting sha256 checksums for sources & patches in example.eb... == * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9","title":"Complete easyconfig"},{"location":"2022-isc22/adding_support_additional_software/#exercises","text":"Exercise E.1 - Making eb-tutorial a bit more personal Change the easyconfig file for eb-tutorial to make the message printed by the eb-tutorial command a bit more personal: include the username of the account that was used to install the software in it (using the $USER environment variable). (click to show solution) For this we need to change the value that is passed to the EBTUTORIAL_MSG configure option: configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" ' Here we have to use inner double quotes, to ensure that the $USER environment variable is expanded by the shell when running the cmake configure command. When you run the eb-tutorial command yourself, you should get output like this (not a message that includes a literal ' $USER ' string): Hello from the EasyBuild tutorial! I was installed by example. To re-install the example.eb easyconfig, you will need to use eb --rebuild or eb --force (or the short form eb -f ). Exercise E.2 - Installing eb-tutorial version 1.1.0 Install version 1.1.0 of the eb-tutorial example software, which is a trivial version bump compared to version 1.0.1. The sources are available via: https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz You can leverage the eb-tutorial easyconfig file we have composed in the example above, but you should not make any manual changes to it! (click to show solution) You can use the --try-software-version option for this: $ eb example.eb --try-software-version 1 .1.0 ... == building and installing eb-tutorial/1.1.0-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 4 sec ) To test: $ module use $HOME/easybuild/modules/all $ module load eb-tutorial/1.1.0-GCC-11.2.0 $ eb-tutorial I have a message for you: Hello from the EasyBuild tutorial! ( eb-tutorial version 1.0.1 doesn't print \" I have a message for you: \") If you check the easyconfig file that was generated (which is saved as $EASYBUILD_PREFIX/ebfiles_repo/eb-tutorial/eb-tutorial-1.1.0-GCC-11.2.0.eb ), you will see that that file now contains a lot of data from the build. This can be safely deleted, but EasyBuild will also simply ignore it if you try to build from that file. You will also notice that the checksum went missing. EasyBuild was clever enough to delete the checksum when it changed the version to ensure that the build would not fail after downloading the new sources. You can always copy the generated easyconfig to your working directory, clean up the mess at the end, and then add a checksum again using eb eb-tutorial-1.1.0-GCC-11.2.0.eb --inject-checksums to get a fully-featured easyconfig again. Exercise E.3 - Installing py-eb-tutorial 1.0.0 Try composing an easyconfig file for the py-eb-tutorial example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz . A couple of tips: There is a generic easyblock available for installing Python packages, which will come in useful here. By default EasyBuild performs an import check when installing Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the options easyconfig parameter in your easyconfig file: options = { 'modulename' : 'example' } (you will need to change ' example ' here, of course) Leverage the software that is already pre-installed in /easybuild in the prepared environment. Remember that some already installed modules may be a bundle of a couple of other software packages. Please also take this into account: Unfortunately this software doesn't come with documentation. That is done to make it an example that is representative for software that you may run into in the wild (it's not because we were lazy when preparing the exercises, really!). You can inspect the sources of this software here . Definitely take a look at the setup.py file, it includes some clues about the requirements to get this software installed. Make sure the installation actually works , by checking that the py-eb-tutorial command runs correctly. Maybe you will need to make sure other required software is available as well, for it to work correctly... (click to show solution) Here is a complete working easyconfig file for py-eb-tutorial : easyblock = 'PythonPackage' name = 'py-eb-tutorial' version = '1.0.0' versionsuffix = '-Python- %(pyver)s ' homepage = 'https://easybuilders.github.io/easybuild-tutorial' description = \"EasyBuild tutorial Python example\" source_urls = [ 'https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/' ] sources = [ SOURCE_TAR_GZ ] checksums = [ 'fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496' ] toolchain = { 'name' : 'foss' , 'version' : '2021b' } dependencies = [ ( 'Python' , '3.9.6' ), ( 'SciPy-bundle' , '2021.10' ), ( 'eb-tutorial' , '1.0.1' ), ] use_pip = True options = { 'modulename' : 'eb_tutorial' } sanity_check_paths = { 'files' : [ 'bin/py-eb-tutorial' ], 'dirs' : [ 'lib/python %(pyshortver)s /site-packages' ], } sanity_check_commands = [ \"py-eb-tutorial\" ] moduleclass = 'tools' Some remarks: We used the PythonPackage generic easyblock. There is also a PythonBundle easyblock for installing bundles of Python packages, which is used for SciPy-bundle for example. But we don't need that here, since we are only dealing with a single Python package. The versionsuffix is not strictly needed, but it's common to tag Python packages with the Python version for which they were installed. The SHA256 checksum for the source tarball was added automatically via eb py-eb-tutorial.eb --inject-checksums . py-eb-tutorial only wants to be installed with pip install , so we had to set use_pip = True . You can consult the custom easyconfig parameters supported by the PythonPackage easyblock via \" eb -a -e PythonPackage \", see the EASYBLOCK-SPECIFIC part of the output. Even when the default installation mechanism used by PythonPackage (which consists of running python setup.py install ) works fine, it is recommended to instruct EasyBuild to use pip install instead. By default EasyBuild will try to import py_eb_tutorial , while the actual name of the Python package provided by py-eb-tutorial is just eb_tutorial . We fixed this by specifying the correct Python module name to use via options . Strictly speaking we don't need to specify a custom sanity_check_paths , since the default used by the PythonPackage easyblock is already pretty decent (it will check for a non-empty lib/python3.9/site-packages directory in the installation). We also want to make sure the py-eb-tutorial command is available in the bin subdirectory however. Hardcoding to python3.9 can be avoided using the %(pyshortver)s template value. A good way to check whether the py-eb-tutorial command works correctly is by running it as a sanity check command. If the eb-tutorial command is not available the py-eb-tutorial command will fail, since it basically just runs the eb-tutorial command. So we need to include eb-tutorial as a (runtime) dependency in the py-eb-tutorial easyconfig file. next: Module naming schemes - (back to overview page)","title":"Exercises"},{"location":"2022-isc22/basic_usage/","text":"Basic usage of Easybuild \u00b6 Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention! Overall workflow \u00b6 Installing software with EasyBuild is as easy as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , often combined with the --robot option to let EasyBuild also install missing dependencies. Alternatively one can specify the name of an easystack file that specifies a collection of software to install, but this feature is currently still marked as * experimental* meaning that it may fail or that may change in incompatible ways in future versions of EasyBuild. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be. Specifying easyconfigs \u00b6 Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; an easystack file to specify a whole stack of software to install at once (via eb --easystack ); Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with .eb , and (try to) use these as easyconfig files. Example command \u00b6 Suppose we have the current situation in our home directory: two (easyconfig) files named example1.eb and example2.eb ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1.eb example2.eb some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb example1.eb bzip2-1.0.6.eb $HOME /example2.eb some_deps EasyBuild will interpret each of these arguments as follows: example1.eb is the name of a file in the current directory, so it can be used directly; bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); $HOME/example2.eb specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , The list.txt file will be ignored since its name does not end with .eb . Easyconfig filenames \u00b6 Note that the eb command does not care how easyconfig files are named, at least to some extent: the .eb file extension does matter when easyconfig files are being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adhere to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ), and which is omitted (including the preceding - ) when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default); Searching for easyconfigs \u00b6 You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package. This can be done by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the search-paths configuration setting, or you can change the robot search path via either the robot or robot-paths configuration options. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for OpenFOAM 8 with a foss toolchain: $ eb --search openfoam-8-foss * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b-20210316.eb * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb The output is a bit more condensed when using eb -S : $ eb -S openfoam-8-foss CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM * $CFGS1 /OpenFOAM-8-foss-2020a.eb * $CFGS1 /OpenFOAM-8-foss-2020b-20210316.eb * $CFGS1 /OpenFOAM-8-foss-2020b.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , or other special characters like ^ or $ to mark the start/end of the filename, but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install TensorFlow 2.6.0 with the 2021a version of a toolchain: $ eb -S '^tensorflow-2.6.0.*2021a' CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/t/TensorFlow * $CFGS1 /TensorFlow-2.6.0-foss-2021a-CUDA-11.3.1.eb * $CFGS1 /TensorFlow-2.6.0-foss-2021a.eb Search index \u00b6 When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information . Inspecting easyconfigs \u00b6 Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.8.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.8' homepage = 'https://sourceware.org/bzip2' description = \"\"\" bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression. \"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/%(name)s/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'ab5a03176ee106d3f0fa90e381da478ddae405918153cca248e682cd0c4a2269' , # bzip2-1.0.8.tar.gz '9299e8ee4d014ea973777b6ea90661fe329dfa991f822add4c763ea9ddb9aab1' , # bzip2-1.0.8-pkgconfig.patch ] builddependencies = [ ( 'binutils' , '2.37' ) , ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later... Checking dependencies \u00b6 Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \" by informing the modules tool about the pre-installed software stack in /easybuild : module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ). Dry run \u00b6 To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the required dependencies for SAMtools-1.11-GCC-10.2.0.eb are already installed: $ eb SAMtools-1.14-GCC-11.2.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-11.2.0.eb ( module: bzip2/1.0.8-GCCcore-11.2.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-11.2.0.eb ( module: XZ/5.2.5-GCCcore-11.2.0 ) * [ x ] $CFGS /g/GCC/GCC-11.2.0.eb ( module: GCC/11.2.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-11.2.0.eb ( module: ncurses/6.2-GCCcore-11.2.0 ) * [ x ] $CFGS /p/pkg-config/pkg-config-0.29.2.eb ( module: pkg-config/0.29.2 ) * [ x ] $CFGS /o/OpenSSL/OpenSSL-1.1.eb ( module: OpenSSL/1.1 ) * [ x ] $CFGS /c/cURL/cURL-7.78.0-GCCcore-11.2.0.eb ( module: cURL/7.78.0-GCCcore-11.2.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.14-GCC-11.2.0.eb ( module: SAMtools/1.14-GCC-11.2.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.14-GCC-11.2.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an x in [ ] . Missing dependencies \u00b6 If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get version 3.6.1 of the PyTables Python package installed using the 2021b version of the foss toolchain: $ eb PyTables-3.6.1-foss-2021b.eb -M 3 out of 69 required modules missing: * LZO/2.10-GCCcore-11.2.0 ( LZO-2.10-GCCcore-11.2.0.eb ) * Blosc/1.21.1-GCCcore-11.2.0 ( Blosc-1.21.1-GCCcore-11.2.0.eb ) * PyTables/3.6.1-foss-2021b ( PyTables-3.6.1-foss-2021b.eb ) That should be pretty self-explanatory: out of the 69 required dependencies (which includes the foss toolchain and everything needed to install it), only 3 dependencies are missing. Great! Inspecting install procedures \u00b6 Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.74.0-GCC-10.2.0.eb : $ eb Boost-1.77.0-GCC-11.2.0.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load GCC/11.2.0 Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-11.2.0 module load zlib/1.2.11-GCCcore-11.2.0 module load XZ/5.2.5-GCCcore-11.2.0 ... Defining build environment... ... export CXX = 'g++' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.77.0-GCC-11.2.0 --without-libraries=python,mpi\" ( in /tmp/example/build/Boost/1.77.0/GCC-11.2.0/Boost-1.77.0 ) ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_system-mt-x64.so * lib/libboost_system.so * lib/libboost_thread-mt-x64.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient to explain what all this output means. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step, and in which directory; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless. Exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not share solutions with others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.5.4. Exercise U.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. We will assume that you have a small software stack installed using the 2021b version of the foss toolchain. Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. To verify that the pre-installed software is available, check whether the foss/2020b module is available: $ module avail foss/ --------------------- /easybuild/modules/all --------------------- foss/2021b Exercise U.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2021.5. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2021.5 == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... CFGS1 = //home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2021.5-foss-2021b-CUDA-11.4.1.eb * $CFGS1 /GROMACS-2021.5-foss-2021b.eb * $CFGS1 /GROMACS-2021.5_fix_threads_gpu_Gmxapitests.patch This actually shows two easyconfig files but also a patch file. We can also search specifically for GROMACS 2021.5 in the foss and fosscuda toolchains using $ eb -S gromacs-2021.5-foss == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2021.5-foss-2021b-CUDA-11.4.1.eb * $CFGS1 /GROMACS-2021.5-foss-2021b.eb and now we find just the two easyconfig files. Exercise U.2 - Checking dependencies Check which dependencies are missing to install QuantumESPRESSO version 6.8 with the 2021b version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: $ eb -S 'QuantumESPRESSO-6.8.*foss-2021b' == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/q/QuantumESPRESSO * $CFGS1 /QuantumESPRESSO-6.8-foss-2021b.eb To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use --missing : $ eb QuantumESPRESSO-6.8-foss-2021b.eb --missing 3 out of 65 required modules missing: * libxc/5.1.6-GCC-11.2.0 ( libxc-5.1.6-GCC-11.2.0.eb ) * ELPA/2021.05.001-foss-2021b ( ELPA-2021.05.001-foss-2021b.eb ) * QuantumESPRESSO/6.8-foss-2021b ( QuantumESPRESSO-6.8-foss-2021b.eb ) (some nonessential output removed). Exercise U.3 - Performing a dry run Figure out which command EasyBuild would use to compile the software provided by the Bowtie2-2.4.4-GCC-11.2.0.eb easyconfig file, without actually installing Bowtie2 . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x Bowtie2-2.4.4-GCC-11.2.0.eb . The output for the build step shows the actual compilation command that would be performed ( make ... ): [ build_step method ] >> running command: [ started at: 2021 -03-08 20 :15:08 ] [ working dir: /tmp/eb-0006djcd/__ROOT__/tmp/example/Bowtie2/2.4.4/GCC-11.2.0/Bowtie2-2.4.4 ] [ output logged in /tmp/eb-0006djcd/easybuild-run_cmd-haojzisn.log ] make -j 8 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" running command \"make -j 16 CC=\" gcc \" CPP=\" g++ \" CXX=\" g++ \" RELEASE_FLAGS=\" -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 \"\" ( in /tmp/example/Bowtie2/2.4.4/GCC-11.2.0/Bowtie2-2.4.4 ) If the output you get is less detailed, you may not have set export EASYBUILD_TRACE=1 . The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/LICENSE * bin/MANUAL * bin/MANUAL.markdown * bin/NEWS * bin/bowtie2 * bin/bowtie2-align-l * bin/bowtie2-align-s * bin/bowtie2-build * bin/bowtie2-build-l * bin/bowtie2-build-s * bin/bowtie2-inspect * bin/bowtie2-inspect-l * bin/bowtie2-inspect-s next: Installing software - (back to overview page)","title":"Basic usage of Easybuild"},{"location":"2022-isc22/basic_usage/#basic-usage-of-easybuild","text":"Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!","title":"Basic usage of Easybuild"},{"location":"2022-isc22/basic_usage/#overall-workflow","text":"Installing software with EasyBuild is as easy as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , often combined with the --robot option to let EasyBuild also install missing dependencies. Alternatively one can specify the name of an easystack file that specifies a collection of software to install, but this feature is currently still marked as * experimental* meaning that it may fail or that may change in incompatible ways in future versions of EasyBuild. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be.","title":"Overall workflow"},{"location":"2022-isc22/basic_usage/#specifying-easyconfigs","text":"Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; an easystack file to specify a whole stack of software to install at once (via eb --easystack ); Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with .eb , and (try to) use these as easyconfig files.","title":"Specifying easyconfigs"},{"location":"2022-isc22/basic_usage/#example-command","text":"Suppose we have the current situation in our home directory: two (easyconfig) files named example1.eb and example2.eb ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1.eb example2.eb some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb example1.eb bzip2-1.0.6.eb $HOME /example2.eb some_deps EasyBuild will interpret each of these arguments as follows: example1.eb is the name of a file in the current directory, so it can be used directly; bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); $HOME/example2.eb specifies the full path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , The list.txt file will be ignored since its name does not end with .eb .","title":"Example command"},{"location":"2022-isc22/basic_usage/#easyconfig-filenames","text":"Note that the eb command does not care how easyconfig files are named, at least to some extent: the .eb file extension does matter when easyconfig files are being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adhere to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ), and which is omitted (including the preceding - ) when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default);","title":"Easyconfig filenames"},{"location":"2022-isc22/basic_usage/#searching-for-easyconfigs","text":"You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package. This can be done by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the search-paths configuration setting, or you can change the robot search path via either the robot or robot-paths configuration options. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for OpenFOAM 8 with a foss toolchain: $ eb --search openfoam-8-foss * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b-20210316.eb * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb The output is a bit more condensed when using eb -S : $ eb -S openfoam-8-foss CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM * $CFGS1 /OpenFOAM-8-foss-2020a.eb * $CFGS1 /OpenFOAM-8-foss-2020b-20210316.eb * $CFGS1 /OpenFOAM-8-foss-2020b.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , or other special characters like ^ or $ to mark the start/end of the filename, but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install TensorFlow 2.6.0 with the 2021a version of a toolchain: $ eb -S '^tensorflow-2.6.0.*2021a' CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/t/TensorFlow * $CFGS1 /TensorFlow-2.6.0-foss-2021a-CUDA-11.3.1.eb * $CFGS1 /TensorFlow-2.6.0-foss-2021a.eb","title":"Searching for easyconfigs"},{"location":"2022-isc22/basic_usage/#search-index","text":"When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information .","title":"Search index"},{"location":"2022-isc22/basic_usage/#inspecting-easyconfigs","text":"Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.8.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.8' homepage = 'https://sourceware.org/bzip2' description = \"\"\" bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression. \"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/%(name)s/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'ab5a03176ee106d3f0fa90e381da478ddae405918153cca248e682cd0c4a2269' , # bzip2-1.0.8.tar.gz '9299e8ee4d014ea973777b6ea90661fe329dfa991f822add4c763ea9ddb9aab1' , # bzip2-1.0.8-pkgconfig.patch ] builddependencies = [ ( 'binutils' , '2.37' ) , ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later...","title":"Inspecting easyconfigs"},{"location":"2022-isc22/basic_usage/#checking-dependencies","text":"Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \" by informing the modules tool about the pre-installed software stack in /easybuild : module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ).","title":"Checking dependencies"},{"location":"2022-isc22/basic_usage/#dry-run","text":"To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the required dependencies for SAMtools-1.11-GCC-10.2.0.eb are already installed: $ eb SAMtools-1.14-GCC-11.2.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-11.2.0.eb ( module: bzip2/1.0.8-GCCcore-11.2.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-11.2.0.eb ( module: XZ/5.2.5-GCCcore-11.2.0 ) * [ x ] $CFGS /g/GCC/GCC-11.2.0.eb ( module: GCC/11.2.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-11.2.0.eb ( module: ncurses/6.2-GCCcore-11.2.0 ) * [ x ] $CFGS /p/pkg-config/pkg-config-0.29.2.eb ( module: pkg-config/0.29.2 ) * [ x ] $CFGS /o/OpenSSL/OpenSSL-1.1.eb ( module: OpenSSL/1.1 ) * [ x ] $CFGS /c/cURL/cURL-7.78.0-GCCcore-11.2.0.eb ( module: cURL/7.78.0-GCCcore-11.2.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.14-GCC-11.2.0.eb ( module: SAMtools/1.14-GCC-11.2.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.14-GCC-11.2.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an x in [ ] .","title":"Dry run"},{"location":"2022-isc22/basic_usage/#missing-dependencies","text":"If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get version 3.6.1 of the PyTables Python package installed using the 2021b version of the foss toolchain: $ eb PyTables-3.6.1-foss-2021b.eb -M 3 out of 69 required modules missing: * LZO/2.10-GCCcore-11.2.0 ( LZO-2.10-GCCcore-11.2.0.eb ) * Blosc/1.21.1-GCCcore-11.2.0 ( Blosc-1.21.1-GCCcore-11.2.0.eb ) * PyTables/3.6.1-foss-2021b ( PyTables-3.6.1-foss-2021b.eb ) That should be pretty self-explanatory: out of the 69 required dependencies (which includes the foss toolchain and everything needed to install it), only 3 dependencies are missing. Great!","title":"Missing dependencies"},{"location":"2022-isc22/basic_usage/#inspecting-install-procedures","text":"Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.74.0-GCC-10.2.0.eb : $ eb Boost-1.77.0-GCC-11.2.0.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load GCC/11.2.0 Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-11.2.0 module load zlib/1.2.11-GCCcore-11.2.0 module load XZ/5.2.5-GCCcore-11.2.0 ... Defining build environment... ... export CXX = 'g++' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.77.0-GCC-11.2.0 --without-libraries=python,mpi\" ( in /tmp/example/build/Boost/1.77.0/GCC-11.2.0/Boost-1.77.0 ) ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_system-mt-x64.so * lib/libboost_system.so * lib/libboost_thread-mt-x64.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient to explain what all this output means. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step, and in which directory; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.","title":"Inspecting install procedures"},{"location":"2022-isc22/basic_usage/#exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not share solutions with others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.5.4. Exercise U.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. We will assume that you have a small software stack installed using the 2021b version of the foss toolchain. Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. To verify that the pre-installed software is available, check whether the foss/2020b module is available: $ module avail foss/ --------------------- /easybuild/modules/all --------------------- foss/2021b Exercise U.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2021.5. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2021.5 == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... CFGS1 = //home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2021.5-foss-2021b-CUDA-11.4.1.eb * $CFGS1 /GROMACS-2021.5-foss-2021b.eb * $CFGS1 /GROMACS-2021.5_fix_threads_gpu_Gmxapitests.patch This actually shows two easyconfig files but also a patch file. We can also search specifically for GROMACS 2021.5 in the foss and fosscuda toolchains using $ eb -S gromacs-2021.5-foss == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2021.5-foss-2021b-CUDA-11.4.1.eb * $CFGS1 /GROMACS-2021.5-foss-2021b.eb and now we find just the two easyconfig files. Exercise U.2 - Checking dependencies Check which dependencies are missing to install QuantumESPRESSO version 6.8 with the 2021b version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: $ eb -S 'QuantumESPRESSO-6.8.*foss-2021b' == found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it... CFGS1 = /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/q/QuantumESPRESSO * $CFGS1 /QuantumESPRESSO-6.8-foss-2021b.eb To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use --missing : $ eb QuantumESPRESSO-6.8-foss-2021b.eb --missing 3 out of 65 required modules missing: * libxc/5.1.6-GCC-11.2.0 ( libxc-5.1.6-GCC-11.2.0.eb ) * ELPA/2021.05.001-foss-2021b ( ELPA-2021.05.001-foss-2021b.eb ) * QuantumESPRESSO/6.8-foss-2021b ( QuantumESPRESSO-6.8-foss-2021b.eb ) (some nonessential output removed). Exercise U.3 - Performing a dry run Figure out which command EasyBuild would use to compile the software provided by the Bowtie2-2.4.4-GCC-11.2.0.eb easyconfig file, without actually installing Bowtie2 . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x Bowtie2-2.4.4-GCC-11.2.0.eb . The output for the build step shows the actual compilation command that would be performed ( make ... ): [ build_step method ] >> running command: [ started at: 2021 -03-08 20 :15:08 ] [ working dir: /tmp/eb-0006djcd/__ROOT__/tmp/example/Bowtie2/2.4.4/GCC-11.2.0/Bowtie2-2.4.4 ] [ output logged in /tmp/eb-0006djcd/easybuild-run_cmd-haojzisn.log ] make -j 8 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" running command \"make -j 16 CC=\" gcc \" CPP=\" g++ \" CXX=\" g++ \" RELEASE_FLAGS=\" -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 \"\" ( in /tmp/example/Bowtie2/2.4.4/GCC-11.2.0/Bowtie2-2.4.4 ) If the output you get is less detailed, you may not have set export EASYBUILD_TRACE=1 . The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/LICENSE * bin/MANUAL * bin/MANUAL.markdown * bin/NEWS * bin/bowtie2 * bin/bowtie2-align-l * bin/bowtie2-align-s * bin/bowtie2-build * bin/bowtie2-build-l * bin/bowtie2-build-s * bin/bowtie2-inspect * bin/bowtie2-inspect-l * bin/bowtie2-inspect-s next: Installing software - (back to overview page)","title":"Exercises"},{"location":"2022-isc22/community/","text":"The EasyBuild community \u00b6","title":"The EasyBuild community"},{"location":"2022-isc22/community/#the-easybuild-community","text":"","title":"The EasyBuild community"},{"location":"2022-isc22/comparison_other_tools/","text":"Comparison between EasyBuild and other tools \u00b6","title":"Comparison between EasyBuild and other tools"},{"location":"2022-isc22/comparison_other_tools/#comparison-between-easybuild-and-other-tools","text":"","title":"Comparison between EasyBuild and other tools"},{"location":"2022-isc22/configuration/","text":"Configuring EasyBuild \u00b6 After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it. Available configuration settings \u00b6 One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, about 270 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones. We will refer to EasyBuild configuration settings using the names as they appears in the output of eb --help , and omit the leading dashes ( -- ) for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details. Overall prefix \u00b6 (default: $HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which can be useful to test and evaluate software installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default software and modules/all names for the subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is strongly recommend to use the path to a directory on a local filesystem for the value of the buildpath configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like /dev/shm/$USER ) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like noexec ). Use a directory on a local filesystem for buildpath for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set buildpath to /tmp/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named ' Example ', EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in sourcepath only read permissions are required. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation ). For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod (next to Tcl syntax). To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool; see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in Lua syntax. We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command, as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between these two configuration settings is that defining robot also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining robot-paths does not have the side effect of enabling dependency resolution. In addition, you can use the --robot command line option without specifying any paths to it, to only enable dependency resolution. Note Keep in mind that when either of the robot (with paths) or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered . There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes . The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Just like with names of easyconfig files , the <-toolchain> part is omitted when the system toolchain is used, and the <versionsuffix> value is empty by default. Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ) is not defined and if the --magic command line option is not used; If the $EASYBUILD_MAGIC environment variable is defined however, then its value will be used for the magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead. Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files (usually *.cfg ) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file ( *.eb ) on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ). Although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Through the --show-config command line option you can easily inspect the currently active EasyBuild configuration. The output of --show-config includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produced by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which affects the value shown for the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ), and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Example Now let us do some basic configuring and inspect the resulting output of eb --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg In addition, define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run eb --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --show-config --installpath = /tmp/ $USER # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with (C) ), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ). Exercises \u00b6 Exercise C.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: The location of the build directories: use /tmp/$USER for this; The locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources . Leave other configuration settings set to their default value. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this (assuming that $USER is set to example ): buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise C.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 EasyBuild $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 EasyBuild $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial. next: Basic usage - (back to overview page)","title":"Configuring EasyBuild"},{"location":"2022-isc22/configuration/#configuring-easybuild","text":"After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it.","title":"Configuring EasyBuild"},{"location":"2022-isc22/configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, about 270 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones. We will refer to EasyBuild configuration settings using the names as they appears in the output of eb --help , and omit the leading dashes ( -- ) for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.","title":"Available configuration settings"},{"location":"2022-isc22/configuration/#overall-prefix","text":"(default: $HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"2022-isc22/configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which can be useful to test and evaluate software installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default software and modules/all names for the subdirectories are used.","title":"Install path"},{"location":"2022-isc22/configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations. It is strongly recommend to use the path to a directory on a local filesystem for the value of the buildpath configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like /dev/shm/$USER ) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like noexec ). Use a directory on a local filesystem for buildpath for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set buildpath to /tmp/$USER , for example.","title":"Build path"},{"location":"2022-isc22/configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named ' Example ', EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in sourcepath only read permissions are required. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere.","title":"Source path"},{"location":"2022-isc22/configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation ). For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"2022-isc22/configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod (next to Tcl syntax). To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool; see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in Lua syntax. We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"2022-isc22/configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command, as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between these two configuration settings is that defining robot also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining robot-paths does not have the side effect of enabling dependency resolution. In addition, you can use the --robot command line option without specifying any paths to it, to only enable dependency resolution. Note Keep in mind that when either of the robot (with paths) or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered . There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"2022-isc22/configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes . The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Just like with names of easyconfig files , the <-toolchain> part is omitted when the system toolchain is used, and the <versionsuffix> value is empty by default.","title":"Module naming scheme"},{"location":"2022-isc22/configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception!","title":"Configuration levels"},{"location":"2022-isc22/configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ) is not defined and if the --magic command line option is not used; If the $EASYBUILD_MAGIC environment variable is defined however, then its value will be used for the magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead.","title":"Configuration level hierarchy"},{"location":"2022-isc22/configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"2022-isc22/configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files (usually *.cfg ) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file ( *.eb ) on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.","title":"EasyBuild configuration files vs easyconfig files"},{"location":"2022-isc22/configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"2022-isc22/configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ). Although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would not be very useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"2022-isc22/configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Through the --show-config command line option you can easily inspect the currently active EasyBuild configuration. The output of --show-config includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produced by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user (which affects the value shown for the robot-paths configuration setting): # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ), and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Example Now let us do some basic configuring and inspect the resulting output of eb --show-config . First, create a user-level EasyBuild configuration file to define the prefix configuration setting: mkdir -p $HOME /.config/easybuild echo '[config]' > $HOME /.config/easybuild/config.cfg echo 'prefix=/apps' >> $HOME /.config/easybuild/config.cfg In addition, define the buildpath configuration setting using the corresponding environment variable: export EASYBUILD_BUILDPATH = /tmp/ $USER Then run eb --show-config while you specify that the installpath configuration setting should be defined as /tmp/$USER : $ eb --show-config --installpath = /tmp/ $USER # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/easybuild containerpath ( F ) = /apps/containers installpath ( C ) = /tmp/easybuild packagepath ( F ) = /apps/packages prefix ( F ) = /apps repositorypath ( F ) = /apps/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( F ) = /apps/sources The output indicates that the installpath setting was specified through a command line option (indicated with (C) ), that the buildpath setting was defined via an environment variable (indicated with (E) ), that the robot-paths setting still has the default value (indicated with (D) ), and that all other configuration settings were specified via a configuration file, some of which indirectly through the prefix value (indicated with (F) ).","title":"Inspecting the current configuration (--show-config)"},{"location":"2022-isc22/configuration/#exercises","text":"Exercise C.1 - Configure EasyBuild Configure EasyBuild to use the easybuild subdirectory in your home directory for everything, except for: The location of the build directories: use /tmp/$USER for this; The locations that should be considered when searching for source files: include both $HOME/easybuild/sources and /easybuild/sources , but make sure that source files that are downloaded by EasyBuild are stored in $HOME/easybuild/sources . Leave other configuration settings set to their default value. (click to show solution) This is pretty straightforward. Here we just define the corresponding environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_SOURCEPATH = $HOME /easybuild/sources:/easybuild/sources The location where EasyBuild should download source files to must be listed first in the sourcepath configuration setting. The output of --show-config should look like this (assuming that $USER is set to example ): buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources:/easybuild/sources Exercise C.2 - Install a trivial software package with EasyBuild Try running the following command: eb bzip2-1.0.6.eb Where do you expect to find the installation? (click to show solution) The software was installed in $HOME/easybuild , since that's how we configured EasyBuild in Exercise 3.1 : $ ls $HOME /easybuild ebfiles_repo modules software sources The actual installation is in $HOME/easybuild/software , while the module file was generated in $HOME/easybuild/modules/all : $ ls $HOME /easybuild/software bzip2 EasyBuild $ ls $HOME /easybuild/software/bzip2 1 .0.6 $ ls $HOME /easybuild/software/bzip2/1.0.6 bin easybuild include lib man $ ls $HOME /easybuild/modules/all bzip2 EasyBuild $ ls $HOME /easybuild/modules/all/bzip2 1 .0.6.lua The source file for bzip2 1.0.6 was downloaded to $HOME/easybuild/sources : $ ls $HOME /easybuild/sources/b/bzip2 bzip2-1.0.6.tar.gz We will discuss this in more detail in the next part of the tutorial. Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial. next: Basic usage - (back to overview page)","title":"Exercises"},{"location":"2022-isc22/contributing/","text":"Contributing to EasyBuild \u00b6","title":"Contributing to EasyBuild"},{"location":"2022-isc22/contributing/#contributing-to-easybuild","text":"","title":"Contributing to EasyBuild"},{"location":"2022-isc22/installation/","text":"Installing EasyBuild \u00b6 Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary Requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended). Installation methods : pip install easybuild installing EasyBuild with EasyBuild development setup Verify EasyBuild installation by running eb commands. Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed via $EB_PYTHON . Installing EasyBuild \u00b6 We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip Method 2: installing EasyBuild with EasyBuild Method 3: Development setup Method 1: Using pip \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). pip vs pip3 \u00b6 On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. If you want to ensure that you are using the pip installation that corresponds to the Python 3 installation that you intend to use, you can use python3 -m pip rather than pip3 . Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, or if you installed EasyBuild with a pip version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update the .bashrc shell startup script in your home directory. Updating $PATH \u00b6 Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). This is not required if you installed EasyBuild in a standard system location. You can check with the \" which eb \" command to determine whether or not you need to update the $PATH environment variable. Updating $PYTHONPATH \u00b6 If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 3.6, make sure you are using /python3.6/ in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH Setting $EB_PYTHON \u00b6 If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. This may be required when you installing EasyBuild with a version of pip that does not correspond with the default Python version. For example, to ensure that the eb command uses python3.6 : export EB_PYTHON = python3.6 Setting $EB_VERBOSE \u00b6 To determine which python commands are being considered by the eb command, you can define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> 'python3' is able to import 'easybuild.main' , so retaining it >> Selected Python command: python3 ( /usr/bin/python3 ) >> python3 -m easybuild.main --version This is EasyBuild 4 .5.4 ( framework: 4 .5.4, easyblocks: 4 .5.4 ) on host example Method 2: Installing EasyBuild with EasyBuild \u00b6 Note This section covers an alternative method for installing EasyBuild. If you already have EasyBuild installed through pip , you can skip ahead to the next section . If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps: Step 1: Installing EasyBuild with pip into a temporary location (only needed if EasyBuild is not installed yet) Step 2: Using EasyBuild to install EasyBuild as a module Step 3: Loading the EasyBuild module Step 1: Installing EasyBuild into a temporary location \u00b6 If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using pip . For example, to install EasyBuild into a subdirectory /tmp/$USER using the default Python 3 version: # pick installation prefix, and install EasyBuild into it export EB_TMPDIR = /tmp/ $USER /eb_tmp python3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild # update environment to use this temporary EasyBuild installation export PATH = $EB_TMPDIR /bin: $PATH export PYTHONPATH = $( /bin/ls -rtd -1 $EB_TMPDIR /lib*/python*/site-packages | tail -1 ) : $PYTHONPATH export EB_PYTHON = python3 Step 2: Using EasyBuild to install EasyBuild \u00b6 Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too. You can use the eb --install-latest-eb-release command for this, combined with the --prefix option to control which directories are used by EasyBuild for the installation. For example, to install the latest version of EasyBuild as a module into $HOME/easybuild : eb --install-latest-eb-release --prefix $HOME /easybuild Note You may see a harmless deprecation warning popping up when performing this installation, just ignore it. Step 3: Loading the EasyBuild module \u00b6 Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' with the path to the directory that you used when running step 2 (for example, $HOME/easybuild ). Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made. Method 3: Development setup \u00b6 If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there. This can be done as follows (into $HOME/easybuild ): mkdir -p $HOME /easybuild cd $HOME /easybuild # clone EasyBuild repositories from GitHub git clone https://github.com/easybuilders/easybuild-framework.git git clone https://github.com/easybuilders/easybuild-easyblocks.git git clone https://github.com/easybuilders/easybuild-easyconfigs.git # update environment for running EasyBuild from there export PATH = $HOME /easybuild/easybuild-framework: $PATH export PYTHONPATH = $HOME /easybuild/easybuild-framework: $HOME /easybuild/easybuild-easyblocks: $HOME /easybuild/easybuild-easyconfigs: $PYTHONPATH # control which Python command is used to run EasyBuild export EB_PYTHON = python3 Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial . System information \u00b6 You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. If you have installed EasyBuild through pip , and you prefer updating that installation, you can use pip install --upgrade easybuild (perhaps with additional options like --user or --prefix ). Exercise \u00b6 Install EasyBuild in your home directory. Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure, or try all these installation methods! install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option; perform a (manual) \"bootstrap\" installation into $HOME/easybuild , as outlined in installation method 2 ; set up a development installation; Check that the installation works by running the verification commands outlined above . Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial! next: Configuring EasyBuild - (back to overview page)","title":"Installing EasyBuild"},{"location":"2022-isc22/installation/#installing-easybuild","text":"Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary Requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended). Installation methods : pip install easybuild installing EasyBuild with EasyBuild development setup Verify EasyBuild installation by running eb commands.","title":"Installing EasyBuild"},{"location":"2022-isc22/installation/#requirements","text":"","title":"Requirements"},{"location":"2022-isc22/installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project.","title":"Linux"},{"location":"2022-isc22/installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.","title":"Python"},{"location":"2022-isc22/installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"2022-isc22/installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"2022-isc22/installation/#python-2-or-python-3","text":"For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed via $EB_PYTHON .","title":"Python 2 or Python 3?"},{"location":"2022-isc22/installation/#installing-easybuild_1","text":"We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip Method 2: installing EasyBuild with EasyBuild Method 3: Development setup","title":"Installing EasyBuild"},{"location":"2022-isc22/installation/#method-1-using-pip","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip"},{"location":"2022-isc22/installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"2022-isc22/installation/#pip-vs-pip3","text":"On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. If you want to ensure that you are using the pip installation that corresponds to the Python 3 installation that you intend to use, you can use python3 -m pip rather than pip3 .","title":"pip vs pip3"},{"location":"2022-isc22/installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, or if you installed EasyBuild with a pip version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update the .bashrc shell startup script in your home directory.","title":"Updating your environment"},{"location":"2022-isc22/installation/#updating-path","text":"Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). This is not required if you installed EasyBuild in a standard system location. You can check with the \" which eb \" command to determine whether or not you need to update the $PATH environment variable.","title":"Updating $PATH"},{"location":"2022-isc22/installation/#updating-pythonpath","text":"If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 3.6, make sure you are using /python3.6/ in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH","title":"Updating $PYTHONPATH"},{"location":"2022-isc22/installation/#setting-eb_python","text":"If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. This may be required when you installing EasyBuild with a version of pip that does not correspond with the default Python version. For example, to ensure that the eb command uses python3.6 : export EB_PYTHON = python3.6","title":"Setting $EB_PYTHON"},{"location":"2022-isc22/installation/#setting-eb_verbose","text":"To determine which python commands are being considered by the eb command, you can define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> 'python3' is able to import 'easybuild.main' , so retaining it >> Selected Python command: python3 ( /usr/bin/python3 ) >> python3 -m easybuild.main --version This is EasyBuild 4 .5.4 ( framework: 4 .5.4, easyblocks: 4 .5.4 ) on host example","title":"Setting $EB_VERBOSE"},{"location":"2022-isc22/installation/#method-2-installing-easybuild-with-easybuild","text":"Note This section covers an alternative method for installing EasyBuild. If you already have EasyBuild installed through pip , you can skip ahead to the next section . If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps: Step 1: Installing EasyBuild with pip into a temporary location (only needed if EasyBuild is not installed yet) Step 2: Using EasyBuild to install EasyBuild as a module Step 3: Loading the EasyBuild module","title":"Method 2: Installing EasyBuild with EasyBuild"},{"location":"2022-isc22/installation/#step-1-installing-easybuild-into-a-temporary-location","text":"If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using pip . For example, to install EasyBuild into a subdirectory /tmp/$USER using the default Python 3 version: # pick installation prefix, and install EasyBuild into it export EB_TMPDIR = /tmp/ $USER /eb_tmp python3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild # update environment to use this temporary EasyBuild installation export PATH = $EB_TMPDIR /bin: $PATH export PYTHONPATH = $( /bin/ls -rtd -1 $EB_TMPDIR /lib*/python*/site-packages | tail -1 ) : $PYTHONPATH export EB_PYTHON = python3","title":"Step 1: Installing EasyBuild into a temporary location"},{"location":"2022-isc22/installation/#step-2-using-easybuild-to-install-easybuild","text":"Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too. You can use the eb --install-latest-eb-release command for this, combined with the --prefix option to control which directories are used by EasyBuild for the installation. For example, to install the latest version of EasyBuild as a module into $HOME/easybuild : eb --install-latest-eb-release --prefix $HOME /easybuild Note You may see a harmless deprecation warning popping up when performing this installation, just ignore it.","title":"Step 2: Using EasyBuild to install EasyBuild"},{"location":"2022-isc22/installation/#step-3-loading-the-easybuild-module","text":"Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' with the path to the directory that you used when running step 2 (for example, $HOME/easybuild ). Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made.","title":"Step 3: Loading the EasyBuild module"},{"location":"2022-isc22/installation/#method-3-development-setup","text":"If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there. This can be done as follows (into $HOME/easybuild ): mkdir -p $HOME /easybuild cd $HOME /easybuild # clone EasyBuild repositories from GitHub git clone https://github.com/easybuilders/easybuild-framework.git git clone https://github.com/easybuilders/easybuild-easyblocks.git git clone https://github.com/easybuilders/easybuild-easyconfigs.git # update environment for running EasyBuild from there export PATH = $HOME /easybuild/easybuild-framework: $PATH export PYTHONPATH = $HOME /easybuild/easybuild-framework: $HOME /easybuild/easybuild-easyblocks: $HOME /easybuild/easybuild-easyconfigs: $PYTHONPATH # control which Python command is used to run EasyBuild export EB_PYTHON = python3","title":"Method 3: Development setup"},{"location":"2022-isc22/installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"2022-isc22/installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"2022-isc22/installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"2022-isc22/installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial .","title":"Showing the default EasyBuild configuration"},{"location":"2022-isc22/installation/#system-information","text":"You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command: eb --show-system-info","title":"System information"},{"location":"2022-isc22/installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. If you have installed EasyBuild through pip , and you prefer updating that installation, you can use pip install --upgrade easybuild (perhaps with additional options like --user or --prefix ).","title":"Updating EasyBuild"},{"location":"2022-isc22/installation/#exercise","text":"Install EasyBuild in your home directory. Make sure that the EasyBuild installation uses the python3 command to run, rather than the standard python command. Choose your own adventure, or try all these installation methods! install EasyBuild with pip (or another very similar command...) using either the --user or --prefix option; perform a (manual) \"bootstrap\" installation into $HOME/easybuild , as outlined in installation method 2 ; set up a development installation; Check that the installation works by running the verification commands outlined above . Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial! next: Configuring EasyBuild - (back to overview page)","title":"Exercise"},{"location":"2022-isc22/installing_software/","text":"Installing software with EasyBuild \u00b6 You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.14: $ eb SAMtools-1.14-GCC-11.2.0.eb == Temporary log file in case of crash /tmp/eb-os2fd8gv/easybuild-yda39z4b.log == processing EasyBuild easyconfig /home/achilles/easybuild/easybuild-easyconfigs/easybuild/easyconfigs/s/SAMtools/SAMtools-1.14-GCC-11.2.0.eb == building and installing SAMtools/1.14-GCC-11.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == ... ( took 1 secs ) == patching... == preparing... == ... ( took 3 secs ) == configuring... == ... ( took 6 secs ) == building... == ... ( took 46 secs ) == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == ... ( took 1 secs ) == cleaning up... == creating module... == ... ( took 1 secs ) == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 1 min 0 secs ) == Results of the build can be found in the log file ( s ) /project/def-maintainers/achilles/Rocky8/zen2/software/SAMtools/1.14-GCC-11.2.0/easybuild/easybuild-SAMtools-1.14-20220502.121241.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-os2fd8gv/easybuild-yda39z4b.log* have been removed. == Temporary directory /tmp/eb-os2fd8gv has been removed. That was... easy. Is that really all there is to it? Well, almost... Enabling dependency resolution \u00b6 The SAMtools installation worked like a charm, but remember that all required dependencies were already available ( see the section on checking dependencies ). If we try this with the BCFtools-1.14-GCC-11.2.0.eb , for which the required GSL and HTSlib dependencies are not available yet, it's less successful: $ eb BCFtools-1.14-GCC-11.2.0.eb -M 3 out of 23 required modules missing: * GSL/2.7-GCC-11.2.0 ( GSL-2.7-GCC-11.2.0.eb ) * HTSlib/1.14-GCC-11.2.0 ( HTSlib-1.14-GCC-11.2.0.eb ) * BCFtools/1.14-GCC-11.4.0 ( BCFtools-1.14-GCC-11.2.0.eb ) $ eb BCFtools-1.14-GCC-11.2.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/build/BCFtools/1.14/GCC-11.2.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0 ( took 1 secs ) == Results of the build can be found in the log file ( s ) /tmp/eb-66a5glv6/easybuild-BCFtools-1.14-20220502.145732.ElHDN.log ERROR: Build of /easybuild/software/EasyBuild/20220501-dev/easybuild/easyconfigs/b/BCFtools/BCFtools-1.14-GCC-11.2.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0 The required dependencies HTSlib/1.14-GCC-11.2.0 and GSL/2.7-GCC-11.2.0 are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb BCFtools-1.14-GCC-11.2.0.eb --robot ... == resolving dependencies ... ... == building and installing HTSlib/1.14-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 14 sec ) ... == building and installing GSL/2.7-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 1 min 10 sec ) ... == building and installing BCFtools/1.14-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 8 sec ) ... == Build succeeded for 3 out of 3 With dependency resolution enabled the HTSlib and GSL modules get installed first, before EasyBuild proceeds with installing BCFtools . Great! Trace output \u00b6 As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of BCFtools-1.14-GCC-11.2.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb BCFtools-1.14-GCC-11.2.0.eb --rebuild ... == configuring... >> running command: [ started at: 2022 -05-02 15 :05:42 ] [ working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14 ] [ output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-mjc8gj6x.log ] /home/easybuild/.local/easybuild/sources/generic/eb_v4.5.5.dev0/ConfigureMake/config.guess >> command completed: exit 0 , ran in < 1s >> running command: [ started at: 2022 -05-02 15 :05:42 ] [ working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14 ] [ output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-cv6vncds.log ] ./configure --prefix = /home/example/easybuild/software/BCFtools/1.14-GCC-11.2.0 --build = x86_64-pc-linux-gnu --host = x86_64-pc-linux-gnu --with-htslib = $EBROOTHTSLIB --enable-libgsl >> command completed: exit 0 , ran in 00h00m01s == ... ( took 1 secs ) == building... >> running command: [ started at: 2022 -05-02 15 :05:43 ] [ working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14 ] [ output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-wtsxpxf2.log ] make -j 8 >> command completed: exit 0 , ran in 00h00m03s That's a bit more comforting to stare at... During the configure step, the ./configure command is run with option to enable support for leveraging HTSlib and GSL . During the build step, the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 8). We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bcftools' found: OK >> file 'bin/plot-vcfstats' found: OK >> file 'bin/vcfutils.pl' found: OK >> (non-empty) directory 'libexec/bcftools' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary. Using installed software \u00b6 So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio devel numlib tools Directories like bio and numlib correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ---------------------- /home/example/easybuild/modules/all ----------------------- BCFtools/1.14-GCC-11.2.0 GSL/2.7-GCC-11.2.0 SAMtools/1.14-GCC-11.2.0 EasyBuild/4.5.4 HTSlib/1.14-GCC-11.2.0 bzip2/1.0.8 ---------------------------- /easybuild/modules/all ----------------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for BCFtools. In our current environment, the bcftools command is not available yet: $ module list No modules loaded $ bcftools -bash: bcftools: command not found Loading the module for BCFtools changes that: $ module load BCFtools/1.14-GCC-11.2.0 $ module list Currently Loaded Modules: 1 ) EasyBuild/4.5.4 7 ) XZ/5.2.5-GCCcore-11.2.0 2 ) GCCcore/11.2.0 8 ) OpenSSL/1.1 3 ) zlib/1.2.11-GCCcore-11.2.0 9 ) cURL/7.78.0-GCCcore-11.2.0 4 ) binutils/2.37-GCCcore-11.2.0 10 ) HTSlib/1.14-GCC-11.2.0 5 ) GCC/11.2.0 11 ) GSL/2.7-GCC-11.2.0 6 ) bzip2/1.0.8-GCCcore-11.2.0 12 ) BCFtools/1.14-GCC-11.2.0 $ bcftools --version bcftools 1 .14 Using htslib 1 .14 ... Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use. Resetting your environment \u00b6 To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \". Stacking software \u00b6 Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here). Exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions for others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.5.4. Exercise S.1 - Installing software Install version 3.6.0 of the h5py Python package and all missing dependencies, using the foss/2021b toolchain, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py-3.6.0.*foss-2021b' CFGS1 = /home/easybuilder/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-3.6.0-foss-2021b.eb Make sure the pre-installed software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install this h5py easyconfig: $ eb h5py-3.6.0-foss-2021b.eb --missing 2 out of 63 required modules missing: * pkgconfig/1.5.5-GCCcore-11.2.0-python ( pkgconfig-1.5.5-GCCcore-11.2.0-python.eb ) * h5py/3.6.0-foss-2021b ( h5py-3.6.0-foss-2021b.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-3.6.0-foss-2021b.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.5-GCCcore-11.2.0-python... ... == building and installing h5py/3.6.0-foss-2021b... ... == installing... >> running command: [ started at: 2022 -05-02 13 :38:37 ] [ working dir: /tmp/example/h5py/3.6.0/foss-2021b/h5py-3.6.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] HDF5_MPI = ON HDF5_DIR = \" $EBROOTHDF5 \" H5PY_SETUP_REQUIRES = 0 pip install --prefix = /tmp/achilles/easybuild/software/h5py/3.6.0-foss-2021b --no-deps --ignore-installed --no-index --no-build-isolation . >> command completed: exit 0 , ran in 00h01m43s ... == COMPLETED: Installation ended successfully ( took 2 min 0 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the installing command, which runs pip install . Exercise S.2 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/3.6.0-foss-2021b module load h5py/3.6.0-foss-2021b The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course you can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Mai 2 15 :48 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask questions in the #tutorial-isc22 channel in the EasyBuild Slack , we're happy to help! next: Troubleshooting - (back to overview page)","title":"Installing software with EasyBuild"},{"location":"2022-isc22/installing_software/#installing-software-with-easybuild","text":"You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.14: $ eb SAMtools-1.14-GCC-11.2.0.eb == Temporary log file in case of crash /tmp/eb-os2fd8gv/easybuild-yda39z4b.log == processing EasyBuild easyconfig /home/achilles/easybuild/easybuild-easyconfigs/easybuild/easyconfigs/s/SAMtools/SAMtools-1.14-GCC-11.2.0.eb == building and installing SAMtools/1.14-GCC-11.2.0... == fetching files... == creating build dir, resetting environment... == unpacking... == ... ( took 1 secs ) == patching... == preparing... == ... ( took 3 secs ) == configuring... == ... ( took 6 secs ) == building... == ... ( took 46 secs ) == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == ... ( took 1 secs ) == cleaning up... == creating module... == ... ( took 1 secs ) == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 1 min 0 secs ) == Results of the build can be found in the log file ( s ) /project/def-maintainers/achilles/Rocky8/zen2/software/SAMtools/1.14-GCC-11.2.0/easybuild/easybuild-SAMtools-1.14-20220502.121241.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-os2fd8gv/easybuild-yda39z4b.log* have been removed. == Temporary directory /tmp/eb-os2fd8gv has been removed. That was... easy. Is that really all there is to it? Well, almost...","title":"Installing software with EasyBuild"},{"location":"2022-isc22/installing_software/#enabling-dependency-resolution","text":"The SAMtools installation worked like a charm, but remember that all required dependencies were already available ( see the section on checking dependencies ). If we try this with the BCFtools-1.14-GCC-11.2.0.eb , for which the required GSL and HTSlib dependencies are not available yet, it's less successful: $ eb BCFtools-1.14-GCC-11.2.0.eb -M 3 out of 23 required modules missing: * GSL/2.7-GCC-11.2.0 ( GSL-2.7-GCC-11.2.0.eb ) * HTSlib/1.14-GCC-11.2.0 ( HTSlib-1.14-GCC-11.2.0.eb ) * BCFtools/1.14-GCC-11.4.0 ( BCFtools-1.14-GCC-11.2.0.eb ) $ eb BCFtools-1.14-GCC-11.2.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/build/BCFtools/1.14/GCC-11.2.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0 ( took 1 secs ) == Results of the build can be found in the log file ( s ) /tmp/eb-66a5glv6/easybuild-BCFtools-1.14-20220502.145732.ElHDN.log ERROR: Build of /easybuild/software/EasyBuild/20220501-dev/easybuild/easyconfigs/b/BCFtools/BCFtools-1.14-GCC-11.2.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0 The required dependencies HTSlib/1.14-GCC-11.2.0 and GSL/2.7-GCC-11.2.0 are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb BCFtools-1.14-GCC-11.2.0.eb --robot ... == resolving dependencies ... ... == building and installing HTSlib/1.14-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 14 sec ) ... == building and installing GSL/2.7-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 1 min 10 sec ) ... == building and installing BCFtools/1.14-GCC-11.2.0... ... == COMPLETED: Installation ended successfully ( took 8 sec ) ... == Build succeeded for 3 out of 3 With dependency resolution enabled the HTSlib and GSL modules get installed first, before EasyBuild proceeds with installing BCFtools . Great!","title":"Enabling dependency resolution"},{"location":"2022-isc22/installing_software/#trace-output","text":"As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of BCFtools-1.14-GCC-11.2.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb BCFtools-1.14-GCC-11.2.0.eb --rebuild ... == configuring... >> running command: [ started at: 2022 -05-02 15 :05:42 ] [ working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14 ] [ output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-mjc8gj6x.log ] /home/easybuild/.local/easybuild/sources/generic/eb_v4.5.5.dev0/ConfigureMake/config.guess >> command completed: exit 0 , ran in < 1s >> running command: [ started at: 2022 -05-02 15 :05:42 ] [ working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14 ] [ output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-cv6vncds.log ] ./configure --prefix = /home/example/easybuild/software/BCFtools/1.14-GCC-11.2.0 --build = x86_64-pc-linux-gnu --host = x86_64-pc-linux-gnu --with-htslib = $EBROOTHTSLIB --enable-libgsl >> command completed: exit 0 , ran in 00h00m01s == ... ( took 1 secs ) == building... >> running command: [ started at: 2022 -05-02 15 :05:43 ] [ working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14 ] [ output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-wtsxpxf2.log ] make -j 8 >> command completed: exit 0 , ran in 00h00m03s That's a bit more comforting to stare at... During the configure step, the ./configure command is run with option to enable support for leveraging HTSlib and GSL . During the build step, the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 8). We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bcftools' found: OK >> file 'bin/plot-vcfstats' found: OK >> file 'bin/vcfutils.pl' found: OK >> (non-empty) directory 'libexec/bcftools' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.","title":"Trace output"},{"location":"2022-isc22/installing_software/#using-installed-software","text":"So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio devel numlib tools Directories like bio and numlib correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ---------------------- /home/example/easybuild/modules/all ----------------------- BCFtools/1.14-GCC-11.2.0 GSL/2.7-GCC-11.2.0 SAMtools/1.14-GCC-11.2.0 EasyBuild/4.5.4 HTSlib/1.14-GCC-11.2.0 bzip2/1.0.8 ---------------------------- /easybuild/modules/all ----------------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for BCFtools. In our current environment, the bcftools command is not available yet: $ module list No modules loaded $ bcftools -bash: bcftools: command not found Loading the module for BCFtools changes that: $ module load BCFtools/1.14-GCC-11.2.0 $ module list Currently Loaded Modules: 1 ) EasyBuild/4.5.4 7 ) XZ/5.2.5-GCCcore-11.2.0 2 ) GCCcore/11.2.0 8 ) OpenSSL/1.1 3 ) zlib/1.2.11-GCCcore-11.2.0 9 ) cURL/7.78.0-GCCcore-11.2.0 4 ) binutils/2.37-GCCcore-11.2.0 10 ) HTSlib/1.14-GCC-11.2.0 5 ) GCC/11.2.0 11 ) GSL/2.7-GCC-11.2.0 6 ) bzip2/1.0.8-GCCcore-11.2.0 12 ) BCFtools/1.14-GCC-11.2.0 $ bcftools --version bcftools 1 .14 Using htslib 1 .14 ... Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use.","title":"Using installed software"},{"location":"2022-isc22/installing_software/#resetting-your-environment","text":"To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \".","title":"Resetting your environment"},{"location":"2022-isc22/installing_software/#stacking-software","text":"Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).","title":"Stacking software"},{"location":"2022-isc22/installing_software/#exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions for others before they have been discussed by the tutorial organisers. The exercises are based on the easyconfig files included with EasyBuild 4.5.4. Exercise S.1 - Installing software Install version 3.6.0 of the h5py Python package and all missing dependencies, using the foss/2021b toolchain, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py-3.6.0.*foss-2021b' CFGS1 = /home/easybuilder/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-3.6.0-foss-2021b.eb Make sure the pre-installed software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install this h5py easyconfig: $ eb h5py-3.6.0-foss-2021b.eb --missing 2 out of 63 required modules missing: * pkgconfig/1.5.5-GCCcore-11.2.0-python ( pkgconfig-1.5.5-GCCcore-11.2.0-python.eb ) * h5py/3.6.0-foss-2021b ( h5py-3.6.0-foss-2021b.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-3.6.0-foss-2021b.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.5-GCCcore-11.2.0-python... ... == building and installing h5py/3.6.0-foss-2021b... ... == installing... >> running command: [ started at: 2022 -05-02 13 :38:37 ] [ working dir: /tmp/example/h5py/3.6.0/foss-2021b/h5py-3.6.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] HDF5_MPI = ON HDF5_DIR = \" $EBROOTHDF5 \" H5PY_SETUP_REQUIRES = 0 pip install --prefix = /tmp/achilles/easybuild/software/h5py/3.6.0-foss-2021b --no-deps --ignore-installed --no-index --no-build-isolation . >> command completed: exit 0 , ran in 00h01m43s ... == COMPLETED: Installation ended successfully ( took 2 min 0 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the installing command, which runs pip install . Exercise S.2 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"empty.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/3.6.0-foss-2021b module load h5py/3.6.0-foss-2021b The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course you can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Mai 2 15 :48 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask questions in the #tutorial-isc22 channel in the EasyBuild Slack , we're happy to help! next: Troubleshooting - (back to overview page)","title":"Exercises"},{"location":"2022-isc22/integration_eessi/","text":"Integration of EasyBuild in EESSI \u00b6","title":"Integration of EasyBuild in EESSI"},{"location":"2022-isc22/integration_eessi/#integration-of-easybuild-in-eessi","text":"","title":"Integration of EasyBuild in EESSI"},{"location":"2022-isc22/integration_jsc/","text":"Integration of EasyBuild at J\u00fclich Supercomputing Centre \u00b6 ( author: Alan O'Cais, J\u00fclich Supercomputing Centre; Sebastian Achilles, J\u00fclich Supercomputing Centre) General info \u00b6 The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc ) at Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process. Staff & user base \u00b6 About 250 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services. In cooperation with hardware and software vendors like IBM, ATOS, Intel, NVIDIA and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008. Resources \u00b6 JSC currently manages 3 primary systems (in addition to a number of other development clusters): JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance on the cluster module and an NVIDIA GPU booster module providing an additional 73 Petaflops. The booster module makes JUWELS the most powerful supercomputer in Europe. JURECA is the precursor system to JUWELS and currently has 2 modules: the JURECA DC Module with 3.54 (CPU, AMD EPYC) + 14.98 (GPU, NVIDIA A100) Petaflop per second peak performance, and the JURECA Booster Module with 5 (KNL) Petaflop per second peak performance. JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms. Usage of EasyBuild within JSC \u00b6 As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated. JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations. Custom toolchains \u00b6 As of June 2022, there are a total of 16 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers ( GCCcore , GCC , Intel and NVHPC ), MPI runtimes ( ParaStationMPI , OpenMPI and IntelMPI ) and mathematical libraries ( MKL ). Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the --try-toolchain option and introduced the --try-update-deps experimental option to more easily adopt upstream changes and adapt them to our environment. Custom module naming scheme \u00b6 By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes). Custom easyconfigs \u00b6 The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository). We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild. Hiding dependencies \u00b6 While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the hide-deps configuration setting). There are currently over 200 such hidden dependencies. While hidden dependencies are not visible in the module view by default, users can expose them by the use of the --show-hidden argument in Lmod : module --show-hidden avail Usage of hooks \u00b6 The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely. We have integrated, and continue to develop, a hook that provides a lot of useful functionality: Facilitates userspace installations alongside system provided installations EasyBuild is configured to allow both shared installations for a group and private installations (group installations are automatically picked up by Lmod for other members of the group) Restricts users from installing non-supported compilers (in particular we don't want people to install their own GCCcore since this would likely lead to an avalanche of required dependencies) and MPI runtimes (since MPI installations are heavily customised) Restricts users to only resolve dependencies from our Golden repository (as well as from their own installed software) but allows them to search in the upstream repositories if they try to install something from the upstream repository, the hook advises them how to do this correctly for our systems Customises the final module files Customises the names of some modules (such as Intel over iccifort and IntelMPI over impi ) Injects an Lmod family in the modules of our compilers and MPI runtimes Adds Lmod properties for GPU enabled applications and user installed software so that they can be easily identified in the module view Adds a site_contact for all modules Updates the Lmod cache when an installation is made system-wide We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system. Upgrading and retiring software \u00b6 The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package. The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. Originally, we had chosen six months as our upgrade period but found this to be cumbersome as the number of supported systems and toolchains grew, our upgrade period is now every 12 months. We chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains. We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. A common workflow is to create a personal installation of a package that can be tweaked, then a group installation for others to try out. Once a software package has been successfully built and tested, it is added to a Golden repository to be used in production. The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage. While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod. next: Integration of EasyBuild in EESSI - (back to overview page)","title":"Integration of EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"2022-isc22/integration_jsc/#integration-of-easybuild-at-julich-supercomputing-centre","text":"( author: Alan O'Cais, J\u00fclich Supercomputing Centre; Sebastian Achilles, J\u00fclich Supercomputing Centre)","title":"Integration of EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"2022-isc22/integration_jsc/#general-info","text":"The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc ) at Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process.","title":"General info"},{"location":"2022-isc22/integration_jsc/#staff-user-base","text":"About 250 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services. In cooperation with hardware and software vendors like IBM, ATOS, Intel, NVIDIA and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008.","title":"Staff &amp; user base"},{"location":"2022-isc22/integration_jsc/#resources","text":"JSC currently manages 3 primary systems (in addition to a number of other development clusters): JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance on the cluster module and an NVIDIA GPU booster module providing an additional 73 Petaflops. The booster module makes JUWELS the most powerful supercomputer in Europe. JURECA is the precursor system to JUWELS and currently has 2 modules: the JURECA DC Module with 3.54 (CPU, AMD EPYC) + 14.98 (GPU, NVIDIA A100) Petaflop per second peak performance, and the JURECA Booster Module with 5 (KNL) Petaflop per second peak performance. JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms.","title":"Resources"},{"location":"2022-isc22/integration_jsc/#usage-of-easybuild-within-jsc","text":"As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated. JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations.","title":"Usage of EasyBuild within JSC"},{"location":"2022-isc22/integration_jsc/#custom-toolchains","text":"As of June 2022, there are a total of 16 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers ( GCCcore , GCC , Intel and NVHPC ), MPI runtimes ( ParaStationMPI , OpenMPI and IntelMPI ) and mathematical libraries ( MKL ). Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the --try-toolchain option and introduced the --try-update-deps experimental option to more easily adopt upstream changes and adapt them to our environment.","title":"Custom toolchains"},{"location":"2022-isc22/integration_jsc/#custom-module-naming-scheme","text":"By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes).","title":"Custom module naming scheme"},{"location":"2022-isc22/integration_jsc/#custom-easyconfigs","text":"The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository). We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild.","title":"Custom easyconfigs"},{"location":"2022-isc22/integration_jsc/#hiding-dependencies","text":"While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the hide-deps configuration setting). There are currently over 200 such hidden dependencies. While hidden dependencies are not visible in the module view by default, users can expose them by the use of the --show-hidden argument in Lmod : module --show-hidden avail","title":"Hiding dependencies"},{"location":"2022-isc22/integration_jsc/#usage-of-hooks","text":"The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely. We have integrated, and continue to develop, a hook that provides a lot of useful functionality: Facilitates userspace installations alongside system provided installations EasyBuild is configured to allow both shared installations for a group and private installations (group installations are automatically picked up by Lmod for other members of the group) Restricts users from installing non-supported compilers (in particular we don't want people to install their own GCCcore since this would likely lead to an avalanche of required dependencies) and MPI runtimes (since MPI installations are heavily customised) Restricts users to only resolve dependencies from our Golden repository (as well as from their own installed software) but allows them to search in the upstream repositories if they try to install something from the upstream repository, the hook advises them how to do this correctly for our systems Customises the final module files Customises the names of some modules (such as Intel over iccifort and IntelMPI over impi ) Injects an Lmod family in the modules of our compilers and MPI runtimes Adds Lmod properties for GPU enabled applications and user installed software so that they can be easily identified in the module view Adds a site_contact for all modules Updates the Lmod cache when an installation is made system-wide We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system.","title":"Usage of hooks"},{"location":"2022-isc22/integration_jsc/#upgrading-and-retiring-software","text":"The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package. The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. Originally, we had chosen six months as our upgrade period but found this to be cumbersome as the number of supported systems and toolchains grew, our upgrade period is now every 12 months. We chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains. We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. A common workflow is to create a personal installation of a package that can be tweaked, then a group installation for others to try out. Once a software package has been successfully built and tested, it is added to a Golden repository to be used in production. The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage. While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod. next: Integration of EasyBuild in EESSI - (back to overview page)","title":"Upgrading and retiring software"},{"location":"2022-isc22/integration_lumi/","text":"Integration of EasyBuild in LUMI \u00b6 General information \u00b6 LUMI , installed in a CSC data centre (Finland)), is one of the three planned EuroHPC pre-exascale systems meant to be installed in 2022-2023, together with Leonardo (installed at Cineca) and MareNostrum5 (installed at BSC). LUMI, which stands for Large Unified Modern Infrastructure, is hosted by the LUMI consortium , a consortium of 10 countries: Finland, Belgium, Czech Republic, Denmark, Estonia, Iceland, Norway, Poland, Sweden, and Switzerland. It was supposed to be installed by the end of 2021, but the global shortage of components and some technical problems have delayed the installation. The final hardware should be installed before mid 2022. LUMI is a HPE Cray EX supercomputer with several partitions targeted for different use cases. It is also possible to run heterogeneous jobs across multiple partitions. The main compute power is provided by the LUMI-G GPU compute partition consisting of 2560 nodes. The LUMI-G node is a revolutionary compute node in the x86+GPU-world. It is also truly a \"GPU first\" system. Each GPU compute node has a single 64 core AMD EPYC 7A53 \"Trento\" CPU and 4 MI250X GPUs. Each MI250X package contains two GPU compute dies connected to each other via AMD's InfinityFabric interconnect and 8 HBM2e memory stacks, 4 per die. The GPUs and CPU are all connected through AMD's InfinityFabric interconnect, creating a system with a cache coherent unified memory space. The Trento CPU is a zen3 generation product but with an optimised I/O die that can run the InfinityFabric interconnect at a higher speed than standard Milan CPUs. Each node also have 4 200Gbit/s SlingShot 11 interconnect cards, each connected directly to a different GPU package. Each node has 512GB HBM2e RAM spread evenly across the GPU dies and 512 GB of regular DDR4 DRAM connected to the CPU. The nodes are diskless nodes. The (very) theoretical peak performance of a GPU node is around 200 Tflops for FP64 vector operations or 400 TFlops for FP64 matrix operations. The main CPU partition, called LUMI-C, consists of 1536 nodes with 2 64-core AMD EPYC 7763 CPUs. Most nodes have 256 GB of RAM memory, but there are 128 nodes with 512 GB of RAM and 32 nodes with 1 TB of RAM. In the final system, each node will be equipped with one 200 Gbit/s SlingShot 11 interconnect card. These nodes are diskless nodes. A section mostly meant for interactive data analysis consists of 8 nodes with 2 64-core AMD EPYC 7742 CPUs and 4 TB of RAM per node. These nodes are connected to the interconnect through 2 100 Gbit/s SlingShot 10 links. The second part of LUMI-D, the data visualisation section, consists of 8 nodes with two 64-core AMD EPYC 7742 CPUs and 8 NVIDIA A40 GPUs each. Each node has 2 TB of RAM and is connected to the interconnect through 2 100 Gbit/s SlingShot 10 links. LUMI-K will be an OpenShift/Kubernetes container cloud platform for running microservices with roughly 50 nodes. LUMI also has an extensive storage system There is a 7 PB flash-based storage system with 2 TB/s of bandwidth and high IOPS capability using the Lustre parallel file system and Cray ClusterStor E1000 technology. The main disk based storage contains of 4 20 PB storage systems based on regular hard disks and also using the Lustre parallel file system. A 30 PB Ceph-based encrypted object storage system for storing, sharing and staging data will become available at a later date. Challenges \u00b6 LUMI comes with the HPE Cray Programming Environment (PE) with the Cray Compiling Environment (a fully Clang/LLVM-based C/C++ compiler and a Fortran compiler using a Cray frontend but LLVM-based backend) and GNU and AMD compilers repackaged by Cray. The HPE Cray PE uses an MPICH-based MPI implementation (with libfabric backend on SlingShot 11) and also comes with its own optimised mathematics libraries containing all the usual suspects you expect from an EasyBuild toolchain. The HPE Cray PE environment is managed outside EasyBuild, but EasyBuild has a mechanism to integrate with it. Due to the specific hardware and software setup of LUMI using the EasyBuild common toolchains is anything but straightforward. Getting Open MPI, a key component of the foss toolchain, to work is a bit of a challenge at the moment. The Intel compilers are not a very good match with AMD CPUs. One needs to be very careful when choosing the target architecture for code optimisation ( -xHost will not generate AVX/AVX2 code), most recent versions of MKL have performance problems and sometimes produce wrong results and some recent MPI versions also cause problems with AMD CPUs. LUMI has only a small central support team of 9 FTE. It is obvious that we cannot give the same level of support for software installations as some of the big sites such as JSC can do. Moreover, due to the nature of the LUMI environment with its Cray PE and novel AMD GPUs, installing software is more challenging than on your typical Intel + NVIDIA GPU cluster with NVIDIA/Mellanox interconnect. Given that the technology is very new, one can also expect a rapid evolution of the programming environment with a risk of breaking compatibility with earlier versions, and a need for frequent software updates in the initial years of operation to work around bugs or make new and important features available. So the maintenance cost of a the user application stack is certainly higher than on clusters based on more conventional technology. Early experience has also shown that we need to be prepared for potentially breaking changes on very short notice. It also means that we have to be very agile when it comes to maintaining the software stack and that it is also impossible to thoroughly test all installations, so we must be able to make corrections quickly. This goes against a big central software stack, as in a central software stack it is nearly impossible to replace an installation that fails for some users outside maintenance intervals. The central support team may be small (the above 9 FTE), but the LUMI consortium agreement states that the consortium countries also have to assist in providing support. Given that neither the LUMI User Support Team members nor the local support teams are employees of CSC this also means that much of the application support has to be delivered with very little rights on the system (at most a working directory that is readable for all users). So we need a setup where it is possible to help users installing applications while having only regular user rights on the system. Due to the exploitation model and the small size of the central support team, license management is a pain. Users come to LUMI through 11 different channels (some with subchannels). Moreover it is the responsibility of the PI to invite users to a project and to ensure that they are eligible for LUMI use (taking into account, e.g., the European and USA export restrictions). At the central level we have no means currently to check who can use which software license. Hence we need a solution to distribute that responsibility also. LUMI software support is based on the idea that users really want a customised software stack. They may say they want a central stack but only as long as it contains the software they need and not much more as they also do not want to search through long lists of modules. Nobody is waiting for 20 different configurations of a package, but the reality is that different users will want different versions with sometimes conflicting configurations, or compiled with different compilers. We also note that some communities forego centrally installed software which may have better optimised binaries to build their own custom setup using tools such as Conda. And even though modules go a long way in managing dependencies and helping to avoid conflicts, we expect that with the explosion of software used on HPC machines and the poor maintenance of that software, it will become increasingly difficult to find versions of dependencies that work for a range of programs, leading to cases where we may simply need to install a software package with different sets of dependencies simply because users want to use it together with other packages that have restrictions on the versions of those dependencies. Experienced Python users without doubt know what a mess this can create and how even a single user sometimes needs different virtual environments with different installations to do their work. Solution with EasyBuild and Lmod \u00b6 On LUMI we selected EasyBuild as our primary software installation tool, but also offer some limited support for Spack. EasyBuild was selected as there is already a lot of experience with EasyBuild in several of the LUMI consortium countries and as it is a good fit with the goals of the EuroHPC JU as they want to establish a European HPC ecosystem with a European technology option at every level. The developers of EasyBuild are also very accessible and it helps that the lead developer and several of the maintainers are from LUMI consortium countries. We use Lmod as the module tool. We basically had the choice between Lmod and the old C implementation of TCL Environment Modules as HPE Cray does not support the more modern Environment Modules 4 or 5 developed in France. Support for Lmod is excellent in EasyBuild and Spack, and Lua is also a more modern language to work with than TCL. Software stacks \u00b6 On LUMI we offer users the choice between multiple software stacks, offered through hand-written Lmod modules. The CrayEnv stack is really just a small layer on top of the HPE Cray PE in which we provide a few additional tools and help the user with managing the environment for the HPE Cray PE. The HPE Cray PE works with a universal compiler wrapper that sets some optimisation options for the supported compilers and sets the flags to compile and link with the MPI, optimised scientific libraries and some other libraries provided with the PE. It does so based on which modules are loaded. The CPU and GPU targets and the MPI fabric library are selected through so-called target modules, typically loaded during shell initialisation, while compiler, MPI and scientific libraries are typically loaded through the so-called PrgEnv-* modules (one for each supported compiler). The CrayEnv software stack module will take care of ensuring that a proper set of target modules is loaded depending on the node type on which the module is loaded, and hence also reloading the proper target modules after a module purge . The environment is also enriched with a number of build tools that are not installed in the OS image or only in an older version. These tools are often build with EasyBuild with the SYSTEM toolchain though we do not make EasyBuild itself available to users in that stack. The LUMI stack is a software stack which is mostly managed with EasyBuild. The stack is versioned based on the version of the HPE Cray PE which makes it easy to retire a whole stack when the compilers are retired from the system. If we need the same software in two different stacks, it is simply compiled twice, even if it is only installed with the system compilers, to make retiring software easier without having to track dependencies (we now simply have to remove a few directories to remove a whole software stack which will not have an impact on the other stacks). The exception are a few packages installed from binaries that are installed in a separate area across software stacks (e.g., ARM Forge and Vampir). The LUMI stack provides optimised binaries for each node type of LUMI, but some software that is not performance-critical is compiled only once. To this end we have a partition corresponding to each node type, but also a common partition which is included with the software of all other partitions. Software in that common partition can only have dependencies in the common partition though. For now we keep the central LUMI software stack very small, but we provide an easy and fully transparent mechanism for the user to install software in their project directory that integrates fully with the LUMI stack. The user only needs to set an environment variable pointing to the project space. In the future we envision that more software stacks may become available on LUMI as at least one local support organisation wants to build their own stack. We also hope to find a solution to get the foss toolchain working on at least the CPU nodes of LUMI with minimal changes in a future collaboration with HPE. EasyBuild for software management \u00b6 The second component to our solution is EasyBuild. EasyBuild can give a very precise description of all the steps needed to build a package while the user needs to give very few arguments to the eb command to actually do the installation. It is also robust enough that with a proper module to configure EasyBuild, an installation done by one user on LUMI will reproduce easily in the environment of another user. The fact that each easyconfig file contains a very precise list of dependencies, including versions and not only the names of the dependencies, is both a curse and a blessing. It is a curse when we need to upgrade to a new compiler and also want to upgrade versions of certain dependencies, as a lot of easyconfig files need to be checked and edited. In those cases the automatic concretiser of Spack may help to get running quicker. But that very precise description is also a blessing when communicating with users as you can communicate with them through EasyBuild recipes (and possibly an easystack file, which defines a list of easyconfig files to install) rather than having a part of the specification in command line options of the tool. So a user doesn't need to copy long command lines and as a support person you know exactly what EasyBuild will do, so this leaves less room for errors and difficult to solve support tickets. (Though note that with Spack environments you can also give a full specification in an Environment manifest.) Offering EasyBuild in the LUMI stacks \u00b6 The LUMI software stack is implemented as an Lmod hierarchy with two levels. On top of it EasyBuild is used with a flat naming scheme (though we did consider a hierarchical one as well). The modules that load a specific version of the software stack are hand-written in Lua. The first level (a module called LUMI ) is the version of the software stack, the second level (a module called partition ) then choses the particular set of hardware to optimise for. The LUMI module will autoload the most suited partition module for the hardware, but users can overwrite this choice, e.g., for cross-compiling which is a common practice on HPE Cray systems but not without difficulties and hence not always possible. The LUMI and partition module combo also check a default location for the user software stack, and an environment variable that is used to point to a different location for the user software stack. If a user software stack is found, its modules are automatically added to the stack. There are also some partition modules that do not correspond to particular hardware but are only used during software installation, to install software in \"special\" locations. E.g., the module partition/common is used to install some software for all partitions without binaries optimised specifically for each partition. On LUMI, a selection of build and version control tools is currently installed that way. The LUMI and partition modules are both implemented in a generic way. Instances in the module tree are symbolic links to the generic implementations, and so-called Lmod introspection functions are used by the modules to determine their function from the location in the module tree. This makes it easy to correct bugs and extend the module files without having to go over different implementations in different locations. To enable all this functionality, including the common partition, a double module structure was needed to ensure the proper working of the Lmod hierarchy. The infrastructure tree is implemented following all proper rules for an Lmod hierarchy. It houses the LUMI and partition modules among others, but also the toolchain modules so that they can be configured specifically for each version of the LUMI software stack and partition . The software module tree contains all software installed through EasyBuild, with room to expand to manually installed software or software installed with Spack should this turn out to be necessary and safe to combine with EasyBuild-managed software. EasyBuild is configured through some configuration modules that set a range of EASYBUILD_* variables to configure EasyBuild. There is again only a single EasyBuild configuration module implemented in Lua, but it appears with three different names in multiple locations in the infrastructure module tree, and again Lmod introspection functions are used by the module to determine its specific function. There are three configurations for EasyBuild: One for installation in the infrastructure module tree, one for installation in the main software tree and one for installation in the user software tree. By using just a single implementation for all three functions, we ensure that the different configurations remains consistent. This is important, e.g., to guarantee that the user configuration builds correctly upon the centrally installed stack, so any change to the structure of the latter should also propagate to the configuration of the former. EasyBuild on LUMI \u00b6 Custom toolchains \u00b6 The LUMI EasyBuild solution is not based on the common toolchains as the HPE Cray Programming Environment is the primary development environment on LUMI for which we also obtain support from HPE and as the common toolchains both post problems on LUMI. So far we have not yet succeeded to ensure proper operation of Open MPI on LUMI which is a showstopper for working with the FOSS toolchain hierarchy. There is also no support yet for AMD GPUs in the common toolchains. Moreover, the FOSS toolchain is becoming a very powerful vehicle by the inclusion of FlexiBLAS and now also efforts to build an Open MPI configuration that supports both CPU nodes and NVIDIA GPU nodes but the downside of this is that it has also become a very complicated setup to adapt if you need something else, as we do on LUMI. The Intel toolchain also has its problems. Intel does not support oneAPI on AMD processors. Though Intel MPI can in principle run on SlingShot as it is also based on libfabric and will be used on Aurora, a USA exascale system build by Intel with HPE Cray as a subcontractor for the hardware, users of AMD systems have reported problems with recent versions. MKL does not only have performance problems, but several sources also report correctness problem, especially in computational chemistry DFT codes. Instead we employ toolchains specific for the three (soon four) versions of the HPE Cray Programming Environment: HPE Cray's own Cray Compiler Environment compilers with a C/C++ compiler based on Clang/LLVM with some vendor-specific plugins and a Fortran compiler that compiles HPE Cray's frontend with a backend based on LLVM, the GNU Compiler Collection with its C/C++ and Fortran compiler, the AMD Optimizing C/C++ and Fortran Compilers (AOCC) and soon also a version employing the AMD ROCm compilers for the AMD GPU compute nodes. The toolchains used on LUMI are a further evolution of the toolchains used at CSCS with many bug corrections in the AOCC-based toolchain and better support for toolchain options specified through toolchainopts . They should however be largely compatible with the EasyConfigs in the CSCS repository . The toolchains are loaded through modules, generated with EasyBuild and a custom EasyBlock, that replace the top PrgEnv modules from the HPE Cray Programming Environment. These modules then use the modules provided by HPE Cray to load the actual compilers, compiler wrappers, MPI libraries and scientific libraries, and the target modules that determine how the main modules work. So contrary to many other EasyBuild toolchains, the compilers, MPI and scientific libraries are not installed through EasyBuild. External modules \u00b6 EasyBuild supports the use of modules that were not installed via EasyBuild. We refer to such modules as external modules . External modules do not define the EBROOT* and EBVERSION* environment variables that are present in EasyBuild-generated modules and that EasyBuild uses internally in some easyblocks and easyconfigs, and they also have no corresponding easyconfig file that can tell EasyBuild about further dependencies. External modules are used extensively on Cray systems to interface with the Cray PE (which comes with its own modules and cannot be installed via EasyBuild): external modules can be used as dependencies , by including the module name in the dependencies list, along with the EXTERNAL_MODULE constant marker. As an example, the Cray PE contains its own FFTW module, called cray-fftw . To use this module as a dependency, you should write the following in your easyconfig file: dependencies = [( 'cray-fftw' , EXTERNAL_MODULE )] (for the default version). For such dependencies, EasyBuild will: load the module before initiating the software build and install procedure include a module load statement in the generated module file (for runtime dependencies) but it will not go looking for a matching easyconfig file. Note The default version of the external module will be loaded unless a specific version is given as dependency, and here that version needs to be given as part of the name of the module and not as the second element in the tuple. dependencies = [( 'cray-fftw/3.3.8.12' , EXTERNAL_MODULE )] If the specified module is not available, EasyBuild will exit with an error message stating that the dependency can not be resolved because the module could not be found, without searching for a matching easyconfig file from which it could generate the module. The metadata for external modules can be supplied through one or more metadata files, pointed to by the --external-modules-metadata configuration option (or corresponding environment variable). These files are expected to be in INI format, with a section per module name and key-value assignments specific to that module. The following keys are supported by EasyBuild : name: software name(s) provided by the module version: software version(s) provided by the module prefix: installation prefix of the software provided by the module For instance, the external module version loaded by the dependency cray-fftw can be specified as follows: [cray-fftw] name = FFTW prefix = FFTW_DIR/.. version = 3.3.8.10 This will then ensure that EasyBuild knows the equivalent EasyBuild name(s), version(s) and root of the software installation for use in easyblocks. It will also create the corresponding $EBROOT* and $EBVERSION* environment variables in the build environment after loading the external module so that the module resembles more a regular EasyBuild-generated module and so that these environment variables can be used, e.g., in options to configure or cmake . EasyBuild also includes a default metadata file that will be used, but that one can be very much out-of-date. And if no information for a particular module is present in the metadata files, EasyBuild will even try to extract the information out of certain environment variables that are used by several Cray PE modules. On LUMI, users in generally don't need to be too concerned about the metadata file as the EasyBuild-user and other EasyBuild configuration modules take care of pointing to the right metadata file, which is specific for each version of the Cray PE and hence each version of the LUMI software stack. Software-specific easyblocks \u00b6 EasyBuild comes with a lot of software-specific easyblocks. These have only been tested with the common toolchains in the automated EasyBuild test procedures. As a result, many of those easyblocks will fail with the Cray toolchains (and with many other custom toolchains). A common problem is that they don't recongnise the compilers as they test for the presence of certain modules and hence simply stop with an error message that the compiler is not recognised, but there may also be more subtle problems, like explicitly checking for the name of a dependency rather than for the presence of the corresponding EBROOT and EBVERSION environment variables through the EasyBuild API. Hence it may fail to recognise external modules that have a different name than the name that EasyBuild uses for the package. For this reason we (and CSCS) tend to use the generic easyblocks more often, specifying configuration and build options by hand in the corresponding easyconfig parameters rather than relying on the logic in an easyblock to set the parameter for us based on the dependencies that are present. In some cases, the easyblocks are adapted, but this poses a maintenance problem. Contributing the modified easyblock back to the EasyBuild community is no guarantee that it remains compatible as the Cray-specific code cannot currently be tested in the automated test procedures due to lack of access to the Cray PE and lack of suitable easyconfig files to do the tests. However, keeping the code in our own repositories is no full solution either as the easyblock may need maintenance when a new version of EasyBuild with an updated easyblock appears. Other LUMI-specific EasyBuild settings \u00b6 On LUMI, we do use a slightly customised version of the flat naming scheme but that is mostly because we are not interested in the categorisation of modules in module classes as this categorisation is too arbitrary. There are simply too many modules that could be put in multiple classes, something which is currently not supported. We decided to remove that level altogether from the module directory tree. Further reading and information \u00b6 LUMI web site LUMI user documentation web site So far most LUMI trainings were done by HPE Cray and their training materials cannot be distributed freely, but there is some additional training material from the LUMI User Support Team . This EasyBuild training web site also contains: A training given to the LUMI User Support Team in the spring and summer of '21 A training for CSC and Local Organisations from May 2022 LUMI GitHub repositories: LUMI-SoftwareStack is the repository that contains all our Lmod modules, custom easyblocks and the easyconfigs of software that has already made it into the central stack. Its structure is inspired on that of the CSCS repository . The repository also contains ample technical information on our implementation which can also be browsed through the lumi-supercomputer GitHub pages . LUMI-EasyBuild-contrib is our main repository of easyconfig files for installation in the user space. Many of these may require more testing or support for more configurations. Most subdirectories with easyconfig files also contain a README.md file that explains the choices we made when implementing the easyconfig file. Other sites with Cray hardware that also use EasyBuild CSCS GitHub repository next: The EasyBuild community - (back to overview page)","title":"Integration of EasyBuild in LUMI"},{"location":"2022-isc22/integration_lumi/#integration-of-easybuild-in-lumi","text":"","title":"Integration of EasyBuild in LUMI"},{"location":"2022-isc22/integration_lumi/#general-information","text":"LUMI , installed in a CSC data centre (Finland)), is one of the three planned EuroHPC pre-exascale systems meant to be installed in 2022-2023, together with Leonardo (installed at Cineca) and MareNostrum5 (installed at BSC). LUMI, which stands for Large Unified Modern Infrastructure, is hosted by the LUMI consortium , a consortium of 10 countries: Finland, Belgium, Czech Republic, Denmark, Estonia, Iceland, Norway, Poland, Sweden, and Switzerland. It was supposed to be installed by the end of 2021, but the global shortage of components and some technical problems have delayed the installation. The final hardware should be installed before mid 2022. LUMI is a HPE Cray EX supercomputer with several partitions targeted for different use cases. It is also possible to run heterogeneous jobs across multiple partitions. The main compute power is provided by the LUMI-G GPU compute partition consisting of 2560 nodes. The LUMI-G node is a revolutionary compute node in the x86+GPU-world. It is also truly a \"GPU first\" system. Each GPU compute node has a single 64 core AMD EPYC 7A53 \"Trento\" CPU and 4 MI250X GPUs. Each MI250X package contains two GPU compute dies connected to each other via AMD's InfinityFabric interconnect and 8 HBM2e memory stacks, 4 per die. The GPUs and CPU are all connected through AMD's InfinityFabric interconnect, creating a system with a cache coherent unified memory space. The Trento CPU is a zen3 generation product but with an optimised I/O die that can run the InfinityFabric interconnect at a higher speed than standard Milan CPUs. Each node also have 4 200Gbit/s SlingShot 11 interconnect cards, each connected directly to a different GPU package. Each node has 512GB HBM2e RAM spread evenly across the GPU dies and 512 GB of regular DDR4 DRAM connected to the CPU. The nodes are diskless nodes. The (very) theoretical peak performance of a GPU node is around 200 Tflops for FP64 vector operations or 400 TFlops for FP64 matrix operations. The main CPU partition, called LUMI-C, consists of 1536 nodes with 2 64-core AMD EPYC 7763 CPUs. Most nodes have 256 GB of RAM memory, but there are 128 nodes with 512 GB of RAM and 32 nodes with 1 TB of RAM. In the final system, each node will be equipped with one 200 Gbit/s SlingShot 11 interconnect card. These nodes are diskless nodes. A section mostly meant for interactive data analysis consists of 8 nodes with 2 64-core AMD EPYC 7742 CPUs and 4 TB of RAM per node. These nodes are connected to the interconnect through 2 100 Gbit/s SlingShot 10 links. The second part of LUMI-D, the data visualisation section, consists of 8 nodes with two 64-core AMD EPYC 7742 CPUs and 8 NVIDIA A40 GPUs each. Each node has 2 TB of RAM and is connected to the interconnect through 2 100 Gbit/s SlingShot 10 links. LUMI-K will be an OpenShift/Kubernetes container cloud platform for running microservices with roughly 50 nodes. LUMI also has an extensive storage system There is a 7 PB flash-based storage system with 2 TB/s of bandwidth and high IOPS capability using the Lustre parallel file system and Cray ClusterStor E1000 technology. The main disk based storage contains of 4 20 PB storage systems based on regular hard disks and also using the Lustre parallel file system. A 30 PB Ceph-based encrypted object storage system for storing, sharing and staging data will become available at a later date.","title":"General information"},{"location":"2022-isc22/integration_lumi/#challenges","text":"LUMI comes with the HPE Cray Programming Environment (PE) with the Cray Compiling Environment (a fully Clang/LLVM-based C/C++ compiler and a Fortran compiler using a Cray frontend but LLVM-based backend) and GNU and AMD compilers repackaged by Cray. The HPE Cray PE uses an MPICH-based MPI implementation (with libfabric backend on SlingShot 11) and also comes with its own optimised mathematics libraries containing all the usual suspects you expect from an EasyBuild toolchain. The HPE Cray PE environment is managed outside EasyBuild, but EasyBuild has a mechanism to integrate with it. Due to the specific hardware and software setup of LUMI using the EasyBuild common toolchains is anything but straightforward. Getting Open MPI, a key component of the foss toolchain, to work is a bit of a challenge at the moment. The Intel compilers are not a very good match with AMD CPUs. One needs to be very careful when choosing the target architecture for code optimisation ( -xHost will not generate AVX/AVX2 code), most recent versions of MKL have performance problems and sometimes produce wrong results and some recent MPI versions also cause problems with AMD CPUs. LUMI has only a small central support team of 9 FTE. It is obvious that we cannot give the same level of support for software installations as some of the big sites such as JSC can do. Moreover, due to the nature of the LUMI environment with its Cray PE and novel AMD GPUs, installing software is more challenging than on your typical Intel + NVIDIA GPU cluster with NVIDIA/Mellanox interconnect. Given that the technology is very new, one can also expect a rapid evolution of the programming environment with a risk of breaking compatibility with earlier versions, and a need for frequent software updates in the initial years of operation to work around bugs or make new and important features available. So the maintenance cost of a the user application stack is certainly higher than on clusters based on more conventional technology. Early experience has also shown that we need to be prepared for potentially breaking changes on very short notice. It also means that we have to be very agile when it comes to maintaining the software stack and that it is also impossible to thoroughly test all installations, so we must be able to make corrections quickly. This goes against a big central software stack, as in a central software stack it is nearly impossible to replace an installation that fails for some users outside maintenance intervals. The central support team may be small (the above 9 FTE), but the LUMI consortium agreement states that the consortium countries also have to assist in providing support. Given that neither the LUMI User Support Team members nor the local support teams are employees of CSC this also means that much of the application support has to be delivered with very little rights on the system (at most a working directory that is readable for all users). So we need a setup where it is possible to help users installing applications while having only regular user rights on the system. Due to the exploitation model and the small size of the central support team, license management is a pain. Users come to LUMI through 11 different channels (some with subchannels). Moreover it is the responsibility of the PI to invite users to a project and to ensure that they are eligible for LUMI use (taking into account, e.g., the European and USA export restrictions). At the central level we have no means currently to check who can use which software license. Hence we need a solution to distribute that responsibility also. LUMI software support is based on the idea that users really want a customised software stack. They may say they want a central stack but only as long as it contains the software they need and not much more as they also do not want to search through long lists of modules. Nobody is waiting for 20 different configurations of a package, but the reality is that different users will want different versions with sometimes conflicting configurations, or compiled with different compilers. We also note that some communities forego centrally installed software which may have better optimised binaries to build their own custom setup using tools such as Conda. And even though modules go a long way in managing dependencies and helping to avoid conflicts, we expect that with the explosion of software used on HPC machines and the poor maintenance of that software, it will become increasingly difficult to find versions of dependencies that work for a range of programs, leading to cases where we may simply need to install a software package with different sets of dependencies simply because users want to use it together with other packages that have restrictions on the versions of those dependencies. Experienced Python users without doubt know what a mess this can create and how even a single user sometimes needs different virtual environments with different installations to do their work.","title":"Challenges"},{"location":"2022-isc22/integration_lumi/#solution-with-easybuild-and-lmod","text":"On LUMI we selected EasyBuild as our primary software installation tool, but also offer some limited support for Spack. EasyBuild was selected as there is already a lot of experience with EasyBuild in several of the LUMI consortium countries and as it is a good fit with the goals of the EuroHPC JU as they want to establish a European HPC ecosystem with a European technology option at every level. The developers of EasyBuild are also very accessible and it helps that the lead developer and several of the maintainers are from LUMI consortium countries. We use Lmod as the module tool. We basically had the choice between Lmod and the old C implementation of TCL Environment Modules as HPE Cray does not support the more modern Environment Modules 4 or 5 developed in France. Support for Lmod is excellent in EasyBuild and Spack, and Lua is also a more modern language to work with than TCL.","title":"Solution with EasyBuild and Lmod"},{"location":"2022-isc22/integration_lumi/#software-stacks","text":"On LUMI we offer users the choice between multiple software stacks, offered through hand-written Lmod modules. The CrayEnv stack is really just a small layer on top of the HPE Cray PE in which we provide a few additional tools and help the user with managing the environment for the HPE Cray PE. The HPE Cray PE works with a universal compiler wrapper that sets some optimisation options for the supported compilers and sets the flags to compile and link with the MPI, optimised scientific libraries and some other libraries provided with the PE. It does so based on which modules are loaded. The CPU and GPU targets and the MPI fabric library are selected through so-called target modules, typically loaded during shell initialisation, while compiler, MPI and scientific libraries are typically loaded through the so-called PrgEnv-* modules (one for each supported compiler). The CrayEnv software stack module will take care of ensuring that a proper set of target modules is loaded depending on the node type on which the module is loaded, and hence also reloading the proper target modules after a module purge . The environment is also enriched with a number of build tools that are not installed in the OS image or only in an older version. These tools are often build with EasyBuild with the SYSTEM toolchain though we do not make EasyBuild itself available to users in that stack. The LUMI stack is a software stack which is mostly managed with EasyBuild. The stack is versioned based on the version of the HPE Cray PE which makes it easy to retire a whole stack when the compilers are retired from the system. If we need the same software in two different stacks, it is simply compiled twice, even if it is only installed with the system compilers, to make retiring software easier without having to track dependencies (we now simply have to remove a few directories to remove a whole software stack which will not have an impact on the other stacks). The exception are a few packages installed from binaries that are installed in a separate area across software stacks (e.g., ARM Forge and Vampir). The LUMI stack provides optimised binaries for each node type of LUMI, but some software that is not performance-critical is compiled only once. To this end we have a partition corresponding to each node type, but also a common partition which is included with the software of all other partitions. Software in that common partition can only have dependencies in the common partition though. For now we keep the central LUMI software stack very small, but we provide an easy and fully transparent mechanism for the user to install software in their project directory that integrates fully with the LUMI stack. The user only needs to set an environment variable pointing to the project space. In the future we envision that more software stacks may become available on LUMI as at least one local support organisation wants to build their own stack. We also hope to find a solution to get the foss toolchain working on at least the CPU nodes of LUMI with minimal changes in a future collaboration with HPE.","title":"Software stacks"},{"location":"2022-isc22/integration_lumi/#easybuild-for-software-management","text":"The second component to our solution is EasyBuild. EasyBuild can give a very precise description of all the steps needed to build a package while the user needs to give very few arguments to the eb command to actually do the installation. It is also robust enough that with a proper module to configure EasyBuild, an installation done by one user on LUMI will reproduce easily in the environment of another user. The fact that each easyconfig file contains a very precise list of dependencies, including versions and not only the names of the dependencies, is both a curse and a blessing. It is a curse when we need to upgrade to a new compiler and also want to upgrade versions of certain dependencies, as a lot of easyconfig files need to be checked and edited. In those cases the automatic concretiser of Spack may help to get running quicker. But that very precise description is also a blessing when communicating with users as you can communicate with them through EasyBuild recipes (and possibly an easystack file, which defines a list of easyconfig files to install) rather than having a part of the specification in command line options of the tool. So a user doesn't need to copy long command lines and as a support person you know exactly what EasyBuild will do, so this leaves less room for errors and difficult to solve support tickets. (Though note that with Spack environments you can also give a full specification in an Environment manifest.)","title":"EasyBuild for software management"},{"location":"2022-isc22/integration_lumi/#offering-easybuild-in-the-lumi-stacks","text":"The LUMI software stack is implemented as an Lmod hierarchy with two levels. On top of it EasyBuild is used with a flat naming scheme (though we did consider a hierarchical one as well). The modules that load a specific version of the software stack are hand-written in Lua. The first level (a module called LUMI ) is the version of the software stack, the second level (a module called partition ) then choses the particular set of hardware to optimise for. The LUMI module will autoload the most suited partition module for the hardware, but users can overwrite this choice, e.g., for cross-compiling which is a common practice on HPE Cray systems but not without difficulties and hence not always possible. The LUMI and partition module combo also check a default location for the user software stack, and an environment variable that is used to point to a different location for the user software stack. If a user software stack is found, its modules are automatically added to the stack. There are also some partition modules that do not correspond to particular hardware but are only used during software installation, to install software in \"special\" locations. E.g., the module partition/common is used to install some software for all partitions without binaries optimised specifically for each partition. On LUMI, a selection of build and version control tools is currently installed that way. The LUMI and partition modules are both implemented in a generic way. Instances in the module tree are symbolic links to the generic implementations, and so-called Lmod introspection functions are used by the modules to determine their function from the location in the module tree. This makes it easy to correct bugs and extend the module files without having to go over different implementations in different locations. To enable all this functionality, including the common partition, a double module structure was needed to ensure the proper working of the Lmod hierarchy. The infrastructure tree is implemented following all proper rules for an Lmod hierarchy. It houses the LUMI and partition modules among others, but also the toolchain modules so that they can be configured specifically for each version of the LUMI software stack and partition . The software module tree contains all software installed through EasyBuild, with room to expand to manually installed software or software installed with Spack should this turn out to be necessary and safe to combine with EasyBuild-managed software. EasyBuild is configured through some configuration modules that set a range of EASYBUILD_* variables to configure EasyBuild. There is again only a single EasyBuild configuration module implemented in Lua, but it appears with three different names in multiple locations in the infrastructure module tree, and again Lmod introspection functions are used by the module to determine its specific function. There are three configurations for EasyBuild: One for installation in the infrastructure module tree, one for installation in the main software tree and one for installation in the user software tree. By using just a single implementation for all three functions, we ensure that the different configurations remains consistent. This is important, e.g., to guarantee that the user configuration builds correctly upon the centrally installed stack, so any change to the structure of the latter should also propagate to the configuration of the former.","title":"Offering EasyBuild in the LUMI stacks"},{"location":"2022-isc22/integration_lumi/#easybuild-on-lumi","text":"","title":"EasyBuild on LUMI"},{"location":"2022-isc22/integration_lumi/#custom-toolchains","text":"The LUMI EasyBuild solution is not based on the common toolchains as the HPE Cray Programming Environment is the primary development environment on LUMI for which we also obtain support from HPE and as the common toolchains both post problems on LUMI. So far we have not yet succeeded to ensure proper operation of Open MPI on LUMI which is a showstopper for working with the FOSS toolchain hierarchy. There is also no support yet for AMD GPUs in the common toolchains. Moreover, the FOSS toolchain is becoming a very powerful vehicle by the inclusion of FlexiBLAS and now also efforts to build an Open MPI configuration that supports both CPU nodes and NVIDIA GPU nodes but the downside of this is that it has also become a very complicated setup to adapt if you need something else, as we do on LUMI. The Intel toolchain also has its problems. Intel does not support oneAPI on AMD processors. Though Intel MPI can in principle run on SlingShot as it is also based on libfabric and will be used on Aurora, a USA exascale system build by Intel with HPE Cray as a subcontractor for the hardware, users of AMD systems have reported problems with recent versions. MKL does not only have performance problems, but several sources also report correctness problem, especially in computational chemistry DFT codes. Instead we employ toolchains specific for the three (soon four) versions of the HPE Cray Programming Environment: HPE Cray's own Cray Compiler Environment compilers with a C/C++ compiler based on Clang/LLVM with some vendor-specific plugins and a Fortran compiler that compiles HPE Cray's frontend with a backend based on LLVM, the GNU Compiler Collection with its C/C++ and Fortran compiler, the AMD Optimizing C/C++ and Fortran Compilers (AOCC) and soon also a version employing the AMD ROCm compilers for the AMD GPU compute nodes. The toolchains used on LUMI are a further evolution of the toolchains used at CSCS with many bug corrections in the AOCC-based toolchain and better support for toolchain options specified through toolchainopts . They should however be largely compatible with the EasyConfigs in the CSCS repository . The toolchains are loaded through modules, generated with EasyBuild and a custom EasyBlock, that replace the top PrgEnv modules from the HPE Cray Programming Environment. These modules then use the modules provided by HPE Cray to load the actual compilers, compiler wrappers, MPI libraries and scientific libraries, and the target modules that determine how the main modules work. So contrary to many other EasyBuild toolchains, the compilers, MPI and scientific libraries are not installed through EasyBuild.","title":"Custom toolchains"},{"location":"2022-isc22/integration_lumi/#external-modules","text":"EasyBuild supports the use of modules that were not installed via EasyBuild. We refer to such modules as external modules . External modules do not define the EBROOT* and EBVERSION* environment variables that are present in EasyBuild-generated modules and that EasyBuild uses internally in some easyblocks and easyconfigs, and they also have no corresponding easyconfig file that can tell EasyBuild about further dependencies. External modules are used extensively on Cray systems to interface with the Cray PE (which comes with its own modules and cannot be installed via EasyBuild): external modules can be used as dependencies , by including the module name in the dependencies list, along with the EXTERNAL_MODULE constant marker. As an example, the Cray PE contains its own FFTW module, called cray-fftw . To use this module as a dependency, you should write the following in your easyconfig file: dependencies = [( 'cray-fftw' , EXTERNAL_MODULE )] (for the default version). For such dependencies, EasyBuild will: load the module before initiating the software build and install procedure include a module load statement in the generated module file (for runtime dependencies) but it will not go looking for a matching easyconfig file. Note The default version of the external module will be loaded unless a specific version is given as dependency, and here that version needs to be given as part of the name of the module and not as the second element in the tuple. dependencies = [( 'cray-fftw/3.3.8.12' , EXTERNAL_MODULE )] If the specified module is not available, EasyBuild will exit with an error message stating that the dependency can not be resolved because the module could not be found, without searching for a matching easyconfig file from which it could generate the module. The metadata for external modules can be supplied through one or more metadata files, pointed to by the --external-modules-metadata configuration option (or corresponding environment variable). These files are expected to be in INI format, with a section per module name and key-value assignments specific to that module. The following keys are supported by EasyBuild : name: software name(s) provided by the module version: software version(s) provided by the module prefix: installation prefix of the software provided by the module For instance, the external module version loaded by the dependency cray-fftw can be specified as follows: [cray-fftw] name = FFTW prefix = FFTW_DIR/.. version = 3.3.8.10 This will then ensure that EasyBuild knows the equivalent EasyBuild name(s), version(s) and root of the software installation for use in easyblocks. It will also create the corresponding $EBROOT* and $EBVERSION* environment variables in the build environment after loading the external module so that the module resembles more a regular EasyBuild-generated module and so that these environment variables can be used, e.g., in options to configure or cmake . EasyBuild also includes a default metadata file that will be used, but that one can be very much out-of-date. And if no information for a particular module is present in the metadata files, EasyBuild will even try to extract the information out of certain environment variables that are used by several Cray PE modules. On LUMI, users in generally don't need to be too concerned about the metadata file as the EasyBuild-user and other EasyBuild configuration modules take care of pointing to the right metadata file, which is specific for each version of the Cray PE and hence each version of the LUMI software stack.","title":"External modules"},{"location":"2022-isc22/integration_lumi/#software-specific-easyblocks","text":"EasyBuild comes with a lot of software-specific easyblocks. These have only been tested with the common toolchains in the automated EasyBuild test procedures. As a result, many of those easyblocks will fail with the Cray toolchains (and with many other custom toolchains). A common problem is that they don't recongnise the compilers as they test for the presence of certain modules and hence simply stop with an error message that the compiler is not recognised, but there may also be more subtle problems, like explicitly checking for the name of a dependency rather than for the presence of the corresponding EBROOT and EBVERSION environment variables through the EasyBuild API. Hence it may fail to recognise external modules that have a different name than the name that EasyBuild uses for the package. For this reason we (and CSCS) tend to use the generic easyblocks more often, specifying configuration and build options by hand in the corresponding easyconfig parameters rather than relying on the logic in an easyblock to set the parameter for us based on the dependencies that are present. In some cases, the easyblocks are adapted, but this poses a maintenance problem. Contributing the modified easyblock back to the EasyBuild community is no guarantee that it remains compatible as the Cray-specific code cannot currently be tested in the automated test procedures due to lack of access to the Cray PE and lack of suitable easyconfig files to do the tests. However, keeping the code in our own repositories is no full solution either as the easyblock may need maintenance when a new version of EasyBuild with an updated easyblock appears.","title":"Software-specific easyblocks"},{"location":"2022-isc22/integration_lumi/#other-lumi-specific-easybuild-settings","text":"On LUMI, we do use a slightly customised version of the flat naming scheme but that is mostly because we are not interested in the categorisation of modules in module classes as this categorisation is too arbitrary. There are simply too many modules that could be put in multiple classes, something which is currently not supported. We decided to remove that level altogether from the module directory tree.","title":"Other LUMI-specific EasyBuild settings"},{"location":"2022-isc22/integration_lumi/#further-reading-and-information","text":"LUMI web site LUMI user documentation web site So far most LUMI trainings were done by HPE Cray and their training materials cannot be distributed freely, but there is some additional training material from the LUMI User Support Team . This EasyBuild training web site also contains: A training given to the LUMI User Support Team in the spring and summer of '21 A training for CSC and Local Organisations from May 2022 LUMI GitHub repositories: LUMI-SoftwareStack is the repository that contains all our Lmod modules, custom easyblocks and the easyconfigs of software that has already made it into the central stack. Its structure is inspired on that of the CSCS repository . The repository also contains ample technical information on our implementation which can also be browsed through the lumi-supercomputer GitHub pages . LUMI-EasyBuild-contrib is our main repository of easyconfig files for installation in the user space. Many of these may require more testing or support for more configurations. Most subdirectories with easyconfig files also contain a README.md file that explains the choices we made when implementing the easyconfig file. Other sites with Cray hardware that also use EasyBuild CSCS GitHub repository next: The EasyBuild community - (back to overview page)","title":"Further reading and information"},{"location":"2022-isc22/introduction/","text":"Introduction to EasyBuild \u00b6 What is EasyBuild? \u00b6 EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. EasyBuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack. History \u00b6 EasyBuild as a project was conceived in 2008 by the HPC team at Ghent University (Belgium) . The first public release of EasyBuild was made available early 2012. EasyBuild v1.0.0 was released in November 2012, during the Supercomputing 2012 conference. Following the public release and the project's introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. Over the years EasyBuild has grown into a community project , which is used and developed by hundreds of HPC centres and consortia worldwide. EasyBuild in a nutshell \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among HPC sites worldwide, and has become an \"expert system\" for installing scientific software on HPC systems. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations. The installation procedure executed by EasyBuild is thoroughly logged , and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed. EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting . Reproducibility \u00b6 In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular compiler toolchain , with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, by opening pull requests to the GitHub repositories or the documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you. next: Terminology - (back to overview page)","title":"Introduction to EasyBuild"},{"location":"2022-isc22/introduction/#introduction-to-easybuild","text":"","title":"Introduction to EasyBuild"},{"location":"2022-isc22/introduction/#what-is-easybuild","text":"EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. EasyBuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack.","title":"What is EasyBuild?"},{"location":"2022-isc22/introduction/#history","text":"EasyBuild as a project was conceived in 2008 by the HPC team at Ghent University (Belgium) . The first public release of EasyBuild was made available early 2012. EasyBuild v1.0.0 was released in November 2012, during the Supercomputing 2012 conference. Following the public release and the project's introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. Over the years EasyBuild has grown into a community project , which is used and developed by hundreds of HPC centres and consortia worldwide.","title":"History"},{"location":"2022-isc22/introduction/#easybuild-in-a-nutshell","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown to become a platform for collaboration among HPC sites worldwide, and has become an \"expert system\" for installing scientific software on HPC systems.","title":"EasyBuild in a nutshell"},{"location":"2022-isc22/introduction/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations. The installation procedure executed by EasyBuild is thoroughly logged , and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed. EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers ( Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on.","title":"Key features"},{"location":"2022-isc22/introduction/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"2022-isc22/introduction/#performance","text":"EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour can be changed via the --optarch configuration setting .","title":"Performance"},{"location":"2022-isc22/introduction/#reproducibility","text":"In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular compiler toolchain , with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"2022-isc22/introduction/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, by opening pull requests to the GitHub repositories or the documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Community effort"},{"location":"2022-isc22/introduction/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is not a magic solution to all your (software installation) problems . You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you. next: Terminology - (back to overview page)","title":"What EasyBuild is not"},{"location":"2022-isc22/module_naming_schemes/","text":"Module naming schemes \u00b6 Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing h5py-3.6.0-foss-2021b.eb the generated module was named h5py/3.6.0-foss-2021b . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: EasyBuildMNS MigrateFromEBToHMNS HierarchicalMNS CategorizedHMNS CategorizedModuleNamingScheme In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. We will also take a quick look at implementing our own custom module naming scheme. Flat vs hierarchical \u00b6 The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/11.2.0 , while the compiler level includes two modules: OpenMPI/4.1.1 and MPICH/3.4.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/11.2.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our example, loading the GCC/11.2.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These correspond to installations of OpenMPI and MPICH that were built using GCC/11.2.0 as a (compiler-only) toolchain. Similarly, the OpenMPI/4.1.1 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2021b toolchain that consists of the GCC/11.2.0 compiler module and the OpenMPI/4.1.1 MPI module. Software installed using foss/2021b (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard Core - Compiler - MPI hierarchy. Pros & cons \u00b6 So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users; Length of module names \u00b6 When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.12.1-gompi-2021b as module name. The -gompi-2021b part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.12.1 which is basically the bare essentials: software name and version. That's way better, nice and clean! Amount of available modules \u00b6 The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands... This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded. Loading compatible modules \u00b6 Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful... In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily. Visibility of existing modules \u00b6 One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file. Semantics of gateway modules \u00b6 An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy. Using a custom module naming scheme \u00b6 Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it. Implementation \u00b6 To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general ModuleNamingScheme class. For a flat module naming scheme, it is sufficient to implement the det_full_module_name method, which should return a string value (the full module name). You may also need to customize the is_short_modname_for method, which verifies whether a given (short) module name is for the software with a particular given name (or not). The argument provided to det_full_module_name can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters ( name , version , toolchain , and versionsuffix ), or an EasyConfig instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters. For simple module naming schemes, just have name , version , toolchain , and versionsuffix available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant REQUIRED_KEYS . A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme EasyBuildMNS . For a hierarchical module naming scheme, various additional methods have to be implemented. Some of these, like det_module_subdir and det_short_module_name , determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like det_modpath_extensions , determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the $MODULEPATH ). A typical example of a hierarchical module naming scheme is HierarchicalMNS that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional Core - Compiler - MPI module hierarchy we discussed above. Configuring EasyBuild \u00b6 To let EasyBuild use a custom module naming scheme, you need to: specify the path to the Python module file implementing it via the include-module-naming-schemes EasyBuild configuration option; indicate that you also want to use this custom module naming scheme via the module-naming-scheme EasyBuild configuration option. For example: export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES = $HOME /easybuild/example_mns.py export EASYBUILD_MODULE_NAMING_SCHEME = ExampleMNS Example custom module naming scheme \u00b6 Here is an example of a custom module naming scheme, where: the versionsuffix goes directly after the version ; all dashes are replaced by underscores; all module names are lowercase; Note that we also need to customise the is_short_modname_for method, to make sure it returns True when the EasyBuild framework checks whether scipy_bundle/2021.10_foss_2021b is a module name for SciPy-bundle . import os from easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme class ExampleMNS ( ModuleNamingScheme ): REQUIRED_KEYS = [ 'name' , 'version' , 'versionsuffix' , 'toolchain' ] def det_full_module_name ( self , ec ): \"\"\" Determine full module name: - all lowercase - replace all dashes with underscores \"\"\" parts = [ ec [ 'version' ]] # versionsuffix directly after version (but only if it's not empty) if ec [ 'versionsuffix' ]: parts . append ( ec [ 'versionsuffix' ]) # only add toolchain name/version for non-system toolchain tc = ec [ 'toolchain' ] if tc [ 'name' ] . lower () != 'system' : parts . extend ([ tc [ 'name' ], tc [ 'version' ]]) modname = ec [ 'name' ] + '/' + '_' . join ( parts ) modname = modname . replace ( '-' , '_' ) . replace ( '__' , '_' ) return modname . lower () def is_short_modname_for ( self , short_modname , name ): \"\"\"Determine whether short module name is a module for the software with specified name.\"\"\" return short_modname . startswith ( name . lower () . replace ( '-' , '_' ) + '/' ) We can see what the module names with this module naming scheme would like like via eb -D : $ eb SciPy-bundle-2021.10-foss-2021b-Python-2.7.18.eb -D ... * [ ] $CFGS/g/GCC/GCC-11.2.0.eb (module: gcc/11.2.0) ... * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-11.2.0.eb (module: python/2.7.18_gcccore_11.2.0) ... * [ ] $CFGS/o/OpenMPI/OpenMPI-4.1.1-GCC-11.2.0.eb (module: openmpi/4.1.1_gcc_11.2.0) ... * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2021.10-foss-2021b-Python-2.7.18.eb (module: scipy_bundle/2021.10_python_2.7.18_foss_2021b) Example module hierarchy: HDF5 \u00b6 Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations. Preparing the environment \u00b6 Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/11.2.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: unset PIP_PREFIX pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 Configuring EasyBuild \u00b6 First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example. Generating modules for HDF5 \u00b6 Let's now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.12.1-gompi-2021b.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.12.1-gompi-2021b.eb --robot --module-only ... == building and installing MPI/GCC/11.2.0/OpenMPI/4.1.1/HDF5/1.12.1... ... == sanity checking... == cleaning up [ skipped ] == creating module... ... == COMPLETED: Installation ended successfully ( took 17 sec ) ... == Build succeeded for 42 out of 42 This should take a couple of minutes in total, for generating 42 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation... Loading the HDF5 module \u00b6 After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME /hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME /hmns/modules/all/Core Let's see what that gives us in terms of available modules: $ module avail ------------------------ /home/easybuild/hmns/modules/all/Core ------------------------- binutils/2.37 GCC/11.2.0 gompi/2021b OpenSSL/1.1 Bison/3.8.2 GCCcore/11.2.0 M4/1.4.19 pkg-config/0.29.2 flex/2.6.4 gettext/0.21 ncurses/6.2 zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let's see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.12.1\" module is available to load. GCC/11.2.0 OpenMPI/4.1.1 This tells us we need to load two gateway modules before we can load the module for HDF5. Let's start with loading the GCC compiler module: module load GCC/11.2.0 And then check again which modules are available: $ module avail --------------------------- /home/easybuild/hmns/modules/all/Compiler/GCC/11.2.0 --------------------------- OpenMPI/4.1.1 ------------------------- /home/easybuild/hmns/modules/all/Compiler/GCCcore/11.2.0 ------------------------- Autoconf/2.71 flex/2.6.4 (D) libreadline/8.1 pkg-config/0.29.2 (D) Automake/1.16.4 groff/1.22.4 libtool/2.4.6 PMIx/4.1.0 Autotools/20210726 help2man/1.48.3 libxml2/2.9.10 Szip/2.1.1 binutils/2.37 (L,D) hwloc/2.5.0 M4/1.4.19 (D) UCX/1.11.2 Bison/3.7.6 libevent/2.1.12 ncurses/6.2 (D) xorg-macros/1.19.3 DB/18.1.40 libfabric/1.13.2 numactl/2.0.14 XZ/5.2.5 expat/2.4.1 libpciaccess/0.16 Perl/5.34.0 zlib/1.2.11 (L,D) ---------------------------------- /home/easybuild/hmns/modules/all/Core ----------------------------------- binutils/2.37 GCC/11.2.0 (L) gompi/2021b OpenSSL/1.1 Bison/3.8.2 (D) GCCcore/11.2.0 (L) M4/1.4.19 pkg-config/0.29.2 flex/2.6.4 gettext/0.21 ncurses/6.2 zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/11.2.0 and Compiler/GCC/11.2.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 11.2.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.1.1 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/11.2.0 and OpenMPI/4.1.1 modules first. So, let us do exactly that (remember that GCC/11.2.0 is already loaded): module load OpenMPI/4.1.1 If you now check the output of \" module avail \" again, you should see the HDF5/1.12.1 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/11.2.0/OpenMPI/4.1.1 ------- HDF5/1.12.1 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/11.2.0 ------------ OpenMPI/4.1.1 (L) ... To use HDF5, we need to load this HDF5/1.12.1 module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.12.1 $ h5dump --version h5dump: Version 1.12.1 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/11.2.0 5 ) numactl/2.0.14 9 ) hwloc/2.5.0 13 ) libfabric/1.13.2 17 ) HDF5/1.12.1 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) OpenSSL/1.1 14 ) PMIx/4.1.0 3 ) binutils/2.37 7 ) libxml2/2.9.10 11 ) libevent/2.1.12 15 ) OpenMPI/4.1.1 4 ) GCC/11.2.0 8 ) libpciaccess/0.16 12 ) UCX/1.11.2 16 ) Szip/2.1.1 Exercise \u00b6 Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2021.10-foss-2021b.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2021.10-foss-2021b.eb -M The output should tell you that 24 out of 64 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2021.10-foss-2021b.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2021.10 Load the gateway modules: module load GCC/11.2.0 OpenMPI/4.1.1 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/11.2.0/OpenMPI/4.1.1 ------ SciPy-bundle/2021.10 module load SciPy-bundle/2021.10 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.3.4 next: EasyBuild at J\u00fclich Supercomputing Centre - (back to overview page)","title":"Module naming schemes"},{"location":"2022-isc22/module_naming_schemes/#module-naming-schemes","text":"Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing h5py-3.6.0-foss-2021b.eb the generated module was named h5py/3.6.0-foss-2021b . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: EasyBuildMNS MigrateFromEBToHMNS HierarchicalMNS CategorizedHMNS CategorizedModuleNamingScheme In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. We will also take a quick look at implementing our own custom module naming scheme.","title":"Module naming schemes"},{"location":"2022-isc22/module_naming_schemes/#flat-vs-hierarchical","text":"The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/11.2.0 , while the compiler level includes two modules: OpenMPI/4.1.1 and MPICH/3.4.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/11.2.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our example, loading the GCC/11.2.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These correspond to installations of OpenMPI and MPICH that were built using GCC/11.2.0 as a (compiler-only) toolchain. Similarly, the OpenMPI/4.1.1 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2021b toolchain that consists of the GCC/11.2.0 compiler module and the OpenMPI/4.1.1 MPI module. Software installed using foss/2021b (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard Core - Compiler - MPI hierarchy.","title":"Flat vs hierarchical"},{"location":"2022-isc22/module_naming_schemes/#pros-cons","text":"So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users;","title":"Pros &amp; cons"},{"location":"2022-isc22/module_naming_schemes/#length-of-module-names","text":"When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.12.1-gompi-2021b as module name. The -gompi-2021b part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.12.1 which is basically the bare essentials: software name and version. That's way better, nice and clean!","title":"Length of module names"},{"location":"2022-isc22/module_naming_schemes/#amount-of-available-modules","text":"The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands... This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded.","title":"Amount of available modules"},{"location":"2022-isc22/module_naming_schemes/#loading-compatible-modules","text":"Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful... In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily.","title":"Loading compatible modules"},{"location":"2022-isc22/module_naming_schemes/#visibility-of-existing-modules","text":"One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.","title":"Visibility of existing modules"},{"location":"2022-isc22/module_naming_schemes/#semantics-of-gateway-modules","text":"An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy.","title":"Semantics of gateway modules"},{"location":"2022-isc22/module_naming_schemes/#using-a-custom-module-naming-scheme","text":"Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it.","title":"Using a custom module naming scheme"},{"location":"2022-isc22/module_naming_schemes/#implementation","text":"To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general ModuleNamingScheme class. For a flat module naming scheme, it is sufficient to implement the det_full_module_name method, which should return a string value (the full module name). You may also need to customize the is_short_modname_for method, which verifies whether a given (short) module name is for the software with a particular given name (or not). The argument provided to det_full_module_name can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters ( name , version , toolchain , and versionsuffix ), or an EasyConfig instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters. For simple module naming schemes, just have name , version , toolchain , and versionsuffix available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant REQUIRED_KEYS . A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme EasyBuildMNS . For a hierarchical module naming scheme, various additional methods have to be implemented. Some of these, like det_module_subdir and det_short_module_name , determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like det_modpath_extensions , determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the $MODULEPATH ). A typical example of a hierarchical module naming scheme is HierarchicalMNS that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional Core - Compiler - MPI module hierarchy we discussed above.","title":"Implementation"},{"location":"2022-isc22/module_naming_schemes/#configuring-easybuild","text":"To let EasyBuild use a custom module naming scheme, you need to: specify the path to the Python module file implementing it via the include-module-naming-schemes EasyBuild configuration option; indicate that you also want to use this custom module naming scheme via the module-naming-scheme EasyBuild configuration option. For example: export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES = $HOME /easybuild/example_mns.py export EASYBUILD_MODULE_NAMING_SCHEME = ExampleMNS","title":"Configuring EasyBuild"},{"location":"2022-isc22/module_naming_schemes/#example-custom-module-naming-scheme","text":"Here is an example of a custom module naming scheme, where: the versionsuffix goes directly after the version ; all dashes are replaced by underscores; all module names are lowercase; Note that we also need to customise the is_short_modname_for method, to make sure it returns True when the EasyBuild framework checks whether scipy_bundle/2021.10_foss_2021b is a module name for SciPy-bundle . import os from easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme class ExampleMNS ( ModuleNamingScheme ): REQUIRED_KEYS = [ 'name' , 'version' , 'versionsuffix' , 'toolchain' ] def det_full_module_name ( self , ec ): \"\"\" Determine full module name: - all lowercase - replace all dashes with underscores \"\"\" parts = [ ec [ 'version' ]] # versionsuffix directly after version (but only if it's not empty) if ec [ 'versionsuffix' ]: parts . append ( ec [ 'versionsuffix' ]) # only add toolchain name/version for non-system toolchain tc = ec [ 'toolchain' ] if tc [ 'name' ] . lower () != 'system' : parts . extend ([ tc [ 'name' ], tc [ 'version' ]]) modname = ec [ 'name' ] + '/' + '_' . join ( parts ) modname = modname . replace ( '-' , '_' ) . replace ( '__' , '_' ) return modname . lower () def is_short_modname_for ( self , short_modname , name ): \"\"\"Determine whether short module name is a module for the software with specified name.\"\"\" return short_modname . startswith ( name . lower () . replace ( '-' , '_' ) + '/' ) We can see what the module names with this module naming scheme would like like via eb -D : $ eb SciPy-bundle-2021.10-foss-2021b-Python-2.7.18.eb -D ... * [ ] $CFGS/g/GCC/GCC-11.2.0.eb (module: gcc/11.2.0) ... * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-11.2.0.eb (module: python/2.7.18_gcccore_11.2.0) ... * [ ] $CFGS/o/OpenMPI/OpenMPI-4.1.1-GCC-11.2.0.eb (module: openmpi/4.1.1_gcc_11.2.0) ... * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2021.10-foss-2021b-Python-2.7.18.eb (module: scipy_bundle/2021.10_python_2.7.18_foss_2021b)","title":"Example custom module naming scheme"},{"location":"2022-isc22/module_naming_schemes/#example-module-hierarchy-hdf5","text":"Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.","title":"Example module hierarchy: HDF5"},{"location":"2022-isc22/module_naming_schemes/#preparing-the-environment","text":"Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/11.2.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: unset PIP_PREFIX pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3","title":"Preparing the environment"},{"location":"2022-isc22/module_naming_schemes/#configuring-easybuild_1","text":"First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example.","title":"Configuring EasyBuild"},{"location":"2022-isc22/module_naming_schemes/#generating-modules-for-hdf5","text":"Let's now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.12.1-gompi-2021b.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.12.1-gompi-2021b.eb --robot --module-only ... == building and installing MPI/GCC/11.2.0/OpenMPI/4.1.1/HDF5/1.12.1... ... == sanity checking... == cleaning up [ skipped ] == creating module... ... == COMPLETED: Installation ended successfully ( took 17 sec ) ... == Build succeeded for 42 out of 42 This should take a couple of minutes in total, for generating 42 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...","title":"Generating modules for HDF5"},{"location":"2022-isc22/module_naming_schemes/#loading-the-hdf5-module","text":"After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME /hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME /hmns/modules/all/Core Let's see what that gives us in terms of available modules: $ module avail ------------------------ /home/easybuild/hmns/modules/all/Core ------------------------- binutils/2.37 GCC/11.2.0 gompi/2021b OpenSSL/1.1 Bison/3.8.2 GCCcore/11.2.0 M4/1.4.19 pkg-config/0.29.2 flex/2.6.4 gettext/0.21 ncurses/6.2 zlib/1.2.11 Nice and short module names, but only a limited set of them. We know a module file exists for HDF5 , but we can't see it yet (and hence we can't load it either). $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. Let's see if module spider is of any help, as \" module avail \" so kindly suggests: $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.12.1\" module is available to load. GCC/11.2.0 OpenMPI/4.1.1 This tells us we need to load two gateway modules before we can load the module for HDF5. Let's start with loading the GCC compiler module: module load GCC/11.2.0 And then check again which modules are available: $ module avail --------------------------- /home/easybuild/hmns/modules/all/Compiler/GCC/11.2.0 --------------------------- OpenMPI/4.1.1 ------------------------- /home/easybuild/hmns/modules/all/Compiler/GCCcore/11.2.0 ------------------------- Autoconf/2.71 flex/2.6.4 (D) libreadline/8.1 pkg-config/0.29.2 (D) Automake/1.16.4 groff/1.22.4 libtool/2.4.6 PMIx/4.1.0 Autotools/20210726 help2man/1.48.3 libxml2/2.9.10 Szip/2.1.1 binutils/2.37 (L,D) hwloc/2.5.0 M4/1.4.19 (D) UCX/1.11.2 Bison/3.7.6 libevent/2.1.12 ncurses/6.2 (D) xorg-macros/1.19.3 DB/18.1.40 libfabric/1.13.2 numactl/2.0.14 XZ/5.2.5 expat/2.4.1 libpciaccess/0.16 Perl/5.34.0 zlib/1.2.11 (L,D) ---------------------------------- /home/easybuild/hmns/modules/all/Core ----------------------------------- binutils/2.37 GCC/11.2.0 (L) gompi/2021b OpenSSL/1.1 Bison/3.8.2 (D) GCCcore/11.2.0 (L) M4/1.4.19 pkg-config/0.29.2 flex/2.6.4 gettext/0.21 ncurses/6.2 zlib/1.2.11 Good news, we now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/11.2.0 and Compiler/GCC/11.2.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 11.2.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.1.1 , which is another gateway module. Remember that the \" module spider \" output told us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/11.2.0 and OpenMPI/4.1.1 modules first. So, let us do exactly that (remember that GCC/11.2.0 is already loaded): module load OpenMPI/4.1.1 If you now check the output of \" module avail \" again, you should see the HDF5/1.12.1 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/11.2.0/OpenMPI/4.1.1 ------- HDF5/1.12.1 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/11.2.0 ------------ OpenMPI/4.1.1 (L) ... To use HDF5, we need to load this HDF5/1.12.1 module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.12.1 $ h5dump --version h5dump: Version 1.12.1 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree: $ module list Currently Loaded Modules: 1 ) GCCcore/11.2.0 5 ) numactl/2.0.14 9 ) hwloc/2.5.0 13 ) libfabric/1.13.2 17 ) HDF5/1.12.1 2 ) zlib/1.2.11 6 ) XZ/5.2.5 10 ) OpenSSL/1.1 14 ) PMIx/4.1.0 3 ) binutils/2.37 7 ) libxml2/2.9.10 11 ) libevent/2.1.12 15 ) OpenMPI/4.1.1 4 ) GCC/11.2.0 8 ) libpciaccess/0.16 12 ) UCX/1.11.2 16 ) Szip/2.1.1","title":"Loading the HDF5 module"},{"location":"2022-isc22/module_naming_schemes/#exercise","text":"Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2021.10-foss-2021b.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2021.10-foss-2021b.eb -M The output should tell you that 24 out of 64 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2021.10-foss-2021b.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2021.10 Load the gateway modules: module load GCC/11.2.0 OpenMPI/4.1.1 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/11.2.0/OpenMPI/4.1.1 ------ SciPy-bundle/2021.10 module load SciPy-bundle/2021.10 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.3.4 next: EasyBuild at J\u00fclich Supercomputing Centre - (back to overview page)","title":"Exercise"},{"location":"2022-isc22/practical_info/","text":"Practical info for the ISC'22 EasyBuild tutorial \u00b6 This page explains how you can prepare for the EasyBuild tutorial that takes place at ISC'22 (registration required!) . Prepared environment \u00b6 Tutorial attendees will be able to log in to a prepared environment where they can follow along with hands-on examples, or solve the tutorial exercises. You can create an account for the prepared environment by filling out the account form . The accounts will not be approved until the day before the event, so please remember to keep a record of your username and password . Once the account is approved, you will be able to access the system at https://isc22.learnhpc.eu/ , or via ssh : ssh isc22.learnhpc.eu Slack \u00b6 We strongly recommend joining the #tutorial-isc22 channel in the EasyBuild Slack . In this channel, you can: raise questions both during the live tutorial session, and afterwards; get help with following the hands-on examples or solving the exercises; The #tutorial-isc22 channel will remain available after the live tutorial session. You can self-request an invitation to join the EasyBuild Slack via https://easybuild.io/join-slack . next: Introduction - (back to overview page)","title":"Practical info for the ISC'22 EasyBuild tutorial"},{"location":"2022-isc22/practical_info/#practical-info-for-the-isc22-easybuild-tutorial","text":"This page explains how you can prepare for the EasyBuild tutorial that takes place at ISC'22 (registration required!) .","title":"Practical info for the ISC'22 EasyBuild tutorial"},{"location":"2022-isc22/practical_info/#prepared-environment","text":"Tutorial attendees will be able to log in to a prepared environment where they can follow along with hands-on examples, or solve the tutorial exercises. You can create an account for the prepared environment by filling out the account form . The accounts will not be approved until the day before the event, so please remember to keep a record of your username and password . Once the account is approved, you will be able to access the system at https://isc22.learnhpc.eu/ , or via ssh : ssh isc22.learnhpc.eu","title":"Prepared environment"},{"location":"2022-isc22/practical_info/#slack","text":"We strongly recommend joining the #tutorial-isc22 channel in the EasyBuild Slack . In this channel, you can: raise questions both during the live tutorial session, and afterwards; get help with following the hands-on examples or solving the exercises; The #tutorial-isc22 channel will remain available after the live tutorial session. You can self-request an invitation to join the EasyBuild Slack via https://easybuild.io/join-slack . next: Introduction - (back to overview page)","title":"Slack"},{"location":"2022-isc22/terminology/","text":"EasyBuild terminology \u00b6 Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software on HPC systems. It is important to be familiar with these terms, so we will briefly cover them one by one. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.toolchains , easybuild.tools , etc.) that collectively form the core of EasyBuild , and is developed in the easybuild-framework repository on GitHub . It implements the common functionality that you need when building software from source , and provides functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this. Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure , and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software package. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , WRF , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file . A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the easybuild-easyblocks repository on GitHub . Easyconfig parameters \u00b6 An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild. Some easyconfig parameters are mandatory . The following parameters must be defined in every easyconfig file: name and version , which specify the name and version of the software to install; homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains section); Other easyconfig parameters are optional : they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock. Some commonly used optional easyconfig parameters include: easyblock , which specifies the (generic) easyblock that EasyBuild should use for the installation; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If no value is specified for an optional easyconfig parameter, the corresponding default value will be used. There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software. Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation. The filename of an easyconfig file usually ends with the .eb extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: name , version , toolchain and versionsuffix . The general format for the filename of an easyconfig file is: <name>-<version><toolchain><versionsuffix>.eb , where the toolchain part is omitted when the system toolchain is used, and the <versionsuffix> can be empty. The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive. In the easybuild-easyconfigs repository on GitHub , the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software. Easystack files \u00b6 Easystack files are a relatively new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild. They are written in YAML syntax , and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels. The support for using easystack files is currently marked as experimental , which means it is subject to change in future EasyBuild releases, and may be prone to errors. Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Common examples are Python packages , R libraries , and Perl modules . As you can tell the common terminology here is a bit messy, so we came up with extensions as a unifying term. Extensions can be installed in different ways: stand-alone , as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into an installation of Python); Dependencies \u00b6 A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of software dependencies: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software (examples: CMake , pkg-config ); a run-time dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package (example: Python ); a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed (example: OpenBLAS ); The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). System toolchain \u00b6 The system toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system , rather than using toolchain components that were installed using EasyBuild. It is used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation. Common toolchains \u00b6 The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , FlexiBLAS with OpenBLAS as default backend, ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation . Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading an environment module will restore the shell environment to its previous state, by reverting the changes that were made to the environment when it was loaded. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files which each define a set of easyconfig parameters . EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. An easystack file can be used to specify a collection of software to install with EasyBuild. next: Installing EasyBuild - (back to overview page)","title":"EasyBuild terminology"},{"location":"2022-isc22/terminology/#easybuild-terminology","text":"Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software on HPC systems. It is important to be familiar with these terms, so we will briefly cover them one by one.","title":"EasyBuild terminology"},{"location":"2022-isc22/terminology/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.toolchains , easybuild.tools , etc.) that collectively form the core of EasyBuild , and is developed in the easybuild-framework repository on GitHub . It implements the common functionality that you need when building software from source , and provides functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this.","title":"Framework"},{"location":"2022-isc22/terminology/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure , and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software package. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , WRF , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file . A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the easybuild-easyblocks repository on GitHub .","title":"Easyblocks"},{"location":"2022-isc22/terminology/#easyconfig-parameters","text":"An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild. Some easyconfig parameters are mandatory . The following parameters must be defined in every easyconfig file: name and version , which specify the name and version of the software to install; homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains section); Other easyconfig parameters are optional : they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock. Some commonly used optional easyconfig parameters include: easyblock , which specifies the (generic) easyblock that EasyBuild should use for the installation; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If no value is specified for an optional easyconfig parameter, the corresponding default value will be used. There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software.","title":"Easyconfig parameters"},{"location":"2022-isc22/terminology/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation. The filename of an easyconfig file usually ends with the .eb extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: name , version , toolchain and versionsuffix . The general format for the filename of an easyconfig file is: <name>-<version><toolchain><versionsuffix>.eb , where the toolchain part is omitted when the system toolchain is used, and the <versionsuffix> can be empty. The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive. In the easybuild-easyconfigs repository on GitHub , the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software.","title":"Easyconfig files"},{"location":"2022-isc22/terminology/#easystack-files","text":"Easystack files are a relatively new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild. They are written in YAML syntax , and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels. The support for using easystack files is currently marked as experimental , which means it is subject to change in future EasyBuild releases, and may be prone to errors.","title":"Easystack files"},{"location":"2022-isc22/terminology/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Common examples are Python packages , R libraries , and Perl modules . As you can tell the common terminology here is a bit messy, so we came up with extensions as a unifying term. Extensions can be installed in different ways: stand-alone , as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into an installation of Python);","title":"Extensions"},{"location":"2022-isc22/terminology/#dependencies","text":"A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of software dependencies: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software (examples: CMake , pkg-config ); a run-time dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package (example: Python ); a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed (example: OpenBLAS ); The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies.","title":"Dependencies"},{"location":"2022-isc22/terminology/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"2022-isc22/terminology/#system-toolchain","text":"The system toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system , rather than using toolchain components that were installed using EasyBuild. It is used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.","title":"System toolchain"},{"location":"2022-isc22/terminology/#common-toolchains","text":"The foss and intel toolchains are also known as the common toolchains , because they are widely adopted by the EasyBuild community. The foss toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free & Open Source Software): GCC , Open MPI , FlexiBLAS with OpenBLAS as default backend, ScaLAPACK and FFTW . The intel toolchain consists of the Intel C, C++ and Fortran compilers (on top of a GCC version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries. Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing. More information on these toolchains is available in the EasyBuild documentation .","title":"Common toolchains"},{"location":"2022-isc22/terminology/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading an environment module will restore the shell environment to its previous state, by reverting the changes that were made to the environment when it was loaded. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"2022-isc22/terminology/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files which each define a set of easyconfig parameters . EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. An easystack file can be used to specify a collection of software to install with EasyBuild. next: Installing EasyBuild - (back to overview page)","title":"Bringing it all together"},{"location":"2022-isc22/troubleshooting/","text":"Troubleshooting \u00b6 When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild... In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention! EasyBuild error messages \u00b6 When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status of the shell command is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted. Example \u00b6 Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb example.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-11.2.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-44 ) Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a imaginary example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled. EasyBuild log files \u00b6 Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes (only) the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by both the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210616.055237.log Last log \u00b6 The eb command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor: vim $(eb --last-log) Navigating log files \u00b6 Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you will miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there. Inspecting the build directory \u00b6 When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-11.2.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out build directories for failed builds, you will need to eventually manually remove them from the buildpath directory. Exercise \u00b6 Let's work our way through a less smooth software installation, using the easyconfig file that is provided below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.3' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.5.0' } # download from https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ '56cef3a2f914d432713069d5c282f48831c3a1ecc89432ad5580caa322a5f56b' ] start_dir = 'src' # -fcommon is required to compile Subread 2.0.3 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the text above in a file named subread.eb , so you can gradually fix the problem you'll encounter. Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Note: If you run eb --dry-run-short ... you might first run into T.2 instead of T.1. Remember though: no peeking before you tried to solve each step yourself! Exercise T.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.3-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.3/GCC-8.5.0): build failed (first 300 chars): Couldn't find file subread-2.0.3-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz mv subread-2.0.3-source.tar.gz $HOME/easybuild/sources/s/Subread/ If downloading is problematic for some reason, the source tarball is also available in /easybuild/sources/s/Subread . Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate download URLs, without the filename of the source file itself. This way, EasyBuild will download the source file when running eb subread.eb . The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Mai 19 15 :21 subread-2.0.3-source.tar.gz Exercise T.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-8.5.0): build failed (first 300 chars): No module found for toolchain: GCC/8.5.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 11.2.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/11.2.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } Exercise T.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-11.2.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.3\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -fcommon -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via the CFLAGS argument to the build command: # -fcommon is required to compile Subread 2.0.3 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the buildopts definition makes it clear that the -fcommon flag is required though, because GCC 10 became a bit stricter by using -fno-common by default. Note that we are using -fcommon as an escape mechanism here: it would be better to fix the source code and create a patch file instead. An easy way to fix this problem is to replace the -fast with -Ofast , as the compiler error suggests. In this case it is advised to change the CFLAGS argument that is added to be build command to replace the -fast with $CFLAGS , which is defined in the build environment by EasyBuild. buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"' Note that we need to be careful with quotes here: we use inner double quotes to ensure that $CFLAGS will be expanded to its value when the build command is run. Exercise T.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-11.2.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.3 with the GCC 11.2.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.3 next: Module naming schemes - (back to overview page)","title":"Troubleshooting"},{"location":"2022-isc22/troubleshooting/#troubleshooting","text":"When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild... In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!","title":"Troubleshooting"},{"location":"2022-isc22/troubleshooting/#easybuild-error-messages","text":"When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status of the shell command is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted.","title":"EasyBuild error messages"},{"location":"2022-isc22/troubleshooting/#example","text":"Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb example.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-11.2.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-44 ) Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a imaginary example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.","title":"Example"},{"location":"2022-isc22/troubleshooting/#easybuild-log-files","text":"Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes (only) the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by both the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210616.055237.log","title":"EasyBuild log files"},{"location":"2022-isc22/troubleshooting/#last-log","text":"The eb command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor: vim $(eb --last-log)","title":"Last log"},{"location":"2022-isc22/troubleshooting/#navigating-log-files","text":"Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you will miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there.","title":"Navigating log files"},{"location":"2022-isc22/troubleshooting/#inspecting-the-build-directory","text":"When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-11.2.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out build directories for failed builds, you will need to eventually manually remove them from the buildpath directory.","title":"Inspecting the build directory"},{"location":"2022-isc22/troubleshooting/#exercise","text":"Let's work our way through a less smooth software installation, using the easyconfig file that is provided below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.3' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.5.0' } # download from https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ '56cef3a2f914d432713069d5c282f48831c3a1ecc89432ad5580caa322a5f56b' ] start_dir = 'src' # -fcommon is required to compile Subread 2.0.3 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the text above in a file named subread.eb , so you can gradually fix the problem you'll encounter. Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Note: If you run eb --dry-run-short ... you might first run into T.2 instead of T.1. Remember though: no peeking before you tried to solve each step yourself! Exercise T.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.3-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.3/GCC-8.5.0): build failed (first 300 chars): Couldn't find file subread-2.0.3-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz mv subread-2.0.3-source.tar.gz $HOME/easybuild/sources/s/Subread/ If downloading is problematic for some reason, the source tarball is also available in /easybuild/sources/s/Subread . Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate download URLs, without the filename of the source file itself. This way, EasyBuild will download the source file when running eb subread.eb . The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Mai 19 15 :21 subread-2.0.3-source.tar.gz Exercise T.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-8.5.0): build failed (first 300 chars): No module found for toolchain: GCC/8.5.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 11.2.0: $ module avail GCC/ ----------------- /easybuild/modules/all ------------------ GCC/11.2.0 So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '11.2.0' } Exercise T.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-11.2.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.3\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -fcommon -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via the CFLAGS argument to the build command: # -fcommon is required to compile Subread 2.0.3 with GCC 10, # which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html) buildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"' EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the buildopts definition makes it clear that the -fcommon flag is required though, because GCC 10 became a bit stricter by using -fno-common by default. Note that we are using -fcommon as an escape mechanism here: it would be better to fix the source code and create a patch file instead. An easy way to fix this problem is to replace the -fast with -Ofast , as the compiler error suggests. In this case it is advised to change the CFLAGS argument that is added to be build command to replace the -fast with $CFLAGS , which is defined in the build environment by EasyBuild. buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"' Note that we need to be careful with quotes here: we use inner double quotes to ensure that $CFLAGS will be expanded to its value when the build command is run. Exercise T.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-11.2.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.3 with the GCC 11.2.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.3 next: Module naming schemes - (back to overview page)","title":"Exercise"}]}