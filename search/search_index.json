{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warning (Apr 19th 2020) This is very much a work in progress! Many pages are still empty, that will hopefully change soon... Welcome to the official EasyBuild tutorial! \u00b6 Scope \u00b6 This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way. Intended audience \u00b6 This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems Prerequisites \u00b6 We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source Required software: OS: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here Practical information \u00b6 For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises; use the prepared container image through Docker or Singularity; Please see this page for more details. Tutorial contents \u00b6 Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild Community Contributing to EasyBuild (*) Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises) Contributors \u00b6 Maxime Boissonneault ( @mboisson , Compute Canada ) Miguel Dias Costa ( @migueldiascosta , National University of Singapore ) Markus Geimer ( @geimer , J\u00fclich Supercomputing Centre, Germany ) Kenneth Hoste ( @boegel , HPC-UGent, Belgium ) Michael Kelsey ( @kelseymh , Texas A&M University, US ) Christian Kniep ( @ChristianKniep , AWS ) Terje Kvernes ( @terjekv , University of Oslo, Norway ) Alan O'Cais ( @ocaisa , J\u00fclich Supercomputing Centre, Germany ) \u00c5ke Sandgren ( @akesandgren , Ume\u00e5 University, Sweden ) Additional resources \u00b6 website: https://easybuilders.github.io/easybuild documentation: https://easybuild.readthedocs.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite here ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":"Home"},{"location":"#welcome-to-the-official-easybuild-tutorial","text":"","title":"Welcome to the official EasyBuild tutorial!"},{"location":"#scope","text":"This is an introductory tutorial to EasyBuild , a command line tool for installing (scientific) software on High Performance Computing (HPC) systems. It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks. Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way.","title":"Scope"},{"location":"#intended-audience","text":"This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it. Our main target audience includes: HPC system administrators HPC user support team members scientific researchers using HPC systems","title":"Intended audience"},{"location":"#prerequisites","text":"We expect you to be (a little bit) familiar with: using a Linux command line interface the (absolute) basics of compiling software from source Required software: OS: GNU/Linux (any distribution) Python 2.7 or 3.5+ an environment modules tool (see the module command) we recommend Lmod , a modern environment modules tool implemented in Lua for more information on the environment modules tools supported by EasyBuild, see here","title":"Prerequisites"},{"location":"#practical-information","text":"For the sake of this tutorial, you can: use the #tutorial channel in the EasyBuild Slack for asking questions or getting help; use AWS Cloud9 for the hands-on exercises; use the prepared container image through Docker or Singularity; Please see this page for more details.","title":"Practical information"},{"location":"#tutorial-contents","text":"Introduction to EasyBuild Installation (*) Configuration (*) Basic usage (*) Troubleshooting (*) Hierarchical module naming schemes (*) Adding support for additional software (*) EasyBuild at J\u00fclich Supercomputing Centre EasyBuild at Compute Canada The EasyBuild Community Contributing to EasyBuild (*) Comparison with other tools Getting help (sections indicated with (*) involve hands-on exercises)","title":"Tutorial contents"},{"location":"#contributors","text":"Maxime Boissonneault ( @mboisson , Compute Canada ) Miguel Dias Costa ( @migueldiascosta , National University of Singapore ) Markus Geimer ( @geimer , J\u00fclich Supercomputing Centre, Germany ) Kenneth Hoste ( @boegel , HPC-UGent, Belgium ) Michael Kelsey ( @kelseymh , Texas A&M University, US ) Christian Kniep ( @ChristianKniep , AWS ) Terje Kvernes ( @terjekv , University of Oslo, Norway ) Alan O'Cais ( @ocaisa , J\u00fclich Supercomputing Centre, Germany ) \u00c5ke Sandgren ( @akesandgren , Ume\u00e5 University, Sweden )","title":"Contributors"},{"location":"#additional-resources","text":"website: https://easybuilders.github.io/easybuild documentation: https://easybuild.readthedocs.io GitHub: https://github.com/easybuilders Slack: https://easybuild.slack.com (self-request an invite here ) mailing list: https://lists.ugent.be/wws/subscribe/easybuild","title":"Additional resources"},{"location":"adding_support_software/","text":"Adding support for additional software \u00b6 Easyconfigs vs easyblocks \u00b6 Writing easyconfig files \u00b6 1 2 3 4 name = 'example' version = '1.2.3' toolchain = { 'name' : 'foss' , 'version' : '2019b' } graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2] Mandatory parameters \u00b6 Software name & version \u00b6 Homepage and description \u00b6 Toolchain \u00b6 Commonly used parameters \u00b6 Easyblock \u00b6 generic vs software-specific common generic easyblocks Sources \u00b6 Dependencies \u00b6 Command options \u00b6 Sanity check \u00b6 Module class \u00b6 Custom parameters \u00b6 eb -a --easyblock Generating tweaked easyconfigs \u00b6 --try-* Copying easyconfigs \u00b6 --copy-ec Implementing easyblocks \u00b6 (out of scope) Hands-on exercises \u00b6 Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0","title":"Adding support for additional software"},{"location":"adding_support_software/#adding-support-for-additional-software","text":"","title":"Adding support for additional software"},{"location":"adding_support_software/#easyconfigs-vs-easyblocks","text":"","title":"Easyconfigs vs easyblocks"},{"location":"adding_support_software/#writing-easyconfig-files","text":"1 2 3 4 name = 'example' version = '1.2.3' toolchain = { 'name' : 'foss' , 'version' : '2019b' } graph TD A[Hard] -->|Text| B(Round) B --> C{Decision} C -->|One| D[Result 1] C -->|Two| E[Result 2]","title":"Writing easyconfig files"},{"location":"adding_support_software/#mandatory-parameters","text":"","title":"Mandatory parameters"},{"location":"adding_support_software/#software-name-version","text":"","title":"Software name &amp; version"},{"location":"adding_support_software/#homepage-and-description","text":"","title":"Homepage and description"},{"location":"adding_support_software/#toolchain","text":"","title":"Toolchain"},{"location":"adding_support_software/#commonly-used-parameters","text":"","title":"Commonly used parameters"},{"location":"adding_support_software/#easyblock","text":"generic vs software-specific common generic easyblocks","title":"Easyblock"},{"location":"adding_support_software/#sources","text":"","title":"Sources"},{"location":"adding_support_software/#dependencies","text":"","title":"Dependencies"},{"location":"adding_support_software/#command-options","text":"","title":"Command options"},{"location":"adding_support_software/#sanity-check","text":"","title":"Sanity check"},{"location":"adding_support_software/#module-class","text":"","title":"Module class"},{"location":"adding_support_software/#custom-parameters","text":"eb -a --easyblock","title":"Custom parameters"},{"location":"adding_support_software/#generating-tweaked-easyconfigs","text":"--try-*","title":"Generating tweaked easyconfigs"},{"location":"adding_support_software/#copying-easyconfigs","text":"--copy-ec","title":"Copying easyconfigs"},{"location":"adding_support_software/#implementing-easyblocks","text":"(out of scope)","title":"Implementing easyblocks"},{"location":"adding_support_software/#hands-on-exercises","text":"Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for TensorFlow 2.2.0. (click to show solution) eb --search TensorFlow-2.2.0","title":"Hands-on exercises"},{"location":"adding_support_software/slides/","text":"Adding support for additional software \u00b6 A.k.a. writing your own easyconfig files.","title":"Slides"},{"location":"adding_support_software/slides/#adding-support-for-additional-software","text":"A.k.a. writing your own easyconfig files.","title":"Adding support for additional software"},{"location":"basic_usage/","text":"Basic usage \u00b6 Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention! Workflow \u00b6 Installing software with EasyBuild is as easy (hah!) as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , usually in combination with the --robot option to enable dependency resolution. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration option are what you would expect, for example. Specifying easyconfigs \u00b6 Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here ). Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with ' .eb ', and (try to) use these as easyconfig files. Example command \u00b6 Suppose we have the current situation in our home directory: two (easyconfig) files named example1 and example2 ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1 example2 some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb bzip2-1.0.6.eb example1 $HOME /example2 deps EasyBuild will interpret each of these arguments as follows: bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); example1 is the name of a file in the current directory, so it can be used directly; likewise, $HOME/example2 specifies the path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , ignoring the list.txt file since its name does not end with ' .eb '; Easyconfig filenames \u00b6 Note that the eb command does not care how easyconfig files are named, at least to some extent: the ' .eb ' file extension does matter w.r.t. easyconfig files being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ); this part (including the preceding - ) is omitted when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default); Searching for easyconfigs \u00b6 You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package, which you can do by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the search-paths configuration setting, or you can change the robot search path via either the --robot or --robot-paths option. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for TensorFlow 2.2.0: $ eb --search tensorflow-2.2.0 * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb This output is a bit more condensed when using eb -S : $ eb -S tensorflow-2.2.0 CFGS1=/home/example/.local/easybuild/easyconfigs/t/TensorFlow * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install OpenFOAM with the foss/2019b toolchain: $ eb -S 'openfoam-[0-9].*foss-2019b' CFGS1=/home/example/.local/easybuild/easyconfigs/o/OpenFOAM * $CFGS1/OpenFOAM-6-foss-2019b.eb * $CFGS1/OpenFOAM-7-foss-2019b.eb Search index \u00b6 When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information . Inspecting easyconfigs \u00b6 Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later, in the part where we discuss writing easyconfig files . Checking dependencies \u00b6 Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". When using the prepared container image , run this command to make the already installed software stack available: module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ). Dry run \u00b6 To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the dependencies that are required for SAMtools-1.10-GCC-9.3.0.eb are already installed: $ eb SAMtools-1.10-GCC-9.3.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/.local/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb ( module: bzip2/1.0.8-GCCcore-9.3.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb ( module: XZ/5.2.5-GCCcore-9.3.0 ) * [ x ] $CFGS /c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb ( module: cURL/7.69.1-GCCcore-9.3.0 ) * [ x ] $CFGS /g/GCC/GCC-9.3.0.eb ( module: GCC/9.3.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb ( module: ncurses/6.2-GCCcore-9.3.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb ( module: SAMtools/1.10-GCC-9.3.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.10-GCC-9.3.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an ' x ' in [ ] . Missing dependencies \u00b6 If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get h5py version 2.10.0 using the 2020a version of the foss toolchain installed: $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) That should be pretty self-explanatory: out of the 54 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great! Inspecting install procedures \u00b6 Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.72.0-gompi-2020a.eb : $ eb Boost-1.72.0-gompi-2020a.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load gompi/2020a Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-9.3.0 module load zlib/1.2.11-GCCcore-9.3.0 module load XZ/5.2.5-GCCcore-9.3.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\" ( in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0 ) file written: user-config.jam ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_mpi.so * lib/libboost_system.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step and in which directory, and that a file named user-config.jam will be created as well; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless. Installing software \u00b6 You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.10: $ eb SAMtools-1.10-GCC-9.3.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb == building and installing SAMtools/1.10-GCC-9.3.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 11 sec ) == Results of the build can be found in the log file ( s ) /tmp/example/isc20/easybuild/software/SAMtools/1.10-GCC-9.3.0/easybuild/easybuild-SAMtools-1.10-20200610.195601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost... Enabling dependency resolution \u00b6 The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above ). If we try this with the Bowtie2-2.4.1-GCC-9.3.0.eb , for which the required tbb dependency is not available yet, it's less successful: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb -M 2 out of 17 required modules missing: * tbb/2020.1-GCCcore-9.3.0 ( tbb-2020.1-GCCcore-9.3.0.eb ) * Bowtie2/2.4.1-GCC-9.3.0 ( Bowtie2-2.4.1-GCC-9.3.0.eb ) $ eb Bowtie2-2.4.1-GCC-9.3.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : tbb/2020.1-GCCcore-9.3.0 ( took 1 min 57 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-x5ik_8b5/easybuild-Bowtie2-2.4.1-20200610.200056.qfgfI.log ERROR: Build of /home/example/.local/easybuild/easyconfigs/b/Bowtie2/Bowtie2-2.4.1-GCC-9.3.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0 The required dependency tbb/2020.1-GCCcore-9.3.0 is not installed yet, and EasyBuild does not automatically install missing dependencies unless it is configured to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --robot ... == resolving dependencies ... ... == building and installing tbb/2020.1-GCCcore-9.3.0... ... == COMPLETED: Installation ended successfully ( took 1 min 4 sec ) ... == building and installing Bowtie2/2.4.1-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 6 min 39 sec ) ... == Build succeeded for 2 out of 2 With dependency resolution enabled the tbb/2020.1-GCCcore-9.3.0 module gets installed first, before EasyBuild proceeds with installing Bowtie2. Great! Trace output \u00b6 As you may have noticed if you tried the previous example hands-on, the installation of Bowtie2 takes a while. The installation was spending quite a bit of time during the build step, but what was actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of Bowtie2-2.4.1-GCC-9.3.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --rebuild ... == building... >> running command: [ started at: 2020 -06-10 20 :22:13 ] [ working dir: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0/bowtie2-2.4.1 ] [ output logged in /tmp/eb-jx1khbgf/easybuild-run_cmd-frodru6e.log ] make -j 4 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" >> command completed: exit 0 , ran in 00h01m03s That's a bit more comforting to stare at... During the build step the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 4), and passes several options to ensure the right compiler commands and compiler options are used. We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 1 min 3 sec to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bowtie2' found: OK >> file 'bin/bowtie2-build' found: OK >> file 'bin/bowtie2-inspect' found: OK ... >> (non-empty) directory 'doc' found: OK >> (non-empty) directory 'example' found: OK >> (non-empty) directory 'scripts' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary. Using installed software \u00b6 So far, we have already installed 3 different software packages (SAMtools, tbb, and Bowtie2); we even installed Bowtie2 twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, created and populating the installation directory, performing a quick sanity check on the installation, cleaning things up and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio lib The bio and lib directories correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ------------ /home/example/easybuild/modules/all ------------ Bowtie2/2.4.1-GCC-9.3.0 tbb/2020.1-GCCcore-9.3.0 SAMtools/1.10-GCC-9.3.0 ------------------- /easybuild/modules/all ------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for Bowtie2. In our current environment, the bowtie2 command is not available yet: $ module list No modules loaded $ bowtie2 bash: bowtie2: command not found Loading the module for Bowtie2 changes that: $ module load Bowtie2/2.4.1-GCC-9.3.0 $ module list Currently Loaded Modules: 1 ) GCCcore/9.3.0 2 ) zlib/1.2.11-GCCcore-9.3.0 3 ) binutils/2.34-GCCcore-9.3.0 4 ) GCC/9.3.0 5 ) tbb/2020.1-GCCcore-9.3.0 6 ) Bowtie2/2.4.1-GCC-9.3.0 $ bowtie2 --version /home/example/easybuild/software/Bowtie2/2.4.1-GCC-9.3.0/bin/bowtie2-align-s version 2 .4.1 64 -bit Built on Wed Jun 10 20 :33:29 UTC 2020 Compiler: gcc version 9 .3.0 ( GCC ) Options: -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -DPOPCNT_CAPABILITY -DWITH_TBB -std = c++11 -DNO_SPINLOCK -DWITH_QUEUELOCK = 1 Sizeof { int, long, long long, void*, size_t, off_t } : { 4 , 8 , 8 , 8 , 8 , 8 } Bowtie 2 version 2 .4.1 Usage: bowtie2 [ options ] * -x <bt2-idx> { -1 <m1> -2 <m2> | -U <r> | --interleaved <i> | -b <bam> } [ -S <sam> ] Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use. Resetting your environment \u00b6 To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \". Stacking software \u00b6 Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed, as long as the module file that provides access to it is available it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here). Hands-on exercises \u00b6 Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. Exercise 4.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. For the easybuilders/tutorial container image , we have installed a small software stack with the 2020a version of the foss toolchain in /easybuild/ . Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2019.4. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2019.4 CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2019.4-foss-2019b.eb Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc version 3.12.4 with the 2020a version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for PETSc version 3.12.4: $ eb -S 'PETSc-3.12.4.*foss-2020a' CFGS1 = /home/example/.local/easybuild/easyconfigs/p/PETSc * $CFGS1 /PETSc-3.12.4-foss-2020a-Python-3.8.2.e To determine which dependencies are missing to install this PETSc easyconfig file, we can use --missing : $ eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing 7 out of 57 required modules missing: * METIS/5.1.0-GCCcore-9.3.0 ( METIS-5.1.0-GCCcore-9.3.0.eb ) * Boost/1.72.0-gompi-2020a ( Boost-1.72.0-gompi-2020a.eb ) * SCOTCH/6.0.9-gompi-2020a ( SCOTCH-6.0.9-gompi-2020a.eb ) * MUMPS/5.2.1-foss-2020a-metis ( MUMPS-5.2.1-foss-2020a-metis.eb ) * SuiteSparse/5.7.1-foss-2020a-METIS-5.1.0 ( SuiteSparse-5.7.1-foss-2020a-METIS-5.1.0.eb ) * Hypre/2.18.2-foss-2020a ( Hypre-2.18.2-foss-2020a.eb ) * PETSc/3.12.4-foss-2020a-Python-3.8.2 ( PETSc-3.12.4-foss-2020a-Python-3.8.2.eb ) eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Figure out which command EasyBuild would use to perform the actual installation of the software provided by the GSL-2.6-GCC-9.3.0.eb easyconfig file, without actually installing GSL . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x GSL-2.6-GCC-9.3.0.eb . The output for the install step shows the actual installation command ( make install ): [ make_installdir method ] directory /home/example/easybuild/software/GSL/2.6-GCC-9.3.0 removed [ install_step method ] >> running command: [ started at: 2020 -06-10 21 :38:14 ] [ working dir: /tmp/eb-u3gkcgvv/__ROOT__/tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ] mp/eb-u3gkcgvv/easybuild-run_cmd-7cl9s7xi.log ] e install running command \"make install\" ( in /tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ) The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/gsl-config * bin/gsl-histogram * bin/gsl-randist Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies on top of Python 3.8.2, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py.*Python-3.8.2' CFGS1 = /home/example/.local/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-2.10.0-foss-2020a-Python-3.8.2.eb Make sure the pre-install software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install h5py : $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2... ... == building and installing h5py/2.10.0-foss-2020a-Python-3.8.2... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/2.10.0/foss-2020a-Python-3.8.2/h5py-2.10.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.2-GCCcore-9.3.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"mytestfile.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/2.10.0-foss-2020a-Python-3.8.2 module load h5py/2.10.0-foss-2020a-Python-3.8.2 The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course yu can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask question in the #tutorial channel in the EasyBuild Slack , we're happy to help!","title":"Basic usage"},{"location":"basic_usage/#basic-usage","text":"Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words. We will look at the high-level workflow first, and then cover each aspect in more detail. A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!","title":"Basic usage"},{"location":"basic_usage/#workflow","text":"Installing software with EasyBuild is as easy (hah!) as specifying to the eb command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer). This is typically done by specifying the name of one or more easyconfig files , usually in combination with the --robot option to enable dependency resolution. It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration option are what you would expect, for example.","title":"Workflow"},{"location":"basic_usage/#specifying-easyconfigs","text":"Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the --software-name option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here ). Arguments passed to the eb command, being anything that is not an option (which starts with - or -- ) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be: the (absolute or relative) path to an easyconfig file; the name of an easyconfig file; the path to a directory containing easyconfig files; Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message: $ eb /tmp/does_not_exist.eb ERROR: Can ' t find path /tmp/does_not_exist.eb When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory . If no file with the specified name is found there EasyBuild will search for the easyconfig file in the robot search path . If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with ' .eb ', and (try to) use these as easyconfig files.","title":"Specifying easyconfigs"},{"location":"basic_usage/#example-command","text":"Suppose we have the current situation in our home directory: two (easyconfig) files named example1 and example2 ; a subdirectory named some_deps , which has two easyconfig files dep1.eb and dep2.eb alongside a text file named list.txt ; a subdirectory named more_deps located in the some_deps subdirectory, which contains another easyconfig file dep3.eb ; Or, visually represented: example1 example2 some_deps/ | -- dep1.eb | -- dep2.eb | -- list.txt | -- more_deps/ | -- dep3.eb In this context, we run the following EasyBuild command from our home directory: eb bzip2-1.0.6.eb example1 $HOME /example2 deps EasyBuild will interpret each of these arguments as follows: bzip2-1.0.6.eb is the name of an easyconfig file to locate via the robot search path (since it does not exist in the current directory); example1 is the name of a file in the current directory, so it can be used directly; likewise, $HOME/example2 specifies the path to an existing file, which can be used directly; some_deps is the relative path to an existing directory, so EasyBuild will scan it and find three easyconfig files: some_deps/dep1.eb , some_deps/dep2.eb and some_deps/more_deps/dep3.eb , ignoring the list.txt file since its name does not end with ' .eb ';","title":"Example command"},{"location":"basic_usage/#easyconfig-filenames","text":"Note that the eb command does not care how easyconfig files are named, at least to some extent: the ' .eb ' file extension does matter w.r.t. easyconfig files being picked up in subdirectories. File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the eb command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here ). This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <name>-<version>-<toolchain><versionsuffix>.eb , where: <name> represents the software name; <version> represents the software version; <toolchain> represents the toolchain used in the easyconfig file, which consists of the toolchain name and version separated with a dash ( - ); this part (including the preceding - ) is omitted when the system toolchain is used; <versionsuffix> represents the value of the versionsuffix easyconfig parameter, which is sometimes used to distinguish multiple variants of particular software installations (and is empty by default);","title":"Easyconfig filenames"},{"location":"basic_usage/#searching-for-easyconfigs","text":"You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package, which you can do by searching for easyconfigs using eb --search or eb -S . By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the search-paths configuration setting, or you can change the robot search path via either the --robot or --robot-paths option. Both the --search and -S options trigger the same search operation, but yield different output: eb --search will print the full path to each easyconfig file that matches the specified search pattern, while eb -S produces a more concise output. For example, let's check which easyconfig files are available for TensorFlow 2.2.0: $ eb --search tensorflow-2.2.0 * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb This output is a bit more condensed when using eb -S : $ eb -S tensorflow-2.2.0 CFGS1=/home/example/.local/easybuild/easyconfigs/t/TensorFlow * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb Note that the search is performed case-insensitive . The search pattern can include wildcards like .* and/or character groups like [0-9] , but you need to be careful that bash does not expand these before the eb command is started, so it is recommended to wrap the search pattern in single quotes ( '...' ) when using wildcards. For example, to check which easyconfigs are available to install OpenFOAM with the foss/2019b toolchain: $ eb -S 'openfoam-[0-9].*foss-2019b' CFGS1=/home/example/.local/easybuild/easyconfigs/o/OpenFOAM * $CFGS1/OpenFOAM-6-foss-2019b.eb * $CFGS1/OpenFOAM-7-foss-2019b.eb","title":"Searching for easyconfigs"},{"location":"basic_usage/#search-index","text":"When searching for easyconfig files, you may see a message like this pop up: == found valid index for <path>, so using it... This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow. For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using eb --create-index <path> . See the EasyBuild documentation for more information .","title":"Search index"},{"location":"basic_usage/#inspecting-easyconfigs","text":"Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it. Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous cat command or your favorite text editor ( vim , what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use eb --show-ec . For example, let's inspect the contents of the bzip2-1.0.6.eb easyconfig file: $ eb --show-ec bzip2-1.0.6.eb == temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log == Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb: name = 'bzip2' version = '1.0.6' homepage = 'https://sourceware.org/bzip2' description = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically compresses files to within 10% to 15% of the best available techniques (the PPM family of statistical compressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\" toolchain = SYSTEM toolchainopts = { 'pic' : True } source_urls = [ 'https://sourceware.org/pub/bzip2/' ] sources = [ SOURCE_TAR_GZ ] patches = [ 'bzip2-%(version)s-pkgconfig.patch' ] checksums = [ 'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd' , # bzip2-1.0.6.tar.gz '5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d' , # bzip2-1.0.6-pkgconfig.patch ] buildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $( BIGFILES ) '\" # building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...) with_shared_libs = OS_TYPE == 'Linux' moduleclass = 'tools' == Temporary log file ( s ) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed. == Temporary directory /tmp/eb-jnpzclhl has been removed. We'll get back to what all of this means later, in the part where we discuss writing easyconfig files .","title":"Inspecting easyconfigs"},{"location":"basic_usage/#checking-dependencies","text":"Note In some of the examples below, we assume that some software is already installed with EasyBuild. If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \" module avail \". When using the prepared container image , run this command to make the already installed software stack available: module use /easybuild/modules/all Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing. This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like $HOME/.local/easybuild , the default installation path ).","title":"Checking dependencies"},{"location":"basic_usage/#dry-run","text":"To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use eb --dry-run . Since --dry-run produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: eb --dry-run-short , which is equivalent with eb -D . For example, to check which of the dependencies that are required for SAMtools-1.10-GCC-9.3.0.eb are already installed: $ eb SAMtools-1.10-GCC-9.3.0.eb -D == temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... Dry run: printing build status of easyconfigs and dependencies CFGS = /home/example/.local/easybuild/easyconfigs ... * [ x ] $CFGS /b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb ( module: bzip2/1.0.8-GCCcore-9.3.0 ) * [ x ] $CFGS /x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb ( module: XZ/5.2.5-GCCcore-9.3.0 ) * [ x ] $CFGS /c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb ( module: cURL/7.69.1-GCCcore-9.3.0 ) * [ x ] $CFGS /g/GCC/GCC-9.3.0.eb ( module: GCC/9.3.0 ) * [ x ] $CFGS /n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb ( module: ncurses/6.2-GCCcore-9.3.0 ) * [ ] $CFGS /s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb ( module: SAMtools/1.10-GCC-9.3.0 ) (We've trimmed the output a bit here, for the sake of brevity.) This output tells us that all dependencies required by SAMtools-1.10-GCC-9.3.0.eb are already installed, since they are all marked with [x] , whereas the easyconfig for SAMtools itself is not installed yet, as indicated by lack of an ' x ' in [ ] .","title":"Dry run"},{"location":"basic_usage/#missing-dependencies","text":"If you are only interested in which dependencies are still missing , you can consult the output of eb --missing , or the equivalent eb -M . For example, let's see which dependencies are missing in order to get h5py version 2.10.0 using the 2020a version of the foss toolchain installed: $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) That should be pretty self-explanatory: out of the 54 required dependencies (which includes the foss toolchain and everything needed to install it), only 2 dependencies are missing. Great!","title":"Missing dependencies"},{"location":"basic_usage/#inspecting-install-procedures","text":"Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software. Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation. Using eb --extended-dry-run , or just eb -x for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild , in a matter of seconds . By means of example, let's inspect some parts of the installation procedure for Boost-1.72.0-gompi-2020a.eb : $ eb Boost-1.72.0-gompi-2020a.eb -x ... preparing... [ DRY RUN ] [ prepare_step method ] Defining build environment, based on toolchain ( options ) and specified dependencies... Loading toolchain module... module load gompi/2020a Loading modules for dependencies... module load bzip2/1.0.8-GCCcore-9.3.0 module load zlib/1.2.11-GCCcore-9.3.0 module load XZ/5.2.5-GCCcore-9.3.0 ... Defining build environment... ... export CXX = 'mpicxx' export CXXFLAGS = '-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC' ... configuring... [ DRY RUN ] [ configure_step method ] running command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\" ( in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0 ) file written: user-config.jam ... [ sanity_check_step method ] Sanity check paths - file [ 'files' ] * lib/libboost_mpi.so * lib/libboost_system.so Sanity check paths - ( non-empty ) directory [ 'dirs' ] * include/boost Sanity check commands ( none ) ... We've obviously trimmed the generated output a bit, but it should be sufficient. An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows: how the build environment will be set up during the prepare step, by loading the module for both the toolchains and the dependencies, and defining a set of environment variables like $CXX , $CXXFLAGS , etc. which command will be executed during the configuration step and in which directory, and that a file named user-config.jam will be created as well; the list of files and directories that will be checked during the sanity check step; If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now. Note It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using eb -x , the reported installation procedure could be partially incorrect. In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by eb -x though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.","title":"Inspecting install procedures"},{"location":"basic_usage/#installing-software","text":"You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require. As mentioned before, installing an easyconfig is as simple as passing it to the eb command. So, let's try to install SAMtools version 1.10: $ eb SAMtools-1.10-GCC-9.3.0.eb == temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log == found valid index for /home/example/.local/easybuild/easyconfigs, so using it... == processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb == building and installing SAMtools/1.10-GCC-9.3.0... == fetching files... == creating build dir, resetting environment... == unpacking... == patching... == preparing... == configuring... == building... == testing... == installing... == taking care of extensions... == restore after iterating... == postprocessing... == sanity checking... == cleaning up... == creating module... == permissions... == packaging... == COMPLETED: Installation ended successfully ( took 11 sec ) == Results of the build can be found in the log file ( s ) /tmp/example/isc20/easybuild/software/SAMtools/1.10-GCC-9.3.0/easybuild/easybuild-SAMtools-1.10-20200610.195601.log == Build succeeded for 1 out of 1 == Temporary log file ( s ) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed. == Temporary directory /tmp/eb-zh7_fyre has been removed. That was... easy. Is that really all there is to it? Well, almost...","title":"Installing software"},{"location":"basic_usage/#enabling-dependency-resolution","text":"The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above ). If we try this with the Bowtie2-2.4.1-GCC-9.3.0.eb , for which the required tbb dependency is not available yet, it's less successful: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb -M 2 out of 17 required modules missing: * tbb/2020.1-GCCcore-9.3.0 ( tbb-2020.1-GCCcore-9.3.0.eb ) * Bowtie2/2.4.1-GCC-9.3.0 ( Bowtie2-2.4.1-GCC-9.3.0.eb ) $ eb Bowtie2-2.4.1-GCC-9.3.0.eb ... == preparing... == FAILED: Installation ended unsuccessfully ( build directory: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0 ) : build failed ( first 300 chars ) : Missing modules for dependencies ( use --robot? ) : tbb/2020.1-GCCcore-9.3.0 ( took 1 min 57 sec ) == Results of the build can be found in the log file ( s ) /tmp/eb-x5ik_8b5/easybuild-Bowtie2-2.4.1-20200610.200056.qfgfI.log ERROR: Build of /home/example/.local/easybuild/easyconfigs/b/Bowtie2/Bowtie2-2.4.1-GCC-9.3.0.eb failed ( err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0' ) Oh my, what's this all about? If we filter the output a bit and focus on the actual error, the problem is clear: Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0 The required dependency tbb/2020.1-GCCcore-9.3.0 is not installed yet, and EasyBuild does not automatically install missing dependencies unless it is configured to do so. It helpfully suggests to use the --robot command line option, so let's try that: $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --robot ... == resolving dependencies ... ... == building and installing tbb/2020.1-GCCcore-9.3.0... ... == COMPLETED: Installation ended successfully ( took 1 min 4 sec ) ... == building and installing Bowtie2/2.4.1-GCC-9.3.0... ... == COMPLETED: Installation ended successfully ( took 6 min 39 sec ) ... == Build succeeded for 2 out of 2 With dependency resolution enabled the tbb/2020.1-GCCcore-9.3.0 module gets installed first, before EasyBuild proceeds with installing Bowtie2. Great!","title":"Enabling dependency resolution"},{"location":"basic_usage/#trace-output","text":"As you may have noticed if you tried the previous example hands-on, the installation of Bowtie2 takes a while. The installation was spending quite a bit of time during the build step, but what was actually going on there? To provide some more feedback as the installation progresses, you can enable the \" trace \" configuration setting. Let's do this by defining the $EASYBUILD_TRACE environment variable, just to avoid having to type --trace over and over again. We will redo the installation of Bowtie2-2.4.1-GCC-9.3.0.eb by passing the --rebuild option to the eb command (try yourself what happens if you don't use the --rebuild option!): $ export EASYBUILD_TRACE = 1 $ eb Bowtie2-2.4.1-GCC-9.3.0.eb --rebuild ... == building... >> running command: [ started at: 2020 -06-10 20 :22:13 ] [ working dir: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0/bowtie2-2.4.1 ] [ output logged in /tmp/eb-jx1khbgf/easybuild-run_cmd-frodru6e.log ] make -j 4 CC = \"gcc\" CPP = \"g++\" CXX = \"g++\" RELEASE_FLAGS = \"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\" >> command completed: exit 0 , ran in 00h01m03s That's a bit more comforting to stare at... During the build step the software is actually being compiled by running the make command. EasyBuild automatically uses the available cores on the system (in this case 4), and passes several options to ensure the right compiler commands and compiler options are used. We even get a pointer to a log file that contains the output of the command being run, so we can use tail -f to see in detail how it progresses. Once the make command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 1 min 3 sec to run. That's good to know. Later during the installation, we now also see this output during the sanity check step: == sanity checking... >> file 'bin/bowtie2' found: OK >> file 'bin/bowtie2-build' found: OK >> file 'bin/bowtie2-inspect' found: OK ... >> (non-empty) directory 'doc' found: OK >> (non-empty) directory 'example' found: OK >> (non-empty) directory 'scripts' found: OK Thanks to enabling trace mode, EasyBuild tells us which files & directories it is checking for in the installation, before declaring it a success. Nice! The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.","title":"Trace output"},{"location":"basic_usage/#using-installed-software","text":"So far, we have already installed 3 different software packages (SAMtools, tbb, and Bowtie2); we even installed Bowtie2 twice! A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, created and populating the installation directory, performing a quick sanity check on the installation, cleaning things up and finally generated the environment module file corresponding to the installation. That's great, but how do we now actually use these installations? This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous module command to digest them. First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of eb --show-config ; the value of the installpath configuration setting is what we are interested in now: $ eb --show-config ... installpath ( E ) = /home/example/easybuild ... repositorypath ( E ) = /home/example/easybuild/ebfiles_repo ... sourcepath ( E ) = /home/example/easybuild/sources ... So, what's in this directory? $ ls -l $HOME /easybuild total 16 drwxrwxr-x 5 example example 4096 Jun 10 20 :11 ebfiles_repo drwxrwxr-x 5 example example 4096 Jun 10 20 :10 modules drwxrwxr-x 6 example example 4096 Jun 10 20 :10 software drwxrwxr-x 6 example example 4096 Jun 10 20 :10 sources The ebfiles_repo and sources directories correspond to the repositorypath and sourcepath configuration settings, respectively. The modules and software directories are what we need now. The modules subdirectory consists of multiple subdirectories: $ ls $HOME /easybuild/modules all bio lib The bio and lib directories correspond to different software categories, and contain symbolic links to the module files in the all directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now. Let's inform the modules tool about the existence of these module files using \"module use\" : module use $HOME /easybuild/modules/all This command does little more that updating the $MODULEPATH environment variable, which contains a list of paths that the modules tool should consider when looking for module files. Now the modules tool should be aware of our brand new installations: $ module avail ------------ /home/example/easybuild/modules/all ------------ Bowtie2/2.4.1-GCC-9.3.0 tbb/2020.1-GCCcore-9.3.0 SAMtools/1.10-GCC-9.3.0 ------------------- /easybuild/modules/all ------------------- ... This output shows both the modules for our own installations as well as the \"central\" installations in /easybuild (which we omitted above for brevity). Now we can load these modules and start using these software installations. Let's test this for Bowtie2. In our current environment, the bowtie2 command is not available yet: $ module list No modules loaded $ bowtie2 bash: bowtie2: command not found Loading the module for Bowtie2 changes that: $ module load Bowtie2/2.4.1-GCC-9.3.0 $ module list Currently Loaded Modules: 1 ) GCCcore/9.3.0 2 ) zlib/1.2.11-GCCcore-9.3.0 3 ) binutils/2.34-GCCcore-9.3.0 4 ) GCC/9.3.0 5 ) tbb/2020.1-GCCcore-9.3.0 6 ) Bowtie2/2.4.1-GCC-9.3.0 $ bowtie2 --version /home/example/easybuild/software/Bowtie2/2.4.1-GCC-9.3.0/bin/bowtie2-align-s version 2 .4.1 64 -bit Built on Wed Jun 10 20 :33:29 UTC 2020 Compiler: gcc version 9 .3.0 ( GCC ) Options: -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -O2 -ftree-vectorize -march = native -fno-math-errno -fPIC -std = gnu++98 -DPOPCNT_CAPABILITY -DWITH_TBB -std = c++11 -DNO_SPINLOCK -DWITH_QUEUELOCK = 1 Sizeof { int, long, long long, void*, size_t, off_t } : { 4 , 8 , 8 , 8 , 8 , 8 } Bowtie 2 version 2 .4.1 Usage: bowtie2 [ options ] * -x <bt2-idx> { -1 <m1> -2 <m2> | -U <r> | --interleaved <i> | -b <bam> } [ -S <sam> ] Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like libstdc++.so ), are loaded automatically. The \" module load \" command changes the active environment, by updating environment variables like $PATH for example, to make the software available for use.","title":"Using installed software"},{"location":"basic_usage/#resetting-your-environment","text":"To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \" module unload \", or you can unload all of them at once using \" module purge \". If you are using an EasyBuild installation provided by a module, don't forget to load the EasyBuild module again after running \" module purge \".","title":"Resetting your environment"},{"location":"basic_usage/#stacking-software","text":"Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in $HOME/easybuild ) on top of installations that are provided in a totally different location ( /easybuild ). EasyBuild doesn't care where software is installed, as long as the module file that provides access to it is available it is happy to pick it up and use it when required. This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).","title":"Stacking software"},{"location":"basic_usage/#hands-on-exercises","text":"Guidelines Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself! Please do not spoil solutions to others before they have been discussed by the tutorial organisers. Exercise 4.0 - Making installed software available Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available. For the easybuilders/tutorial container image , we have installed a small software stack with the 2020a version of the foss toolchain in /easybuild/ . Tip: execute a \" module use \" command, and verify with \" module avail \" that a bunch of software modules are available for loading. (click to show solution) Use the following command to make the modules for the software available that is pre-installed in the prepared environment: module use /easybuild/modules/all If software is installed in a different location than /easybuild/ in your environment, you should adjust the command accordingly. Exercise 4.1 - Searching easyconfigs See if EasyBuild provides any easyconfig files for installing GROMACS version 2019.4. (click to show solution) To check for available easyconfig files, we can use eb --search or eb -S : $ eb -S gromacs-2019.4 CFGS1 = /home/example/.local/easybuild/easyconfigs/g/GROMACS * $CFGS1 /GROMACS-2019.4-foss-2019b.eb Exercise 4.2 - Checking dependencies Check which dependencies are missing to install PETSc version 3.12.4 with the 2020a version of the foss toolchain. (click to show solution) First, we need to determine the name of the easyconfig file for PETSc version 3.12.4: $ eb -S 'PETSc-3.12.4.*foss-2020a' CFGS1 = /home/example/.local/easybuild/easyconfigs/p/PETSc * $CFGS1 /PETSc-3.12.4-foss-2020a-Python-3.8.2.e To determine which dependencies are missing to install this PETSc easyconfig file, we can use --missing : $ eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing 7 out of 57 required modules missing: * METIS/5.1.0-GCCcore-9.3.0 ( METIS-5.1.0-GCCcore-9.3.0.eb ) * Boost/1.72.0-gompi-2020a ( Boost-1.72.0-gompi-2020a.eb ) * SCOTCH/6.0.9-gompi-2020a ( SCOTCH-6.0.9-gompi-2020a.eb ) * MUMPS/5.2.1-foss-2020a-metis ( MUMPS-5.2.1-foss-2020a-metis.eb ) * SuiteSparse/5.7.1-foss-2020a-METIS-5.1.0 ( SuiteSparse-5.7.1-foss-2020a-METIS-5.1.0.eb ) * Hypre/2.18.2-foss-2020a ( Hypre-2.18.2-foss-2020a.eb ) * PETSc/3.12.4-foss-2020a-Python-3.8.2 ( PETSc-3.12.4-foss-2020a-Python-3.8.2.eb ) eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing Exercise 4.3 - Performing a dry run Figure out which command EasyBuild would use to perform the actual installation of the software provided by the GSL-2.6-GCC-9.3.0.eb easyconfig file, without actually installing GSL . Also, which binaries will EasyBuild check for to sanity check the installation? (click to show solution) To inspect the installation procedure, we can use eb -x GSL-2.6-GCC-9.3.0.eb . The output for the install step shows the actual installation command ( make install ): [ make_installdir method ] directory /home/example/easybuild/software/GSL/2.6-GCC-9.3.0 removed [ install_step method ] >> running command: [ started at: 2020 -06-10 21 :38:14 ] [ working dir: /tmp/eb-u3gkcgvv/__ROOT__/tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ] mp/eb-u3gkcgvv/easybuild-run_cmd-7cl9s7xi.log ] e install running command \"make install\" ( in /tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6 ) The output for the sanity check step shows which binaries are expected to be installed: [sanity_check_step method] Sanity check paths - file ['files'] * bin/gsl-config * bin/gsl-histogram * bin/gsl-randist Exercise 4.4 - Installing software Install the h5py Python package and all missing dependencies on top of Python 3.8.2, into /tmp/$USER/easybuild , while leveraging the already installed software available from /easybuild . Enable trace output so you can see which parts of the installation take a while. (click to show solution) First, determine the easyconfig file we can use for this: $ eb -S 'h5py.*Python-3.8.2' CFGS1 = /home/example/.local/easybuild/easyconfigs/h/h5py * $CFGS1 /h5py-2.10.0-foss-2020a-Python-3.8.2.eb Make sure the pre-install software in /easybuild/ is available: module use /easybuild/modules/all Check which dependencies are missing to install h5py : $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing 2 out of 54 required modules missing: * pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 ( pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb ) * h5py/2.10.0-foss-2020a-Python-3.8.2 ( h5py-2.10.0-foss-2020a-Python-3.8.2.eb ) Install h5py by specifying the easyconfig file and enabling dependency resolution via --robot , while indicating that we want to install the software into /tmp/$USER/easybuild using the --installpath option. Also make sure that trace mode is enabled by defining the $EASYBUILD_TRACE environment variable. $ export EASYBUILD_TRACE = 1 $ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/ $USER /easybuild ... == building and installing pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2... ... == building and installing h5py/2.10.0-foss-2020a-Python-3.8.2... ... == building... >> running command: [ started at: 2020 -06-10 21 :47:32 ] [ working dir: /tmp/example/h5py/2.10.0/foss-2020a-Python-3.8.2/h5py-2.10.0 ] [ output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log ] python setup.py configure --mpi --hdf5 = $EBROOTHDF5 && /easybuild/software/Python/3.8.2-GCCcore-9.3.0/bin/python setup.py build >> command completed: exit 0 , ran in 00h01m27s ... == COMPLETED: Installation ended successfully ( took 2 min 46 sec ) ... == Build succeeded for 2 out of 2 The trace output shows that most time is spent in the build command, which runs both python setup.py configure and python setup.py build . Exercise 4.5 - Using installed software Using the h5py installation from the previous exercise to create an empty HDF5 file, using the following Python statements: import h5py f = h5py . File ( \"mytestfile.hdf5\" , \"w\" ) f . close () Check the resulting file using the h5stat command. (click to show solution) First, we need to make the modules tool aware of the module files that were installed into /tmp/$USER/easybuild : module use /tmp/ $USER /easybuild/modules/all Then we can check the h5py module is available, and load it: $ module avail h5py ------------ /tmp/example/easybuild/modules/all ------------ h5py/2.10.0-foss-2020a-Python-3.8.2 module load h5py/2.10.0-foss-2020a-Python-3.8.2 The Python code snippet can be run directly on the command line using \" python -c '...' \", since it's tiny: python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()' Of course yu can also copy the Python code snippet in a file named test_h5py.py , and then run it with python test_h5py.py . Checking with the h5stat command shows that the resulting empty.hdf5 is indeed a valid HDF5 file: $ ls -l empty.hdf5 -rw-rw-r-- 1 example example 800 Jun 10 21 :54 empty.hdf5 $ h5stat empty.hdf5 Filename: empty.hdf5 File information # of unique groups: 1 # of unique datasets: 0 ... If you've made it through the hands-on exercises, congratulations! If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time... Feel free to ask question in the #tutorial channel in the EasyBuild Slack , we're happy to help!","title":"Hands-on exercises"},{"location":"basic_usage/slides/","text":"Basic usage \u00b6 Use the eb command line, Luke.","title":"Slides"},{"location":"basic_usage/slides/#basic-usage","text":"Use the eb command line, Luke.","title":"Basic usage"},{"location":"community/","text":"","title":"The EasyBuild Community"},{"location":"community/slides/","text":"The EasyBuild community \u00b6 Divide & conquer.","title":"Slides"},{"location":"community/slides/#the-easybuild-community","text":"Divide & conquer.","title":"The EasyBuild community"},{"location":"comparison_other_tools/","text":"","title":"Comparison with other tools"},{"location":"comparison_other_tools/slides/","text":"Comparison with other tools: Spark \u00b6 Or Slack?","title":"Slides"},{"location":"comparison_other_tools/slides/#comparison-with-other-tools-spark","text":"Or Slack?","title":"Comparison with other tools: Spark"},{"location":"computecanada/","text":"Compute Canada \u00b6 ( author: Maxime Boissonneault, Compute Canada) General info \u00b6 Compute Canada ( https://www.computecanada.ca ) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US. Staff & user base \u00b6 Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year. Resources \u00b6 Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud. Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs. Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size. B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs. Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, and all identical nodes with nearly 80,000 cores. Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores. Compute Canada software stack \u00b6 Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere. For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here . This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available. Software distribution \u00b6 One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS . This allows any cluster, virtual machine, or event desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here . Some users use it for continuous integration, we also use it in virtual clusters in the cloud. Compatibility layer \u00b6 Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to glibc and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we have used the Nix package manager, but we are now moving toward using Gentoo Prefix instead. Scientific layer and EasyBuild \u00b6 For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2020, we have over 800 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 1,600, 3,200 and 6,000 combinations of builds. Usage of EasyBuild within Compute Canada \u00b6 To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada. Filtering out dependencies \u00b6 Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through yum or apt-get ). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example binutils , Automake , flex , etc. This is configured through our EasyBuild configuration file . Custom toolchains \u00b6 Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the iomkl or gomkl toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common foss and intel toolchains). We therefore make a heavy use of the --try-toolchain option of EasyBuild, to use upstream recipes but with our preferred toolchains. Custom module naming scheme \u00b6 We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops versionsuffix . If we need to have different flavors of a given recipe, we instead use modaltsoftname to add the flavor to the name of the software package. This is enabled through this Python module , which implements our custom module naming scheme. Using RPATH and disabling LD_LIBRARY_PATH \u00b6 Our compatibility layer has a modified linker which ensures that RPATH is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the LD_LIBRARY_PATH from the modules. This is specified in our EasyBuild configuration file . Usage of hooks \u00b6 We make a rather intensive usage of hooks. For example, we use them to inject specific configure options to our OpenMPI builds add compiler and MPI footers to the modules split the installation of the Intel compiler into redistributable and non-redistributable parts strip down the installation of Python to a small set of Python packages Python specific customizations \u00b6 Compute Canada makes heavy usage of the multi_deps feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install PyQt alongside Qt , in the same module. For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments . The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository .","title":"EasyBuild at Compute Canada"},{"location":"computecanada/#compute-canada","text":"( author: Maxime Boissonneault, Compute Canada)","title":"Compute Canada"},{"location":"computecanada/#general-info","text":"Compute Canada ( https://www.computecanada.ca ) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US.","title":"General info"},{"location":"computecanada/#staff-user-base","text":"Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year.","title":"Staff &amp; user base"},{"location":"computecanada/#resources","text":"Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud. Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs. Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size. B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs. Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, and all identical nodes with nearly 80,000 cores. Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores.","title":"Resources"},{"location":"computecanada/#compute-canada-software-stack","text":"Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere. For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here . This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available.","title":"Compute Canada software stack"},{"location":"computecanada/#software-distribution","text":"One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS . This allows any cluster, virtual machine, or event desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here . Some users use it for continuous integration, we also use it in virtual clusters in the cloud.","title":"Software distribution"},{"location":"computecanada/#compatibility-layer","text":"Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to glibc and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we have used the Nix package manager, but we are now moving toward using Gentoo Prefix instead.","title":"Compatibility layer"},{"location":"computecanada/#scientific-layer-and-easybuild","text":"For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2020, we have over 800 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 1,600, 3,200 and 6,000 combinations of builds.","title":"Scientific layer and EasyBuild"},{"location":"computecanada/#usage-of-easybuild-within-compute-canada","text":"To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada.","title":"Usage of EasyBuild within Compute Canada"},{"location":"computecanada/#filtering-out-dependencies","text":"Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through yum or apt-get ). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example binutils , Automake , flex , etc. This is configured through our EasyBuild configuration file .","title":"Filtering out dependencies"},{"location":"computecanada/#custom-toolchains","text":"Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the iomkl or gomkl toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common foss and intel toolchains). We therefore make a heavy use of the --try-toolchain option of EasyBuild, to use upstream recipes but with our preferred toolchains.","title":"Custom toolchains"},{"location":"computecanada/#custom-module-naming-scheme","text":"We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops versionsuffix . If we need to have different flavors of a given recipe, we instead use modaltsoftname to add the flavor to the name of the software package. This is enabled through this Python module , which implements our custom module naming scheme.","title":"Custom module naming scheme"},{"location":"computecanada/#using-rpath-and-disabling-ld_library_path","text":"Our compatibility layer has a modified linker which ensures that RPATH is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the LD_LIBRARY_PATH from the modules. This is specified in our EasyBuild configuration file .","title":"Using RPATH and disabling LD_LIBRARY_PATH"},{"location":"computecanada/#usage-of-hooks","text":"We make a rather intensive usage of hooks. For example, we use them to inject specific configure options to our OpenMPI builds add compiler and MPI footers to the modules split the installation of the Intel compiler into redistributable and non-redistributable parts strip down the installation of Python to a small set of Python packages","title":"Usage of hooks"},{"location":"computecanada/#python-specific-customizations","text":"Compute Canada makes heavy usage of the multi_deps feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install PyQt alongside Qt , in the same module. For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments . The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository .","title":"Python specific customizations"},{"location":"computecanada/slides/","text":"EasyBuild at Compute Canada \u00b6 TODO: Maxime?","title":"Slides"},{"location":"computecanada/slides/#easybuild-at-compute-canada","text":"TODO: Maxime?","title":"EasyBuild at Compute Canada"},{"location":"configuration/","text":"Configuration \u00b6 After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here . Available configuration settings \u00b6 One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details. Overall prefix \u00b6 (default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting. Install path \u00b6 (default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used. Build path \u00b6 (default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is reattempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example. Source path \u00b6 (default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild. Easyconfigs archive \u00b6 (default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting. Modules tool & module syntax \u00b6 (default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax. Robot search path \u00b6 (default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that setting robot also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation . Module naming scheme \u00b6 (default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes . Configuration levels \u00b6 Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception! Configuration level hierarchy \u00b6 There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always * win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead; Configuration files \u00b6 Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing. EasyBuild configuration files vs easyconfig files \u00b6 EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion... $EASYBUILD_* environment variables \u00b6 A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ). eb command line options \u00b6 Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would be less than useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb Inspecting the current configuration ( --show-config ) \u00b6 Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user : # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config : $ export EASYBUILD_PREFIX = $HOME /easybuild $ export EASYBUILD_BUILDPATH = /tmp/ $USER $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( C ) = /tmp/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the robot-paths setting still has the default values, and that all other configuration settings were specified via an environment variable (some of which indirectly through the prefix value). Warning Make sure you have EasyBuild properly configured before you proceed with the rest of the tutorial! We recommend using the following configuration (unless otherwise specified in the examples/exercises): export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER","title":"Configuration"},{"location":"configuration/#configuration","text":"After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences. Note Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here .","title":"Configuration"},{"location":"configuration/#available-configuration-settings","text":"One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings. The full list of configuration settings can be consulted via eb --help , which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild. For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones. Note We will usually refer to configuration settings using the name as it appears in the output of eb --help , which may includes dashes ( - ). The leading ' -- ' is omitted for the sake of clarity. Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.","title":"Available configuration settings"},{"location":"configuration/#overall-prefix","text":"(default: HOME/.local/easybuild ) The prefix configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings : installpath : <prefix> buildpath : <prefix>/build sourcepath : <prefix>/sources repositorypath (easyconfigs archive): <prefix>/ebfiles_repo containerpath : <prefix>/containers Here, <prefix> represents the value of the prefix configuration setting. If one of the configuration settings affected by prefix is defined specifically, the prefix value becomes irrelevant for that specific configuration setting.","title":"Overall prefix"},{"location":"configuration/#install-path","text":"(default: <prefix> ) The location for both the software installation directories and generated module files can be controlled via the installpath configuration setting. Software installation directories will be placed in <installpath>/software , while <installpath>/modules/all will be used for generated module files. The installpath location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations. Separate configuration settings are available for both software and modules locations, as well as for controlling the software and modules/all subdirectories. We recommend to only change the installpath configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default software and modules/all subdirectories are used.","title":"Install path"},{"location":"configuration/#build-path","text":"(default: <prefix>/build ) For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the buildpath configuration setting. Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is reattempted. Running out of disk space in the location where build directories are created will result in failing installations. It is recommended to use a directory on a local filesystem for buildpath , or an in-memory filesystem like /dev/shm (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set buildpath to /tmp/$USER or /dev/shm/$USER , for example.","title":"Build path"},{"location":"configuration/#source-path","text":"(default: <prefix>/sources ) For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path. The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the sourcepath configuration setting. The sourcepath value is a colon ( : ) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed ' Example' , EasyBuild will consider locations like <sourcepath>/e/Example/ , <sourcepath>/Example/ , and so on. The first path listed in sourcepath is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories. Make sure you have write permissions to the first path listed in sourcepath , so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild.","title":"Source path"},{"location":"configuration/#easyconfigs-archive","text":"(default: <prefix>/ebfiles_repo ) EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the repositorypath configuration setting. By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported. More information is available in the EasyBuild documentation . For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the prefix configuration setting.","title":"Easyconfigs archive"},{"location":"configuration/#modules-tool-module-syntax","text":"(default: Lmod as modules tool, Lua as module syntax) By default, EasyBuild assumes you are using Lmod as modules tool . In addition, it will generate module files in Lua syntax, as supported by Lmod. To diverge from this, you can define the modules-tool configuration setting to indicate you are using a different modules tool, see the output of eb --avail-modules-tools for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through $PATH (more information on this in the EasyBuild documentation ). If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the module-syntax configuration setting. Note that this is required if you are using a modules tool other than Lmod. We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax.","title":"Modules tool &amp; module syntax"},{"location":"configuration/#robot-search-path","text":"(default: robot-paths specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled) When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path . This applies to both easyconfig files that were specified using only their filename as an argument to the eb command as well as to easyconfigs required to resolve dependencies (more on that later). To control the robot search path, two configuration settings are available: robot and robot-paths . Both accept a colon-separated list of locations to consider when looking for easyconfig files, with robot overriding robot-paths . The key difference between both is that setting robot also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining robot-paths does not have this side effect. In addition, you can use the --robot command line option without specifying any paths to it to only enable dependency resolution. Note Keep in mind that when either of the robot or robot-paths configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered. There are ways around this however, which are outside of the scope of this tutorial. For more information, see the EasyBuild documentation .","title":"Robot search path"},{"location":"configuration/#module-naming-scheme","text":"(default: EasyBuildMNS ) EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation. Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via eb --avail-module-naming-schemes ). The default EasyBuildMNS module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the versionsuffix easyconfig parameter): <name>/<version><-toolchain><versionsuffix> . Note Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes .","title":"Module naming scheme"},{"location":"configuration/#configuration-levels","text":"Configuring EasyBuild can be done in different ways: through one or more configuration files; via $EASYBUILD_* environment variables; using eb command line options; Each of the methods corresponds to a configuration level . Every configuration setting can be defined via one of these mechanisms, without exception!","title":"Configuration levels"},{"location":"configuration/#configuration-level-hierarchy","text":"There is a strict hierarchy between the different configuration levels supported by EasyBuild. Settings defined via a configuration file only override default values. A configuration setting that is defined via the corresponding $EASYBUILD_* environment variable takes precedence over the value specified in a configuration file (if any). Finally, values specified through eb command line options always * win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable. For example, let us consider a fictional configuration setting named -magic : If a value for magic is specified in an EasyBuild configuration file, then this value will only be used if the corresponding environment variable ( $EASYBUILD_MAGIC ). is not defined and if the ---magic command line option is not used; If the $EASYBUILD_MAGIC environment is defined however, then its value will be used for the this-is-magic configuration setting; Unless the --magic command line option is used, since in that case the value provided as an argument there will be used instead;","title":"Configuration level hierarchy"},{"location":"configuration/#configuration-files","text":"Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of eb --show-default-configfiles tells you which locations are considered, and whether any configuration files were found. EasyBuild configuration files are written in the standard INI format , and the configuration settings are grouped into different sections . To create an EasyBuild configuration file, the output of eb --confighelp is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax. Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.","title":"Configuration files"},{"location":"configuration/#easybuild-configuration-files-vs-easyconfig-files","text":"EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts! EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings , such as the location where software should be installed, or the syntax that should be used when generating module files. An easyconfig file on the other hand specifies the details for one particular software installation . It does this by defining a set of easyconfig parameters , which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc. For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options. Hopefully this helps to avoid the confusion...","title":"EasyBuild configuration files vs easyconfig files"},{"location":"configuration/#easybuild_-environment-variables","text":"A particularly easy way to configure EasyBuild is through environment variables . At startup, EasyBuild will pick up any environment variable of which the name starts with ' EASYBUILD_ '. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found). Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes ( - ) with underscores ( _ ), and prefix with EASYBUILD_ . For example: the module-syntax configuration setting can be specified by defining the $EASYBUILD_MODULE_SYNTAX environment variable: export EASYBUILD_MODULE_SYNTAX = Tcl Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines $EASYBUILD_* environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it. Note Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example $HOME/.bash_profile or $HOME/.bashrc ).","title":"$EASYBUILD_* environment variables"},{"location":"configuration/#eb-command-line-options","text":"Finally, you can also configure EasyBuild by specifying one or options to the eb command. As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option. There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the eb command print the EasyBuild version (via eb --version ); although you could configure EasyBuild to always print its version and then exit whenever the eb command is run, that would be less than useful... Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory: eb --installpath /tmp/ $USER example.eb","title":"eb command line options"},{"location":"configuration/#inspecting-the-current-configuration-show-config","text":"Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured. Therefore, the --show-config command line option is provided to easily inspect the currently active EasyBuild configuration. The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like buildpath , installpath , sourcepath , and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed. This is the output produces by eb --show-config for the default EasyBuild configuration, where EasyBuild was installed via pip install --user : # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( D ) = /home/example/.local/easybuild/build containerpath ( D ) = /home/example/.local/easybuild/containers installpath ( D ) = /home/example/.local/easybuild repositorypath ( D ) = /home/example/.local/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( D ) = /home/example/.local/easybuild/sources As shown here, all configuration settings shown follow the default prefix value ( $HOME/.local/easybuild ) and none of the values diverge from the default value, since all entries are marked with (D) for \"default value\"). Now let us do some basic configuring and inspect the resulting output of --show-config : $ export EASYBUILD_PREFIX = $HOME /easybuild $ export EASYBUILD_BUILDPATH = /tmp/ $USER $ eb --installpath = /tmp/ $USER --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( C ) = /tmp/easybuild packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources The output indicates that the installpath setting was specified through a command line option (indicated with ' (C) '), that the robot-paths setting still has the default values, and that all other configuration settings were specified via an environment variable (some of which indirectly through the prefix value). Warning Make sure you have EasyBuild properly configured before you proceed with the rest of the tutorial! We recommend using the following configuration (unless otherwise specified in the examples/exercises): export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER","title":"Inspecting the current configuration (--show-config)"},{"location":"configuration/slides/","text":"Configuration \u00b6 (coming soon)","title":"Slides"},{"location":"configuration/slides/#configuration","text":"(coming soon)","title":"Configuration"},{"location":"contributing/","text":"Contributing to EasyBuild \u00b6 Github integration features \u00b6 Using easyconfigs from a PR \u00b6 --from-pr Note: we link to this section from the \"Basic usage\" part!","title":"Contributing to EasyBuild"},{"location":"contributing/#contributing-to-easybuild","text":"","title":"Contributing to EasyBuild"},{"location":"contributing/#github-integration-features","text":"","title":"Github integration features"},{"location":"contributing/#using-easyconfigs-from-a-pr","text":"--from-pr Note: we link to this section from the \"Basic usage\" part!","title":"Using easyconfigs from a PR"},{"location":"contributing/slides/","text":"Contributing to EasyBuild \u00b6 You know you want to.","title":"Slides"},{"location":"contributing/slides/#contributing-to-easybuild","text":"You know you want to.","title":"Contributing to EasyBuild"},{"location":"getting_help/","text":"","title":"Getting help"},{"location":"getting_help/slides/","text":"Getting help \u00b6 mailing list GitHub issues Slack","title":"Slides"},{"location":"getting_help/slides/#getting-help","text":"mailing list GitHub issues Slack","title":"Getting help"},{"location":"hmns/","text":"Hierarchical module naming schemes \u00b6 Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing Bowtie2-2.4.1-GCC-9.3.0.eb the generated module was named Bowtie2/2.4.1-GCC-9.3.0 . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild. Flat vs hierarchical \u00b6 The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . As you will notice, at every level we select the module of the layer we are entering. At core level we select our compiler. When in the compiler level we select our MPI implementation, and within the MPI level we select our software. Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These corresponds to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installing using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy. Pros & cons \u00b6 So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users; Length of module names \u00b6 When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what's kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean! Amount of available modules \u00b6 The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can quickly grow into the hundreds or even thousands! Yikes! This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a modest set of modules are available, and relatively small groups of additional modules become available as gateway modules are loaded. Loading compatible modules \u00b6 Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise and you are being very careful... In a module hierarchy this can be prevented, since modules for software that was installed with a different compiler and/or a different MPI library is located in a different part of the module hierarchy, and thus these modules will be prevented from being loaded together. Visibility of existing modules \u00b6 One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file. Semantics of gateway modules \u00b6 An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy. Example \u00b6 Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations. Preparing the environment \u00b6 Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/9.3.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3 Configuring EasyBuild \u00b6 First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example. Generating modules for HDF5 \u00b6 Let us now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.6-gompi-2020a.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.6-gompi-2020a.eb --robot --module-only ... == building and installing MPI/GCC/9.3.0/OpenMPI/4.0.3/HDF5/1.10.6... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 37 out of 37 This should take about 2 minutes in total, for generating 37 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation... Loading the HDF5 module \u00b6 After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let us see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 flex/2.6.4 help2man/1.47.4 Bison/3.5.3 (D) M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 binutils/2.34 gompi/2020a zlib/1.2.11 Nice and short module names, but only a limited set of them. The gateway module here is the GCC/9.3.0 compiler module, so let us load that: module load GCC/9.3.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 -------------- OpenMPI/4.0.3 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/9.3.0 ------------ Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 ... Szip/2.1.1 libpciaccess/0.16 zlib/1.2.11 (L,D) UCX/1.8.0 libreadline/8.0 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.5.3 M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 (L) binutils/2.34 gompi/2020a zlib/1.2.11 Good news! We now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/9.3.0 and Compiler/GCC/9.3.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 9.3.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.3 , which is another gateway module. We can figure this out by asking Lmod whether a module exists for HDF5 using the \" module spider \" command, as suggested in the output of \" module avail HDF5 \": $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.6\" module is available to load. GCC/9.3.0 OpenMPI/4.0.3 This output tells us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/9.3.0 and OpenMPI/4.0.3 modules first. So, let us do exactly that (remember that GCC/9.3.0 is already loaded): module load OpenMPI/4.0.3 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.6 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------- HDF5/1.10.6 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 ------------ OpenMPI/4.0.3 (L) ... To use HDF5, we just need to load this module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.6 $ h5dump --version h5dump: Version 1.10.6 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree. Exercise \u00b6 Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.03-Python-3.8.2 Load the gateway modules: module load GCC/9.3.0 OpenMPI/4.0.3 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------ SciPy-bundle/2020.03-Python-3.8.2 module load SciPy-bundle/2020.03-Python-3.8.2 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.0.3","title":"Hierarchical module naming schemes"},{"location":"hmns/#hierarchical-module-naming-schemes","text":"Up until now we have used EasyBuild's default module naming scheme ( EasyBuildMNS ), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing Bowtie2-2.4.1-GCC-9.3.0.eb the generated module was named Bowtie2/2.4.1-GCC-9.3.0 . EasyBuild supports several different module naming schemes: $ eb --avail-module-naming-schemes List of supported module naming schemes: CategorizedHMNS CategorizedModuleNamingScheme EasyBuildMNS HierarchicalMNS MigrateFromEBToHMNS In this part of the tutorial we will take a closer look at HierarchicalMNS , which is the standard hierarchical module naming scheme included with EasyBuild.","title":"Hierarchical module naming schemes"},{"location":"hmns/#flat-vs-hierarchical","text":"The default module naming scheme EasyBuildMNS is an example of regular \"flat\" module naming scheme, which is characterized by: all module files are directly available for loading; each module name uniquely identifies a particular installation; In contrast, a hierarchical module naming scheme consists of a hierarchy of module files. The typical module hierarchy has 3 levels: a core level, where module files for software that was installed using the system toolchain are kept; a compiler level, where module files for software that was installed using a compiler-only toolchain are stored; and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component; Here is a simple example of such a 3-level module hierarchy: In this example the core level only includes a single module GCC/9.3.0 , while the compiler level includes two modules: OpenMPI/4.0.3 and MPICH/3.3.2 . In the MPI level, three modules are available: one for FFTW , one for ScaLAPACK , and one for HDF5 . As you will notice, at every level we select the module of the layer we are entering. At core level we select our compiler. When in the compiler level we select our MPI implementation, and within the MPI level we select our software. Initially only the modules on the top level of a module hierarchy are available for loading. If you run \" module avail \" with the example module hierarchy, you will only see the GCC/9.3.0 module. Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the GCC/9.3.0 module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for OpenMPI and MPICH . These corresponds to installations of OpenMPI and MPICH that were built using GCC/9.3.0 as a toolchain. Similarly, the OpenMPI/4.0.3 module serves as a gateway to the three modules in the MPI level. Only by loading the OpenMPI module will these additional three modules become available for loading. They correspond to software installations built using the gompi/2020a toolchain that consists of the GCC/9.3.0 compiler module and the OpenMPI/4.0.3 MPI module. Software installing using foss/2020a (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy. The characteristics of a module hierarchy are: not all module files are directly available for loading; some modules serve as a gateway to more modules; to access some software installations you will first need to load one or more gateway modules in order to use them; You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.","title":"Flat vs hierarchical"},{"location":"hmns/#pros-cons","text":"So why go through all this trouble of organizing modules hierarchically? There are a couple of advantages to this approach: shorter module names; less overwhelming list of available modules; only compatible modules can be loaded together; However, the are some minor disadvantages too: not all existing modules are directly visible; gateway modules may have little meaning to end users;","title":"Pros &amp; cons"},{"location":"hmns/#length-of-module-names","text":"When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our HDF5 installation for example, we have HDF5/1.10.6-gompi-2020a as module name. The -gompi-2020a part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what's kind of Pok\u00e9mon is a \"gompi\"?!). In the example module hierarchy shown above, the module for HDF5 is named HDF5/1.10.6 which is basically the bare essentials: software name and version. That's way better, nice and clean!","title":"Length of module names"},{"location":"hmns/#amount-of-available-modules","text":"The output of \" module avail \" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can quickly grow into the hundreds or even thousands! Yikes! This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a modest set of modules are available, and relatively small groups of additional modules become available as gateway modules are loaded.","title":"Amount of available modules"},{"location":"hmns/#loading-compatible-modules","text":"Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other. Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise and you are being very careful... In a module hierarchy this can be prevented, since modules for software that was installed with a different compiler and/or a different MPI library is located in a different part of the module hierarchy, and thus these modules will be prevented from being loaded together.","title":"Loading compatible modules"},{"location":"hmns/#visibility-of-existing-modules","text":"One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \" module avail \" only shows a subset of all modules. Lmod has a solution for this though: it provides a separate \" module spider \" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \" module spider \" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.","title":"Visibility of existing modules"},{"location":"hmns/#semantics-of-gateway-modules","text":"An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline... This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \" module spider \" command to navigate the module hierarchy.","title":"Semantics of gateway modules"},{"location":"hmns/#example","text":"Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree. In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment. The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.","title":"Example"},{"location":"hmns/#preparing-the-environment","text":"Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment. We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme! Some module files will have the same name in both module trees (like GCC/9.3.0 for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems... So we have to make sure that the module files we already have in /easybuild are not visible. The easiest way to do this is to unload all modules (using \" module purge \") and resetting the module search path to be empty, which we can do with \" module unuse $MODULEPATH \". module purge module unuse $MODULEPATH In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue. We strongly recommend using an EasyBuild installation that was installed via \" pip install \" or \" pip3 install \" in this part of the tutorial. An easy way to do this is in the prepared environment is to run: pip3 install --user easybuild export PATH = $HOME /.local/bin: $PATH export EB_PYTHON = python3","title":"Preparing the environment"},{"location":"hmns/#configuring-easybuild","text":"First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables: export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER export EASYBUILD_INSTALLPATH_SOFTWARE = /easybuild/software export EASYBUILD_MODULE_NAMING_SCHEME = HierarchicalMNS export EASYBUILD_INSTALLPATH_MODULES = $HOME /hmns/modules To make sure we didn't make any silly mistakes, we double check using eb --show-config : $ eb --show-config # # Current EasyBuild configuration # (C: command line argument, D: default value, E: environment variable, F: configuration file) # buildpath ( E ) = /tmp/example containerpath ( E ) = /home/example/easybuild/containers installpath ( E ) = /home/example/easybuild installpath-modules ( E ) = /home/example/hmns/modules installpath-software ( E ) = /easybuild/software module-naming-scheme ( E ) = HierarchicalMNS packagepath ( E ) = /home/example/easybuild/packages prefix ( E ) = /home/example/easybuild repositorypath ( E ) = /home/example/easybuild/ebfiles_repo robot-paths ( D ) = /home/example/.local/easybuild/easyconfigs sourcepath ( E ) = /home/example/easybuild/sources There are a couple of things worth pointing out here: We have defined the module-naming-scheme configuration setting to HierarchicalMNS , which makes EasyBuild use the included standard hierarchical module naming scheme (the classic core / compiler / MPI one we discussed above). We have specified different locations for the software (via installpath-software ) and the module files (via installpath-modules ). This is important because we want to reuse the software that is already installed in /easybuild/software while we want to generate an entirely new module tree for it (in $HOME/hmns/modules ). The other configuration settings are the same as before, and mostly irrelevant for this example.","title":"Configuring EasyBuild"},{"location":"hmns/#generating-modules-for-hdf5","text":"Let us now generate a hierarchical module tree for HDF5 and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us. The steps we will have to go through are: Tell EasyBuild we want to \"install\" the HDF5-1.10.6-gompi-2020a.eb easyconfig file; Enable dependency resolution via --robot ; Instruct EasyBuild to only generate the module files, not to install the software (since it is there already in /easybuild/software ), via the --module-only option. These steps translate to this single eb command: $ eb HDF5-1.10.6-gompi-2020a.eb --robot --module-only ... == building and installing MPI/GCC/9.3.0/OpenMPI/4.0.3/HDF5/1.10.6... ... == sanity checking... == cleaning up [skipped] == creating module... ... == COMPLETED: Installation ended successfully (took 9 sec) ... == Build succeeded for 37 out of 37 This should take about 2 minutes in total, for generating 37 modules. Remember that this also includes generating module files for the toolchain and all of its components. In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using --module-only to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...","title":"Generating modules for HDF5"},{"location":"hmns/#loading-the-hdf5-module","text":"After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it? Here's what the module tree looks like on disk: $ ls $HOME/hmns/modules/all Compiler Core MPI Those are basically the 3 levels in the module hierarchy we showed in our example earlier. The starting point is the top level of the module hierarchy named Core : module use $HOME/hmns/modules/all/Core Let us see what that gives us in terms of available modules: $ module avail --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 flex/2.6.4 help2man/1.47.4 Bison/3.5.3 (D) M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 binutils/2.34 gompi/2020a zlib/1.2.11 Nice and short module names, but only a limited set of them. The gateway module here is the GCC/9.3.0 compiler module, so let us load that: module load GCC/9.3.0 And then check again which modules are available: $ module avail -------------- /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 -------------- OpenMPI/4.0.3 ------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/9.3.0 ------------ Autoconf/2.69 XZ/5.2.5 libtool/2.4.6 ... Szip/2.1.1 libpciaccess/0.16 zlib/1.2.11 (L,D) UCX/1.8.0 libreadline/8.0 --------------------- /home/easybuild/hmns/modules/all/Core --------------------- Bison/3.3.2 GCCcore/9.3.0 (L) flex/2.6.4 help2man/1.47.4 Bison/3.5.3 M4/1.4.18 gettext/0.20.1 ncurses/6.1 GCC/9.3.0 (L) binutils/2.34 gompi/2020a zlib/1.2.11 Good news! We now have additional modules available! The compiler level of our hierarchy actually consists of two directories here: Compiler/GCCcore/9.3.0 and Compiler/GCC/9.3.0 . The modules in the GCCcore directory are ones we can use in other compiler toolchains that use GCC 9.3.0 as a base compiler (the details of that are out of scope here). The module we are interested in is OpenMPI/4.0.3 , which is another gateway module. We can figure this out by asking Lmod whether a module exists for HDF5 using the \" module spider \" command, as suggested in the output of \" module avail HDF5 \": $ module avail HDF5 No module(s) or extension(s) found! Use \"module spider\" to find all possible modules and extensions. $ module spider HDF5 ... You will need to load all module(s) on any one of the lines below before the \"HDF5/1.10.6\" module is available to load. GCC/9.3.0 OpenMPI/4.0.3 This output tells us that there does indeed exist a module for HDF5 , but that we need to load both the GCC/9.3.0 and OpenMPI/4.0.3 modules first. So, let us do exactly that (remember that GCC/9.3.0 is already loaded): module load OpenMPI/4.0.3 If you now check the output of \" module avail \" again, you should see the HDF5/1.10.6 module: $ module avail -------- /home/easybuild/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------- HDF5/1.10.6 ------------ /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 ------------ OpenMPI/4.0.3 (L) ... To use HDF5, we just need to load this module. We can verify that the installation works using one of the commands provided by HDF5, h5dump for example: module load HDF5/1.10.6 $ h5dump --version h5dump: Version 1.10.6 If you now check which modules are loaded via \" module list \", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree.","title":"Loading the HDF5 module"},{"location":"hmns/#exercise","text":"Now it is your turn! Try to get a feeling for how a hierarchical module tree works by: installing the missing modules for the SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb in the module hierarchy we generated for HDF5; figure out where the SciPy-bundle module is located in the hierarchy, and then also load it; You can verify your work by running this command (since pandas is one of the Python packages included in the SciPy-bundle installation): python -c 'import pandas; print(pandas.__version__)' Start from a clean slate, by first running: module purge module unuse $MODULEPATH (click to show solution) Step 0: check which modules are still missing, using --missing or -M : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb -M The output should tell you that 15 out of 50 required modules are still missing. Install the missing modules in the module hierarchy we have generated in $HOME/hmns/modules : eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb --robot --module-only Don't forget to use both --robot (to enable dependency resolution) and --module-only (to only run the sanity check and generate module files, not install the software again). Start at the top of the module hierarchy (the Core level), and run module spider to check which gateway modules to load to make SciPy-bundle available: module use $HOME /hmns/modules/all/Core module spider SciPy-bundle/2020.03-Python-3.8.2 Load the gateway modules: module load GCC/9.3.0 OpenMPI/4.0.3 Check that the SciPy-bundle module is available, and load it: $ module avail SciPy-bundle ----- /home/example/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------ SciPy-bundle/2020.03-Python-3.8.2 module load SciPy-bundle/2020.03-Python-3.8.2 Run the test command: $ python -c 'import pandas; print(pandas.__version__)' 1.0.3","title":"Exercise"},{"location":"hmns/slides/","text":"Hierarchical module naming schemes \u00b6 Or HMNS for short.","title":"Slides"},{"location":"hmns/slides/#hierarchical-module-naming-schemes","text":"Or HMNS for short.","title":"Hierarchical module naming schemes"},{"location":"installation/","text":"Installation \u00b6 Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing so, and the things you should pay attention to. By the end of it, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version and eb --help Requirements \u00b6 Linux \u00b6 The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project. Python \u00b6 EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later. Environment modules tool \u00b6 An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information. EasyBuild as a Python package \u00b6 EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve! Python 2 or Python 3? \u00b6 For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation . Installing EasyBuild \u00b6 We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty! Method 1: Using pip (recommended) \u00b6 Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild. Running pip install \u00b6 Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). pip vs pip3 \u00b6 On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above. Updating your environment \u00b6 If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH $EB_PYTHON and $EB_VERBOSE If you want to control which Python version is used to run EasyBuild, you can speicfy the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. For example, to ensure that eb uses python3 : export EB_PYTHON = python3 To get a better view on which python commands are being considered by the eb command, you can (temporarily) define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3 ) >> python3 -m easybuild.main --version This is EasyBuild 4 .2.1 ( framework: 4 .2.1, easyblocks: 4 .2.1 ) on host example Method 2: Bootstrapping EasyBuild \u00b6 Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it. Step 1: Downloading the bootstrap script \u00b6 First, download the latest version of the EasyBuild bootstrap script from GitHub. A common way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py Step 2: Running the bootstrap script \u00b6 To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ). Step 3: Loading the EasyBuild module \u00b6 Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands. That is expected behaviour and completely normal. Verifying the installation \u00b6 Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation: Checking the version \u00b6 To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version . Consulting the help output \u00b6 You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help Showing the default EasyBuild configuration \u00b6 To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial. Updating EasyBuild \u00b6 Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Warning Make sure you have EasyBuild installed before you proceed with the rest of the tutorial!","title":"Installation"},{"location":"installation/#installation","text":"Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild. In this section we outline a couple of different ways of doing so, and the things you should pay attention to. By the end of it, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial. Summary requirements : Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended) installation methods: pip install easybuild bootstrapping EasyBuild verify EasyBuild installation using eb --version and eb --help","title":"Installation"},{"location":"installation/#requirements","text":"","title":"Requirements"},{"location":"installation/#linux","text":"The main target platform for EasyBuild is Linux , since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux ). EasyBuild is also compatible with macOS , but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project.","title":"Linux"},{"location":"installation/#python","text":"EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3). To check which Python version you have, use: python -V No additional Python packages are required by EasyBuild , the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.","title":"Python"},{"location":"installation/#environment-modules-tool","text":"An environment modules tool is required for using EasyBuild. We strongly recommend using Lmod , a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported. To check if you have a modules tool installed, use: module --version If this produces output that starts with something like \" Modules based on Lua: Version 8.2.5 \" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. If you see output that starts with a line like \" VERSION=3.2.10 \" or \" Modules Release 4.5.0 \", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation . If the module function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.","title":"Environment modules tool"},{"location":"installation/#easybuild-as-a-python-package","text":"EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders , as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild . As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation. Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry. You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like pip , virtualenv , pipenv , ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!","title":"EasyBuild as a Python package"},{"location":"installation/#python-2-or-python-3","text":"For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life , we strongly recommend using Python 3 if you have the choice. By default EasyBuild will use the python command to run, but you can control this if needed. For more information, see the EasyBuild documentation .","title":"Python 2 or Python 3?"},{"location":"installation/#installing-easybuild","text":"We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation. Time to get your hands dirty!","title":"Installing EasyBuild"},{"location":"installation/#method-1-using-pip-recommended","text":"Since EasyBuild is released as a Python package on PyPI you can install it using pip , the most commonly used tool for installing Python packages. You may need to take additional steps after the installation, depending on the exact installation command. Note There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like virtualenv or pipenv , feel free to use those instead to install EasyBuild.","title":"Method 1: Using pip (recommended)"},{"location":"installation/#running-pip-install","text":"Installing EasyBuild with pip is as simple as running the following command: pip install easybuild However, you may need to slightly change this command depending on the context and your personal preferences: To install EasyBuild system-wide , you can use sudo (if you have admin privileges): sudo pip install easybuild To install EasyBuild in your personal home directory , you can use the --user option: pip install --user easybuild This will result in an EasyBuild installation in $HOME/.local/ . To install EasyBuild in a specific directory you can use the --prefix option: pip install --prefix _PREFIX_ easybuild In this command, you should replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Running pip install"},{"location":"installation/#pip-vs-pip3","text":"On systems where both Python 2 and Python 3 are installed you may also have different pip commands available. Or maybe pip is not available at all, and only \"versioned\" pip commands like pip3 are available. If you (only) have pip3 available, you can replace pip with pip3 in any of the pip install commands above.","title":"pip vs pip3"},{"location":"installation/#updating-your-environment","text":"If you used the --user or --prefix option in the pip install command, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location. Note Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory ( .bashrc for example). $PATH Update the $PATH environment variable to make sure the eb command is available: export PATH = _PREFIX_/bin: $PATH Replace ' _PREFIX_ ' in this command with the directory path where EasyBuild was installed into (use $HOME/.local if you used pip install --user ). $PYTHONPATH If you installed EasyBuild to a non-standard location using pip install --prefix , you also need to update the Python search path environment variable $PYTHONPATH to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the --user option, since Python will automatically consider $HOME/.local when searching for installed Python packages. Update $PYTHONPATH by running a command like: export PYTHONPATH = _PREFIX_/lib/pythonX.Y/site-packages: $PYTHONPATH Here, you need to replace the X and Y with the major and minor version of your Python installation, which you can determine by running python -V . For example, if you are using Python 2.7, make sure you are using ' python2.7 ' in the command to update $PYTHONPATH . And of course, you again need to replace ' _PREFIX_ ' with the installation prefix where EasyBuild was installed into. For example: # update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6 export PYTHONPATH = $HOME /tools/lib/python3.6/site-packages: $PYTHONPATH $EB_PYTHON and $EB_VERBOSE If you want to control which Python version is used to run EasyBuild, you can speicfy the name or the full path to the python command that should be used by the eb command via the $EB_PYTHON environment variable. For example, to ensure that eb uses python3 : export EB_PYTHON = python3 To get a better view on which python commands are being considered by the eb command, you can (temporarily) define the $EB_VERBOSE environment variable. For example: $ EB_VERBOSE = 1 eb --version >> Considering 'python3' ... >> 'python3' version: 3 .6.8, which matches Python 3 version requirement ( > = 3 .5 ) >> Selected Python command: python3 ( /usr/bin/python3 ) >> python3 -m easybuild.main --version This is EasyBuild 4 .2.1 ( framework: 4 .2.1, easyblocks: 4 .2.1 ) on host example","title":"Updating your environment"},{"location":"installation/#method-2-bootstrapping-easybuild","text":"Note This section covers an alternative installation method. If you already have EasyBuild installed, you can skip ahead to the next section . If pip is not available or if the installation with pip is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild . In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it.","title":"Method 2: Bootstrapping EasyBuild"},{"location":"installation/#step-1-downloading-the-bootstrap-script","text":"First, download the latest version of the EasyBuild bootstrap script from GitHub. A common way to do this is by running this curl command: curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py","title":"Step 1: Downloading the bootstrap script"},{"location":"installation/#step-2-running-the-bootstrap-script","text":"To install EasyBuild using the bootstrap script simply run it using the python command and specify the installation prefix as an argument: python bootstrap_eb.py _PREFIX_ Replace ' _PREFIX_ ' with the location where you want to have EasyBuild installed (for example, $HOME/tools or /tmp/$USER ).","title":"Step 2: Running the bootstrap script"},{"location":"installation/#step-3-loading-the-easybuild-module","text":"Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session. First, make the module available by running the following command (which will update the module search path environment variable $MODULEPATH ): module use _PREFIX_/modules/all Replace ' _PREFIX_ ' in the same way as you did when running the bootstrap script. Then, load the EasyBuild module to update your environment and make EasyBuild available for use: module load EasyBuild Note No output will be generated by either of these module commands. That is expected behaviour and completely normal.","title":"Step 3: Loading the EasyBuild module"},{"location":"installation/#verifying-the-installation","text":"Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:","title":"Verifying the installation"},{"location":"installation/#checking-the-version","text":"To check which EasyBuild version you have installed, run: eb --version The output should match with the latest EasyBuild version .","title":"Checking the version"},{"location":"installation/#consulting-the-help-output","text":"You can consult the help output of the eb command, which produces a long list of available options along with a short informative message. eb --help","title":"Consulting the help output"},{"location":"installation/#showing-the-default-easybuild-configuration","text":"To inspect the current EasyBuild configuration, you can use this command: eb --show-config This should tell you that EasyBuild (ab)uses $HOME/.local/easybuild as a default location. More on configuring EasyBuild in the next part of the tutorial.","title":"Showing the default EasyBuild configuration"},{"location":"installation/#updating-easybuild","text":"Before we wrap up here, a brief word about updating EasyBuild. Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module: eb --install-latest-eb-release This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration. Warning Make sure you have EasyBuild installed before you proceed with the rest of the tutorial!","title":"Updating EasyBuild"},{"location":"installation/slides/","text":"Installation \u00b6 To install EasyBuild: pip install --prefix $HOME /tools easybuild export PATH = $HOME /tools/bin: $PATH export PYTHONPATH = $HOME /tools/lib/python2.7/site-packages: $PYTHONPATH","title":"Slides"},{"location":"installation/slides/#installation","text":"To install EasyBuild: pip install --prefix $HOME /tools easybuild export PATH = $HOME /tools/bin: $PATH export PYTHONPATH = $HOME /tools/lib/python2.7/site-packages: $PYTHONPATH","title":"Installation"},{"location":"introduction/","text":"Introduction \u00b6 What is EasyBuild? \u00b6 EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments. Elevator pitch \u00b6 EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown out to be a platform for collaboration with HPC sites worldwide. Key features \u00b6 EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry run and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers (Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release. What EasyBuild is not \u00b6 EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is *not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you. Implementation \u00b6 EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository. Terminology \u00b6 Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms. Framework \u00b6 The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ). Easyblocks \u00b6 An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files ). Easyconfig files \u00b6 Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory . The following parameters must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If these parameters are not provided, the corresponding default value will be used. Extensions \u00b6 Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules . As you can tell the common terminology here is a mess, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation); Dependencies \u00b6 A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed; The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial. Toolchains \u00b6 A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries). System toolchain \u00b6 The system toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation. Modules \u00b6 Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used. Bringing it all together \u00b6 The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software. Focus points \u00b6 EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made. Performance \u00b6 EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour may be changed via the --optarch configuration setting . Reproducibility \u00b6 In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild. Community effort \u00b6 In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency. The EasyBuild community \u00b6 EasyBuild was originally created by the HPC team at Ghent University (Belgium) in 2009, and was developed in-house before it was publicly released in 2012. Since then it has grown out to a community project , which is used and developed by various HPC centres and consortia worldwide, including (but not limited to): Flemish Supercomputer Centre (VSC), Belgium Consortium des \u00c9quipements de Calcul Intensif (C\u00c9CI), Belgium J\u00fclich Supercomputing Centre (JSC), Germany Swiss National Supercomputing Centre (CSCS) Birmingham Environment for Academic Research (BEAR), UK SURFsara, Netherlands Swedish National Infrastructure for Computing (SNIC) Compute Canada Fred Hutchinson Cancer Research Center, US Texas A&M University (TAMU) High Performance Research Computing (HPRC), US National University of Singapore (NUS) University of Melbourne, Australia HPCNow! Today, an experienced team of HPC experts actively maintains the project, by implementing additional features and bug fixes, and processing incoming contributions. The EasyBuild documentation is available at https://easybuild.readthedocs.io . You can interact with the EasyBuild community via the Slack channel (request an invitation here ), or by subscribing to the mailing list .","title":"Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#what-is-easybuild","text":"EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC) environments.","title":"What is EasyBuild?"},{"location":"introduction/#elevator-pitch","text":"EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems. It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. In addition, EasyBuild can empower scientific researchers to self-manage their software stack , and it can serve as a tool that can be leveraged for building optimized container images . The project has grown out to be a platform for collaboration with HPC sites worldwide.","title":"Elevator pitch"},{"location":"introduction/#key-features","text":"EasyBuild is capable of fully autonomously installing (scientific) software , including making sure that all necessary dependencies are installed, and automatically generating environment module files. No admin privileges are required : it is sufficient to have write permissions to the preferred software installation prefix. It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required. The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry run and tracing . EasyBuild supports using a custom module naming scheme , allows for hierarchical module naming schemes, and integrates with various other tools ranging from resource managers (Slurm and GC3Pie ), container tools ( Singularity and Docker ), packaging tools ( FPM ), and so on. The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release.","title":"Key features"},{"location":"introduction/#what-easybuild-is-not","text":"EasyBuild is not YABT (Yet Another Build Tool) : it does not replace established build tools like CMake or make , it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you. It is not a replacement for traditional Linux package managers like yum , dnf or apt . EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution. Finally, EasyBuild is *not a magic solution to all your (software installation) problems . You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you.","title":"What EasyBuild is not"},{"location":"introduction/#implementation","text":"EasyBuild is implemented in Python , and fully supports both Python 2.7 and 3.5+. Releases are published via PyPI , under the GPLv2 open source license . Development is done through the easybuilders organisation on GitHub , where each of the EasyBuild components is hosted in a separate repository.","title":"Implementation"},{"location":"introduction/#terminology","text":"Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software. It is important to be familiar with these terms.","title":"Terminology"},{"location":"introduction/#framework","text":"The EasyBuild framework consists of a set of Python modules organised in packages ( easybuild.framework , easybuild.tools , etc.) that collectively form the heart of EasyBuild . It implements the common functionality that you need when building software from source , providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc. The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks ).","title":"Framework"},{"location":"introduction/#easyblocks","text":"An easyblock is a Python module that implements a specific software installation procedure . It can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific . A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the ConfigureMake easyblock which implements the ubiquitous configure - make - make install procedure, and the PythonPackage easyblock that can be used to install a Python package. A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for GCC , OpenFOAM , TensorFlow , ... The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files ).","title":"Easyblocks"},{"location":"introduction/#easyconfig-files","text":"Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install . They define the different easyconfig parameters that collectively form a complete specification for a particular software installation. Some easyconfig parameters are mandatory . The following parameters must be defined in each easyconfig file: name and version , which specify the name and version of the software to install (surprise!); homepage and description , which provide key metadata for the software; toolchain , which specifies the compiler toolchain to use to install the software (see toolchains tab); Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock . Some commonly used optional easyconfig parameters include: easyblock , which specifies which (generic) easyblock should be used; sources and source_urls , which specify the list of source files and where to download them; dependencies and builddependencies , which specify (drum roll...) the list of (build) dependencies; configopts , buildopts , and installopts , which specify options for the configuration/build/install commands, respectively; If these parameters are not provided, the corresponding default value will be used.","title":"Easyconfig files"},{"location":"introduction/#extensions","text":"Extensions is the collective term we use for additional software packages that can be installed on top of another software package . Examples are Python packages , R libraries and Perl modules . As you can tell the common terminology here is a mess, so we came up with a unifying term... Extensions can be installed in different ways: stand-alone, as a separate installation on top of one or more other installations; as a part of a bundle of extensions that collectively form a separate installation; or as an actual extension to a specific installation to yield a \"batteries included\" type of installation (for examples by adding a bunch of Python packages from PyPI into a Python installation);","title":"Extensions"},{"location":"introduction/#dependencies","text":"A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features). There are three main types of dependencies for computer software: a build dependency is only required when building/installing a software package; once the software package is installed, it is no longer needed to use that software; a runtime dependency (often referred to simply as dependency ) is a software package that is required to use (or run ) another software package; a link-time dependency is somewhere in between a build and runtime dependency: it is only needed when linking a software package; it can become either a build or runtime dependency, depending on exactly how the software is installed; The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial.","title":"Dependencies"},{"location":"introduction/#toolchains","text":"A compiler toolchain (or just toolchain for short) is a set of compilers , which are used to build software from source, together with a set of additional libraries that provide further core functionality. We refer to the different parts of a toolchain as toolchain components . The compiler component typically consists of C , C++ , and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included. Additional toolchain components are usually special-purpose libraries: an MPI library to support distributed computations (for example, Open MPI ); libraries providing efficient linear algebra routines ( BLAS , LAPACK ); a library supporting computing Fast Fourier Transformations (for example, FFTW ); A toolchain that includes all of these libraries is referred to as a full toolchain , while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).","title":"Toolchains"},{"location":"introduction/#system-toolchain","text":"The system toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild. It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.","title":"System toolchain"},{"location":"introduction/#modules","text":"Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file) . Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell -agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state. Environment module files are processed via a modules tool , of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod , a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones. EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild . Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax. Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.","title":"Modules"},{"location":"introduction/#bringing-it-all-together","text":"The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions , using a particular compiler toolchain , as specified in easyconfig files . EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.","title":"Bringing it all together"},{"location":"introduction/#focus-points","text":"EasyBuild was created specifically for installing scientific software on HPC systems , which is reflected in some of the design choices that were made.","title":"Focus points"},{"location":"introduction/#performance","text":"EasyBuild strongly prefers to build software from source code , whenever possible. This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run. For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like -march=native (GCC), -xHost (Intel compilers), etc. This behaviour may be changed via the --optarch configuration setting .","title":"Performance"},{"location":"introduction/#reproducibility","text":"In addition to performance, reproducibility of installations is a core aspect of EasyBuild. Most software installations performed with EasyBuild use a particular toolchain , with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like OpenSSL for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system. For both toolchains and dependencies, fixed software versions are specified in the easyconfig files . That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.","title":"Reproducibility"},{"location":"introduction/#community-effort","text":"In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out. We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework , easyblocks , easyconfigs repositories, or to the EasyBuild documentation . Through the foss and intel common toolchains , we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository . Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.","title":"Community effort"},{"location":"introduction/#the-easybuild-community","text":"EasyBuild was originally created by the HPC team at Ghent University (Belgium) in 2009, and was developed in-house before it was publicly released in 2012. Since then it has grown out to a community project , which is used and developed by various HPC centres and consortia worldwide, including (but not limited to): Flemish Supercomputer Centre (VSC), Belgium Consortium des \u00c9quipements de Calcul Intensif (C\u00c9CI), Belgium J\u00fclich Supercomputing Centre (JSC), Germany Swiss National Supercomputing Centre (CSCS) Birmingham Environment for Academic Research (BEAR), UK SURFsara, Netherlands Swedish National Infrastructure for Computing (SNIC) Compute Canada Fred Hutchinson Cancer Research Center, US Texas A&M University (TAMU) High Performance Research Computing (HPRC), US National University of Singapore (NUS) University of Melbourne, Australia HPCNow! Today, an experienced team of HPC experts actively maintains the project, by implementing additional features and bug fixes, and processing incoming contributions. The EasyBuild documentation is available at https://easybuild.readthedocs.io . You can interact with the EasyBuild community via the Slack channel (request an invitation here ), or by subscribing to the mailing list .","title":"The EasyBuild community"},{"location":"introduction/slides/","text":"Introducing EasyBuild (slide 1) \u00b6 foo bar Introducing EasyBuild (slide 2) \u00b6 blah blah","title":"Slides"},{"location":"introduction/slides/#introducing-easybuild-slide-1","text":"foo bar","title":"Introducing EasyBuild (slide 1)"},{"location":"introduction/slides/#introducing-easybuild-slide-2","text":"blah blah","title":"Introducing EasyBuild (slide 2)"},{"location":"jsc/","text":"","title":"EasyBuild at J\u00fclich Supercomputing Centre"},{"location":"jsc/slides/","text":"EasyBuild at J\u00fclich Supercomputing Centre (JSC) \u00b6 TODO: Alan O'Cais","title":"Slides"},{"location":"jsc/slides/#easybuild-at-julich-supercomputing-centre-jsc","text":"TODO: Alan O'Cais","title":"EasyBuild at J\u00fclich Supercomputing Centre (JSC)"},{"location":"practical_information/","text":"Practical information \u00b6 Contact points, resources, helpful hints, and things to keep in mind for the EasyBuild tutorial. Slack \u00b6 There is a dedicated #tutorial channel in the EasyBuild Slack where you can get in touch with organisers of the tutorial, other participants, and volunteers. Please use this channel to ask questions throughout the tutorial, or for any other assistance related to the tutorial. To access this channel, you will first need to create an account in the EasyBuild Slack. This is done via https://easybuild-slack.herokuapp.com/ . Once you have the account set up, you can join the EasyBuild Slack via https://easybuild.slack.com/ . From there you can join the #tutorial channel. For more information about Slack, please see the official documentation . AWS resources \u00b6 (only available during the tutorial on Tuesday June 23rd 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, or you have not received the email with the connection information, please contact the tutorial organisers via Slack. Prepared container image \u00b6 For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image includes a small software stack that was installed using EasyBuild, which will come in useful for some of the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub , and can be used with both Docker and Singularity. Requirements for using the container images \u00b6 (only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a system with a processor supporting the AVX2 instruction set. AVX2 is supported by Intel Haswell or AMD Bulldozer (both released in 2012) and onwards. If you are in doubt about your systems compatibility, see \"Testing host compatibility\" at the end of this document. Container size \u00b6 The compressed container image is about 1.25GB in size, and will be downloaded automatically from Docker Hub when you run the docker or singularity command shown below. Using Docker \u00b6 If you want to use the prepared container image via Docker, run the following docker command: docker run -ti --hostname tutorial --rm easybuilders/tutorial:isc20-haswell Docker and cgroups v2 \u00b6 If you are using a recent Linux distribution that has switched to cgroups v2 (e.g. Fedora >= 31 ), docker will fail with OCI runtime create failed: this version of runc doesn't work on cgroups v2 since it is not yet compatible with cgroups v2. Possible workarounds include: reverting to cgroups v1 (it can be done via the kernel command-line argument systemd.unified_cgroup_hierarchy=0 ); using Podman instead, which implements the docker CLI; using Singularity instead (see below); Using Singularity \u00b6 (not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: mkdir -p /tmp/ $USER /isc20 singularity run --cleanenv --home /tmp/ $USER /isc20 docker://easybuilders/tutorial:isc20-haswell The additional options are required to: --cleanenv : start with clean environment --home /tmp/$USER/isc20 : use (empty) /tmp/$USER/isc20 directory as home directory in container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises. Singularity cache \u00b6 By default Singularity keeps its cache at $HOME/.singularity/cache . Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup. If your home directory is limited in size you can either make $HOME/.singularity a symbolic link to /tmp/$USER/singularity or a similar spacious volume, or define the $SINGULARITY_CACHEDIR environment variable to make Singulartiy use a different location: export SINGULARITY_CACHEDIR = /tmp/ $USER /singularity Warning messages \u00b6 When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by: warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\" You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unpriviledged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/ . Welcome message \u00b6 If you are correctly logged in to the container, you should see a message like this: You are logged in to the prepared environment for the introductory tutorial to ______ ____ _ _ _ | ____| | _ \\ (_)| | | | | |__ __ _ ___ _ _ | |_) | _ _ _ | | __| | | __| / _` |/ __|| | | || _ < | | | || || | / _` | | |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| | |______|\\__,_||___/ \\__, ||____/ \\__,_||_||_| \\__,_| __/ | |___/ The tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial . OS: CentOS Linux release 7.8.2003 (Core) modules tool: Lmod 8.2.7 To access the pre-installed software run 'module use /easybuild/modules/all', and then check which modules are installed using 'module avail'. In case of questions or problems contact the tutorial organisers via the #tutorial channel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com . Testing host compatibility \u00b6 To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX2 instructions (Intel Haswell generation, or newer). You can test the compatibility of your host with the following commands: module use /easybuild/modules/all module load Python python -V If the last command prints a Python version (like Python 3.8.2 ), then your host is compatible. If you see a message like \" Illegal instruction (core dumped) \", the processor in your system is not compatible with the pre-installed software stack, and you will have to use another system to participate in the tutorial.","title":"Practical information"},{"location":"practical_information/#practical-information","text":"Contact points, resources, helpful hints, and things to keep in mind for the EasyBuild tutorial.","title":"Practical information"},{"location":"practical_information/#slack","text":"There is a dedicated #tutorial channel in the EasyBuild Slack where you can get in touch with organisers of the tutorial, other participants, and volunteers. Please use this channel to ask questions throughout the tutorial, or for any other assistance related to the tutorial. To access this channel, you will first need to create an account in the EasyBuild Slack. This is done via https://easybuild-slack.herokuapp.com/ . Once you have the account set up, you can join the EasyBuild Slack via https://easybuild.slack.com/ . From there you can join the #tutorial channel. For more information about Slack, please see the official documentation .","title":"Slack"},{"location":"practical_information/#aws-resources","text":"(only available during the tutorial on Tuesday June 23rd 2020) Access to a shell environment on AWS Cloud9 is provided for this tutorial. You should have received an email with connection information if you have registered in time for this tutorial. If you did not register and would still like to use AWS Cloud9 for this tutorial, or you have not received the email with the connection information, please contact the tutorial organisers via Slack.","title":"AWS resources"},{"location":"practical_information/#prepared-container-image","text":"For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment. This container image includes a small software stack that was installed using EasyBuild, which will come in useful for some of the exercises. The container is available through the easybuilders/tutorial repository on Docker Hub , and can be used with both Docker and Singularity.","title":"Prepared container image"},{"location":"practical_information/#requirements-for-using-the-container-images","text":"(only relevant if you are not using AWS Cloud9) having Docker or Singularity installed a system with a processor supporting the AVX2 instruction set. AVX2 is supported by Intel Haswell or AMD Bulldozer (both released in 2012) and onwards. If you are in doubt about your systems compatibility, see \"Testing host compatibility\" at the end of this document.","title":"Requirements for using the container images"},{"location":"practical_information/#container-size","text":"The compressed container image is about 1.25GB in size, and will be downloaded automatically from Docker Hub when you run the docker or singularity command shown below.","title":"Container size"},{"location":"practical_information/#using-docker","text":"If you want to use the prepared container image via Docker, run the following docker command: docker run -ti --hostname tutorial --rm easybuilders/tutorial:isc20-haswell","title":"Using Docker"},{"location":"practical_information/#docker-and-cgroups-v2","text":"If you are using a recent Linux distribution that has switched to cgroups v2 (e.g. Fedora >= 31 ), docker will fail with OCI runtime create failed: this version of runc doesn't work on cgroups v2 since it is not yet compatible with cgroups v2. Possible workarounds include: reverting to cgroups v1 (it can be done via the kernel command-line argument systemd.unified_cgroup_hierarchy=0 ); using Podman instead, which implements the docker CLI; using Singularity instead (see below);","title":"Docker and cgroups v2"},{"location":"practical_information/#using-singularity","text":"(not available in AWS environment) To use the prepared container image via Singularity, run the following singularity command: mkdir -p /tmp/ $USER /isc20 singularity run --cleanenv --home /tmp/ $USER /isc20 docker://easybuilders/tutorial:isc20-haswell The additional options are required to: --cleanenv : start with clean environment --home /tmp/$USER/isc20 : use (empty) /tmp/$USER/isc20 directory as home directory in container This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises.","title":"Using Singularity"},{"location":"practical_information/#singularity-cache","text":"By default Singularity keeps its cache at $HOME/.singularity/cache . Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup. If your home directory is limited in size you can either make $HOME/.singularity a symbolic link to /tmp/$USER/singularity or a similar spacious volume, or define the $SINGULARITY_CACHEDIR environment variable to make Singulartiy use a different location: export SINGULARITY_CACHEDIR = /tmp/ $USER /singularity","title":"Singularity cache"},{"location":"practical_information/#warning-messages","text":"When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by: warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\" You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unpriviledged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/ .","title":"Warning messages"},{"location":"practical_information/#welcome-message","text":"If you are correctly logged in to the container, you should see a message like this: You are logged in to the prepared environment for the introductory tutorial to ______ ____ _ _ _ | ____| | _ \\ (_)| | | | | |__ __ _ ___ _ _ | |_) | _ _ _ | | __| | | __| / _` |/ __|| | | || _ < | | | || || | / _` | | |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| | |______|\\__,_||___/ \\__, ||____/ \\__,_||_||_| \\__,_| __/ | |___/ The tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial . OS: CentOS Linux release 7.8.2003 (Core) modules tool: Lmod 8.2.7 To access the pre-installed software run 'module use /easybuild/modules/all', and then check which modules are installed using 'module avail'. In case of questions or problems contact the tutorial organisers via the #tutorial channel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com .","title":"Welcome message"},{"location":"practical_information/#testing-host-compatibility","text":"To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX2 instructions (Intel Haswell generation, or newer). You can test the compatibility of your host with the following commands: module use /easybuild/modules/all module load Python python -V If the last command prints a Python version (like Python 3.8.2 ), then your host is compatible. If you see a message like \" Illegal instruction (core dumped) \", the processor in your system is not compatible with the pre-installed software stack, and you will have to use another system to participate in the tutorial.","title":"Testing host compatibility"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild. In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention! EasyBuild error messages \u00b6 When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, a problem has occurred and the installation will be interrupted. Example \u00b6 Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb trouble.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-39 ) Oh my that's pretty ancient. That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled. EasyBuild log files \u00b6 Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a sensible way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created for every installation, which is located in the unique temporary directory that was created for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.6-gompi-2020a/easybuild/easybuild-HDF5-1.10.6-20200609.131126.log Navigating log files \u00b6 Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you'll miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.6/gompi-2020a/hdf5-1.10.6/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there. Inspecting the build directory \u00b6 When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the buildpath directory. Exercise \u00b6 Let's work our way through a less smooth software installation, using the easyconfig file that is provided in /easybuild/tutorial/subread.eb in the tutorial container image. For completeness sake, the contents are shown below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.4.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the easyconfig file to your home directory, so you can make changes to it. cd $HOME cp /easybuild/tutorial/subread.eb . Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise 5.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ In case download is problematic, the source tarball is also available in /easybuild/tutorial/ : cp /easybuild/tutorial/subread-2.0.1-source.tar.gz $HOME /easybuild/sources/s/Subread/ Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate URLs, without the filename of the source file. The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise 5.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.4.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): No module found for toolchain: GCC/8.4.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 9.3.0. So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } Or run the following sed command to change the toolchain version to '9.3.0' : sed -i 's/8.4.0/9.3.0/' subread.eb Exercise 5.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via CFLAGS= to the build command: buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' EasyBuild sets up the build environment so there should be no need to hard specify compiler flags (certainly not incorrect ones), but it's good to keep an eye on it to make sure that the compiler flags specified by EasyBuild are actually being used. In this case we need to get rid of the ' CFLAGS=\"...\" ' part in the buildopts value, but the \" -f Makefile.Linux \" part should stay. The problem can be fixed by changing the easyconfig file as follows: buildopts = '-f Makefile.Linux' You can copy-paste and run this sed command to make the change without using an editor: sed -i \"s/buildopts.*/buildopts = '-f Makefile.Linux'/\" subread.eb Exercise 5.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] Or you can use this sed command to make that change: sed -i 's/featureCounts --version/featureCounts -v/' subread.eb After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 9.3.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild. In this part we take a look at how you can troubleshoot a failing installation , and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild , the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed. At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!","title":"Troubleshooting"},{"location":"troubleshooting/#easybuild-error-messages","text":"When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message. Things that could go wrong during an installation include: missing source or patch files; a checksum error on a downloaded source or patch file; required dependencies that are not specified in the easyconfig file; failing shell commands; running out of available memory or disk space; a segmentation fault caused by a flipped bit triggered by a cosmic ray ( really, it happens! ); Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation... For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, a problem has occurred and the installation will be interrupted.","title":"EasyBuild error messages"},{"location":"troubleshooting/#example","text":"Here is an example of an EasyBuild error message (slightly reformatted for clarity): $ eb trouble.eb ... == building... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): build failed (first 300 chars): cmd \"make\" exited with exit code 2 and output: /usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp g++: error: unrecognized command line option '-std=c++14' (took 1 sec) == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log ERROR: Build of /home/easybuild/subread.eb failed (err: ...) Let's break this down a bit: during the build step of the installation procedure EasyBuild was running make as a shell command, which failed (exit code 2, so not zero). The make command tripped over the compilation of core.cpp that failed because -std=c++14 is not a known option to the g++ command. OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is make using /usr/bin/g++ for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under /easybuild/software . Let's see what /usr/bin/g++ is: $ /usr/bin/g++ --version g++ ( GCC ) 4 .8.5 20150623 ( Red Hat 4 .8.5-39 ) Oh my that's pretty ancient. That could definitely explain why it doesn't know about the C++14 standard yet... Your next step in this case should probably be figuring out why /usr/bin/g++ is being used rather than just g++ , which would result in using the right compiler version because EasyBuild sets up the build environment carefully. This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.","title":"Example"},{"location":"troubleshooting/#easybuild-log-files","text":"Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward... EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a sensible way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed. In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes. In that case, you will have the dive into the log file that is created for every installation, which is located in the unique temporary directory that was created for the EasyBuild session. See for example this output line from our earlier example error message: == Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log You can open this file with your favorite text editor or a tool like less to take a look at the information collected in the log file, which includes things like: informative messages produced by the EasyBuild framework and the easyblock describing how the installation is progressing; how the build environment was set up: which modules were loaded, which environment variables were set; the exact shell commands that were executed, and in which directory they were run; the full output produced by these commands, and their exit code; Note that the installation log is also copied into each software installation directory for successful installation, into the easybuild subdirectory. For example: /easybuild/software/HDF5/1.10.6-gompi-2020a/easybuild/easybuild-HDF5-1.10.6-20200609.131126.log","title":"EasyBuild log files"},{"location":"troubleshooting/#navigating-log-files","text":"Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors: ERROR Error 1 error: failure not found No such file or directory bazel Segmentation fault Using \" error \" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an error.c file), and you'll miss others that do include errors but mention ERROR or Error rather than error . When using less to view a log file, you can navigate it by: hitting ' $ ' followed by ' G ' to go to the end of the log file; using your arrow keys to scroll up/down; typing ' ? ' followed by some text and Enter to search backwards for a particular pattern (' / ' to search forwards, ' n ' for next match); hitting ' q ' to exit; It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these: == 2020-06-13 01:34:48,816 example INFO configuring... == 2020-06-13 01:34:48,817 example INFO Starting configure step ... == 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for HDF5 ): == 2020-06-09 13:11:19,968 run.py:222 INFO running cmd: make install == 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output: Making install in src make[1]: Entering directory `/tmp/example/HDF5/1.10.6/gompi-2020a/hdf5-1.10.6/src' ... It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \" INFO running cmd \" as a search pattern, and then looking for patterns like \" error: \" from there.","title":"Navigating log files"},{"location":"troubleshooting/#inspecting-the-build-directory","text":"When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there. The location of the build directory is mentioned in the EasyBuild error message: == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): ... For software using a classic configure script, you may have to locate and inspect the config.log file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in CMakeOutput.log or CMakeError.log for clues, which are sneakily hidden by CMake in a CMakeFiles subdirectory of the build directory. As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the buildpath directory.","title":"Inspecting the build directory"},{"location":"troubleshooting/#exercise","text":"Let's work our way through a less smooth software installation, using the easyconfig file that is provided in /easybuild/tutorial/subread.eb in the tutorial container image. For completeness sake, the contents are shown below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial . easyblock = 'MakeCp' name = 'Subread' version = '2.0.1' homepage = 'http://subread.sourceforge.net' description = \"High performance read alignment, quantification and mutation discovery\" toolchain = { 'name' : 'GCC' , 'version' : '8.4.0' } # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] checksums = [ 'd808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b' ] start_dir = 'src' buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' files_to_copy = [ 'bin' ] sanity_check_paths = { 'files' : [ 'bin/featureCounts' , 'bin/subread-align' ], 'dirs' : [ 'bin/utilities' ], } sanity_check_commands = [ \"featureCounts --version\" ] moduleclass = 'bio' Do you spot any potential problems yet with this easyconfig file? Preparation Start by copying the easyconfig file to your home directory, so you can make changes to it. cd $HOME cp /easybuild/tutorial/subread.eb . Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself): module use /easybuild/modules/all module load EasyBuild For this exercise, make sure EasyBuild is configured to use $HOME/easybuild as prefix , and to use /tmp/$USER as buildpath : export EASYBUILD_PREFIX = $HOME /easybuild export EASYBUILD_BUILDPATH = /tmp/ $USER Check your configuration via eb --show-config . Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions. Remember though: no peeking before you tried to solve each step yourself! Exercise 5.1 - Sources Try to install the subread.eb easyconfig file, see what happens. Can you fix the problem you run into, perhaps without even changing the easyconfig file? (click to show solution) The installation fails because the source file subread-2.0.1-source.tar.gz is not found: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): Couldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either... Paths attempted (in order): ... In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: # download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz sources = [ 'subread- %(version)s -source.tar.gz' ] We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the sourcepath directory): curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz mv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/ In case download is problematic, the source tarball is also available in /easybuild/tutorial/ : cp /easybuild/tutorial/subread-2.0.1-source.tar.gz $HOME /easybuild/sources/s/Subread/ Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: source_urls = [ 'https://download.sourceforge.net/subread/' ] sources = [ 'subread- %(version)s -source.tar.gz' ] Note that the source_urls value is a list of candidate URLs, without the filename of the source file. The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while. $ ls -lh $HOME /easybuild/sources/s/Subread total 23M -rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17 :42 subread-2.0.1-source.tar.gz Exercise 5.2 - Toolchain After fixing the problem with missing source file, try the installation again. What's wrong now? How can you fix it quickly? Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here... (click to show solution) The installation fails because the easyconfig specifies that GCC 8.4.0 should be used as toolchain: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars): No module found for toolchain: GCC/8.4.0 (took 1 sec) We don't have this GCC version installed, but we do have GCC 9.3.0. So let's try using that instead. Edit the easyconfig file so it contains this: toolchain = { 'name' : 'GCC' , 'version' : '9.3.0' } Or run the following sed command to change the toolchain version to '9.3.0' : sed -i 's/8.4.0/9.3.0/' subread.eb Exercise 5.3 - Build step With the first two problems fixed, now we can actually try to build the software. Can you fix the next problem you run into? (click to show solution) The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): cmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast\"\" exited with exit code 2 and output: gcc -mtune=core2 -O3 -DMAKE_FOR_EXON -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\" -D_FILE_OFFSET_BITS=64 -fmessage-length=0 -ggdb -fast -c -o core.o core.c gcc: error: unrecognized command line opti (took 1 sec) If you open the log file and scroll to the end, the error is pretty obvious: gcc: error: unrecognized command line option -fast; did you mean -Ofast? make: *** [core.o] Error 1 The easyconfig file hard specifies the -fast compiler flag via CFLAGS= to the build command: buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"' EasyBuild sets up the build environment so there should be no need to hard specify compiler flags (certainly not incorrect ones), but it's good to keep an eye on it to make sure that the compiler flags specified by EasyBuild are actually being used. In this case we need to get rid of the ' CFLAGS=\"...\" ' part in the buildopts value, but the \" -f Makefile.Linux \" part should stay. The problem can be fixed by changing the easyconfig file as follows: buildopts = '-f Makefile.Linux' You can copy-paste and run this sed command to make the change without using an editor: sed -i \"s/buildopts.*/buildopts = '-f Makefile.Linux'/\" subread.eb Exercise 5.4 - Sanity check After fixing the compilation issue, you're really close to getting the installation working, we promise! Don't give up now, try one last time and fix the last problem that occurs... (click to show solution) Now the installation itself works but the sanity check fails, and hence the module file does not get generated: $ eb subread.eb ... == FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars): Sanity check failed: sanity check command featureCounts --version exited with code 255 (output: featureCounts: unrecognized option '--version' ... If you look at the full output in the log file you can see that the correct option to check the version of the featureCounts command is \" -v \" rather than \" --version \", so we need to fix this in the easyconfig file. Make the following change in the easyconfig file: sanity_check_commands = [ \"featureCounts -v\" ] Or you can use this sed command to make that change: sed -i 's/featureCounts --version/featureCounts -v/' subread.eb After doing so, you don't have to redo the installation from scratch , you can use the --module-only option to only run the sanity check and generate the module file again: eb subread.eb --module-only In the end, you should be able to install Subread 2.0.1 with the GCC 9.3.0 toolchain by fixing the problems with the subread.eb easyconfig file. Check your work by manually loading the module and checking the version via the featureCounts command, which should look like this: $ featureCounts -v featureCounts v2.0.1","title":"Exercise"},{"location":"troubleshooting/slides/","text":"Troubleshooting \u00b6 In trouble, huh?","title":"Slides"},{"location":"troubleshooting/slides/#troubleshooting","text":"In trouble, huh?","title":"Troubleshooting"}]}