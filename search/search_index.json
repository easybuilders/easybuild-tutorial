{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the official EasyBuild tutorial!","text":""},{"location":"#scope","title":"Scope","text":"<p>This is an introductory tutorial to EasyBuild, a command line tool for installing (scientific) software on High Performance Computing (HPC) systems.</p> <p>It aims to explain the core concepts of EasyBuild, get you started with using it, make you familiar with some of the features it provides, and show how it is used by large HPC sites to maintain their central software stacks.</p> <p>Through hands-on exercises and demos, you will learn how EasyBuild can help you to get scientific software installed in an efficient way.</p>"},{"location":"#intended-audience","title":"Intended audience","text":"<p>This tutorial is primarily intended for people new to EasyBuild, but even if you're already familiar with the project it could be interesting to step through it.</p> <p>Our main target audience includes:</p> <ul> <li>HPC system administrators</li> <li>HPC user support team members</li> <li>scientific researchers using HPC systems</li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>We expect you to be (a little bit) familiar with:</p> <ul> <li>using a Linux command line interface</li> <li>the (absolute) basics of compiling software from source</li> </ul> <p>EasyBuild requires:</p> <ul> <li>GNU/Linux (any distribution)</li> <li>Python 2.7 or 3.5+</li> <li> <p>an environment modules tool (see the <code>module</code> command)</p> <ul> <li>we recommend Lmod, a modern environment modules tool implemented in Lua</li> <li>for more information on the environment modules tools supported by EasyBuild, see here</li> </ul> </li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Sebastian Achilles (<code>@SebastianAchilles</code>, J\u00fclich Supercomputing Centre, Germany)</li> <li>Maxime Boissonneault (<code>@mboisson</code>, Compute Canada)</li> <li>Miguel Dias Costa (<code>@migueldiascosta</code>, National University of Singapore)</li> <li>Markus Geimer (<code>@geimer</code>, J\u00fclich Supercomputing Centre, Germany)</li> <li>Kenneth Hoste (<code>@boegel</code>, HPC-UGent, Belgium)</li> <li>Michael Kelsey (<code>@kelseymh</code>, Texas A&amp;M University, US)</li> <li>Christian Kniep (<code>@ChristianKniep</code>, AWS)</li> <li>Terje Kvernes (<code>@terjekv</code>, University of Oslo, Norway)</li> <li>Kurt Lust ( <code>@klust</code>, University of Antwerp, Belgium)</li> <li>Alan O'Cais (<code>@ocaisa</code>, J\u00fclich Supercomputing Centre, Germany)</li> <li>Bart Oldeman (<code>@bartoldeman</code>, Compute Canada)</li> <li>\u00c5ke Sandgren (<code>@akesandgren</code>, Ume\u00e5 University, Sweden)</li> </ul>"},{"location":"#additional-resources","title":"Additional resources","text":"<ul> <li>website: https://easybuild.io</li> <li>documentation: https://docs.easybuild.io</li> <li>GitHub: https://github.com/easybuilders</li> <li>Slack: https://easybuild.slack.com (self-request an invite via https://easybuild.io/join-slack)</li> <li>mailing list: https://lists.ugent.be/wws/subscribe/easybuild</li> </ul>"},{"location":"2020-06-isc20/","title":"Welcome to the official EasyBuild tutorial!","text":""},{"location":"2020-06-isc20/#notes","title":"Notes","text":"<p>For the sake of this tutorial, you can:</p> <ul> <li>use the <code>#tutorial</code> channel in the EasyBuild Slack for asking questions or getting help;</li> <li>use AWS Cloud9 for the hands-on exercises (only during the live tutorial on June 23rd 2020!);</li> </ul> <p>A container image is available that can be run using either Docker or Singularity, which provides a prepared environment that can be used for the hands-on exercises in this tutorial.</p>"},{"location":"2020-06-isc20/#tutorial-contents","title":"Tutorial contents","text":"<p>(Practical information)</p> <ol> <li>Introduction to EasyBuild</li> <li>Installation <code>(*)</code></li> <li>Configuration <code>(*)</code></li> <li>Basic usage <code>(*)</code></li> <li>Troubleshooting <code>(*)</code></li> <li>Hierarchical module naming schemes <code>(*)</code></li> <li>Adding support for additional software <code>(*)</code></li> <li>EasyBuild at J\u00fclich Supercomputing Centre</li> <li>EasyBuild at Compute Canada</li> <li>The EasyBuild community</li> <li>Contributing to EasyBuild</li> <li>Comparison with other tools</li> <li>Getting help</li> </ol> <p>(sections indicated with <code>(*)</code> involve hands-on exercises)</p>"},{"location":"2020-06-isc20/#recordings","title":"Recordings","text":"<p>This introductory tutorial to EasyBuild was streamed on Tuesday June 23rd 2020. The recordings are available on YouTube.</p> <p>See https://github.com/easybuilders/easybuild/wiki/EasyBuild-tutorial for more information.</p>"},{"location":"2020-06-isc20/adding_support_software/","title":"Adding support for additional software","text":"<p>We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet?</p> <p>To do this we will need to create additional easyconfig files, since every software installation performed by EasyBuild is done based on an easyconfig file.</p> <p>In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!</p>"},{"location":"2020-06-isc20/adding_support_software/#easyconfigs-vs-easyblocks","title":"Easyconfigs vs easyblocks","text":"<p>Before we dive into writing easyconfig files, let us take a brief look at how they relate to easyblocks.</p> <p>As we discussed earlier, an easyconfig file (<code>*.eb</code>) is required for each installation performed by EasyBuild which specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module).</p> <p>When can we leverage a generic easyblock, perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock?</p> <p>This is not an easy question to answer in a general sense since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc.</p> <p>In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a paritcular software package.</p> <p>Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include:</p> <ul> <li>'critical' values for easyconfig parameters required to make installation succeed;</li> <li>toolchain-specific aspects of the build and installation procedure (e.g., configure options);</li> <li>interactive commands that need to be run;</li> <li>custom (configure) options for dependencies;</li> <li>having to create or adjust specific (configuration) files;</li> <li>'hackish' usage of a generic easyblock;</li> <li>complex or very non-standard installation procedure;</li> </ul> <p>Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation.</p>"},{"location":"2020-06-isc20/adding_support_software/#writing-easyconfig-files","title":"Writing easyconfig files","text":"<p>Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a '<code>.eb</code>' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier).</p> <p>The syntax for easyconfig files is Python syntax: you are basically defining a bunch of Python variables that correspond to easyconfig parameters.</p> <p>The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.</p>"},{"location":"2020-06-isc20/adding_support_software/#mandatory-parameters","title":"Mandatory parameters","text":"<p>A limited number of easyconfig parameters are mandatory, they must be defined in every easyconfig file:</p> <ul> <li><code>name</code>: the name of the software to install;</li> <li><code>version</code>: the version of the software to install;</li> <li><code>homepage</code>: a URL to the website of the software;</li> <li><code>description</code>: a short description of the software;</li> <li><code>toolchain</code>: the compiler toolchain to use for the installation;</li> </ul> <p><code>name</code>, <code>version</code></p> <p>It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install.</p> <pre><code>name = 'example'\nversion = '1.0'\n</code></pre> <p><code>homepage</code>, <code>description</code></p> <p>The homepage and description are included in the generated module file for the installation. That way the \"<code>module show</code>\" command provides some useful high-level information about the installation.</p> <pre><code>homepage = 'https://example.org'\ndescription = \"This is just an example.\"\n</code></pre> <p>Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!).</p> <p>For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax):</p> <pre><code>description = \"\"\"This is an example\n of a multi-line description.\n It is spread across multiple lines.\"\"\"\n</code></pre> <p><code>toolchain</code></p> <p>EasyBuild also requires that the compiler toolchain is specified, via the <code>toolchain</code> easyconfig parameter.</p> <p>This can either be the <code>system</code> toolchain, for which a constant named <code>SYSTEM</code> is available:</p> <pre><code>toolchain = SYSTEM\n</code></pre> <p>Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 9.3.0 which we used before, or the full toolchain <code>foss</code> 2020a. The name and version of the toolchain can be specified using a Python dictionary, for example:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '9.3.0'}\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#commonly-used-parameters","title":"Commonly used parameters","text":"<p>You will definitely need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory.</p> <p>A full overview of all known easyconfig parameters can be obtained via \"<code>eb --avail-easyconfig-params</code>\" or just \"<code>eb -a</code>\" for short, or can be consulted in the EasyBuild documentation.</p>"},{"location":"2020-06-isc20/adding_support_software/#sources-patches-and-checksums","title":"Sources, patches, and checksums","text":"<p>In most easyconfig files you will see that a list of source files is specified via the <code>sources</code> easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via <code>source_urls</code>. There also may be patch files listed (specified via <code>patches</code>), and checksums for both the source files and patches (specified via <code>checksums</code>).</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>Here is an example of how these easyconfig parameters can be specified:</p> <pre><code>source_urls = [\n    'https://example.org/download/',\n    'https://example.org/download/archive/',\n]\nsources = ['example-1.0-src.tar.gz']\npatches = ['example-fix.patch']\nchecksums = [\n    '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa',\n    '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c',\n]\n</code></pre> <p>Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list (<code>[]</code>).</p> <p>Some things worth pointing out here:</p> <ul> <li>The download URLs specified via <code>source_urls</code> do not include the name of the file, that is added   automatically by EasyBuild when it tries to download the file (only if it's not available already.)</li> <li>If multiple download URLs are specified, they are each tried once in order until the download of the source file was   successful. This can be useful to include backup locations where source files can be downloaded from.</li> <li>Names of source files and patches should not include hardcoded software versions, they usually use a   template value like <code>%(version)s</code> instead:   <pre><code>sources = ['example-%(version)s-src.tar.gz']\n</code></pre>   EasyBuild will use the value of the <code>version</code> easyconfig parameter to determine the actual name of the source   file. This way the software version is only specified in one place and the easyconfig file is easier to   update to other software versions. A list of template values can be consulted via the EasyBuild command   line via the <code>--avail-easyconfig-templates</code> option, or in the EasyBuild documentation.</li> <li>Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information.</li> <li>Specified checksums are usually SHA256 checksum values, but other types are also supported.</li> </ul>"},{"location":"2020-06-isc20/adding_support_software/#easyblock","title":"Easyblock","text":"<p>The easyblock that should be used for the installation can be specified via the <code>easyblock</code> easyconfig parameter.</p> <p>This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If '<code>example</code>' is specified as software name, EasyBuild will try to locate a software-specific easyblock named <code>EB_example</code> (in a Python module named <code>example.py</code>). Software-specific easyblocks follow the convention that the class name starts with <code>'EB_</code>', followed by the software name (where some characters are replaced, like '<code>-</code>' with '<code>_minus_</code>').</p> <p>Generic easyblocks</p> <p>Usually the <code>easyblock</code> value is the name of a generic easyblock, if it is specified. The name of  a generic easyblock does not start with '<code>EB_</code>', so you can easily distinguish it from a software-specific easyblock.</p> <p>Here are a couple of commonly used generic easyblocks:</p> <ul> <li><code>ConfigureMake</code>: implements the standard <code>./configure</code>, <code>make</code>, <code>make install</code> installation procedure;</li> <li><code>CMakeMake</code>: same as <code>ConfigureMake</code>, but with <code>./configure</code> replaced with <code>cmake</code> for the configuration step;</li> <li><code>PythonPackage</code>: implements the installation procedure for a single Python package, by default using    \"<code>python setup.py install</code>\" but other methods like using \"<code>pip install</code>\" are also supported;</li> <li><code>Bundle</code>: a simple generic easyblock to bundle a set of software packages together under a single module file;</li> <li><code>PythonBundle</code>: a customized version of the <code>Bundle</code> generic easyblock to install a bundle of Python packages   in a single installation directory;</li> </ul> <p>A full overview of the available generic easyblock is available in the EasyBuild documentation. You can also consult the output of <code>eb --list-easyblocks</code>, which gives an overview of all known easyblocks, and how they relate to each other.</p> <p>Custom easyconfig parameters</p> <p>Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \"<code>eb -a --easyblock ...</code>\" or just \"<code>eb -a -e ...</code>\", which will result in an additional \"<code>EASYBLOCK-SPECIFIC</code>\" to be added. See the output of this command for example:</p> <pre><code>$ eb -a -e ConfigureMake\nAvailable easyconfig parameters (* indicates specific to the ConfigureMake easyblock):\n...\nEASYBLOCK-SPECIFIC\n------------------\nbuild_cmd*              Build command to use [default: \"make\"]\nbuild_type*             Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\nconfigure_cmd*          Configure command to use [default: \"./configure\"]\nconfigure_cmd_prefix*   Prefix to be glued before ./configure [default: \"\"]\nhost_type*              Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\ninstall_cmd*            Build command to use [default: \"make install\"]\nprefix_opt*             Prefix command line option for configure script ('--prefix=' if None) [default: None]\ntar_config_opts*        Override tar settings as determined by configure. [default: False]\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#dependencies","title":"Dependencies","text":"<p>You will often need to list one or more dependencies that are required to install or run the software.</p> <p>We distinguish between two main different types of dependencies: runtime dependencies and build dependencies.</p> <p>Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the <code>dependencies</code> easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file.</p> <p>Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file.</p> <p>You can specify build dependencies via the <code>builddependencies</code> easyconfig parameter. One typical example of a build dependency is <code>CMake</code>, which is only needed for configuring the build.</p> <p>Here is a simple example of specifying dependencies:</p> <pre><code>builddependencies = [('CMake', '3.16.4')]\n\ndependencies = [\n    ('Python', '3.8.2'),\n    ('HDF5', '1.10.6'),\n    ('SciPy-bundle', '2020.03', '-Python-%(pyver)s'),\n]\n</code></pre> <p>Both <code>builddependencies</code> and <code>dependencies</code> require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values).</p> <p>In some cases additional information may have to be provided, as is shown in the example above for the <code>SciPy-bundle</code> dependency where a 3rd value is specified corresponding to the <code>versionsuffix</code> value of this dependency. If this is not specified, it is assumed to be the empty string (<code>''</code>).</p> <p>Note how we use the '<code>%(pyver)s'</code> template value in the <code>SciPy-bundle</code> dependency specification, to avoid hardcoding the Python version in different places.</p> <p>See also the EasyBuild documentation for additional options on specifying dependencies.</p>"},{"location":"2020-06-isc20/adding_support_software/#version-suffix","title":"Version suffix","text":"<p>In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation.</p> <p>The <code>versionsuffix</code> easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme.</p> <p>If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example:</p> <pre><code>versionsuffix = '-example-label'\n</code></pre> <p>This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the <code>%(pyver)s</code> template comes in useful again:</p> <pre><code>versionsuffix = '-Python-%(pyver)s'\n...\ndependencies = [('Python', '3.8.2')]\n</code></pre> <p>Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The <code>versionsuffix</code> label is helpful to inform the user that a particular Python version is required by the installation.</p>"},{"location":"2020-06-isc20/adding_support_software/#customizing-configure-build-test-and-install-commands","title":"Customizing configure, build, test and install commands","text":"<p>When using a generic easyblock like <code>ConfigureMake</code> or <code>CMakeMake</code>, you will often find yourself having to specify options to the configure, build, test or install commands, or to inject additional commands right before them.</p> <p>For this the following standard easyconfig parameters are available:</p> <ul> <li><code>preconfigopts</code>: string value that is glued before the configure command;</li> <li><code>configopts</code>: string value that is added after the configure command, which can be used to specify configuration options;</li> </ul> <p>Equivalent easyconfig parameters are available for the <code>build</code>, <code>test</code> and <code>install</code> steps: <code>prebuildopts</code>, <code>buildopts</code>, <code>pretestopts</code>, <code>testopts</code>, <code>preinstallopts</code>, and <code>installopts</code>.</p> <p>Here is a fictitious example of how they can be used:</p> <pre><code>easyblock = 'ConfigureMake'\n...\ndependencies = [('HDF5', '1.10.6')]\n...\nconfigopts = '--enable-hdf5-support'\n\nprebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp; '\n\ninstallopts = \"PREFIX='%(installdir)s'\"\n</code></pre> <p>Here we are:</p> <ul> <li> <p>Adding the <code>--enable-hdf5-support</code> configure option, to convince the <code>ConfigureMake</code> easyblock to run the following   command during the configure step:   <pre><code>./configure --prefix ... --enable-hdf5-support\n</code></pre>   (where the '<code>...</code>' represents the path to installation directory where the software should be installed).</p> </li> <li> <p>Specifying that an additional command has to be run before running <code>make</code> in the build step. We use '<code>&amp;&amp;</code>' to glue the   command to the <code>make</code> command, so <code>make</code> will only be run if the command we specified ran correctly. So, the build step will run something like:   <pre><code>export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp;  make -j 4\n</code></pre>   The '<code>4</code>' value passed to the <code>-j</code> option shown here, which specifies how many commands <code>make</code> can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account <code>ulimit</code> settings, and cpuset and cgroup restrictions).</p> </li> <li> <p>Passing the location where the software should be installed to the <code>PREFIX</code> option   of the <code>make install</code> command during the installation step. This results in the   following command being run:   <pre><code>make install PREFIX=...\n</code></pre>   (where the '<code>...</code>' again represents the path to installation directory).   Even though the   installation directory is already specified in the configure command, it is   apparently blatantly ignored by the software we are installing here, and we are expected to specify it   this way instead. How rude!</p> </li> </ul> <p>The <code>$EBROOTHDF5</code> environment variable we are using in <code>prebuildopts</code> corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild defines an <code>$EBROOT*</code> environment variable like this in every module file it generates (see the output of \"<code>module show HDF5</code>\").</p>"},{"location":"2020-06-isc20/adding_support_software/#sanity-check","title":"Sanity check","text":"<p>One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step.</p> <p>By default EasyBuild does a simple sanity check that verifies whether there is a non-empty <code>bin</code> subdirectory in the installation, next to a non-empty <code>lib</code> or <code>lib64</code> directory (either is sufficient).</p> <p>It is recommended to customize the sanity check however to check for something more specific, like a particular binary or directory, or making sure that a trivial command (like <code>example -V</code> or <code>example --help</code>) runs correctly.</p> <p>To specify a custom set of files and/or directories to check, you can use the <code>sanity_check_paths</code> easyconfig parameter. The expected value is Python dictionary with two keys: <code>files</code> and <code>dirs</code>. For example:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/example'],\n    'dirs': ['examples/one', 'examples/two'],\n}\n</code></pre> <p>In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the <code>sanity_check_commands</code> easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example:</p> <pre><code>sanity_check_commands = [\n    \"example --version\",\n    \"example --help\",\n]\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#module-class","title":"Module class","text":"<p>Finally, you will usually see the <code>moduleclass</code> easyconfig parameter to be defined as well, for example:</p> <pre><code>moduleclass = 'lib'\n</code></pre> <p>This is done to categorize software, and it is used to group the generated module files into smaller sets (remember what we saw when installing software earlier).</p>"},{"location":"2020-06-isc20/adding_support_software/#generating-tweaked-easyconfigs","title":"Generating tweaked easyconfigs","text":"<p>Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too?</p> <p>We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the <code>--try-*</code> options provided by the <code>eb</code> command to make EasyBuild generate a new easyconfig file based on an existing one.</p> <p>For example, to try installing a different software version you can use the <code>--try-software-version</code> option:</p> <pre><code>eb example-1.2.3.eb --try-software-version 1.2.4\n</code></pre> <p>Or, to try using a different compiler toolchain you can use <code>--try-toolchain</code>:</p> <pre><code>eb example-1.2.3-foss-2020a.eb --try-toolchain intel,2020a\n</code></pre> <p>It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a <code>--try-*</code> option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.</p>"},{"location":"2020-06-isc20/adding_support_software/#copying-easyconfigs","title":"Copying easyconfigs","text":"<p>One additional handy command line option we want to highlight is <code>--copy-ec</code>, which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the <code>eb</code> command using only the filename, and letting the robot search mechanism locate them.</p> <p>So to copy an easyconfig file, we would have to use <code>eb --search</code> first to get the full location to it, copy-paste that, and then use the <code>cp</code> command. That's annoying.</p> <p>It is a lot easier with <code>--copy-ec</code>:</p> <pre><code>$ eb --copy-ec SAMtools-1.10-GCC-9.3.0.eb SAMtools.eb\n...\nSAMtools-1.10-GCC-9.3.0.eb copied to SAMtools.eb\n</code></pre> <p>If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename.</p> <p>You can copy multiple easyconfig files, as long as the target location is an existing directory.</p>"},{"location":"2020-06-isc20/adding_support_software/#example","title":"Example","text":"<p>By means of example, we are going to puzzle together an easyconfig file to install the example software package <code>eb-tutorial</code>.</p> <p>The sources for <code>eb-tutorial</code> version 1.0.0 are available at:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.0.tar.gz\n</code></pre> <p>You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.0.</p>"},{"location":"2020-06-isc20/adding_support_software/#preparation","title":"Preparation","text":"<p>Make sure EasyBuild is properly configured before you start:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>and that the installed software in <code>/easybuild</code> is available:</p> <pre><code>module use /easybuild/modules/all\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#mandatory-easyconfig-parameters","title":"Mandatory easyconfig parameters","text":"<p>Let's start by getting the mandatory easyconfig parameter defined in the easyconfig file:</p> <pre><code>name = 'eb-tutorial'\nversion = '1.0.0'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\ntoolchain = {'name': 'GCC', 'version': '9.3.0'}\n</code></pre> <p>We will use <code>GCC/9.3.0</code> as toolchain, since we know it is already installed in <code>/easybuild</code> in the prepared environment.</p> <p>In addition, we'll also specify the <code>moduleclass</code>. This is not required, but it is usually set to a reasonable value:</p> <pre><code>moduleclass = 'tools'\n</code></pre> <p>The default value is '<code>base</code>', at least '<code>tools</code>' has some meaning.</p>"},{"location":"2020-06-isc20/adding_support_software/#easyblock_1","title":"Easyblock","text":"<p>Let us see what happens if we take this easyconfig file for a spin:</p> <pre><code>$ eb eb-tutorial.eb == temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log\nERROR: Failed to process easyconfig /home/example/eb-tutorial.eb:\nNo software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial\n</code></pre> <p>That didn't get us very far...</p> <p>The error shows that there is no software-specific easyblock available for <code>eb-tutorial</code>. Does that mean we have to implement an easyblock?</p> <p>In this simple case it doesn't since we can leverage one of the available generic easyblocks. But, which one? Build instructions are usually shared in the <code>README</code> or documentation, but here were are left to figure things out by ourselves...</p> <p>When inspecting the unpacked sources we see a <code>CMakeLists.txt</code> file. That probably means the installation will involve running <code>cmake</code> to configure the build, which likely will yield a <code>Makefile</code> so we can run <code>make</code> afterwards.</p> <p>We briefly discussed a generic easyblock that does exactly this: <code>CMakeMake</code>.</p> <pre><code>easyblock = 'CMakeMake'\n</code></pre> <p>The \"<code>easyblock =</code>\" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).</p>"},{"location":"2020-06-isc20/adding_support_software/#cmake-build-dependency","title":"CMake build dependency","text":"<p>Does using the <code>CMakeMake</code> generic easyblock help at all?</p> <pre><code>$ eb eb-tutorial.eb \n== temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log\n== found valid index for /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/eb-tutorial.eb\n== building and installing eb-tutorial/1.0.0-GCC-9.3.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.0/GCC-9.3.0):\nbuild failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native  (took 0 sec)\n</code></pre> <p>It did help: EasyBuild made an attempt to configure the build using the <code>cmake</code> command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message:</p> <pre><code>/bin/bash: cmake: command not found\n</code></pre> <p>Ah, that explains it, <code>cmake</code> isn't even installed on this system. Or is it?</p> <pre><code>$ module avail CMake\n\n--------------------------- /easybuild/modules/all ----------------------------\n   CMake/3.16.4-GCCcore-9.3.0\n</code></pre> <p>Since a module is available for <code>CMake</code> that is compatible with the toolchain we are using (GCC 9.3.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency:</p> <pre><code>builddependencies = [('CMake', '3.16.4')]\n</code></pre> <p>There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies.</p> <p>You can verify this via <code>eb -D</code>:</p> <pre><code>$ eb eb-tutorial.eb -D\n ...\n * [x] /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/c/CMake/CMake-3.16.4-GCCcore-9.3.0.eb (module: CMake/3.16.4-GCCcore-9.3.0)\n * [x] /easybuild/software/EasyBuild/4.2.1/easybuild/easyconfigs/g/GCC/GCC-9.3.0.eb (module: GCC/9.3.0)\n * [ ] /home/example/eb-tutorial.eb (module: eb-tutorial/1.0.0-GCC-9.3.0)\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#sources","title":"Sources","text":"<p>If you try again after adding <code>CMake</code> as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals:</p> <pre><code>CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.0/GCC-9.3.0\" does not appear to contain CMakeLists.txt.\n</code></pre> <p>Wait, but there is a <code>CMakeLists.txt</code>, we can see it in the unpacked sources!</p> <p>Let's inspect the build directory:</p> <pre><code>$ ls /tmp/$USER/ebtutorial/1.0.0/GCC-9.3.0\neasybuild_obj\n$ ls /tmp/$USER/ebtutorial/1.0.0/GCC-9.3.0/easybuild_obj\n$\n</code></pre> <p>There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file...</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>So we need to specify <code>sources</code>. We might as well also define <code>source_urls</code>, so EasyBuild can download the sources for us.</p> <pre><code>source_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = ['eb-tutorial-1.0.0.tar.gz']\n</code></pre> <p>This will work, but we can do better by not hardcoding the software version (<code>1.0.0</code>) in <code>sources</code>, and use a template value '<code>%(version)s</code>' instead:</p> <pre><code>sources = ['eb-tutorial-%(version)s.tar.gz']\n</code></pre> <p>That way, we only have the software version specified once in the easyconfig file (via the <code>version</code> easyconfig parameter). That will come in useful later (see Exercise 7.2)...</p> <p>We can even use the <code>SOURCE_TAR_GZ</code> template constant in this case, since the name of source file adheres to the standard <code>name-version.tar.gz</code> pattern:</p> <pre><code>sources = [SOURCE_TAR_GZ]\n</code></pre> <p>See the output of \"<code>eb --avail-easyconfig-templates</code>\" for a list of known templates.</p>"},{"location":"2020-06-isc20/adding_support_software/#required-configure-option","title":"Required configure option","text":"<p>With <code>sources</code> defined, we can try again. And yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe...</p> <p>Here's what we find in the log file:</p> <pre><code>CMake Error at CMakeLists.txt:7 (message):\n  EBTUTORIAL_MSG is not set!\n</code></pre> <p>Apparently the <code>eb-tutorial</code> software has a required configure option. It's almost as if that was done on purpose, how silly!</p> <p>Options to the configure command can be specified by the <code>configopts</code> easyconfig parameter. To define the value of a CMake option, we need to use <code>-DNAME_OF_OPTION</code>, so:</p> <pre><code>configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n</code></pre> <p>We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the <code>EBTUTORIAL_MSG</code> configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1).</p>"},{"location":"2020-06-isc20/adding_support_software/#sanity-check_1","title":"Sanity check","text":"<p>Hopefully that brings us closer to getting the installation to work...</p> <pre><code>$ eb eb-tutorial.eb\n....\n== sanity checking...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.0/GCC-9.3.0): build failed (first 300 chars):\nSanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0 (took 2 sec)\n</code></pre> <p>It got all the way to the sanity check step, yaay!</p> <p>The sanity check failed because no '<code>lib</code>' or <code>'lib64'</code> directory was found. Indeed:</p> <pre><code>$ ls $HOME/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0\nbin\n$ ls $HOME/easybuild/software/eb-tutorial/1.0.0-GCC-9.3.0/bin\neb-tutorial\n</code></pre> <p>There is only a binary named <code>eb-tutorial</code> in the <code>bin</code> subdirectory. So we will need to customize the sanity check:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n</code></pre> <p>Since we want to obtain a working installation, we might as well try to run this <code>eb-tutorial</code> command as well:</p> <pre><code>sanity_check_commands = ['eb-tutorial']\n</code></pre> <p>Let us now retry, but use <code>--module-only</code> rather than redoing the whole installation. <code>--module-only</code> still sanity checks the installation, so if it creates a module, we know it will work as expected.  Also, by enabling tracing of the module via <code>--trace</code> we can get some more information too:</p> <pre><code>eb eb-tutorial.eb --module-only --trace\n...\n== sanity checking...\n  &gt;&gt; file 'bin/eb-tutorial' found: OK\n  &gt;&gt; running command 'eb-tutorial' ...\n  &gt;&gt; result for command 'eb-tutorial': OK\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> <p>Yes, great success!</p> <p>To convince yourself that the installation works as intended, try to load the <code>eb-tutorial</code> module and run the <code>eb-tutorial</code> command yourself:</p> <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial\n$ eb-tutorial\nHello from the EasyBuild tutorial!\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#complete-easyconfig","title":"Complete easyconfig","text":"<p>Here is the complete easyconfig we puzzled together for this example:</p> <pre><code>easyblock = 'CMakeMake'\n\nname = 'eb-tutorial'\nversion = '1.0.0'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['87643c9a950d02471fc283b31e8a088da7d5d49bc9e1bebd5c83b52c2e23b4d8']\n\ntoolchain = {'name': 'GCC', 'version': '9.3.0'}\n\nbuilddependencies = [('CMake', '3.16.4')]\n\nconfigopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n\nsanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n\nsanity_check_commands = ['eb-tutorial']\n\nmoduleclass = 'tools'\n</code></pre>"},{"location":"2020-06-isc20/adding_support_software/#exercises","title":"Exercises","text":"<p>Exercise 7.1 - Making <code>eb-tutorial</code> a bit more personal</p> <p>Change the easyconfig file for <code>eb-tutorial</code> to make the message printed by the <code>eb-tutorial</code> command a bit more personal: include the username of the account that was used to install the software in it (using the <code>$USER</code> environment variable).</p> (click to show solution) <p>For this we need to change the value that is passed to the <code>EBTUTORIAL_MSG</code> configure option: <pre><code>configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" '\n</code></pre> Here we have to use inner double quotes, to ensure that the <code>$USER</code> environment variable is expanded by the shell when running the <code>cmake</code> configure command.</p> <p>When you run the <code>eb-tutorial</code> command yourself, you should get output like this (not a message that includes a literal '<code>$USER</code>' string):</p> <pre><code>Hello from the EasyBuild tutorial! I was installed by example.\n</code></pre> <p>To re-install the <code>eb-tutorial.eb</code> easyconfig, you will need to use <code>eb --rebuild</code> or <code>eb --force</code>.</p> <p>Exercise 7.2 - Installing eb-tutorial version 1.1.0</p> <p>Install version 1.1.0 of the <code>eb-tutorial</code> example software, which is a trivial version bump compared to version 1.0.0.</p> <p>The sources are available via:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz\n</code></pre> <p>You can leverage the <code>eb-tutorial</code> easyconfig file we have composed in the example above, but you should not make any manual changes to it!</p> (click to show solution) <p>You can use the <code>--try-software-version</code> option for this: <pre><code>$ eb eb-tutorial.eb --try-software-version 1.1.0\n...\n== building and installing eb-tutorial/1.1.0-GCC-9.3.0...\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> To test: <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial/1.1.0-GCC-9.3.0\n$ eb-tutorial\nI have a message for you:\nHello from the EasyBuild tutorial!\n</code></pre> (<code>eb-tutorial</code> version 1.0.0 doesn't print \"<code>I have a message for you:</code>\")</p> <p>Exercise 7.2 - Installing py-eb-tutorial 1.0.0</p> <p>Try composing an easyconfig file for the <code>py-eb-tutorial</code> example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz.</p> <p>A couple of tips:</p> <ul> <li> <p>There is a generic easyblock available for installing Python packages, which will come in useful here.</p> </li> <li> <p>By default EasyBuild performs an <code>import</code> check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the <code>options</code> easyconfig parameter in your easyconfig file:   <pre><code>options = {'modulename': 'example'}\n</code></pre>   (you will need to change '<code>example</code>' here, of course)</p> </li> <li> <p>Leverage the software that is already pre-installed in <code>/easybuild</code> in the prepared environment.   Remember that some already installed modules may be a bundle of a couple of other software packages.</p> </li> </ul> <p>Please also take this into account:</p> <ul> <li> <p>Unfortunately this software doesn't come with documentation. That is done to make it an example that   is representative for software that you may run into in the wild (it's not because   we were lazy when preparing the exercises, really!).   You can inspect the sources of this software here. Definitely take a look at the <code>setup.py</code> file, it includes some clues   about the requirements to get this software installed.</p> </li> <li> <p>Make sure the installation actually works, by checking that the <code>py-eb-tutorial</code> command runs correctly.   Maybe you will need to make sure other required software is available as well, for it to work correctly...</p> </li> </ul> (click to show solution) <p>Here is a complete working easyconfig file for <code>py-eb-tutorial</code>: <pre><code>easyblock = 'PythonPackage'\n\nname = 'py-eb-tutorial'\nversion = '1.0.0'\nversionsuffix = '-Python-%(pyver)s'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial Python example\"\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496']\n\ntoolchain = {'name': 'foss', 'version': '2020a'}\n\ndependencies = [\n    ('Python', '3.8.2'),\n    ('SciPy-bundle', '2020.03', versionsuffix),\n    ('eb-tutorial', '1.0.0'),\n]\n\nuse_pip = True\n\noptions = {'modulename': 'eb_tutorial'}\n\nsanity_check_paths = {\n    'files': ['bin/py-eb-tutorial'],\n    'dirs': ['lib/python%(pyshortver)s/site-packages'],\n}\n\nsanity_check_commands = [\"py-eb-tutorial\"]\n\nmoduleclass = 'tools'\n</code></pre></p> <p>Some remarks:</p> <ul> <li> <p>We used the <code>PythonPackage</code> generic easyblock. There is also a <code>PythonBundle</code> easyblock for installing   bundles of Python packages, which is used for <code>SciPy-bundle</code> for example. But we don't need that here,   since we are only dealing with a single Python package.</p> </li> <li> <p>The <code>versionsuffix</code> is not strictly needed, but it's common to tag Python packages with the Python version   for which they were installed. </p> </li> <li> <p>The SHA256 checksum for the source tarball was added automatically via <code>eb py-eb-tutorial.eb --inject-checksums</code>.</p> </li> <li> <p><code>py-eb-tutorial</code> only wants to be installed with <code>pip install</code>, so we had to set <code>use_pip = True</code>.   You can consult the custom easyconfig parameters supported by the <code>PythonPackage</code> easyblock via   \"<code>eb -a -e PythonPackage</code>\", see the <code>EASYBLOCK-SPECIFIC</code> part of the output.</p> </li> <li> <p>By default EasyBuild will try to import <code>py_eb_tutorial</code>, while the actual name of the Python package   provided by <code>py-eb-tutorial</code> is just <code>eb_tutorial</code>. We fixed this by specifying the correct Python module name to   use via <code>options</code>.</p> </li> <li> <p>Strictly speaking we don't need to specify a custom <code>sanity_check_paths</code>, since the default used   by Python package is already pretty decent (it will check for a non-empty <code>lib/python3.8/site-packages</code>   directory in the installation). We also want to make sure the <code>py-eb-tutorial</code> command is available in   the <code>bin</code> subdirectory however. Hardcoding to <code>python3.8</code> can be avoided using the <code>%(pyshortver)s</code>   template value.</p> </li> <li> <p>A good way to check whether the <code>py-eb-tutorial</code> command works correctly is by running it as a sanity check   command. If the <code>eb-tutorial</code> command is not available the <code>py-eb-tutorial</code> command will fail,   since it basically just runs the <code>eb-tutorial</code> command. So we need to include <code>eb-tutorial</code> as a (runtime)   dependency in the <code>py-eb-tutorial</code> easyconfig file.</p> </li> </ul>"},{"location":"2020-06-isc20/basic_usage/","title":"Basic usage","text":"<p>Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat or having to resist the urge to shout out four-letter words.</p> <p>We will look at the high-level workflow first, and then cover each aspect in more detail.</p> <p>A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!</p>"},{"location":"2020-06-isc20/basic_usage/#workflow","title":"Workflow","text":"<p>Installing software with EasyBuild is as easy (hah!) as specifying to the <code>eb</code> command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer).</p> <p>This is typically done by specifying the name of one or more easyconfig files, usually in combination with the <code>--robot</code> option to enable dependency resolution.</p> <p>It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild and ensure that the configuration options are what you would expect, for example.</p>"},{"location":"2020-06-isc20/basic_usage/#specifying-easyconfigs","title":"Specifying easyconfigs","text":"<p>Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the <code>--software-name</code> option won't be covered in this tutorial, since they are not commonly used. We will briefly cover how to install easyconfig files straight from a GitHub pull request later though (see here).</p> <p>Arguments passed to the <code>eb</code> command, being anything that is not an option (which starts with <code>-</code> or <code>--</code>) or is a value for a preceding option, are assumed to refer to easyconfig files. These could be:</p> <ul> <li>the (absolute or relative) path to an easyconfig file;</li> <li>the name of an easyconfig file;</li> <li>the path to a directory containing easyconfig files;</li> </ul> <p>Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message:</p> <pre><code>$ eb /tmp/does_not_exist.eb\nERROR: Can't find path /tmp/does_not_exist.eb\n</code></pre> <p>When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory. If no file with the specified name is found there EasyBuild will search for the easyconfig file in the robot search path.</p> <p>If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with '<code>.eb</code>', and (try to) use these as easyconfig files.</p>"},{"location":"2020-06-isc20/basic_usage/#example-command","title":"Example command","text":"<p>Suppose we have the current situation in our home directory:</p> <ul> <li>two (easyconfig) files named <code>example1</code> and <code>example2</code>;</li> <li>a subdirectory named <code>some_deps</code>, which has two easyconfig files <code>dep1.eb</code> and <code>dep2.eb</code>   alongside a text file named <code>list.txt</code>;</li> <li>a subdirectory named <code>more_deps</code> located in the <code>some_deps</code> subdirectory,   which contains another easyconfig file <code>dep3.eb</code>;</li> </ul> <p>Or, visually represented:</p> <pre><code>example1\nexample2\nsome_deps/\n|-- dep1.eb\n|-- dep2.eb\n|-- list.txt\n|-- more_deps/\n    |-- dep3.eb\n</code></pre> <p>In this context, we run the following EasyBuild command from our home directory:</p> <pre><code>eb bzip2-1.0.6.eb example1 $HOME/example2 some_deps\n</code></pre> <p>EasyBuild will interpret each of these arguments as follows:</p> <ul> <li><code>bzip2-1.0.6.eb</code> is the name of an easyconfig file to locate via the robot search path   (since it does not exist in the current directory);</li> <li><code>example1</code> is the name of a file in the current directory, so it can be used directly;</li> <li>likewise, <code>$HOME/example2</code> specifies the path to an existing file, which can be used directly;</li> <li><code>some_deps</code> is the relative path to an existing directory, so EasyBuild will scan it and find three   easyconfig files: <code>some_deps/dep1.eb</code>, <code>some_deps/dep2.eb</code> and <code>some_deps/more_deps/dep3.eb</code>,   ignoring the <code>list.txt</code> file since its name does not end with '<code>.eb</code>';</li> </ul>"},{"location":"2020-06-isc20/basic_usage/#easyconfig-filenames","title":"Easyconfig filenames","text":"<p>Note that the <code>eb</code> command does not care how easyconfig files are named, at least to some extent: the '<code>.eb</code>' file extension does matter w.r.t. easyconfig files being picked up in subdirectories.</p> <p>File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the <code>eb</code> command however. As we will learn soon, the name of easyconfig files does matter when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here).</p> <p>This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <code>&lt;name&gt;-&lt;version&gt;-&lt;toolchain&gt;&lt;versionsuffix&gt;.eb</code>, where:</p> <ul> <li><code>&lt;name&gt;</code> represents the software name;</li> <li><code>&lt;version&gt;</code> represents the software version;</li> <li><code>&lt;toolchain&gt;</code> represents the toolchain used in the easyconfig file, which consists of the toolchain name   and version separated with a dash (<code>-</code>); this part (including the preceding <code>-</code>) is omitted when the   <code>system</code> toolchain is used;</li> <li><code>&lt;versionsuffix&gt;</code> represents the value of the <code>versionsuffix</code> easyconfig parameter,   which is sometimes used to distinguish multiple variants of particular software installations   (and is empty by default);</li> </ul>"},{"location":"2020-06-isc20/basic_usage/#searching-for-easyconfigs","title":"Searching for easyconfigs","text":"<p>You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package,  which you can do by searching for easyconfigs using <code>eb --search</code> or <code>eb -S</code>.</p> <p>By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path you can use the <code>search-paths</code> configuration setting, or you can change the robot search path via either the <code>--robot</code> or <code>--robot-paths</code> option.</p> <p>Both the <code>--search</code> and <code>-S</code> options trigger the same search operation, but yield different output: <code>eb --search</code> will print the full path to each easyconfig file that matches the specified search pattern, while <code>eb -S</code> produces a more concise output.</p> <p>For example, let's check which easyconfig files are available for TensorFlow 2.2.0:</p> <pre><code>$ eb --search tensorflow-2.2.0\n * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb\n * /home/example/.local/easybuild/easyconfigs/t/TensorFlow/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb\n</code></pre> <p>This output is a bit more condensed when using <code>eb -S</code>:</p> <pre><code>$ eb -S tensorflow-2.2.0\nCFGS1=/home/example/.local/easybuild/easyconfigs/t/TensorFlow\n * $CFGS1/TensorFlow-2.2.0-foss-2019b-Python-3.7.4.eb\n * $CFGS1/TensorFlow-2.2.0-fosscuda-2019b-Python-3.7.4.eb\n</code></pre> <p>Note that the search is performed case-insensitive.</p> <p>The search pattern can include wildcards like <code>.*</code> and/or character groups like <code>[0-9]</code>, but you need to be careful that <code>bash</code> does not expand these before the <code>eb</code> command is started, so it is recommended to wrap the search pattern in single quotes (<code>'...'</code>) when using wildcards.</p> <p>For example, to check which easyconfigs are available to install OpenFOAM with the <code>foss/2019b</code> toolchain:</p> <pre><code>$ eb -S 'openfoam-[0-9].*foss-2019b'\nCFGS1=/home/example/.local/easybuild/easyconfigs/o/OpenFOAM\n * $CFGS1/OpenFOAM-6-foss-2019b.eb\n * $CFGS1/OpenFOAM-7-foss-2019b.eb\n</code></pre>"},{"location":"2020-06-isc20/basic_usage/#search-index","title":"Search index","text":"<p>When searching for easyconfig files, you may see a message like this pop up:</p> <pre><code>== found valid index for &lt;path&gt;, so using it...\n</code></pre> <p>This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of small files are rather slow.</p> <p>For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using <code>eb --create-index &lt;path&gt;</code>.</p> <p>See the EasyBuild documentation for more information.</p>"},{"location":"2020-06-isc20/basic_usage/#inspecting-easyconfigs","title":"Inspecting easyconfigs","text":"<p>Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it.</p> <p>Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous <code>cat</code> command or your favorite text editor (<code>vim</code>, what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use <code>eb --show-ec</code>.</p> <p>For example, let's inspect the contents of the <code>bzip2-1.0.6.eb</code> easyconfig file:</p> <pre><code>$ eb --show-ec bzip2-1.0.6.eb\n== temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log\n== Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb:\nname = 'bzip2'\nversion = '1.0.6'\n\nhomepage = 'https://sourceware.org/bzip2'\ndescription = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically\ncompresses files to within 10% to 15% of the best available techniques (the PPM family of statistical\ncompressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\"\n\ntoolchain = SYSTEM\ntoolchainopts = {'pic': True}\n\nsource_urls = ['https://sourceware.org/pub/bzip2/']\nsources = [SOURCE_TAR_GZ]\npatches = ['bzip2-%(version)s-pkgconfig.patch']\nchecksums = [\n'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd',  # bzip2-1.0.6.tar.gz\n'5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d',  # bzip2-1.0.6-pkgconfig.patch\n]\n\nbuildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $(BIGFILES)'\"\n\n# building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...)\nwith_shared_libs = OS_TYPE == 'Linux'\n\nmoduleclass = 'tools'\n\n== Temporary log file(s) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed.\n== Temporary directory /tmp/eb-jnpzclhl has been removed.\n</code></pre> <p>We'll get back to what all of this means later, in the part where we discuss writing easyconfig files.</p>"},{"location":"2020-06-isc20/basic_usage/#checking-dependencies","title":"Checking dependencies","text":"<p>Note</p> <p>In some of the examples below, we assume that some software is already installed with EasyBuild.</p> <p>If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \"<code>module avail</code>\".</p> <p>When using the prepared container image, run this command to make the already installed software stack available: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing.</p> <p>This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like <code>$HOME/.local/easybuild</code>, the default installation path).</p>"},{"location":"2020-06-isc20/basic_usage/#dry-run","title":"Dry run","text":"<p>To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use <code>eb --dry-run</code>.</p> <p>Since <code>--dry-run</code> produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: <code>eb --dry-run-short</code>, which is equivalent with <code>eb -D</code>.</p> <p>For example, to check which of the dependencies that are required for <code>SAMtools-1.10-GCC-9.3.0.eb</code> are already installed:</p> <pre><code>$ eb SAMtools-1.10-GCC-9.3.0.eb -D\n== temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\nDry run: printing build status of easyconfigs and dependencies\nCFGS=/home/example/.local/easybuild/easyconfigs\n ...\n * [x] $CFGS/b/bzip2/bzip2-1.0.8-GCCcore-9.3.0.eb (module: bzip2/1.0.8-GCCcore-9.3.0)\n* [x] $CFGS/x/XZ/XZ-5.2.5-GCCcore-9.3.0.eb (module: XZ/5.2.5-GCCcore-9.3.0)\n* [x] $CFGS/c/cURL/cURL-7.69.1-GCCcore-9.3.0.eb (module: cURL/7.69.1-GCCcore-9.3.0)\n* [x] $CFGS/g/GCC/GCC-9.3.0.eb (module: GCC/9.3.0)\n* [x] $CFGS/n/ncurses/ncurses-6.2-GCCcore-9.3.0.eb (module: ncurses/6.2-GCCcore-9.3.0)\n* [ ] $CFGS/s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb (module: SAMtools/1.10-GCC-9.3.0)\n</code></pre> <p>(We've trimmed the output a bit here, for the sake of brevity.)</p> <p>This output tells us that all dependencies required by <code>SAMtools-1.10-GCC-9.3.0.eb</code> are already installed, since they are all marked with <code>[x]</code>, whereas the easyconfig for <code>SAMtools</code> itself is not installed yet, as indicated by lack of an '<code>x</code>' in <code>[ ]</code>.</p>"},{"location":"2020-06-isc20/basic_usage/#missing-dependencies","title":"Missing dependencies","text":"<p>If you are only interested in which dependencies are still missing, you can consult the output of <code>eb --missing</code>, or the equivalent <code>eb -M</code>.</p> <p>For example, let's see which dependencies are missing in order to get <code>h5py</code> version 2.10.0 using the <code>2020a</code> version of the <code>foss</code> toolchain installed:</p> <pre><code>$ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb -M\n\n2 out of 54 required modules missing:\n\n* pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 (pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb)\n* h5py/2.10.0-foss-2020a-Python-3.8.2 (h5py-2.10.0-foss-2020a-Python-3.8.2.eb)\n</code></pre> <p>That should be pretty self-explanatory: out of the 54 required dependencies (which includes the <code>foss</code> toolchain and everything needed to install it), only 2 dependencies are missing. Great!</p>"},{"location":"2020-06-isc20/basic_usage/#inspecting-install-procedures","title":"Inspecting install procedures","text":"<p>Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software.</p> <p>Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation.</p> <p>Using <code>eb --extended-dry-run</code>, or just <code>eb -x</code> for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild, in a matter of seconds.</p> <p>By means of example, let's inspect some parts of the installation procedure for <code>Boost-1.72.0-gompi-2020a.eb</code>:</p> <pre><code>$ eb Boost-1.72.0-gompi-2020a.eb -x\n...\n\npreparing... [DRY RUN]\n\n[prepare_step method]\nDefining build environment, based on toolchain (options) and specified dependencies...\n\nLoading toolchain module...\n\nmodule load gompi/2020a\n\nLoading modules for dependencies...\n\nmodule load bzip2/1.0.8-GCCcore-9.3.0\nmodule load zlib/1.2.11-GCCcore-9.3.0\nmodule load XZ/5.2.5-GCCcore-9.3.0\n\n...\n\nDefining build environment...\n\n  ...\n  export CXX='mpicxx'\nexport CXXFLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC'\n...\n\nconfiguring... [DRY RUN]\n\n[configure_step method]\nrunning command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.72.0/gompi-2020a/obj --without-libraries=python\"\n(in /tmp/kehoste/fakehome/.local/easybuild/build/Boost/1.72.0/gompi-2020a/Boost-1.72.0)\nfile written: user-config.jam\n\n...\n\n[sanity_check_step method]\nSanity check paths - file ['files']\n* lib/libboost_mpi.so\n  * lib/libboost_system.so\nSanity check paths - (non-empty) directory ['dirs']\n* include/boost\nSanity check commands\n  (none)\n\n...\n</code></pre> <p>We've obviously trimmed the generated output a bit, but it should be sufficient.</p> <p>An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows:</p> <ul> <li>how the build environment will be set up during the <code>prepare</code> step, by loading the module for both the   toolchains and the dependencies, and defining a set of environment variables like <code>$CXX</code>, <code>$CXXFLAGS</code>, etc.</li> <li>which command will be executed during the configuration step and in which directory,   and that a file named <code>user-config.jam</code> will be created as well;</li> <li>the list of files and directories that will be checked during the sanity check step;</li> </ul> <p>If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now.</p> <p>Note</p> <p>It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using <code>eb -x</code>, the reported installation procedure could be partially incorrect.</p> <p>In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by <code>eb -x</code> though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.</p>"},{"location":"2020-06-isc20/basic_usage/#installing-software","title":"Installing software","text":"<p>You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require.</p> <p>As mentioned before, installing an easyconfig is as simple as passing it to the <code>eb</code> command.</p> <p>So, let's try to install SAMtools version 1.10:</p> <pre><code>$ eb SAMtools-1.10-GCC-9.3.0.eb\n== temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.10-GCC-9.3.0.eb\n== building and installing SAMtools/1.10-GCC-9.3.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== building...\n== testing...\n== installing...\n== taking care of extensions...\n== restore after iterating...\n== postprocessing...\n== sanity checking...\n== cleaning up...\n== creating module...\n== permissions...\n== packaging...\n== COMPLETED: Installation ended successfully (took 11 sec)\n== Results of the build can be found in the log file(s) /tmp/example/isc20/easybuild/software/SAMtools/1.10-GCC-9.3.0/easybuild/easybuild-SAMtools-1.10-20200610.195601.log\n== Build succeeded for 1 out of 1\n== Temporary log file(s) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed.\n== Temporary directory /tmp/eb-zh7_fyre has been removed.\n</code></pre> <p>That was... easy. Is that really all there is to it? Well, almost...</p>"},{"location":"2020-06-isc20/basic_usage/#enabling-dependency-resolution","title":"Enabling dependency resolution","text":"<p>The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above).</p> <p>If we try this with the <code>Bowtie2-2.4.1-GCC-9.3.0.eb</code>, for which the required <code>tbb</code> dependency is not available yet, it's less successful:</p> <pre><code>$ eb Bowtie2-2.4.1-GCC-9.3.0.eb -M\n\n2 out of 17 required modules missing:\n\n* tbb/2020.1-GCCcore-9.3.0 (tbb-2020.1-GCCcore-9.3.0.eb)\n* Bowtie2/2.4.1-GCC-9.3.0 (Bowtie2-2.4.1-GCC-9.3.0.eb)\n</code></pre> <pre><code>$ eb Bowtie2-2.4.1-GCC-9.3.0.eb   \n...\n== preparing...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0): build failed (first 300 chars): Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0 (took 1 min 57 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-x5ik_8b5/easybuild-Bowtie2-2.4.1-20200610.200056.qfgfI.log\nERROR: Build of /home/example/.local/easybuild/easyconfigs/b/Bowtie2/Bowtie2-2.4.1-GCC-9.3.0.eb failed (err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0')\n</code></pre> <p>Oh my, what's this all about?</p> <p>If we filter the output a bit and focus on the actual error, the problem is clear:</p> <pre><code>Missing modules for dependencies (use --robot?): tbb/2020.1-GCCcore-9.3.0\n</code></pre> <p>The required dependency <code>tbb/2020.1-GCCcore-9.3.0</code> is not installed yet, and EasyBuild does not automatically install missing dependencies unless it is configured to do so.</p> <p>It helpfully suggests to use the <code>--robot</code> command line option, so let's try that:</p> <pre><code>$ eb Bowtie2-2.4.1-GCC-9.3.0.eb --robot\n...\n== resolving dependencies ...\n...\n== building and installing tbb/2020.1-GCCcore-9.3.0...\n...\n== COMPLETED: Installation ended successfully (took 1 min 4 sec)\n...\n== building and installing Bowtie2/2.4.1-GCC-9.3.0...\n...\n== COMPLETED: Installation ended successfully (took 6 min 39 sec)\n...\n== Build succeeded for 2 out of 2\n</code></pre> <p>With dependency resolution enabled the <code>tbb/2020.1-GCCcore-9.3.0</code> module gets installed first, before EasyBuild proceeds with installing Bowtie2. Great!</p>"},{"location":"2020-06-isc20/basic_usage/#trace-output","title":"Trace output","text":"<p>As you may have noticed if you tried the previous example hands-on, the installation of Bowtie2 takes a while. The installation was spending quite a bit of time during the build step, but what was actually going on there?</p> <p>To provide some more feedback as the installation progresses, you can enable the \"<code>trace</code>\" configuration setting. Let's do this by defining the <code>$EASYBUILD_TRACE</code> environment variable, just to avoid having to type <code>--trace</code> over and over again.</p> <p>We will redo the installation of <code>Bowtie2-2.4.1-GCC-9.3.0.eb</code> by passing the <code>--rebuild</code> option to the <code>eb</code> command (try yourself what happens if you don't use the <code>--rebuild</code> option!):</p> <pre><code>$ export EASYBUILD_TRACE=1\n$ eb Bowtie2-2.4.1-GCC-9.3.0.eb --rebuild\n...\n== building...\n  &gt;&gt; running command:\n        [started at: 2020-06-10 20:22:13]\n[working dir: /tmp/example/Bowtie2/2.4.1/GCC-9.3.0/bowtie2-2.4.1]\n[output logged in /tmp/eb-jx1khbgf/easybuild-run_cmd-frodru6e.log]\nmake -j 4  CC=\"gcc\"  CPP=\"g++\" CXX=\"g++\"  RELEASE_FLAGS=\"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\"\n&gt;&gt; command completed: exit 0, ran in 00h01m03s\n</code></pre> <p>That's a bit more comforting to stare at...</p> <p>During the build step the software is actually being compiled by running the <code>make</code> command. EasyBuild automatically uses the available cores on the system (in this case 4), and passes several options to ensure the right compiler commands and compiler options are used.</p> <p>We even get a pointer to a log file that contains the output of the command being run, so we can use <code>tail -f</code> to see in detail how it progresses.</p> <p>Once the <code>make</code> command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 1 min 3 sec to run. That's good to know.</p> <p>Later during the installation, we now also see this output during the sanity check step:</p> <pre><code>== sanity checking...\n  &gt;&gt; file 'bin/bowtie2' found: OK\n  &gt;&gt; file 'bin/bowtie2-build' found: OK\n  &gt;&gt; file 'bin/bowtie2-inspect' found: OK\n  ...\n  &gt;&gt; (non-empty) directory 'doc' found: OK\n  &gt;&gt; (non-empty) directory 'example' found: OK\n  &gt;&gt; (non-empty) directory 'scripts' found: OK\n</code></pre> <p>Thanks to enabling trace mode, EasyBuild tells us which files &amp; directories it is checking for in the installation, before declaring it a success. Nice!</p> <p>The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.</p>"},{"location":"2020-06-isc20/basic_usage/#using-installed-software","title":"Using installed software","text":"<p>So far, we have already installed 3 different software packages (SAMtools, tbb, and Bowtie2); we even installed Bowtie2 twice!</p> <p>A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, created and populating the installation directory, performing a quick sanity check on the installation, cleaning things up and finally generated the environment module file corresponding to the installation.</p> <p>That's great, but how do we now actually use these installations?</p> <p>This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous <code>module</code> command to digest them.</p> <p>First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of <code>eb --show-config</code>; the value of the <code>installpath</code> configuration setting is what we are interested in now:</p> <pre><code>$ eb --show-config\n...\ninstallpath    (E) = /home/example/easybuild\n...\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\n...\nsourcepath     (E) = /home/example/easybuild/sources\n...\n</code></pre> <p>So, what's in this directory?</p> <pre><code>$ ls -l $HOME/easybuild\ntotal 16\ndrwxrwxr-x 5 example example 4096 Jun 10 20:11 ebfiles_repo\ndrwxrwxr-x 5 example example 4096 Jun 10 20:10 modules\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 software\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 sources\n</code></pre> <p>The <code>ebfiles_repo</code> and <code>sources</code> directories correspond to the <code>repositorypath</code> and <code>sourcepath</code> configuration settings, respectively. The <code>modules</code> and <code>software</code> directories are what we need now.</p> <p>The <code>modules</code> subdirectory consists of multiple subdirectories:</p> <pre><code>$ ls $HOME/easybuild/modules\nall  bio  lib\n</code></pre> <p>The <code>bio</code> and <code>lib</code> directories correspond to different software categories, and contain symbolic links to the module files in the <code>all</code> directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now.</p> <p>Let's inform the modules tool about the existence of these module files using <code>\"module use\"</code>:</p> <pre><code>module use $HOME/easybuild/modules/all\n</code></pre> <p>This command does little more that updating the <code>$MODULEPATH</code> environment variable, which contains a list of paths that the modules tool should consider when looking for module files.</p> <p>Now the modules tool should be aware of our brand new installations:</p> <pre><code>$ module avail\n\n------------ /home/example/easybuild/modules/all ------------\n   Bowtie2/2.4.1-GCC-9.3.0    bzip2/1.0.6\n   SAMtools/1.10-GCC-9.3.0    tbb/2020.1-GCCcore-9.3.0\n\n------------------- /easybuild/modules/all -------------------\n    ...\n</code></pre> <p>This output shows both the modules for our own installations as well as the \"central\" installations in <code>/easybuild</code> (which we omitted above for brevity).</p> <p>Now we can load these modules and start using these software installations.</p> <p>Let's test this for Bowtie2. In our current environment, the <code>bowtie2</code> command is not available yet:</p> <pre><code>$ module list\nNo modules loaded\n\n$ bowtie2\nbash: bowtie2: command not found\n</code></pre> <p>Loading the module for Bowtie2 changes that:</p> <pre><code>$ module load Bowtie2/2.4.1-GCC-9.3.0\n\n$ module list\nCurrently Loaded Modules:\n  1) GCCcore/9.3.0\n  2) zlib/1.2.11-GCCcore-9.3.0\n  3) binutils/2.34-GCCcore-9.3.0\n  4) GCC/9.3.0\n  5) tbb/2020.1-GCCcore-9.3.0\n  6) Bowtie2/2.4.1-GCC-9.3.0\n\n$ bowtie2 --version\n/home/example/easybuild/software/Bowtie2/2.4.1-GCC-9.3.0/bin/bowtie2-align-s version 2.4.1\n64-bit\nBuilt on \nWed Jun 10 20:33:29 UTC 2020\nCompiler: gcc version 9.3.0 (GCC) \nOptions: -O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98 -O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98 -DPOPCNT_CAPABILITY -DWITH_TBB -std=c++11 -DNO_SPINLOCK -DWITH_QUEUELOCK=1\nSizeof {int, long, long long, void*, size_t, off_t}: {4, 8, 8, 8, 8, 8}\nBowtie 2 version 2.4.1\nUsage: bowtie2 [options]* -x &lt;bt2-idx&gt; {-1 &lt;m1&gt; -2 &lt;m2&gt; | -U &lt;r&gt; | --interleaved &lt;i&gt; | -b &lt;bam&gt;} [-S &lt;sam&gt;]\n</code></pre> <p>Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like <code>libstdc++.so</code>), are loaded automatically. The \"<code>module load</code>\" command changes the active environment, by updating environment variables like <code>$PATH</code> for example, to make the software available for use.</p>"},{"location":"2020-06-isc20/basic_usage/#resetting-your-environment","title":"Resetting your environment","text":"<p>To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \"<code>module unload</code>\", or you can unload all of them at once using \"<code>module purge</code>\".</p> <p>If you are using an EasyBuild installation provided by a module, don't forget to load the <code>EasyBuild</code> module again after running \"<code>module purge</code>\".</p>"},{"location":"2020-06-isc20/basic_usage/#stacking-software","title":"Stacking software","text":"<p>Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in <code>$HOME/easybuild</code>) on top of installations that are provided in a totally different location (<code>/easybuild</code>).</p> <p>EasyBuild doesn't care where software is installed, as long as the module file that provides access to it is available it is happy to pick it up and use it when required.</p> <p>This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).</p>"},{"location":"2020-06-isc20/basic_usage/#hands-on-exercises","title":"Hands-on exercises","text":"<p>Guidelines</p> <p>Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself!</p> <p>Please do not spoil solutions to others before they have been discussed by the tutorial organisers.</p> <p>Exercise 4.0 - Making installed software available</p> <p>Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available.</p> <p>For the <code>easybuilders/tutorial</code> container image, we have installed a small software stack with the <code>2020a</code> version of the <code>foss</code> toolchain in <code>/easybuild/</code>.</p> <p>Tip: execute a \"<code>module use</code>\" command, and verify with \"<code>module avail</code>\" that a bunch of software modules are available for loading.</p> (click to show solution) <p>Use the following command to make the modules for the software available that is pre-installed in the prepared environment: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>If software is installed in a different location than <code>/easybuild/</code> in your environment, you should adjust the command accordingly.</p> <p>Exercise 4.1 - Searching easyconfigs</p> <p>See if EasyBuild provides any easyconfig files for installing GROMACS version 2019.4.</p> (click to show solution) <p>To check for available easyconfig files, we can use <code>eb --search</code> or <code>eb -S</code>: <pre><code>$ eb -S gromacs-2019.4\nCFGS1=/home/example/.local/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2019.4-foss-2019b.eb\n</code></pre></p> <p>Exercise 4.2 - Checking dependencies</p> <p>Check which dependencies are missing to install PETSc version 3.12.4 with the <code>2020a</code> version of the <code>foss</code> toolchain.</p> (click to show solution) <p>First, we need to determine the name of the easyconfig file for PETSc version 3.12.4: <pre><code>$ eb -S 'PETSc-3.12.4.*foss-2020a'\nCFGS1=/home/example/.local/easybuild/easyconfigs/p/PETSc\n * $CFGS1/PETSc-3.12.4-foss-2020a-Python-3.8.2.e\n</code></pre></p> <p>To determine which dependencies are missing to install this PETSc easyconfig file, we can use <code>--missing</code>: <pre><code>$ eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing\n\n7 out of 57 required modules missing:\n\n* METIS/5.1.0-GCCcore-9.3.0 (METIS-5.1.0-GCCcore-9.3.0.eb)\n* Boost/1.72.0-gompi-2020a (Boost-1.72.0-gompi-2020a.eb)\n* SCOTCH/6.0.9-gompi-2020a (SCOTCH-6.0.9-gompi-2020a.eb)\n* MUMPS/5.2.1-foss-2020a-metis (MUMPS-5.2.1-foss-2020a-metis.eb)\n* SuiteSparse/5.7.1-foss-2020a-METIS-5.1.0 (SuiteSparse-5.7.1-foss-2020a-METIS-5.1.0.eb)\n* Hypre/2.18.2-foss-2020a (Hypre-2.18.2-foss-2020a.eb)\n* PETSc/3.12.4-foss-2020a-Python-3.8.2 (PETSc-3.12.4-foss-2020a-Python-3.8.2.eb)eb PETSc-3.12.4-foss-2020a-Python-3.8.2.eb --missing\n</code></pre></p> <p>Exercise 4.3 - Performing a dry run</p> <p>Figure out which command EasyBuild would use to perform the actual installation of the software provided by the <code>GSL-2.6-GCC-9.3.0.eb</code> easyconfig file, without actually installing <code>GSL</code>.</p> <p>Also, which binaries will EasyBuild check for to sanity check the installation?</p> (click to show solution) <p>To inspect the installation procedure, we can use <code>eb -x GSL-2.6-GCC-9.3.0.eb</code>.</p> <p>The output for the install step shows the actual installation command (<code>make install</code>):</p> <pre><code>[make_installdir method]\ndirectory /home/example/easybuild/software/GSL/2.6-GCC-9.3.0 removed\n[install_step method]\n&gt;&gt; running command:\n        [started at: 2020-06-10 21:38:14]\n[working dir: /tmp/eb-u3gkcgvv/__ROOT__/tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6]mp/eb-u3gkcgvv/easybuild-run_cmd-7cl9s7xi.log]e install\n  running command \"make install\"\n(in /tmp/example/GSL/2.6/GCC-9.3.0/GSL-2.6)\n</code></pre> <p>The output for the sanity check step shows which binaries are expected to be installed: <pre><code>[sanity_check_step method]\nSanity check paths - file ['files']\n  * bin/gsl-config\n  * bin/gsl-histogram\n  * bin/gsl-randist\n</code></pre></p> <p>Exercise 4.4 - Installing software</p> <p>Install the <code>h5py</code> Python package and all missing dependencies on top of Python 3.8.2, into <code>/tmp/$USER/easybuild</code>, while leveraging the already installed software available from <code>/easybuild</code>.</p> <p>Enable trace output so you can see which parts of the installation take a while.</p> (click to show solution) <p>First, determine the easyconfig file we can use for this: <pre><code>$ eb -S 'h5py.*Python-3.8.2'\nCFGS1=/home/example/.local/easybuild/easyconfigs/h/h5py\n* $CFGS1/h5py-2.10.0-foss-2020a-Python-3.8.2.eb\n</code></pre></p> <p>Make sure the pre-install software in <code>/easybuild/</code> is available: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>Check which dependencies are missing to install <code>h5py</code>: <pre><code>$ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --missing\n2 out of 54 required modules missing:\n\n* pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2 (pkgconfig-1.5.1-GCCcore-9.3.0-Python-3.8.2.eb)\n* h5py/2.10.0-foss-2020a-Python-3.8.2 (h5py-2.10.0-foss-2020a-Python-3.8.2.eb)\n</code></pre></p> <p>Install <code>h5py</code> by specifying the easyconfig file and enabling dependency resolution via <code>--robot</code>, while indicating that we want to install the software into <code>/tmp/$USER/easybuild</code> using the <code>--installpath</code> option. Also make sure that trace mode is enabled by defining the <code>$EASYBUILD_TRACE</code> environment variable. <pre><code>$ export EASYBUILD_TRACE=1\n$ eb h5py-2.10.0-foss-2020a-Python-3.8.2.eb --robot --installpath /tmp/$USER/easybuild\n...\n== building and installing pkgconfig/1.5.1-GCCcore-9.3.0-Python-3.8.2...\n...\n== building and installing h5py/2.10.0-foss-2020a-Python-3.8.2...\n...\n== building...\n  &gt;&gt; running command:\n        [started at: 2020-06-10 21:47:32]\n[working dir: /tmp/example/h5py/2.10.0/foss-2020a-Python-3.8.2/h5py-2.10.0]\n[output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log]  python setup.py configure --mpi --hdf5=$EBROOTHDF5 &amp;&amp; /easybuild/software/Python/3.8.2-GCCcore-9.3.0/bin/python setup.py build\n  &gt;&gt; command completed: exit 0, ran in 00h01m27s\n...\n== COMPLETED: Installation ended successfully (took 2 min 46 sec)\n...\n== Build succeeded for 2 out of 2\n</code></pre></p> <p>The trace output shows that most time is spent in the build command, which runs both <code>python setup.py configure</code> and <code>python setup.py build</code>.</p> <p>Exercise 4.5 - Using installed software</p> <p>Using the <code>h5py</code> installation from the previous exercise to create an empty HDF5 file, using the following Python statements:</p> <pre><code>import h5py\nf = h5py.File(\"empty.hdf5\", \"w\")\nf.close()\n</code></pre> <p>Check the resulting file using the <code>h5stat</code> command.</p> (click to show solution) <p>First, we need to make the modules tool aware of the module files that were installed into <code>/tmp/$USER/easybuild</code>: <pre><code>module use /tmp/$USER/easybuild/modules/all\n</code></pre></p> <p>Then we can check the <code>h5py</code> module is available, and load it: <pre><code>$ module avail h5py\n------------ /tmp/example/easybuild/modules/all ------------\nh5py/2.10.0-foss-2020a-Python-3.8.2\n</code></pre></p> <pre><code>module load h5py/2.10.0-foss-2020a-Python-3.8.2\n</code></pre> <p>The Python code snippet can be run directly on the command line using \"<code>python -c '...'</code>\", since it's tiny: <pre><code>python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()'\n</code></pre> Of course yu can also copy the Python code snippet in a file named <code>test_h5py.py</code>, and then run it with <code>python test_h5py.py</code>.</p> <p>Checking with the <code>h5stat</code> command shows that the resulting <code>empty.hdf5</code> is indeed a valid HDF5 file: <pre><code>$ ls -l empty.hdf5 \n-rw-rw-r-- 1 example example 800 Jun 10 21:54 empty.hdf5\n\n$ h5stat empty.hdf5\nFilename: empty.hdf5\nFile information\n        # of unique groups: 1\n# of unique datasets: 0\n...\n</code></pre></p> <p>If you've made it through the hands-on exercises, congratulations!</p> <p>If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time...</p> <p>Feel free to ask question in the <code>#tutorial</code> channel in the EasyBuild Slack, we're happy to help!</p>"},{"location":"2020-06-isc20/community/","title":"The EasyBuild community","text":""},{"location":"2020-06-isc20/community/#the-early-years","title":"The early years","text":"<p>EasyBuild as a project was conceived in 2009 by the HPC team at Ghent University (Belgium). The codebase was developed in-house, and went through a couple of redesigns as the team gradually learned the ropes of developing a sizeable software project and tried to tackle the never-ending corner cases of the installation procedures of scientific software. During these very early days, several summer interns were invaluable in their assistance in refining EasyBuild.</p> <p>As the project grew and its usefulness became apparent, the HPC-UGent team begun to desire feedback from the HPC community at large. Maybe others would find EasyBuild useful? Or maybe this was actually a solved problem, and they were unknowingly reinventing the wheel...</p> <p>The first step in this process was to pick a license. As many an in-house project, EasyBuild at the time lacked such formalities. This led to a short debate on open source licenses before the team landed on GPLv2. And no, commercial licenses never even made it to the table. Like so many open source projects, the goal was simple enough; scratch HPC-UGent's own itch  and get some outside feedback to help in getting it done!</p> <p>The first public release of EasyBuild became available in April 2012 and was tagged as version 0.5. This public release took place mostly out of necessity as the project was about to be presented at the HEPIX Spring Workshop 2012. Based on early feedback, the EasyBuild team realised others would indeed find EasyBuild useful, so efforts were made to produce a stable version to ensure that others could rely on the project if they wanted to.</p> <p>(EasyBuild v1.0) was released in November 2012, barely seven months after version 0.5 was published. This first stable release coincided with the SC'12 conference in Salt Lake City, where the team handed out stickers and went around asking how everyone else installed scientific software. There was never much of a sales pitch, but the conversations very quickly took on a rather predictable script...</p> <p>EasyBuild team member: How do you install scientific software?</p> <p>HPC staff: We do it manually, and spend a lot of time on it. </p> <p>EasyBuild team member: What if there was a tool that could help?</p> <p>HPC staff: Nobody in their right mind would develop a tool like that. That's madness.</p> <p>EasyBuild team member: What if we have a tool like this that you could use?</p> <p>HPC staff: What does it cost? </p> <p>EasyBuild team member: It's open source. It's free.</p> <p>HPC staff: ... Yeah, cool. What about the hard stuff? When will you support OpenFOAM? </p> <p>EasyBuild team member: We already do. And we support WRF too.</p> <p>And then suddenly everyone was a friend. Beers and snacks started appearing out of nowhere and all the stickers disappeared. Once the beers and snacks had been \"processed\", EasyBuild took its place on the presentation floor. At SC'12, EasyBuild's stage was the PyHPC 2012 workshop.</p> <p>Following the public release and the projects introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. As odd as it might sound, this was quite unexpected. The EasyBuild team was hoping for feedback. Receiving contributions was a big surprising bonus.  Early adopters were the University of Luxembourg, the Cyprus Institute, the University of Basel, and the J\u00fclich Supercomputing Centre.</p>"},{"location":"2020-06-isc20/community/#a-worldwide-community","title":"A worldwide community","text":"<p>Over the years EasyBuild has grown into a community project, which is used and developed by dozens (hundreds?) of HPC centres and consortia worldwide. Starting in 2016, the community has gathered for a yearly EasyBuild User Meeting which typically takes place a week before or after FOSDEM. The EasyBuild User Meeting is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild enthusiasts, discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins, Ansible, CernVM-FS, ReFrame etc.</p> <p>The map below shows from which cities the EasyBuild documentation has been visited in the last year (June 2019 - June 2020), and how often. The community has truly become global.</p> <p>HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):</p> <p> </p>"},{"location":"2020-06-isc20/community/#development","title":"Development","text":"<p> The EasyBuild community develops the project through the easybuilders GitHub organisation as set of repositories:</p> <ul> <li>easybuild-framework (EasyBuild framework codebase)</li> <li>easybuild-easyblocks (collection of easyblocks)</li> <li>easybuild-easyconfigs (collection of easyconfigs)</li> <li>easybuild (documentation)</li> <li>easybuild-tutorial (this tutorial)</li> </ul>"},{"location":"2020-06-isc20/community/#maintainers","title":"Maintainers","text":"<p>EasyBuild is maintained by an experienced team of HPC experts, including people from:</p> <ul> <li>Ghent University (Belgium)</li> <li>Vrije Universiteit Brussel (Belgium)</li> <li>Compute Canada</li> <li>J\u00fclich Supercomputing Centre (Germany)</li> <li>SURF (Netherlands)</li> <li>National University of Singapore</li> <li>Chalmers University of Technology (Sweden)</li> <li>Ume\u00e5 University (Sweden)</li> <li>sciCORE at the University of Basel (Switzerland)</li> <li>Swiss Data Science Center</li> <li>Big Data Institute Oxford (UK)</li> </ul> <p>The EasyBuild maintainers implement additional features and bug fixes, review and test incoming contributions, and frequently release new stable versions.</p>"},{"location":"2020-06-isc20/comparison_other_tools/","title":"Comparison with other tools","text":"<p>The project that most compares with EasyBuild is Spack, a flexible package manager for HPC systems.</p> <p>It was created by Todd Gamblin at Lawrence Livermore National Lab (LLNL) in California, USA.</p> <p>In several ways it looks similar to EasyBuild:</p> <ul> <li>implemented in Python, compatible with Python 2.6 and 3.5+</li> <li>open source software, development on GitHub</li> <li>similar high-level structure (core + packages)</li> <li>supports installing (scientific) software without admin privileges</li> <li>strong focus on HPC and performance</li> <li>highly configurable</li> <li>well documented (see https://spack.readthedocs.io/)</li> <li>generates environment modules files</li> <li>worldwide community</li> <li>broad spectrum of supported software (1000s)</li> </ul> <p>In other ways, EasyBuild and Spack are quite different. Spack is released under a more permissive open source license (MIT/Apache 2.0 dual license), and  whereas EasyBuild supports Linux and Cray PE, Spack also provides good support for macOS out-of-the-box.</p> <p>The Spack command line interface is quite different from EasyBuild: it supports subcommands (like \"<code>spack install</code>\"), and provides a flexible interface for specifying an abstract specification of what to install. Here is an example:</p> <pre><code>spack install mpileaks@3.3 ^mpich@3.2 %gcc@4.9.3\n</code></pre> <p>This tells Spack to install <code>mpileaks</code> version 3.3 on top of MPICH version 3.2, using GCC 4.9.3 as compiler.</p> <p>This abstract specification is then passed to a concretization algorithm which fills in the blanks: it will pick versions of other required dependencies, determine which compiler flags to use, and so on. This information is fed to the Spack package (which is the equivalent of an easyblock in EasyBuild) to perform the actual installation.</p> <p>There are many other differences between EasyBuild and Spack as well, too many for this document to cover in detail. See the \"Installing software for scientists on a multi-user HPC system\" recorded talk at FOSDEM'18 and the Spack documentation for more information.</p> <p> </p> <p>Nix and GNU Guix are both purely functional package managers, which strongly focus on the reproducibility of software installations.</p> <p>In Nix packages are expressed as Nix expressions (a custom DSL), and software installations are usually done in the Nix store, a dedicated installation directory, each in a specific subdirectory that includes a unique identifier for that installation. For example:</p> <pre><code>/nix/store/b6gvzjyb2pg0kjfwrjmg1vfhh54ad73z-firefox-33.1/\n</code></pre> <p>Guix is very similar to Nix, but is a separate project entirely. There is a dedicated Guix HPC community that focuses on the use of Guix in an HPC context. Packages in Guix are implemented in Guile Scheme, and many advanced features like transactional upgrades and rollbacks are supported.</p> <p>To the best of our knowledge, neither of these tools have seen wide adoption in the HPC community to date.</p> <p></p> <p>Conda is a package manager that runs on Windows, macOS and Linux, and is very popular in the scientific community.</p> <p>It focuses on quick installation of software and ease of use, and lets users create a conda environment in which they can install one or more packages. These packages are usually pre-built generic binaries however, which significantly impacts the performance of the installations.</p> <p>Despite wide adoption in the scientific community <code>conda</code> is not a good fit for HPC systems for a number of reasons, including poor support for multi-user environments, a lack of focus on performance, heavily relying on the home directory (which usually is limited in size on HPC systems), and more. See this link for a more detailed discussion.</p> <p>In addition, software installed via <code>conda</code> usually does not mix well with software installed through environment modules.</p>"},{"location":"2020-06-isc20/computecanada/","title":"Compute Canada","text":"<p>(author: Maxime Boissonneault, Compute Canada)</p>"},{"location":"2020-06-isc20/computecanada/#general-info","title":"General info","text":"<p>Compute Canada (https://www.computecanada.ca) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US.</p>"},{"location":"2020-06-isc20/computecanada/#staff-user-base","title":"Staff &amp; user base","text":"<p>Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year.</p>"},{"location":"2020-06-isc20/computecanada/#resources","title":"Resources","text":"<p>Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud.</p> <p>Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs.</p> <p>Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size.</p> <p>B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs.</p> <p>Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, and all identical nodes with nearly 80,000 cores.</p> <p>Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores.</p>"},{"location":"2020-06-isc20/computecanada/#compute-canada-software-stack","title":"Compute Canada software stack","text":"<p>Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere.</p> <p>For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here.</p> <p>This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available.</p>"},{"location":"2020-06-isc20/computecanada/#software-distribution","title":"Software distribution","text":"<p>One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS. This allows any cluster, virtual machine, or event desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here. Some users use it for continuous integration, we also use it in virtual clusters in the cloud.</p>"},{"location":"2020-06-isc20/computecanada/#compatibility-layer","title":"Compatibility layer","text":"<p>Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to <code>glibc</code> and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we have used the Nix package manager, but we are now moving toward using Gentoo Prefix instead.</p>"},{"location":"2020-06-isc20/computecanada/#scientific-layer-and-easybuild","title":"Scientific layer and EasyBuild","text":"<p>For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2020, we have over 800 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 1,600, 3,200 and 6,000 combinations of builds.</p>"},{"location":"2020-06-isc20/computecanada/#usage-of-easybuild-within-compute-canada","title":"Usage of EasyBuild within Compute Canada","text":"<p>To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada.</p>"},{"location":"2020-06-isc20/computecanada/#filtering-out-dependencies","title":"Filtering out dependencies","text":"<p>Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through <code>yum</code> or <code>apt-get</code>). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example <code>binutils</code>, <code>Automake</code>, <code>flex</code>, etc. This is configured through our EasyBuild configuration file.</p>"},{"location":"2020-06-isc20/computecanada/#custom-toolchains","title":"Custom toolchains","text":"<p>Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the <code>iomkl</code> or <code>gomkl</code> toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common <code>foss</code> and <code>intel</code> toolchains). We therefore make a heavy use of the <code>--try-toolchain</code> option of EasyBuild, to use upstream recipes but with our preferred toolchains.</p>"},{"location":"2020-06-isc20/computecanada/#custom-module-naming-scheme","title":"Custom module naming scheme","text":"<p>We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops <code>versionsuffix</code>. If we need to have different flavors of a given recipe, we instead use <code>modaltsoftname</code> to add the flavor to the name of the software package. This is enabled through this Python module, which implements our custom module naming scheme.</p>"},{"location":"2020-06-isc20/computecanada/#using-rpath-and-disabling-ld_library_path","title":"Using <code>RPATH</code> and disabling <code>LD_LIBRARY_PATH</code>","text":"<p>Our compatibility layer has a modified linker which ensures that <code>RPATH</code> is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the <code>LD_LIBRARY_PATH</code> from the modules. This is specified in our EasyBuild configuration file.</p>"},{"location":"2020-06-isc20/computecanada/#usage-of-hooks","title":"Usage of hooks","text":"<p>We make a rather intensive usage of hooks. For example, we use them to</p> <ul> <li>inject specific configure options to our OpenMPI builds</li> <li>add compiler and MPI footers to the modules</li> <li>split the installation of the Intel compiler into redistributable and non-redistributable parts</li> <li>strip down the installation of Python to a small set of Python packages</li> </ul>"},{"location":"2020-06-isc20/computecanada/#python-specific-customizations","title":"Python specific customizations","text":"<p>Compute Canada makes heavy usage of the <code>multi_deps</code> feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install <code>PyQt</code> alongside <code>Qt</code>, in the same module.</p> <p>For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments. The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository.</p>"},{"location":"2020-06-isc20/configuration/","title":"Configuration","text":"<p>After installing EasyBuild, you should configure it. EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool; if you are not using Lmod, please see here for more information. Nevertheless, we strongly recommend you to inspect the default configuration and tailor it to your preferences.</p> <p>Note</p> <p>Configuring EasyBuild is also covered in detail in the EasyBuild documentation, see here.</p>"},{"location":"2020-06-isc20/configuration/#available-configuration-settings","title":"Available configuration settings","text":"<p>One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases flexibility to configure EasyBuild to your liking, it also results in a large amount of available configuration settings.</p> <p>The full list of configuration settings can be consulted via <code>eb --help</code>, which shows the corresponding command line option accompanied by a short description. At the time of writing, over 230 different configuration settings are supported by EasyBuild.</p> <p>For the sake of this tutorial we will focus on a specific subset of configuration settings and cover the most prominent and important ones.</p> <p>Note</p> <p>We will usually refer to configuration settings using the name as it appears in the output of <code>eb --help</code>, which may includes dashes (<code>-</code>). The leading '<code>--</code>' is omitted for the sake of clarity.</p> <p>Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.</p>"},{"location":"2020-06-isc20/configuration/#overall-prefix","title":"Overall prefix","text":"<p>(default: <code>HOME/.local/easybuild</code>)</p> <p>The <code>prefix</code> configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings:</p> <ul> <li><code>installpath</code>: <code>&lt;prefix&gt;</code></li> <li><code>buildpath</code>: <code>&lt;prefix&gt;/build</code></li> <li><code>sourcepath</code>: <code>&lt;prefix&gt;/sources</code></li> <li><code>repositorypath</code> (easyconfigs archive): <code>&lt;prefix&gt;/ebfiles_repo</code></li> <li><code>containerpath</code>: <code>&lt;prefix&gt;/containers</code></li> </ul> <p>Here, <code>&lt;prefix&gt;</code> represents the value of the <code>prefix</code> configuration setting.</p> <p>If one of the configuration settings affected by <code>prefix</code> is defined specifically, the <code>prefix</code> value becomes irrelevant for that specific configuration setting.</p>"},{"location":"2020-06-isc20/configuration/#install-path","title":"Install path","text":"<p>(default: <code>&lt;prefix&gt;</code>)</p> <p>The location for both the software installation directories and generated module files can be controlled via the <code>installpath</code> configuration setting. Software installation directories will be placed in <code>&lt;installpath&gt;/software</code>, while <code>&lt;installpath&gt;/modules/all</code> will be used for generated module files.</p> <p>The <code>installpath</code> location is usually set to a directory on a shared filesystem when installing software for an HPC cluster, such that the installation can be performed on one node  while being accessible on the whole cluster. Of course, software can also be installed on a local filesystem. This is particularly useful when testing and evaluating installations.</p> <p>Separate configuration settings are available for both software and modules locations, as well as for controlling the <code>software</code> and <code>modules/all</code> subdirectories.</p> <p>We recommend to only change the <code>installpath</code> configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory and the default <code>software</code> and <code>modules/all</code> subdirectories are used.</p>"},{"location":"2020-06-isc20/configuration/#build-path","title":"Build path","text":"<p>(default: <code>&lt;prefix&gt;/build</code>)</p> <p>For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the <code>buildpath</code> configuration setting.</p> <p>Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations.</p> <p>It is recommended to use a directory on a local filesystem for <code>buildpath</code>, or an in-memory filesystem like <code>/dev/shm</code> (if you have a significant amount of working memory available on your system). In addition, try to ensure you use a path that does not overlap with other users on the same system. So set <code>buildpath</code> to <code>/tmp/$USER</code> or <code>/dev/shm/$USER</code>, for example.</p>"},{"location":"2020-06-isc20/configuration/#source-path","title":"Source path","text":"<p>(default: <code>&lt;prefix&gt;/sources</code>)</p> <p>For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path.</p> <p>The locations considered by EasyBuild when checking for available source files as well as the location to stored downloaded source files can be controlled via the <code>sourcepath</code> configuration setting.</p> <p>The <code>sourcepath</code> value is a colon (<code>:</code>) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software packagamed '<code>Example'</code>, EasyBuild will consider locations like <code>&lt;sourcepath&gt;/e/Example/</code>, <code>&lt;sourcepath&gt;/Example/</code>, and so on.</p> <p>The first path listed in <code>sourcepath</code> is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories.</p> <p>Make sure you have write permissions to the first path listed in <code>sourcepath</code>, so EasyBuild is able to store downloaded files there. Any additional paths can be read-only for the account running EasyBuild.</p>"},{"location":"2020-06-isc20/configuration/#easyconfigs-archive","title":"Easyconfigs archive","text":"<p>(default: <code>&lt;prefix&gt;/ebfiles_repo</code>)</p> <p>EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the <code>repositorypath</code> configuration setting.</p> <p>By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported.</p> <p>More information is available in the EasyBuild documentation.</p> <p>For the sake of this tutorial we recommend sticking to a regular directory, and sticking to the default location as a subdirectory of the <code>prefix</code> configuration setting.</p>"},{"location":"2020-06-isc20/configuration/#modules-tool-module-syntax","title":"Modules tool &amp; module syntax","text":"<p>(default: <code>Lmod</code> as modules tool, <code>Lua</code> as module syntax)</p> <p>By default, EasyBuild assumes you are using Lmod as modules tool. In addition, it will generate module files in Lua syntax, as supported by Lmod.</p> <p>To diverge from this, you can define the <code>modules-tool</code> configuration setting to indicate you are using a different modules tool, see the output of <code>eb --avail-modules-tools</code> for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through <code>$PATH</code> (more information on this in the EasyBuild documentation).</p> <p>If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the <code>module-syntax</code> configuration setting. Note that this is required if you are using a modules tool other than Lmod.</p> <p>We recommend using EasyBuild with Lmod as modules tool and Lua as module syntax.</p>"},{"location":"2020-06-isc20/configuration/#robot-search-path","title":"Robot search path","text":"<p>(default: <code>robot-paths</code> specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled)</p> <p>When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path. This applies to both easyconfig files that were specified using only their filename as an argument to the <code>eb</code> command as well as to easyconfigs required to resolve dependencies (more on that later).</p> <p>To control the robot search path, two configuration settings are available: <code>robot</code> and <code>robot-paths</code>. Both accept a colon-separated list of locations to consider when looking for easyconfig files, with <code>robot</code> overriding <code>robot-paths</code>.</p> <p>The key difference between both is that setting <code>robot</code> also enables dependency resolution and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files, while defining <code>robot-paths</code> does not have this side effect. In addition, you can use the <code>--robot</code> command line option without specifying any paths to it to only enable dependency resolution.</p> <p>Note</p> <p>Keep in mind that when either of the <code>robot</code> or <code>robot-paths</code> configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered.</p> <p>There are ways around this however, which are outside of the scope of this tutorial.</p> <p>For more information, see the EasyBuild documentation.</p>"},{"location":"2020-06-isc20/configuration/#module-naming-scheme","title":"Module naming scheme","text":"<p>(default: <code>EasyBuildMNS</code>)</p> <p>EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation.</p> <p>Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via <code>eb --avail-module-naming-schemes</code>).</p> <p>The default <code>EasyBuildMNS</code> module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional labels (which corresponds to value of the <code>versionsuffix</code> easyconfig parameter): <code>&lt;name&gt;/&lt;version&gt;&lt;-toolchain&gt;&lt;versionsuffix&gt;</code>.</p> <p>Note</p> <p>Using a different module naming scheme is largely out of scope for this tutorial, except when covering hierarchical module naming schemes.</p>"},{"location":"2020-06-isc20/configuration/#configuration-levels","title":"Configuration levels","text":"<p>Configuring EasyBuild can be done in different ways:</p> <ul> <li>through one or more configuration files;</li> <li>via <code>$EASYBUILD_*</code> environment variables;</li> <li>using <code>eb</code> command line options;</li> </ul> <p>Each of the methods corresponds to a configuration level.</p> <p>Every configuration setting can be defined via one of these mechanisms, without exception!</p>"},{"location":"2020-06-isc20/configuration/#configuration-level-hierarchy","title":"Configuration level hierarchy","text":"<p>There is a strict hierarchy between the different configuration levels supported by EasyBuild.</p> <p>Settings defined via a configuration file only override default values.</p> <p>A configuration setting that is defined via the corresponding <code>$EASYBUILD_*</code> environment variable takes precedence over the value specified in a configuration file (if any).</p> <p>Finally, values specified through <code>eb</code> command line options always* win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable.</p> <p>For example, let us consider a fictional configuration setting named <code>-magic</code>:</p> <ul> <li>If a value for <code>magic</code> is specified in an EasyBuild configuration file,   then this value will only be used if the corresponding environment variable   (<code>$EASYBUILD_MAGIC</code>).   is not defined and if the <code>---magic</code> command line option is not used;</li> <li>If the <code>$EASYBUILD_MAGIC</code> environment is defined however, then its value   will be used for the <code>this-is-magic</code> configuration setting;</li> <li>Unless the <code>--magic</code> command line option is used,   since in that case the value provided as an argument there will be used instead;</li> </ul>"},{"location":"2020-06-isc20/configuration/#configuration-files","title":"Configuration files","text":"<p>Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of <code>eb --show-default-configfiles</code> tells you which locations are considered, and whether any configuration files were found.</p> <p>EasyBuild configuration files are written in the standard INI format, and the configuration settings are grouped into different sections.</p> <p>To create an EasyBuild configuration file, the output of <code>eb --confighelp</code> is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax.</p> <p>Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.</p>"},{"location":"2020-06-isc20/configuration/#easybuild-configuration-files-vs-easyconfig-files","title":"EasyBuild configuration files vs easyconfig files","text":"<p>EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts!</p> <p>EasyBuild configuration files are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings, such as the location where software should be installed, or the syntax that should be used when generating module files.</p> <p>An easyconfig file on the other hand specifies the details for one particular software installation. It does this by defining a set of easyconfig parameters, which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc.</p> <p>For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file perhaps combined with a user-level one. Or there may be no configuration files involved  at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.</p> <p>Hopefully this helps to avoid the confusion...</p>"},{"location":"2020-06-isc20/configuration/#easybuild_-environment-variables","title":"<code>$EASYBUILD_*</code> environment variables","text":"<p>A particularly easy way to configure EasyBuild is through environment variables.</p> <p>At startup, EasyBuild will pick up any environment variable of which the name starts with '<code>EASYBUILD_</code>'. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found).</p> <p>Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes (<code>-</code>) with underscores (<code>_</code>), and prefix with <code>EASYBUILD_</code>. For example: the <code>module-syntax</code> configuration setting can be specified by defining the <code>$EASYBUILD_MODULE_SYNTAX</code> environment variable:</p> <pre><code>export EASYBUILD_MODULE_SYNTAX=Tcl\n</code></pre> <p>Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines <code>$EASYBUILD_*</code> environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it.</p> <p>Note</p> <p>Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example <code>$HOME/.bash_profile</code> or <code>$HOME/.bashrc</code>).</p>"},{"location":"2020-06-isc20/configuration/#eb-command-line-options","title":"<code>eb</code> command line options","text":"<p>Finally, you can also configure EasyBuild by specifying one or options to the <code>eb</code> command.</p> <p>As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use a command line option.</p> <p>There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the <code>eb</code> command print the EasyBuild version (via <code>eb --version</code>); although you could configure EasyBuild to always print its version and then exit whenever the <code>eb</code> command is run, that would be less than useful...</p> <p>Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory:</p> <pre><code>eb --installpath /tmp/$USER example.eb\n</code></pre>"},{"location":"2020-06-isc20/configuration/#inspecting-the-current-configuration-show-config","title":"Inspecting the current configuration (<code>--show-config</code>)","text":"<p>Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured.</p> <p>Therefore, the <code>--show-config</code> command line option is provided to easily inspect the currently active EasyBuild configuration.</p> <p>The output includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like <code>buildpath</code>, <code>installpath</code>, <code>sourcepath</code>, and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed.</p> <p>This is the output produces by <code>eb --show-config</code> for the default EasyBuild configuration, where EasyBuild was installed via <code>pip install --user</code> (which affects the <code>robot-paths</code> configuration setting):</p> <pre><code>#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (D) = /home/example/.local/easybuild/build\ncontainerpath  (D) = /home/example/.local/easybuild/containers\ninstallpath    (D) = /home/example/.local/easybuild\nrepositorypath (D) = /home/example/.local/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (D) = /home/example/.local/easybuild/sources\n</code></pre> <p>As shown here, all configuration settings shown follow the default <code>prefix</code> value (<code>$HOME/.local/easybuild</code>) and none of the values diverge from the default value, since all entries are marked with <code>(D)</code> for \"default value\").</p> <p>Now let us do some basic configuring and inspect the resulting output of <code>--show-config</code>.</p> <p>First, create a user-level EasyBuild configuration file to define the <code>prefix</code> configuration setting:</p> <pre><code>mkdir -p $HOME/.config/easybuild\necho '[config]' &gt; $HOME/.config/easybuild/config.cfg\necho 'prefix=/apps' &gt;&gt; $HOME/.config/easybuild/config.cfg\n</code></pre> <p>Define the <code>buildpath</code> configuration setting using the corresponding environment variable:</p> <pre><code>export EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Then run <code>--show-config</code> while you specify that the <code>installpath</code> configuration setting should be defined as <code>/tmp/$USER</code>:</p> <pre><code>$ eb --installpath=/tmp/$USER --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (E) = /tmp/easybuild\ncontainerpath  (F) = /apps/containers\ninstallpath    (C) = /tmp/easybuild\npackagepath    (F) = /apps/packages\nprefix         (F) = /apps\nrepositorypath (F) = /apps/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (F) = /apps/sources\n</code></pre> <p>The output indicates that the <code>installpath</code> setting was specified through a command line option (indicated with '<code>(C)</code>'), that the <code>buildpath</code> setting was defined via an environment variable (indicated with <code>(E)</code>), that the <code>robot-paths</code> setting still has the default value (indicated with <code>(D)</code>), and that all other configuration settings were specified via a configuration file, some of which indirectly through the <code>prefix</code> value (indicated with <code>(F)</code>).</p>"},{"location":"2020-06-isc20/configuration/#exercises","title":"Exercises","text":"<p>Exercise 3.1 - Configure EasyBuild</p> <p>Configure EasyBuild to use the <code>easybuild</code> subdirectory in your home directory for everything, except for:</p> <ul> <li>the location of the build directories: use <code>/tmp/$USER</code> for this;</li> <li>the locations that should be considered when searching for source files:   include both <code>$HOME/easybuild/sources</code> and <code>/easybuild/sources</code>, but make   sure that source files that are downloaded by EasyBuild are stored in   <code>$HOME/easybuild/sources</code></li> </ul> <p>Leave other configuration settings set to their defaults.</p> (click to show solution) <p>This is pretty straightforward.</p> <p>Here we just define the corresponding environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_SOURCEPATH=$HOME/easybuild/sources:/easybuild/sources\n</code></pre> <p>The location where EasyBuild should download source files to must be listed first in the <code>sourcepath</code> configuration setting.</p> <p>The output of <code>--show-config</code> should look like this:</p> <pre><code>buildpath      (E) = /tmp/example\ncontainerpath  (E) = /home/example/easybuild/containers\ninstallpath    (E) = /home/example/easybuild\npackagepath    (E) = /home/example/easybuild/packages\nprefix         (E) = /home/example/easybuild\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/easybuild/easyconfigs\nsourcepath     (E) = /home/example/easybuild/sources:/easybuild/sources\n</code></pre> <p>Exercise 3.2 - Install a trivial software package with EasyBuild</p> <p>Try running the following command:</p> <pre><code>eb bzip2-1.0.6.eb\n</code></pre> <p>Where do you expect to find the installation?</p> (click to show solution) <p>The software was installed in <code>$HOME/easybuild</code>, since that's how we configured EasyBuild in Exercise 3.1:</p> <pre><code>$ ls $HOME/easybuild\nebfiles_repo  modules  software  sources\n</code></pre> <p>The actual installation is in <code>$HOME/easybuild/software</code>, while the module file was generated in <code>$HOME/easybuild/modules/all</code>:</p> <pre><code>$ ls $HOME/easybuild/software\nbzip2\n$ ls $HOME/easybuild/software/bzip2\n1.0.6\n$ ls $HOME/easybuild/software/bzip2/1.0.6\nbin  easybuild  include  lib  man\n</code></pre> <pre><code>$ ls $HOME/easybuild/modules/all\nbzip2\n$ ls $HOME/easybuild/modules/all/bzip2\n1.0.6.lua\n</code></pre> <p>The source file for bzip2 1.0.6 was downloaded to <code>$HOME/easybuild/sources</code>:</p> <pre><code>$ ls $HOME/easybuild/sources/b/bzip2\nbzip2-1.0.6.tar.gz\n</code></pre> <p>We will discuss this in more detail in the next part of the tutorial.</p> <p>Make sure EasyBuild is configured as instructed in the exercise before you continue with the rest of this tutorial.</p>"},{"location":"2020-06-isc20/contributing/","title":"Contributing to EasyBuild","text":""},{"location":"2020-06-isc20/contributing/#contribution-procedure","title":"Contribution procedure","text":"<p>There are several ways to contribute to EasyBuild, including:</p> <ul> <li>providing feedback;</li> <li>reporting bugs;</li> <li>joining the discussions (mailing list, Slack, conf calls);</li> <li>sharing suggestions/ideas for enhancements &amp; additional features;</li> <li>contributing easyconfigs, enhancing easyblocks, adding support for new software, implementing additional features, ...;</li> <li>extending &amp; enhancing documentation;</li> </ul> <p>To contribute changes to the code or easyconfigs, you should:</p> <p>0) Create and setup a GitHub account (and register your SSH public key);</p> <p>1) First clone and fork the appropriate GitHub repository, for example:</p> <pre><code>git clone git@github.com:easybuilders/easybuild-easyconfigs.git\ncd easybuild-easyconfigs\ngit remote add my_fork git@github.com:example/easybuild-easyconfigs.git\n</code></pre> <p>You should change '<code>example</code>' in the last line to your own GitHub user name!</p> <p>2) Create and check out a new branch:</p> <pre><code>git checkout -b example\n</code></pre> <p>3) Stage the changes you want to contribute:</p> <pre><code>git add easybuild/easyconfigs/e/example-1.2.3.eb\n</code></pre> <p>4) Commit those changes with a sensible commit message:</p> <pre><code>git commit -m \"This is just an example\"\n</code></pre> <p>5) Push your branch to your fork of the repository on GitHub:</p> <pre><code>git push my_fork example\n</code></pre> <p>6) Open the pull request through the GitHub web interface, making sure that:</p> <ul> <li>the target branch is correct (should be <code>develop</code>);</li> <li>an appropriate title is used;</li> <li>a short description of the changes is provided;</li> <li>the changes are indeed the ones you want to propose;</li> <li>clicking the (correct) green button;</li> </ul> <p>In addition, for easyconfig files you should make sure that they have the correct filename, and that they are located in the correct subdirectory.</p> <p>That didn't exactly motivate you to contribute, did it...</p>"},{"location":"2020-06-isc20/contributing/#github-integration-features","title":"Github integration features","text":"<p>Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute...</p> <p>In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with <code>git</code> you may quickly end up demotivated.</p> <p>This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures.</p> <p>At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running <code>git</code> commands and interacting with the GitHub API.</p> <p>We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation.</p>"},{"location":"2020-06-isc20/contributing/#requirements-configuration","title":"Requirements &amp; configuration","text":"<p>First of all, the GitHub integration features impose a couple of additional requirements and configuration.</p> <p>Additional dependencies</p> <p>Both the <code>GitPython</code> and <code>keyring</code> Python packages as well as the <code>keyrings.cryptfile</code> add-on package must be installed. In the prepared environment, you can do this via:</p> <pre><code>pip3 install --user GitPython keyring keyrings.cryptfile\n</code></pre> <p>SSH public key in GitHub account</p> <p>You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys).</p> <p>If you need to generate an SSH key pair, you can run the following command:</p> <pre><code>ssh-keygen -t rsa -b 4096\n</code></pre> <p>You can copy the SSH public key from the output of this command:</p> <pre><code>cat .ssh/id_rsa.pub\n</code></pre> <p>Warning</p> <p>If you are using the prepared tutorial environment, we strongly recommend you:</p> <ul> <li>to protect the SSH key pair you create with a password;</li> <li>to remove the public key from your GitHub account after completing this   part of the tutorial;</li> </ul> <p>Keep in mind that anyone who obtains your SSH private key and knows the password to unlock it can push changes to your GitHub repositories!</p> <p>Forked repository in GitHub</p> <p>In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs).</p> <p>EasyBuild configuration, incl. GitHub token</p> <p>You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials.</p> <p>To do this, you should define the <code>github-user</code> configuration option and run the \"<code>eb --install-github-token</code>\" command:</p> <pre><code># replace 'ebtutorial' with your own GitHub username!\n$ export EASYBUILD_GITHUB_USER=ebtutorial\n$ eb --install-github-token\n</code></pre> <p>To create a GitHub token:</p> <ul> <li>Visit https://github.com/settings/tokens.</li> <li>Click \"Personal access tokens\".</li> <li>Click followed by \"Generate new token\".</li> <li>Give the token a name (for example \"Token for EasyBuild\").</li> <li>Select both the '<code>repo</code>' and '<code>gist</code>' scopes.</li> <li>Click the green \"Generate token\" button.</li> <li>Copy the generated token.</li> <li>Paste the token when asked by <code>--install-github-token</code> (and hit Enter).</li> <li>Enter a password to encrypt your GitHub token.</li> </ul> <p>The output should look something like this:</p> <pre><code>$ eb --install-github-token\n== temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log\nToken: \nValidating token...\nToken seems to be valid, installing it.\nPlease set a password for your new keyring: \nPlease confirm the password:\nToken 'fed..987' installed!\n</code></pre> <p>Warning</p> <p>If you are using the prepared tutorial environment, we strongly recommend you to revoke the GitHub token  again from your GitHub account after completing this part of the tutorial.</p> <p>Anyone who knows the GitHub token can perform actions in your name on GitHub through the GitHub API!</p> <p>Checking status of GitHub integration</p> <p>You can check the status of the GitHub integration using \"<code>eb --check-github</code>\":</p> <pre><code>$ eb --check-github\n== temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log\n\nChecking status of GitHub integration...\n\nMaking sure we're online...OK\n\n* GitHub user...ebtutorial=&gt; OK\nPlease enter password for encrypted keyring:\n* GitHub token...fed..987 (len: 40) =&gt; OK (validated)\n* git command...OK (\"git version 1.8.3.1; \")\n* GitPython module...OK (GitPython version 3.1.3)\nEnter passphrase for key '/home/easybuild/.ssh/id_rsa': \nEnter passphrase for key '/home/easybuild/.ssh/id_rsa': \n* push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK\nEnter passphrase for key '/home/easybuild/.ssh/id_rsa':\n* creating gists...OK\n* location to Git working dirs... not found (suboptimal)\n\nAll checks PASSed!\n\nStatus of GitHub integration:\n* --from-pr: OK\n* --new-pr: OK\n* --review-pr: OK\n* --update-pr: OK\n* --upload-test-report: OK\n</code></pre> <p>If you see '<code>OK</code>' for each of the status checks, you're all set to try out the GitHub integration features!</p> <p>Note</p> <p>If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \"<code>eb --check-github</code>\".</p> <p>You can avoid this by using an SSH agent.</p>"},{"location":"2020-06-isc20/contributing/#creating-pull-requests","title":"Creating pull requests","text":"<p>The GitHub integration in EasyBuild allows you to create pull requests using the <code>eb</code> command, without even leaving your shell environment. How cool is that\u203d</p> <p>To create a pull request to the <code>easybuild-easyconfigs</code> repository, you can either do it in a single go by running \"<code>eb --new-pr</code>\" and passing it one or more easyconfig files to add into the pull request.</p> <p>The more detailed option is to first create a branch in your repository fork in GitHub via \"<code>eb --new-branch-github</code>\" and then later open the pull request via \"<code>eb --new-pr-from-branch</code>\". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork).</p> <p>The <code>--new-pr</code> option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa!</p> <p>You can control the target repository for your pull request using <code>--pr-target-account</code> (default is <code>easybuilders</code>) and <code>--pr-target-repo</code>.</p> <p>If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \"<code>eb --dry-run --new-pr</code>\" or \"<code>eb -D --new-pr</code>\".</p> <p>Finally, you can use \"<code>eb --preview-pr</code>\" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.</p>"},{"location":"2020-06-isc20/contributing/#updating-pull-requests","title":"Updating pull requests","text":"<p>To update an existing pull request with additional changes you can use \"<code>eb --update-pr</code>\" and pass the pull request ID, alongside the paths to the updated files.</p> <p>If you have only created a branch (for example via <code>eb --new-branch-github</code>) you can update it via <code>--update-branch-github</code> in the same way, passing the branch name instead of a pull request ID.</p>"},{"location":"2020-06-isc20/contributing/#using-a-pull-request","title":"Using a pull request","text":"<p>Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which  support is not yet included in the latest EasyBuild release.</p> <p>Using the <code>--from-pr</code> option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the <code>--robot</code> option to ensure that the easyconfig files are installed in the correct order with respect to dependencies.</p> <p>Similarly, using a new or updated easyblock from a pull request is as simple as using the <code>--include-easyblocks-from-pr</code> option. And of course you can combine it with <code>--from-pr</code>!</p> <p>Via <code>--upload-test-report</code> you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.</p>"},{"location":"2020-06-isc20/contributing/#demo","title":"Demo","text":"<p>That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the <code>eb-tutorial</code> example software to a fork of the <code>easybuild-easyconfigs</code> repository using the <code>eb</code> command, and submit a test report in it.</p> <p>Note</p> <p>Make sure that you have correctly configured the GitHub integration, see above.</p>"},{"location":"2020-06-isc20/contributing/#creating-pull-request","title":"Creating pull request","text":"<p>We first configure EasyBuild to target the <code>boegel</code> GitHub account rather than the default <code>easybuilders</code> GitHub organisation, by defining the <code>pr-target-account</code> configuration setting:</p> <pre><code>export EASYBUILD_PR_TARGET_ACCOUNT=boegel\n</code></pre> <p>In the output of \"<code>eb --show-config</code>\" you should see a line like this:</p> <pre><code>pr-target-account (E) = boegel\n</code></pre> <p>We only do this to avoid that lots of pull requests for the <code>eb-tutorial</code> example software are opened in the central easyconfigs repository.</p> <p>Opening a pull request is as simple as running \"<code>eb --new-pr</code>\" and passing the easyconfig file:</p> <pre><code>$ eb --new-pr eb-tutorial.eb == temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n== fetching branch 'develop' from https://github.com/boegel/easybuild-easyconfigs.git...\n== copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs...\n== pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' (git@github.com:ebtutorial/easybuild-easyconfigs.git)\nEnter passphrase for key '/home/example/.ssh/id_rsa': \nPlease enter password for encrypted keyring: \n\nOpening pull request\n* target: boegel/easybuild-easyconfigs:develop\n* from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100\n* title: \"{tools}[GCC/9.3.0] eb-tutorial v1.0.0\"\n* labels: new\n* description:\n\"\"\"\n(created using `eb --new-pr`)\n\n\"\"\"\n* overview of changes:\n easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.0-GCC-9.3.0.eb | 26 ++++++++++++++++++++++++++\n 1 file changed, 26 insertions(+)\n\nOpened pull request: https://github.com/boegel/easybuild-easyconfigs/pull/65\n== Temporary log file(s) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed.\n== Temporary directory /tmp/eb-ggr6scbq has been removed.\n</code></pre> <p>Take a moment to grasp what we did here: we ran a single <code>eb</code> command which took care of the whole contribution procedure for us, including:</p> <ul> <li>Cloning the <code>easybuilders/easybuild-easyconfigs</code> repository and checking out the <code>develop</code> branch (in a temporary   directory);</li> <li>Picking a sensible name for a branch and creating it;</li> <li>Adding the <code>eb-tutorial</code> easyconfig file to the branch, in the correct location   (<code>easybuild/easyconfigs/e/eb-tutorial/</code>) and with the correct filename (<code>eb-tutorial-1.0.0-GCC-9.3.0.eb</code>);</li> <li>Pushing the branch to our fork (<code>example/easybuild-easyconfigs</code>);</li> <li>Actually opening the pull request, using an informative title.</li> </ul> <p>That is so... easy!</p> <p>This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the <code>develop</code> branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to).</p> <p>There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since <code>--new-pr</code> created the branch only in a temporary directory).</p> <p>If many contributions are made via <code>--new-pr</code> it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar.</p> <p>Warning</p> <p>If you are using the prepared tutorial environment, do not forget to remove the GitHub public key and GitHub token that you created earlier for this part of the tutorial from your GitHub account!</p>"},{"location":"2020-06-isc20/contributing/#uploading-test-report","title":"Uploading test report","text":"<p>After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request.</p> <p>First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for <code>eb-tutorial</code> are already installed there:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>You can verify which dependencies are still missing using <code>--from-pr</code> combined with <code>--missing</code>:</p> <pre><code># change '65' to the ID of your own pull request (see output of --new-pr)\n$ eb --from-pr 65 --missing\n== temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log\nPlease enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n\n1 out of 20 required modules missing:\n\n* eb-tutorial/1.0.0-GCC-9.3.0 (eb-tutorial-1.0.0-GCC-9.3.0.eb)\n</code></pre> <p>Uploading a test report boils down to combining <code>--from-pr</code> with <code>--upload-test-report</code>:</p> <pre><code># change '65' to the ID of your own pull request (see output of --new-pr)\n$ eb --rebuild --from-pr 65 --upload-test-report\nPlease enter password for encrypted keyring: \n...\n== processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.0-GCC-9.3.0.eb\n== building and installing eb-tutorial/1.0.0-GCC-9.3.0...\n...\n== COMPLETED: Installation ended successfully (took 2 sec)\n...\nAdding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial\n**SUCCESS**\nBuild succeeded for 1 out of 1 (1 easyconfigs in this PR)\nexample - Linux centos linux 7.8.2003, x86_64, Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz (haswell), Python 3.6.8\nSee https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report.'\n== Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#65\n</code></pre> <p>Note that we may need to use <code>--rebuild</code> here since <code>eb-tutorial</code> may already be installed.</p> <p>This results in a comment being added to the pull request:</p> <p>The gist linked from this comment provides more detailed information:</p>"},{"location":"2020-06-isc20/contributing/#contribution-stats","title":"Contribution stats","text":"<p>To wrap up, let us look at some statistics about the contributions that have been made to EasyBuild over the years.</p>"},{"location":"2020-06-isc20/contributing/#unique-contributors","title":"Unique contributors","text":"<p>Since EasyBuild went public in 2012 more than 250 different people have made contributions to the <code>easybuild-easyconfigs</code> repository. We also recently passed the threshold of 100 unique contributors in the easyblocks repository, and at the time of writing we were just one contributor short of reaching 100 unique contributors to the EasyBuild framework repository.</p> <p>If we look at unique contributors per year, we see that the number of contributors to the easyconfigs repository has been gradually increasing over the years, while the number of unique contributors to the framework and easyblocks repositories has largely remained stable. Making contributions to the latter two repositories requires significantly more effort, which explains the difference with the easyconfigs repository.</p>"},{"location":"2020-06-isc20/contributing/#pull-requests-per-year-easyconfigs","title":"Pull requests per year (easyconfigs)","text":"<p>Plotting the number of pull requests to the easyconfigs repository per year clearly shows an increase, with almost 2,100 merged contributions in 2019. In total over 2,600 pull requests were merged in 2019 across all EasyBuild repositories.</p> <p>It is also worth noting that in 2019 about two thirds of all contributions were made by people outside of the HPC-UGent team.</p> <p>Looking at the ratio of pull requests that were created using <code>--new-pr</code> versus the ones that were created manually shows a steady increase in adoption  since 2016 the GitHub integration feature. Throughout 2019, 77% of all pull requests were made using <code>--new-pr</code>, and we see this increasing further in 2020.</p>"},{"location":"2020-06-isc20/getting_help/","title":"Getting help","text":"<p>If you have any questions about EasyBuild, or if you need help, please don't hesitate to reach out to the EasyBuild community through one of these channels.</p>"},{"location":"2020-06-isc20/getting_help/#documentation","title":"Documentation","text":"<p>Make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io.</p> <p>It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful.</p> <p></p> <p>You can open an issue in one of the EasyBuild repositories in the <code>easybuilders</code> GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements.</p> <p>Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate.</p> <p>You can also use the search box on the top left to see if somebody else has already asked a similar question.</p>"},{"location":"2020-06-isc20/getting_help/#mailing-list","title":"Mailing list","text":"<p>Feel free to ask any questions or provide feedback via the EasyBuild mailing list <code>easybuild@lists.ugent.be</code>.</p> <p>Keep in mind that you need to be subscribed to the mailing list in order to post messages there! You can subscribe via this link.</p> <p>In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel.</p> <p></p> <p>The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 275 people have joined it so far, and there is usually somebody awake in there who may be able to help you out.</p> <p>To join the EasyBuild Slack, request an invitation via this link.</p> <p>If you are not a big fan of Slack, you can also consider joining the <code>#easybuild</code> IRC channel (available on the Freenode IRC network). A bot relays messages between this IRC channel and the <code>#general</code> channel in the EasyBuild Slack.</p> <p>Note</p> <p>A dedicated <code>#tutorial</code> channel was created for this tutorial in the EasyBuild Slack.</p> <p>If you have any questions that are specific to this tutorial, please post them there.</p>"},{"location":"2020-06-isc20/getting_help/#conference-calls","title":"Conference calls","text":"<p>Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call.</p> <p>These conference calls are open to anyone interested in the EasyBuild project.</p> <p>More information, including the dates and times of the next calls, is available here.</p>"},{"location":"2020-06-isc20/hmns/","title":"Hierarchical module naming schemes","text":"<p>Up until now we have used EasyBuild's default module naming scheme (<code>EasyBuildMNS</code>), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing <code>Bowtie2-2.4.1-GCC-9.3.0.eb</code> the generated module was named <code>Bowtie2/2.4.1-GCC-9.3.0</code>.</p> <p>EasyBuild supports several different module naming schemes:</p> <pre><code>$ eb --avail-module-naming-schemes\nList of supported module naming schemes:\n    CategorizedHMNS\n    CategorizedModuleNamingScheme\n    EasyBuildMNS\n    HierarchicalMNS\n    MigrateFromEBToHMNS\n</code></pre> <p>In this part of the tutorial we will take a closer look at <code>HierarchicalMNS</code>, which is the standard hierarchical module naming scheme included with EasyBuild.</p>"},{"location":"2020-06-isc20/hmns/#flat-vs-hierarchical","title":"Flat vs hierarchical","text":"<p>The default module naming scheme <code>EasyBuildMNS</code> is an example of regular \"flat\" module naming scheme, which is characterized by:</p> <ul> <li>all module files are directly available for loading;</li> <li>each module name uniquely identifies a particular installation;</li> </ul> <p>In contrast, a hierarchical module naming scheme consists of a hierarchy of module files.</p> <p>The typical module hierarchy has 3 levels:</p> <ul> <li>a core level, where module files for software that was installed using the   <code>system</code> toolchain are kept;</li> <li>a compiler level, where module files for software that was installed using a compiler-only toolchain are stored;</li> <li>and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component;</li> </ul> <p>Here is a simple example of such a 3-level module hierarchy:</p> <p>In this example the core level only includes a single module <code>GCC/9.3.0</code>, while  the compiler level includes two modules: <code>OpenMPI/4.0.3</code> and <code>MPICH/3.3.2</code>.  In the MPI level, three modules are available: one for <code>FFTW</code>, one for <code>ScaLAPACK</code>, and one for <code>HDF5</code>. As you will notice, at every level we select the module of the layer we are entering. At core level we select our compiler. When in the compiler level we select our MPI implementation, and within the MPI level we select our software.</p> <p>Initially only the modules on the top level of a module hierarchy are available for loading. If you run \"<code>module avail</code>\" with the example module hierarchy, you will only see the <code>GCC/9.3.0</code> module.</p> <p>Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the <code>GCC/9.3.0</code> module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for <code>OpenMPI</code> and <code>MPICH</code>. These corresponds to installations of <code>OpenMPI</code> and <code>MPICH</code> that were built using <code>GCC/9.3.0</code> as a toolchain.</p> <p>Similarly, the <code>OpenMPI/4.0.3</code> module serves as a gateway to the three modules in the MPI level. Only by loading the <code>OpenMPI</code> module will these additional three modules become available for loading. They correspond to software installations built using the <code>gompi/2020a</code> toolchain that consists of the <code>GCC/9.3.0</code> compiler module and the <code>OpenMPI/4.0.3</code> MPI module. Software installing using <code>foss/2020a</code> (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy.</p> <p>The characteristics of a module hierarchy are:</p> <ul> <li>not all module files are directly available for loading;</li> <li>some modules serve as a gateway to more modules;</li> <li>to access some software installations you will first need to load one or more gateway modules in order   to use them;</li> </ul> <p>You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.</p>"},{"location":"2020-06-isc20/hmns/#pros-cons","title":"Pros &amp; cons","text":"<p>So why go through all this trouble of organizing modules hierarchically?</p> <p>There are a couple of advantages to this approach:</p> <ul> <li>shorter module names;</li> <li>less overwhelming list of available modules;</li> <li>only compatible modules can be loaded together;</li> </ul> <p>However, the are some minor disadvantages too:</p> <ul> <li>not all existing modules are directly visible;</li> <li>gateway modules may have little meaning to end users;</li> </ul>"},{"location":"2020-06-isc20/hmns/#length-of-module-names","title":"Length of module names","text":"<p>When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our <code>HDF5</code> installation for example, we have <code>HDF5/1.10.6-gompi-2020a</code> as module name. The <code>-gompi-2020a</code> part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!).</p> <p>In the example module hierarchy shown above, the module for <code>HDF5</code> is named <code>HDF5/1.10.6</code> which is basically the bare essentials: software name and version. That's way better, nice and clean!</p>"},{"location":"2020-06-isc20/hmns/#amount-of-available-modules","title":"Amount of available modules","text":"<p>The output of \"<code>module avail</code>\" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can quickly grow into the hundreds or even thousands! Yikes!</p> <p>This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a modest set of modules are available, and relatively small groups of additional modules become available as gateway modules are loaded.</p>"},{"location":"2020-06-isc20/hmns/#loading-compatible-modules","title":"Loading compatible modules","text":"<p>Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other.</p> <p>Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise and you are being very careful...</p> <p>In a module hierarchy this can be prevented, since modules for software that was installed with a different compiler and/or a different MPI library is located in a different part of the module hierarchy, and thus these modules will be prevented from being loaded together.</p>"},{"location":"2020-06-isc20/hmns/#visibility-of-existing-modules","title":"Visibility of existing modules","text":"<p>One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \"<code>module avail</code>\" only shows a subset of all modules.</p> <p>Lmod has a solution for this though: it provides a separate \"<code>module spider</code>\" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \"<code>module spider</code>\" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.</p>"},{"location":"2020-06-isc20/hmns/#semantics-of-gateway-modules","title":"Semantics of gateway modules","text":"<p>An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline...</p> <p>This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \"<code>module spider</code>\" command to navigate the module hierarchy.</p>"},{"location":"2020-06-isc20/hmns/#example","title":"Example","text":"<p>Warning</p> <p>This example will not work when running the prepared container image using Singularity, because the <code>/easybuild</code> directory is read-only in this case, and EasyBuild still requires write access to <code>/easybuild/software</code> even when generate module files outside of <code>/easybuild</code>.</p> <p>Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree.</p> <p>In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment.</p> <p>The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.</p>"},{"location":"2020-06-isc20/hmns/#preparing-the-environment","title":"Preparing the environment","text":"<p>Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment.</p> <p>We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme!</p> <p>Some module files will have the same name in both module trees (like <code>GCC/9.3.0</code> for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems...</p> <p>So we have to make sure that the module files we already have in <code>/easybuild</code> are not visible. The easiest way to do this is to unload all modules (using \"<code>module purge</code>\") and resetting the module search path to be empty, which we can do with \"<code>module unuse $MODULEPATH</code>\".</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> <p>In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue.</p> <p>We strongly recommend using an EasyBuild installation that was installed via \"<code>pip install</code>\" or \"<code>pip3 install</code>\" in this part of the tutorial.</p> <p>An easy way to do this is in the prepared environment is to run:</p> <pre><code>pip3 install --user easybuild\nexport PATH=$HOME/.local/bin:$PATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2020-06-isc20/hmns/#configuring-easybuild","title":"Configuring EasyBuild","text":"<p>First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_INSTALLPATH_SOFTWARE=/easybuild/software\nexport EASYBUILD_MODULE_NAMING_SCHEME=HierarchicalMNS\nexport EASYBUILD_INSTALLPATH_MODULES=$HOME/hmns/modules\n</code></pre> <p>To make sure we didn't make any silly mistakes, we double check using <code>eb --show-config</code>:</p> <pre><code>$ eb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath            (E) = /tmp/example\ncontainerpath        (E) = /home/example/easybuild/containers\ninstallpath          (E) = /home/example/easybuild\ninstallpath-modules  (E) = /home/example/hmns/modules\ninstallpath-software (E) = /easybuild/software\nmodule-naming-scheme (E) = HierarchicalMNS\npackagepath          (E) = /home/example/easybuild/packages\nprefix               (E) = /home/example/easybuild\nrepositorypath       (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths          (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath           (E) = /home/example/easybuild/sources\n</code></pre> <p>There are a couple of things worth pointing out here:</p> <ul> <li>We have defined the <code>module-naming-scheme</code> configuration setting to <code>HierarchicalMNS</code>,   which makes EasyBuild use the included standard hierarchical module naming scheme (the classic   core / compiler / MPI one we discussed above).</li> <li>We have specified different locations for the software (via <code>installpath-software</code>)   and the module files (via <code>installpath-modules</code>). This is important because we want to   reuse the software that is already installed in <code>/easybuild/software</code> while we want to   generate an entirely new module tree for it (in <code>$HOME/hmns/modules</code>).</li> </ul> <p>The other configuration settings are the same as before, and mostly irrelevant for this example.</p>"},{"location":"2020-06-isc20/hmns/#generating-modules-for-hdf5","title":"Generating modules for HDF5","text":"<p>Let us now generate a hierarchical module tree for <code>HDF5</code> and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us.</p> <p>The steps we will have to go through are:</p> <ul> <li>Tell EasyBuild we want to \"install\" the <code>HDF5-1.10.6-gompi-2020a.eb</code> easyconfig file;</li> <li>Enable dependency resolution via <code>--robot</code>;</li> <li>Instruct EasyBuild to only generate the module files, not to install the software (since it is   there already in <code>/easybuild/software</code>), via the <code>--module-only</code> option.</li> </ul> <p>These steps translate to this single <code>eb</code> command:</p> <pre><code>$ eb HDF5-1.10.6-gompi-2020a.eb --robot --module-only\n...\n== building and installing MPI/GCC/9.3.0/OpenMPI/4.0.3/HDF5/1.10.6...\n...\n== sanity checking...\n== cleaning up [skipped]\n== creating module...\n...\n== COMPLETED: Installation ended successfully (took 9 sec)\n...\n== Build succeeded for 37 out of 37\n</code></pre> <p>This should take about 2 minutes in total, for generating 37 modules. Remember that this also includes generating module files for the toolchain and all of its components.</p> <p>In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using <code>--module-only</code> to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...</p>"},{"location":"2020-06-isc20/hmns/#loading-the-hdf5-module","title":"Loading the HDF5 module","text":"<p>After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it?</p> <p>Here's what the module tree looks like on disk:</p> <pre><code>$ ls $HOME/hmns/modules/all\nCompiler  Core  MPI\n</code></pre> <p>Those are basically the 3 levels in the module hierarchy we showed in our example earlier.</p> <p>The starting point is the top level of the module hierarchy named <code>Core</code>:</p> <pre><code>module use $HOME/hmns/modules/all/Core\n</code></pre> <p>Let us see what that gives us in terms of available modules:</p> <pre><code>$ module avail\n\n--------------------- /home/easybuild/hmns/modules/all/Core ---------------------\n   Bison/3.3.2        GCCcore/9.3.0    flex/2.6.4        help2man/1.47.4\n   Bison/3.5.3 (D)    M4/1.4.18        gettext/0.20.1    ncurses/6.1\n   GCC/9.3.0          binutils/2.34    gompi/2020a       zlib/1.2.11\n</code></pre> <p>Nice and short module names, but only a limited set of them.</p> <p>We know a module file exists for <code>HDF5</code>, but we can't see it yet (and hence we can't load it either).</p> <pre><code>$ module avail HDF5\nNo module(s) or extension(s) found!\nUse \"module spider\" to find all possible modules and extensions.\n</code></pre> <p>Let us see if <code>module spider</code> is of any help, as \"<code>module avail</code>\" so kindly suggests:</p> <pre><code>$ module spider HDF5\n...\n\n    You will need to load all module(s) on any one of the lines below\n    before the \"HDF5/1.10.6\" module is available to load.\n\n      GCC/9.3.0  OpenMPI/4.0.3\n</code></pre> <p>This tells us we need to load two gateway modules before we can load the module for HDF5.</p> <p>Let us start with loading the <code>GCC</code> compiler module:</p> <pre><code>module load GCC/9.3.0\n</code></pre> <p>And then check again which modules are available:</p> <pre><code>$ module avail\n\n-------------- /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 --------------\n   OpenMPI/4.0.3\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/9.3.0 ------------\n   Autoconf/2.69         XZ/5.2.5                libtool/2.4.6\n   ...\n   Szip/2.1.1            libpciaccess/0.16       zlib/1.2.11        (L,D)\n   UCX/1.8.0             libreadline/8.0\n\n--------------------- /home/easybuild/hmns/modules/all/Core ---------------------\n   Bison/3.3.2        GCCcore/9.3.0 (L)    flex/2.6.4        help2man/1.47.4\n   Bison/3.5.3        M4/1.4.18            gettext/0.20.1    ncurses/6.1\n   GCC/9.3.0   (L)    binutils/2.34        gompi/2020a       zlib/1.2.11\n</code></pre> <p>Good news, we now have additional modules available!</p> <p>The compiler level of our hierarchy actually consists of two directories here: <code>Compiler/GCCcore/9.3.0</code> and <code>Compiler/GCC/9.3.0</code>. The modules in the <code>GCCcore</code> directory are ones we can use in other compiler toolchains that use GCC 9.3.0 as a base compiler (the details of that are out of scope here).</p> <p>The module we are interested in is <code>OpenMPI/4.0.3</code>, which is another gateway module.</p> <p>Remember that the \"<code>module spider</code>\" output told us that there does indeed exist a module for <code>HDF5</code>, but that we need to load both the <code>GCC/9.3.0</code> and <code>OpenMPI/4.0.3</code> modules first.</p> <p>So, let us do exactly that (remember that <code>GCC/9.3.0</code> is already loaded):</p> <pre><code>module load OpenMPI/4.0.3\n</code></pre> <p>If you now check the output of \"<code>module avail</code>\" again, you should see the <code>HDF5/1.10.6</code> module:</p> <pre><code>$ module avail\n\n-------- /home/easybuild/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 -------\n   HDF5/1.10.6\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCC/9.3.0 ------------\n   OpenMPI/4.0.3 (L)\n\n...\n</code></pre> <p>To use HDF5, we just need to load this module. We can verify that the installation works using one of the commands provided by HDF5, <code>h5dump</code> for example:</p> <pre><code>module load HDF5/1.10.6\n</code></pre> <pre><code>$ h5dump --version\nh5dump: Version 1.10.6\n</code></pre> <p>If you now check which modules are loaded via \"<code>module list</code>\", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree:</p> <pre><code>$ module list\n\nCurrently Loaded Modules:\n  1) GCCcore/9.3.0   5) numactl/2.0.13      9) hwloc/2.2.0    13) HDF5/1.10.6\n  2) zlib/1.2.11     6) XZ/5.2.5           10) UCX/1.8.0\n  3) binutils/2.34   7) libxml2/2.9.10     11) OpenMPI/4.0.3\n  4) GCC/9.3.0       8) libpciaccess/0.16  12) Szip/2.1.1\n</code></pre>"},{"location":"2020-06-isc20/hmns/#exercise","title":"Exercise","text":"<p>Now it is your turn!</p> <p>Try to get a feeling for how a hierarchical module tree works by:</p> <ul> <li>installing the missing modules for the <code>SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb</code> in the module hierarchy we   generated for HDF5;</li> <li>figure out where the <code>SciPy-bundle</code> module is located in the hierarchy, and then also load it;</li> </ul> <p>You can verify your work by running this command (since <code>pandas</code> is one of the Python packages included in the <code>SciPy-bundle</code> installation):</p> <pre><code>python -c 'import pandas; print(pandas.__version__)'\n</code></pre> <p>Start from a clean slate, by first running:</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> (click to show solution) <ul> <li> <p>Step 0: check which modules are still missing, using <code>--missing</code> or <code>-M</code>:   <pre><code>eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb -M\n</code></pre>   The output should tell you that 15 out of 50 required modules are still missing.</p> </li> <li> <p>Install the missing modules in the module hierarchy we have generated in <code>$HOME/hmns/modules</code>:   <pre><code>eb SciPy-bundle-2020.03-foss-2020a-Python-3.8.2.eb --robot --module-only\n</code></pre>   Don't forget to use both <code>--robot</code> (to enable dependency resolution) and <code>--module-only</code>   (to only run the sanity check and generate module files, not install the software again).</p> </li> <li> <p>Start at the top of the module hierarchy (the <code>Core</code> level),   and run module spider to check which gateway modules to load to make <code>SciPy-bundle</code> available:   <pre><code>module use $HOME/hmns/modules/all/Core\nmodule spider SciPy-bundle/2020.03-Python-3.8.2\n</code></pre></p> </li> <li>Load the gateway modules:   <pre><code>module load GCC/9.3.0 OpenMPI/4.0.3\n</code></pre></li> <li>Check that the <code>SciPy-bundle</code> module is available, and load it:   <pre><code>$ module avail SciPy-bundle\n----- /home/example/hmns/modules/all/MPI/GCC/9.3.0/OpenMPI/4.0.3 ------\n   SciPy-bundle/2020.03-Python-3.8.2\n</code></pre> <pre><code>module load SciPy-bundle/2020.03-Python-3.8.2\n</code></pre></li> <li>Run the test command:   <pre><code>$ python -c 'import pandas; print(pandas.__version__)'\n1.0.3\n</code></pre></li> </ul> <p>Warning</p> <p>This exercise will not work when running the prepared container image using Singularity, because the <code>/easybuild</code> directory is read-only in this case, and EasyBuild still requires write access to <code>/easybuild/software</code> even when generate module files outside of <code>/easybuild</code>.</p>"},{"location":"2020-06-isc20/installation/","title":"Installation","text":"<p>Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild.</p> <p>In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial.</p> <p>Summary</p> <ul> <li>requirements: Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended)</li> <li>installation methods:<ul> <li><code>pip install easybuild</code></li> <li>bootstrapping EasyBuild</li> </ul> </li> <li>verify EasyBuild installation using <code>eb --version</code> and <code>eb --help</code></li> </ul>"},{"location":"2020-06-isc20/installation/#requirements","title":"Requirements","text":""},{"location":"2020-06-isc20/installation/#linux","title":"Linux","text":"<p>The main target platform for EasyBuild is Linux, since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux).</p> <p>EasyBuild is also compatible with macOS, but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like contributing back to the project.</p>"},{"location":"2020-06-isc20/installation/#python","title":"Python","text":"<p>EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3).</p> <p>To check which Python version you have, use:</p> <pre><code>python -V\n</code></pre> <p>No additional Python packages are required by EasyBuild, the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.</p>"},{"location":"2020-06-isc20/installation/#environment-modules-tool","title":"Environment modules tool","text":"<p>An environment modules tool is required for using EasyBuild.</p> <p>We strongly recommend using Lmod, a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported.</p> <p>To check if you have a modules tool installed, use:</p> <pre><code>module --version\n</code></pre> <p>If this produces output that starts with something like \"<code>Modules based on Lua: Version 8.2.5</code>\" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. </p> <p>If you see output that starts with a line like \"<code>VERSION=3.2.10</code>\" or \"<code>Modules Release 4.5.0</code>\", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation.</p> <p>If the <code>module</code> function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.</p>"},{"location":"2020-06-isc20/installation/#easybuild-as-a-python-package","title":"EasyBuild as a Python package","text":"<p>EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders, as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild.</p> <p>As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation.</p> <p>Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry.</p> <p>You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like <code>pip</code>, <code>virtualenv</code>, <code>pipenv</code>, ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!</p>"},{"location":"2020-06-isc20/installation/#python-2-or-python-3","title":"Python 2 or Python 3?","text":"<p>For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life, we strongly recommend using Python 3 if you have the choice.</p> <p>By default EasyBuild will use the <code>python</code> command to run, but you can control this if needed. For more information, see  the EasyBuild documentation.</p>"},{"location":"2020-06-isc20/installation/#installing-easybuild","title":"Installing EasyBuild","text":"<p>We present two methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation.</p> <p>Time to get your hands dirty!</p>"},{"location":"2020-06-isc20/installation/#method-1-using-pip-recommended","title":"Method 1: Using <code>pip</code> (recommended)","text":"<p>Since EasyBuild is released as a Python package on PyPI you can install it using <code>pip</code>, the most commonly used tool for installing Python packages.</p> <p>You may need to take additional steps after the installation, depending on the exact installation command.</p> <p>Note</p> <p>There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like <code>virtualenv</code> or <code>pipenv</code>, feel free to use those instead to install EasyBuild.</p>"},{"location":"2020-06-isc20/installation/#running-pip-install","title":"Running <code>pip install</code>","text":"<p>Installing EasyBuild with <code>pip</code> is as simple as running the following command:</p> <pre><code>pip install easybuild\n</code></pre> <p>However, you may need to slightly change this command depending on the context and your personal preferences:</p> <ul> <li> <p>To install EasyBuild system-wide, you can use <code>sudo</code> (if you have admin privileges):   <pre><code>sudo pip install easybuild\n</code></pre></p> </li> <li> <p>To install EasyBuild in your personal home directory, you can use the <code>--user</code> option:   <pre><code>pip install --user easybuild\n</code></pre>   This will result in an EasyBuild installation in <code>$HOME/.local/</code>.</p> </li> <li> <p>To install EasyBuild in a specific directory you can use the <code>--prefix</code> option:   <pre><code>pip install --prefix _PREFIX_ easybuild\n</code></pre>   In this command, you should replace '<code>_PREFIX_</code>' with the location where you want to have EasyBuild installed   (for example, <code>$HOME/tools</code> or <code>/tmp/$USER</code>).</p> </li> </ul>"},{"location":"2020-06-isc20/installation/#pip-vs-pip3","title":"<code>pip</code> vs <code>pip3</code>","text":"<p>On systems where both Python 2 and Python 3 are installed you may also have different <code>pip</code> commands available. Or maybe <code>pip</code> is not available at all, and only \"versioned\" <code>pip</code> commands like <code>pip3</code> are available.</p> <p>If you (only) have <code>pip3</code> available, you can replace <code>pip</code> with <code>pip3</code> in any of the <code>pip install</code> commands above.</p>"},{"location":"2020-06-isc20/installation/#updating-your-environment","title":"Updating your environment","text":"<p>If you used the <code>--user</code> or <code>--prefix</code> option in the <code>pip install</code> command,  you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location.</p> <p>Note</p> <p>Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory (<code>.bashrc</code> for example).</p> <p><code>$PATH</code></p> <p>Update the <code>$PATH</code> environment variable to make sure the <code>eb</code> command is available: <pre><code>export PATH=_PREFIX_/bin:$PATH\n</code></pre> Replace '<code>_PREFIX_</code>' in this command with the directory path where EasyBuild was installed into (use <code>$HOME/.local</code> if you used <code>pip install --user</code>).</p> <p><code>$PYTHONPATH</code></p> <p>If you installed EasyBuild to a non-standard location using <code>pip install --prefix</code>, you also need to update the Python search path environment variable <code>$PYTHONPATH</code> to instruct Python where it can find the EasyBuild Python packages. This is not required if you used the <code>--user</code> option, since Python will automatically consider <code>$HOME/.local</code> when searching for installed Python packages.</p> <p>Update <code>$PYTHONPATH</code> by running a command like:</p> <pre><code>export PYTHONPATH=_PREFIX_/lib/pythonX.Y/site-packages:$PYTHONPATH\n</code></pre> <p>Here, you need to replace the <code>X</code> and <code>Y</code> with the major and minor version of your Python installation, which you can determine by running <code>python -V</code>. For example, if you are using Python 2.7, make sure you are using '<code>python2.7</code>' in the command to update <code>$PYTHONPATH</code>.</p> <p>And of course, you again need to replace '<code>_PREFIX_</code>' with the installation prefix where EasyBuild was installed into.</p> <p>For example:</p> <pre><code># update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6\nexport PYTHONPATH=$HOME/tools/lib/python3.6/site-packages:$PYTHONPATH\n</code></pre> <p><code>$EB_PYTHON</code> and <code>$EB_VERBOSE</code></p> <p>If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the <code>python</code> command that should be used by the <code>eb</code> command via the <code>$EB_PYTHON</code> environment variable.</p> <p>For example, to ensure that <code>eb</code> uses <code>python3</code>:</p> <pre><code>export EB_PYTHON=python3\n</code></pre> <p>To get a better view on which <code>python</code> commands are being considered by the <code>eb</code> command, you can (temporarily) define the <code>$EB_VERBOSE</code> environment variable. For example:</p> <pre><code>$ EB_VERBOSE=1 eb --version\n&gt;&gt; Considering 'python3'...\n&gt;&gt; 'python3' version: 3.6.8, which matches Python 3 version requirement (&gt;= 3.5)\n&gt;&gt; Selected Python command: python3 (/usr/bin/python3)\n&gt;&gt; python3 -m easybuild.main --version\nThis is EasyBuild 4.2.1 (framework: 4.2.1, easyblocks: 4.2.1) on host example\n</code></pre>"},{"location":"2020-06-isc20/installation/#method-2-bootstrapping-easybuild","title":"Method 2: Bootstrapping EasyBuild","text":"<p>Note</p> <p>This section covers an alternative installation method.</p> <p>If you already have EasyBuild installed, you can skip ahead to the next section.</p> <p>If <code>pip</code> is not available or if the installation with <code>pip</code> is not working out for some reason, you can resort to using the bootstrapping procedure for installing EasyBuild.</p> <p>In essence, the bootstrap script installs EasyBuild into a temporary location and then uses this temporary EasyBuild installation to install EasyBuild into the specified directory and provide a module for it.</p>"},{"location":"2020-06-isc20/installation/#step-1-downloading-the-bootstrap-script","title":"Step 1: Downloading the bootstrap script","text":"<p>First, download the latest version of the EasyBuild bootstrap script from GitHub.</p> <p>A common way to do this is by running this <code>curl</code> command:</p> <pre><code>curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py\n</code></pre>"},{"location":"2020-06-isc20/installation/#step-2-running-the-bootstrap-script","title":"Step 2: Running the bootstrap script","text":"<p>To install EasyBuild using the bootstrap script simply run it using the <code>python</code> command and specify the installation prefix as an argument:</p> <pre><code>python bootstrap_eb.py _PREFIX_\n</code></pre> <p>Replace '<code>_PREFIX_</code>' with the location where you want to have EasyBuild installed (for example, <code>$HOME/tools</code> or <code>/tmp/$USER</code>).</p>"},{"location":"2020-06-isc20/installation/#step-3-loading-the-easybuild-module","title":"Step 3: Loading the EasyBuild module","text":"<p>Once the bootstrap procedure completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session.</p> <p>First, make the module available by running the following command (which will update the module search path environment variable <code>$MODULEPATH</code>):</p> <pre><code>module use _PREFIX_/modules/all\n</code></pre> <p>Replace '<code>_PREFIX_</code>' in the same way as you did when running the bootstrap script.</p> <p>Then, load the <code>EasyBuild</code> module to update your environment and make EasyBuild available for use:</p> <pre><code>module load EasyBuild\n</code></pre> <p>Note</p> <p>No output will be generated by either of these <code>module</code> commands. That is expected behaviour and completely normal.</p>"},{"location":"2020-06-isc20/installation/#verifying-the-installation","title":"Verifying the installation","text":"<p>Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:</p>"},{"location":"2020-06-isc20/installation/#checking-the-version","title":"Checking the version","text":"<p>To check which EasyBuild version you have installed, run:</p> <pre><code>eb --version\n</code></pre> <p>The output should match with the latest EasyBuild version.</p>"},{"location":"2020-06-isc20/installation/#consulting-the-help-output","title":"Consulting the help output","text":"<p>You can consult the help output of the <code>eb</code> command, which produces a long list of available options along with a short informative message.</p> <pre><code>eb --help\n</code></pre>"},{"location":"2020-06-isc20/installation/#showing-the-default-easybuild-configuration","title":"Showing the default EasyBuild configuration","text":"<p>To inspect the current EasyBuild configuration, you can use this command:</p> <pre><code>eb --show-config\n</code></pre> <p>This should tell you that EasyBuild (ab)uses <code>$HOME/.local/easybuild</code> as a default location. More on configuring EasyBuild in the next part of the tutorial.</p>"},{"location":"2020-06-isc20/installation/#system-information","title":"System information","text":"<p>You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command:</p> <pre><code>eb --show-system-info\n</code></pre>"},{"location":"2020-06-isc20/installation/#updating-easybuild","title":"Updating EasyBuild","text":"<p>Before we wrap up here, a brief word about updating EasyBuild.</p> <p>Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module:</p> <pre><code>eb --install-latest-eb-release\n</code></pre> <p>This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update).</p> <p>The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration.</p>"},{"location":"2020-06-isc20/installation/#exercise","title":"Exercise","text":"<p>Install EasyBuild in your home directory</p> <p>Make sure that the EasyBuild installation uses the <code>python3</code> command to run, rather than the standard <code>python</code> command.</p> <p>Choose your own adventure (or try both installation methods)!</p> <ul> <li>perform a bootstrap installation into <code>$HOME/easybuild</code></li> <li>install EasyBuild with <code>pip</code> (or another very similar command...) using either the <code>--user</code> or <code>--prefix</code> option</li> </ul> <p>Check that the installation works by running the verification commands outlined above.</p> (click to show solution using bootstrapping) <p>To perform a bootstrap installation, it suffices to download the bootstrap script and run it using the <code>python3</code> command.</p> <pre><code>$ curl -O https://raw.githubusercontent.com/easybuilders/easybuild-framework/develop/easybuild/scripts/bootstrap_eb.py\n...\n$ python3 bootstrap_eb.py $HOME/easybuild\n[[INFO]] EasyBuild bootstrap script (version 20200203.01, MD5: fcb6314d4e0747db9c28a71f8bb2870c)\n[[INFO]] Found Python 3.6.8 (default, Apr  2 2020, 13:34:55) ; [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)]\n\n[[INFO]] Installation prefix /home/easybuild/easybuild\n...\n</code></pre> <p>Afterwards we can just load the generated module, which already takes care of correctly setting <code>$EB_PYTHON</code> to ensure the right <code>python</code> command is used:</p> <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load EasyBuild\n$ echo $EB_PYTHON\n/usr/bin/python3\n$ eb --version\nThis is EasyBuild 4.2.1 (framework: 4.2.1, easyblocks: 4.2.1) on host example.\n</code></pre> (click to show solution using pip) <p>To ensure that EasyBuild is installed with Python 3, we need to use the <code>pip3</code> command rather than just <code>pip</code>.</p> <p>We can install EasyBuild using <code>pip3 install --user</code>, and update <code>$PATH</code> and define <code>$EB_PYTHON</code> to ensure the right <code>python</code> command is used (the order in which we do this doesn't matter):</p> <pre><code>export PATH=$HOME/.local/bin:$PATH\nexport EB_PYTHON=python3\npip3 install --user easybuild\n</code></pre> <p>Or we can use <code>pip3 install --prefix</code>, but then we need to update both <code>$PATH</code> and <code>$PYTHONPATH</code> (after checking the Python version), and also define <code>$EB_PTYHON</code>:</p> <pre><code>$ python -V\nPython 3.6.8\n</code></pre> <pre><code>export PATH=$HOME/bin:$PATH\nexport PYTHONPATH=$HOME/lib/python3.6/site-packages:$PATH\nexport EB_PYTHON=python3\npip3 install --prefix $HOME easybuild\n</code></pre> <p>Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial!</p>"},{"location":"2020-06-isc20/introduction/","title":"Introduction","text":""},{"location":"2020-06-isc20/introduction/#what-is-easybuild","title":"What is EasyBuild?","text":"<p>EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromises on performance. Easybuild is especially tailored towards High Performance Computing (HPC)  environments.</p>"},{"location":"2020-06-isc20/introduction/#elevator-pitch","title":"Elevator pitch","text":"<p>EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems.</p> <p>It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. </p> <p>In addition, EasyBuild can empower scientific researchers to self-manage their software stack, and it can serve as a tool that can be leveraged for building optimized container images.</p> <p>The project has grown to become a platform for collaboration among worldwide HPC sites.</p>"},{"location":"2020-06-isc20/introduction/#key-features","title":"Key features","text":"<p>EasyBuild is capable of fully autonomously installing (scientific) software, including making sure that all necessary dependencies are installed, and automatically generating environment module files.</p> <p>No admin privileges are required: it is sufficient to have write permissions to the preferred software installation prefix.</p> <p>It is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations if required.</p> <p>The installation procedure executed by EasyBuild is thoroughly logged and fully transparent via dry runs and tracing.</p> <p>EasyBuild supports using a custom module naming scheme, allows for hierarchical module naming schemes, and integrates with various other tools ranging from  resource managers (Slurm and GC3Pie), container tools (Singularity and Docker), packaging tools (FPM), and so on.</p> <p>The project is actively developed by a worldwide community, with stable versions being released every 6-8 weeks since 2012. Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment, consistent testing of incoming contributions, and thorough regression testing before every release.</p>"},{"location":"2020-06-isc20/introduction/#what-easybuild-is-not","title":"What EasyBuild is not","text":"<p>EasyBuild is not YABT (Yet Another Build Tool): it does not replace established build tools like CMake or <code>make</code>, it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you.</p> <p>It is not a replacement for traditional Linux package managers like <code>yum</code>, <code>dnf</code> or <code>apt</code>. EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, Infiniband, GPU drivers, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution.</p> <p>Finally, EasyBuild is not a magic solution to all your (software installation) problems. You may, and probably will still occasionally, run into compiler errors unless somebody has already taken care of the problem for you.</p>"},{"location":"2020-06-isc20/introduction/#implementation","title":"Implementation","text":"<p>EasyBuild is implemented in Python, and fully supports both Python 2.7 and 3.5+.</p> <p>Releases are published via PyPI, under the GPLv2 open source license.</p> <p>Development is done through the <code>easybuilders</code> organisation on GitHub, where each of the EasyBuild components is hosted in a separate repository.</p>"},{"location":"2020-06-isc20/introduction/#terminology","title":"Terminology","text":"<p>Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software.</p> <p>It is important to be familiar with these terms.</p>"},{"location":"2020-06-isc20/introduction/#framework","title":"Framework","text":"<p>The EasyBuild framework consists of a set of Python modules organised in packages (<code>easybuild.framework</code>, <code>easybuild.tools</code>, etc.) that collectively form the heart of EasyBuild.</p> <p>It implements the common functionality that you need when building software from source, providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc.</p> <p>The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this (see easyblocks).</p>"},{"location":"2020-06-isc20/introduction/#easyblocks","title":"Easyblocks","text":"<p>An easyblock is a Python module that implements a specific software installation procedure. It can be viewed as a plugin to the EasyBuild framework.</p> <p>Easyblocks can be either generic or software-specific.</p> <p>A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the <code>ConfigureMake</code> easyblock which implements the ubiquitous <code>configure</code>-<code>make</code>-<code>make install</code> procedure, and the <code>PythonPackage</code> easyblock that can be used to install a Python package.</p> <p>A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for <code>GCC</code>, <code>OpenFOAM</code>, <code>TensorFlow</code>, ...</p> <p>The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters (see easyconfig files).</p>"},{"location":"2020-06-isc20/introduction/#easyconfig-files","title":"Easyconfig files","text":"<p>Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install. They define the different easyconfig parameters that collectively form a complete specification for a particular software installation.</p> <p>Some easyconfig parameters are mandatory. The following parameters must be defined in each easyconfig file:</p> <ul> <li><code>name</code> and <code>version</code>, which specify the name and version of the software to install (surprise!);</li> <li><code>homepage</code> and <code>description</code>, which provide key metadata for the software;</li> <li><code>toolchain</code>, which specifies the compiler toolchain to use to install the software (see   <code>toolchains</code> tab);</li> </ul> <p>Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock.</p> <p>Some commonly used optional easyconfig parameters include:</p> <ul> <li><code>easyblock</code>, which specifies which (generic) easyblock should be used;</li> <li><code>sources</code> and <code>source_urls</code>, which specify the list of source files and where to download them;</li> <li><code>dependencies</code> and <code>builddependencies</code>, which specify (drum roll...) the list of (build) dependencies;</li> <li><code>configopts</code>, <code>buildopts</code>, and <code>installopts</code>, which specify options for the configuration/build/install commands, respectively;</li> </ul> <p>If these parameters are not provided, the corresponding default value will be used.</p>"},{"location":"2020-06-isc20/introduction/#extensions","title":"Extensions","text":"<p>Extensions is the collective term we use for additional software packages that can be installed on top of another software package. Examples are Python packages, R libraries and Perl modules.</p> <p>As you can tell the common terminology here is a mess, so we came up with a unifying term...</p> <p>Extensions can be installed in different ways:</p> <ul> <li>stand-alone, as a separate installation on top of one or more other installations;</li> <li>as a part of a bundle of extensions that collectively form a separate installation;</li> <li>or as an actual extension to a specific installation to yield a \"batteries included\"   type of installation (for examples by adding a bunch of Python packages from PyPI into   a Python installation);</li> </ul>"},{"location":"2020-06-isc20/introduction/#dependencies","title":"Dependencies","text":"<p>A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features).</p> <p>There are three main types of dependencies for computer software:</p> <ul> <li>a build dependency is only required when building/installing a software package;   once the software package is installed, it is no longer needed to use that software;</li> <li>a runtime dependency (often referred to simply as dependency) is a software package that is   required to use (or run) another software package;</li> <li>a link-time dependency is somewhere in between a build and runtime dependency:    it is only needed when linking a software package; it can become either a build or runtime   dependency, depending on exactly how the software is installed;</li> </ul> <p>The distinction between link-time and build/runtime dependencies is irrelevant for this tutorial.</p>"},{"location":"2020-06-isc20/introduction/#toolchains","title":"Toolchains","text":"<p>A compiler toolchain (or just toolchain for short) is a set of compilers, which are used to build software from source, together with a set of additional libraries that provide further core functionality.</p> <p>We refer to the different parts of a toolchain as toolchain components.</p> <p>The compiler component typically consists of C, C++, and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included.</p> <p>Additional toolchain components are usually special-purpose libraries:</p> <ul> <li>an MPI library to support distributed computations (for example, Open MPI);</li> <li>libraries providing efficient linear algebra routines (BLAS,   LAPACK);</li> <li>a library supporting computing Fast Fourier Transformations (for example, FFTW);</li> </ul> <p>A toolchain that includes all of these libraries is referred to as a full toolchain, while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).</p>"},{"location":"2020-06-isc20/introduction/#system-toolchain","title":"System toolchain","text":"<p>The <code>system</code> toolchain is a special case which corresponds to using the system-provided compilers and libraries, rather than using toolchain components that were installed using EasyBuild.</p> <p>It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system tools and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.</p>"},{"location":"2020-06-isc20/introduction/#common-toolchains","title":"Common toolchains","text":"<p>The <code>foss</code> and <code>intel</code> toolchains are also known as the common toolchains, because they are widely adopted by the EasyBuild community.</p> <p>The <code>foss</code> toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free &amp; Open Source Software): GCC, Open MPI, OpenBLAS, ScaLAPACK and FFTW.</p> <p>The <code>intel</code> toolchain consists of the Intel C, C++ and Fortran compilers (on top of a <code>GCC</code> version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries.</p> <p>Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing.</p> <p>More information on these toolchains is available in the EasyBuild documentation.</p>"},{"location":"2020-06-isc20/introduction/#modules","title":"Modules","text":"<p>Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file).</p> <p>Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell-agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state.</p> <p>Environment module files are processed via a modules tool, of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod, a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones.</p> <p>EasyBuild heavily relies on environment modules, and hence having a modules tool installed is a strict requirement in order to use EasyBuild. Both Lmod and the Tcl-based Environment Modules tools are supported by EasyBuild, as well as module files in both Tcl and Lua syntax.</p> <p>Module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.</p>"},{"location":"2020-06-isc20/introduction/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions, using a particular compiler toolchain, as specified in easyconfig files.</p> <p>EasyBuild ensures that the specified dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.</p>"},{"location":"2020-06-isc20/introduction/#focus-points","title":"Focus points","text":"<p>EasyBuild was created specifically for installing scientific software on HPC systems, which is reflected in some of the design choices that were made.</p>"},{"location":"2020-06-isc20/introduction/#performance","title":"Performance","text":"<p>EasyBuild strongly prefers to build software from source code, whenever possible.</p> <p>This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run.</p> <p>For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like <code>-march=native</code> (GCC), <code>-xHost</code> (Intel compilers), etc. This behaviour may be changed via the <code>--optarch</code> configuration setting.</p>"},{"location":"2020-06-isc20/introduction/#reproducibility","title":"Reproducibility","text":"<p>In addition to performance, reproducibility of installations is a core aspect of EasyBuild.</p> <p>Most software installations performed with EasyBuild use a particular toolchain, with which we aim to take control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like <code>OpenSSL</code> for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system.</p> <p>For both toolchains and dependencies, fixed software versions are specified in the easyconfig files. That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.</p>"},{"location":"2020-06-isc20/introduction/#community-effort","title":"Community effort","text":"<p>In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out.</p> <p>We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the EasyBuild framework, easyblocks, easyconfigs repositories, or to the EasyBuild documentation.</p> <p>Through the <code>foss</code> and <code>intel</code> common toolchains, we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository.</p> <p>Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.</p>"},{"location":"2020-06-isc20/jsc/","title":"J\u00fclich Supercomputing Centre","text":"<p>(author: Alan O'Cais, J\u00fclich Supercomputing Centre)</p>"},{"location":"2020-06-isc20/jsc/#general-info","title":"General info","text":"<p>The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc) at  Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process.</p>"},{"location":"2020-06-isc20/jsc/#staff-user-base","title":"Staff &amp; user base","text":"<p>About 200 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services.</p> <p>In cooperation with hardware and software vendors like IBM, Intel and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008.</p>"},{"location":"2020-06-isc20/jsc/#resources","title":"Resources","text":"<p>JSC currently manages 3 primary systems (in addition to a number of other development clusters):</p> <p>JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance. In the coming months, JUWELS will become the first supercomputer equipped with NVIDIA A100 GPU, when a new GPU module providing an additional 58 Petaflops will be installed. This module will make JUWELS the most powerful supercomputer in Europe.</p> <p>JURECA is the precursor system to JUWELS with 1.8 (CPU) + 0.44 (GPU) + 5 (KNL) Petaflop per second peak performance. It is due to be decommissioned at the end of November 2020. The technical details about the successor system, the JURECA DC (data centric) module, will be announced soon.</p> <p>JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms.</p>"},{"location":"2020-06-isc20/jsc/#usage-of-easybuild-within-jsc","title":"Usage of EasyBuild within JSC","text":"<p>As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated.</p> <p>JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations.</p>"},{"location":"2020-06-isc20/jsc/#custom-toolchains","title":"Custom toolchains","text":"<p>As of June 2020, there are a total of 15 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers (<code>GCCcore</code>, <code>GCC</code>, <code>Intel</code> and <code>PGI</code>), MPI runtimes (<code>ParaStationMPI</code>, <code>OpenMPI</code>, <code>IntelMPI</code> and <code>MVAPICH2</code>) and mathematical libraries (<code>MKL</code>).</p> <p>Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the <code>--try-toolchain</code> option and has recently introduced the <code>--try-update-deps</code> experimental option to more easily adopt upstream changes and adapt them to our environment. </p>"},{"location":"2020-06-isc20/jsc/#custom-module-naming-scheme","title":"Custom module naming scheme","text":"<p>By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes).</p>"},{"location":"2020-06-isc20/jsc/#custom-easyconfigs","title":"Custom easyconfigs","text":"<p>The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository).</p> <p>We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild.</p>"},{"location":"2020-06-isc20/jsc/#hiding-dependencies","title":"Hiding dependencies","text":"<p>While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the <code>hide-deps</code> configuration setting). There are currently over 200 such hidden dependencies.  </p> <p>While hidden dependencies are not visible in the <code>module</code> view by default, users can expose them by the use of the <code>--show-hidden</code> argument in <code>Lmod</code>: <pre><code>module --show-hidden avail\n</code></pre></p>"},{"location":"2020-06-isc20/jsc/#usage-of-hooks","title":"Usage of hooks","text":"<p>The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely.</p> <p>We are currently integrating a new hook that provides a lot of useful functionality:</p> <ul> <li>Facilitates userspace installations alongside system provided installations</li> <li>Restricts users from installing non-supported compilers (in particular we don't want     people to install their own <code>GCCcore</code> since this would likely lead to an avalanche     of required dependencies) and MPI runtimes (since MPI installations     are heavily customised)</li> <li>Restricts users to only resolve dependencies from our Golden repository (as well     as from     their own installed software) but allows them to search in the upstream repositories<ul> <li>if they try to install something from the upstream repository, the hook advises   them how to do this correctly for our systems</li> </ul> </li> <li>Customises the final module files</li> <li>Customises the names of some modules (such as <code>Intel</code> over <code>iccifort</code> and     <code>IntelMPI</code> over <code>impi</code>)</li> <li>Injects an Lmod family in the modules of our compilers and MPI runtimes</li> <li>Adds Lmod properties for GPU enabled applications and user installed software so     that they can be easily identified in the <code>module</code> view</li> <li>Adds a <code>site_contact</code> for all modules</li> <li>Updates the Lmod cache when an installation is made system-wide</li> </ul> <p>We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system.</p>"},{"location":"2020-06-isc20/jsc/#upgrading-and-retiring-software","title":"Upgrading and retiring software","text":"<p>The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package.</p> <p>The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. For this reason, we have chosen six months as our upgrade period and we chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains.</p> <p>We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. We provide a special development stage with the latest toolchains for the support team where they can prepare their easyconfig files for inclusion in the upgrade. Once a software package has been successfully built and tested, it is added to a Golden repository to be used for the stage upgrade.</p> <p>The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage.</p> <p>While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod.</p>"},{"location":"2020-06-isc20/practical_information/","title":"Practical information","text":"<p>Contact points, resources, helpful hints, and things to keep in mind for the EasyBuild tutorial.</p>"},{"location":"2020-06-isc20/practical_information/#slack","title":"Slack","text":"<p>There is a dedicated <code>#tutorial</code> channel in the EasyBuild Slack where you can get in touch with  organisers of the tutorial, other participants, and volunteers. Please use this channel to ask questions throughout the tutorial, or for any other assistance related to the tutorial.</p> <p>To access this channel, you will first need to create an account in the EasyBuild Slack. This is done via https://easybuild-slack.herokuapp.com/.</p> <p>Once you have the account set up, you can join the EasyBuild Slack via https://easybuild.slack.com/. From there you can join the <code>#tutorial</code> channel. For more information about Slack, please see the official documentation.</p>"},{"location":"2020-06-isc20/practical_information/#aws-resources","title":"AWS resources","text":"<p>(only available during the tutorial on Tuesday June 23rd 2020)</p> <p>Access to a shell environment on AWS Cloud9 is provided for this tutorial.</p> <p>You should have received an email with connection information if you have registered in time for this tutorial.</p> <p>If you did not register and would still like to use AWS Cloud9 for this tutorial, or you have not received the email with the connection information, please contact the tutorial organisers via Slack.</p>"},{"location":"2020-06-isc20/practical_information/#prepared-container-image","title":"Prepared container image","text":"<p>For the purpose of this tutorial, we have prepared a Docker container that you can use to follow the hands-on exercises in a controlled environment.</p> <p>This container image includes a small software stack that was installed using EasyBuild, which will come in useful for the exercises.</p> <p>The container is available through the <code>easybuilders/tutorial</code> repository on Docker Hub, and can be used with both Docker and Singularity.</p> <p>Make sure you use the container image tagged with \"<code>isc20</code>\".</p> <p>Note</p> <p>The command you should use to run the container can be copy-pasted below.</p>"},{"location":"2020-06-isc20/practical_information/#requirements-for-using-the-container-images","title":"Requirements for using the container images","text":"<p>(only relevant if you are not using AWS Cloud9)</p> <ul> <li>having Docker or Singularity installed</li> <li>a system with a processor supporting the AVX instruction set. AVX is supported by Intel Sandy Bridge or AMD Bulldozer (both released in 2011) and onwards.</li> </ul> <p>If you are in doubt about your systems compatibility, see Testing host compatibility at the end of this document.</p>"},{"location":"2020-06-isc20/practical_information/#container-size","title":"Container size","text":"<p>The compressed container image is about 1.25GB in size, and will be downloaded automatically from Docker Hub when you run the <code>docker</code> or <code>singularity</code> command shown below.</p>"},{"location":"2020-06-isc20/practical_information/#using-docker","title":"Using Docker","text":"<p>If you want to use the prepared container image via Docker, run the following <code>docker</code> command:</p> <pre><code>mkdir -p isc20_easybuild_tutorial\nchmod 1777 isc20_easybuild_tutorial\ndocker run -ti --rm --mount type=bind,source=$PWD/isc20_easybuild_tutorial,target=/home/easybuild --hostname tutorial easybuilders/tutorial:isc20\n</code></pre> <p>Note that we are bind mounting the <code>isc20_easybuild_tutorial</code> directory into the container as home directory (<code>/home/easybuild</code>). That way you can easily access the files you create when using the container outside of it as well, for example to edit them. In addition, it allows you to restart the container without losing the contents of your home directory.</p> <p>Output</p> <p>When running the \"<code>docker run</code>\" command shown above, you should see output like is shown below showing that the different layers are being downloaded.</p> <p>Take into account that it will take a while for the container image to be downloaded.</p> <pre><code>Unable to find image 'easybuilders/tutorial:isc20' locally\nisc20: Pulling from easybuilders/tutorial\n9b4ebb48de8d: Pull complete\nf1933cd5add8: Downloading  73.48MB/125.9MB\n7bd84e6bca4a: Download complete \n0a4ea0f4d48f: Download complete \n503478215221: Download complete \nc92d5dd0b39f: Download complete \nf968b6fd8043: Download complete \n5bf43b832c15: Download complete \n0545f7354a51: Downloading  30.56MB/534.8MB\nd1a244ce82da: Waiting \nc14d5fe9b1e6: Waiting \nb93ec9ec5f20: Waiting\n239fd4ac6c1a: Waiting \n9f7279164d6c: Waiting \n8ee47766d1ab: Waiting\n</code></pre> <p>followed by:</p> <pre><code>...\n8ee47766d1ab: Pull complete \nDigest: sha256:25edb356623dde212b256ef23ae17d2b1dc68921094a9c752eac460c78ba9b4c\nStatus: Downloaded newer image for easybuilders/tutorial:isc20\n</code></pre> <p>After this, you should see the welcome message.</p> <p>Docker and cgroups v2</p> <p>If you are using a recent Linux distribution that has switched to cgroups v2  (e.g. Fedora &gt;= 31), docker will fail with</p> <pre><code>OCI runtime create failed: this version of runc doesn't work on cgroups v2\n</code></pre> <p>since it is not yet compatible with cgroups v2. Possible workarounds include:</p> <ul> <li>reverting to cgroups v1 (it can be done via the kernel command-line argument <code>systemd.unified_cgroup_hierarchy=0</code>);</li> <li>using Podman instead, which implements the docker CLI;</li> <li>using Singularity instead (see below);</li> </ul>"},{"location":"2020-06-isc20/practical_information/#using-singularity","title":"Using Singularity","text":"<p>(not available in AWS environment)</p> <p></p> <p>To use the prepared container image via Singularity, run the following <code>singularity</code> command:</p> <pre><code>mkdir -p isc20_easybuild_tutorial\nsingularity run --cleanenv --home $PWD/isc20_easybuild_tutorial docker://easybuilders/tutorial:isc20\n</code></pre> <p>The additional options are required to:</p> <ul> <li><code>--cleanenv</code>: start with clean environment</li> <li><code>--home $PWD/isc20_easybuild_tutorial</code>: use the <code>isc20_easybuild_tutorial</code> subdirectory in the current working directory as home directory in the container</li> </ul> <p>This is mainly to avoid that anything from the host environment or your home directory \"leaks\" into the container, which could interfere with the hands-on exercises.</p> <p>Limitation: <code>/easybuild</code> is read-only</p> <p>When the Docker container image is being run with Singularity, the <code>/easybuild</code> directory is read-only in the container.</p> <p>This creates problems for the demo and exercise in the Hierarchical module naming schemes part of the tutorial, because EasyBuild still requires write access to <code>/easybuild/software</code> even when generating module files in a different location outside of <code>/easybuild</code>.</p> <p>Output</p> <p>When running the \"<code>singularity run</code>\" command shown above, you should see output like is shown below.</p> <p>Take into account that it will take a while for the container image to be downloaded.</p> <pre><code>INFO:    Converting OCI blobs to SIF format\nINFO:    Starting build...\nGetting image source signatures\nCopying blob 9b4ebb48de8d done\nCopying blob f1933cd5add8 done\nCopying blob 7bd84e6bca4a done\nCopying blob 0a4ea0f4d48f done\nCopying blob 503478215221 done\nCopying blob c92d5dd0b39f done\nCopying blob f968b6fd8043 done\nCopying blob 5bf43b832c15 done\nCopying blob 0545f7354a51 done\nCopying blob d1a244ce82da done\nCopying blob c14d5fe9b1e6 done\nCopying blob b93ec9ec5f20 done\nCopying blob 239fd4ac6c1a done\nCopying blob 9f7279164d6c done\nCopying blob 8ee47766d1ab done\nCopying config 717b13fece done\nWriting manifest to image destination\nStoring signatures\n...\nINFO:    Creating SIF file...\n</code></pre> <p>After this, you should see the welcome message.</p> <p>Singularity cache</p> <p>By default Singularity keeps its cache at <code>$HOME/.singularity/cache</code>. Since the uncompressed container image requires about 2.2GB of disk space, make sure this will work in your setup.</p> <p>If your home directory is limited in size you can either make <code>$HOME/.singularity</code> a symbolic link to <code>/tmp/$USER/singularity</code> or a similar spacious volume, or define the <code>$SINGULARITY_CACHEDIR</code> environment variable to make Singulartiy use a different location:</p> <pre><code>export SINGULARITY_CACHEDIR=/tmp/$USER/singularity\n</code></pre> <p>Warning messages</p> <p>When running the Docker container with Singularity, you may see a bunch of warning messages like this pass by:</p> <pre><code>warn rootless{path/to/file} ignoring (usually) harmless EPERM on setxattr \"user.rootlesscontainers\"\n</code></pre> <p>You can safely ignore these warnings, they are harmless. They occur because the Docker container image contains xattrs that can not be set when the container is extracted as an unprivileged user by Singularity. The warnings are generated by the umoci library that Singularity uses to extract Docker/OCI layers, and is documented at https://umo.ci/quick-start/rootless/.</p>"},{"location":"2020-06-isc20/practical_information/#welcome-message","title":"Welcome message","text":"<p>If you are correctly logged in to the container, you should see a message like this:</p> <pre><code>You are logged in to the prepared environment for the introductory tutorial to\n ______                    ____          _  _      _\n|  ____|                  |  _ \\        (_)| |    | |\n| |__    __ _  ___  _   _ | |_) | _   _  _ | |  __| |\n|  __|  / _` |/ __|| | | ||  _ &lt; | | | || || | / _` |\n| |____| (_| |\\__ \\| |_| || |_) || |_| || || || (_| |\n|______|\\__,_||___/ \\__, ||____/  \\__,_||_||_| \\__,_|\n                     __/ |\n                    |___/\n\nThe tutorial materials are available at https://easybuilders.github.io/easybuild-tutorial .\n\nOS: CentOS Linux release 7.8.2003 (Core)\nmodules tool: Lmod 8.2.7\n\nTo access the pre-installed software run 'module use /easybuild/modules/all',\nand then check which modules are installed using 'module avail'.\n\nIn case of questions or problems contact the tutorial organisers via the #tutorial\nchannel in the EasyBuild Slack, join via https://easybuild-slack.herokuapp.com .\n</code></pre>"},{"location":"2020-06-isc20/practical_information/#testing-host-compatibility","title":"Testing host compatibility","text":"<p>To leverage the pre-installed software stack that is included in the container image, the processor in your system must be compatible with binaries that use AVX instructions (Intel Sandy Bridge generation, or newer).</p> <p>You can test the compatibility of your host with the following commands:</p> <pre><code>module use /easybuild/modules/all\nmodule load Python\npython -V\n</code></pre> <p>If the last command prints a Python version (like <code>Python 3.8.2</code>), then your host is compatible.</p> <p>If you see a message like \"<code>Illegal instruction (core dumped)</code>\", the processor in your system is not compatible with the pre-installed software stack, and you will have to use another system to participate in the tutorial.</p> <p>After running this test, you should reset your environment by running \"<code>module purge</code>\", since most of the exercises assume you are starting from a clean environment.</p>"},{"location":"2020-06-isc20/troubleshooting/","title":"Troubleshooting","text":"<p>When installing scientific software you are bound to run into problems  that make the installation fail sooner or later, even when using EasyBuild.</p> <p>In this part we take a look at how you can troubleshoot a failing installation, and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild, the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed.</p> <p>At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!</p>"},{"location":"2020-06-isc20/troubleshooting/#easybuild-error-messages","title":"EasyBuild error messages","text":"<p>When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message.</p> <p>Things that could go wrong during an installation include:</p> <ul> <li>missing source or patch files;</li> <li>a checksum error on a downloaded source or patch file;</li> <li>required dependencies that are not specified in the easyconfig file;</li> <li>failing shell commands;</li> <li>running out of available memory or disk space;</li> <li>a segmentation fault caused by a flipped bit triggered by a cosmic ray (really, it happens!);</li> </ul> <p>Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation...</p> <p>For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, a problem has occurred and the installation will be interrupted.</p>"},{"location":"2020-06-isc20/troubleshooting/#example","title":"Example","text":"<p>Here is an example of an EasyBuild error message (slightly reformatted for clarity):</p> <pre><code>$ eb trouble.eb\n...\n== building...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0):\nbuild failed (first 300 chars): cmd \"make\" exited with exit code 2 and output:\n/usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp\ng++: error: unrecognized command line option '-std=c++14' (took 1 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log\nERROR: Build of /home/easybuild/subread.eb failed (err: ...)\n</code></pre> <p>Let's break this down a bit: during the <code>build</code> step of the installation procedure EasyBuild was running <code>make</code> as a shell command, which failed (exit code 2, so not zero). The <code>make</code> command tripped over the compilation of <code>core.cpp</code> that failed because <code>-std=c++14</code> is not a known option to the <code>g++</code> command.</p> <p>OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is <code>make</code> using <code>/usr/bin/g++</code> for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under <code>/easybuild/software</code>.</p> <p>Let's see what <code>/usr/bin/g++</code> is:</p> <pre><code>$ /usr/bin/g++ --version\ng++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)\n</code></pre> <p>Oh my that's pretty ancient. That could definitely explain why it doesn't know about the C++14 standard yet...</p> <p>Your next step in this case should probably be figuring out why <code>/usr/bin/g++</code> is being used rather than just <code>g++</code>, which would result in using the right compiler version because EasyBuild sets up the build environment carefully.</p> <p>This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.</p>"},{"location":"2020-06-isc20/troubleshooting/#easybuild-log-files","title":"EasyBuild log files","text":"<p>Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward...</p> <p>EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a sensible way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed.</p> <p>In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes.</p> <p>In that case, you will have the dive into the log file that is created for every installation, which is located in the unique temporary directory that was created for the EasyBuild session.</p> <p>See for example this output line from our earlier example error message:</p> <pre><code>== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-trouble-1.0-20200613.145414.aUEJA.log\n</code></pre> <p>You can open this file with your favorite text editor or a tool like <code>less</code> to take a look at the information collected in the log file, which includes things like:</p> <ul> <li>informative messages produced by the EasyBuild framework and the easyblock   describing how the installation is progressing;</li> <li>how the build environment was set up: which modules were loaded, which environment variables were set;</li> <li>the exact shell commands that were executed, and in which directory they were run;</li> <li>the full output produced by these commands, and their exit code;</li> </ul> <p>Note that the installation log is also copied into each software installation directory for successful installation, into the <code>easybuild</code> subdirectory. For example:</p> <pre><code>/easybuild/software/HDF5/1.10.6-gompi-2020a/easybuild/easybuild-HDF5-1.10.6-20200609.131126.log\n</code></pre>"},{"location":"2020-06-isc20/troubleshooting/#last-log","title":"Last log","text":"<pre><code>vim $(eb --last-log)\n</code></pre>"},{"location":"2020-06-isc20/troubleshooting/#navigating-log-files","title":"Navigating log files","text":"<p>Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors:</p> <ul> <li><code>ERROR</code></li> <li><code>Error 1</code></li> <li><code>error:</code></li> <li><code>failure</code></li> <li><code>not found</code></li> <li><code>No such file or directory</code></li> <li><code>bazel</code></li> <li><code>Segmentation fault</code></li> </ul> <p>Using \"<code>error</code>\" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an <code>error.c</code> file), and you'll miss others that do include errors but mention <code>ERROR</code> or <code>Error</code> rather than <code>error</code>.</p> <p>When using <code>less</code> to view a log file, you can navigate it by:</p> <ul> <li>hitting '<code>$</code>' followed by '<code>G</code>' to go to the end of the log file;</li> <li>using your arrow keys to scroll up/down;</li> <li>typing '<code>?</code>' followed by some text and Enter to search backwards for a particular pattern ('<code>/</code>' to search forwards, '<code>n</code>' for next match);</li> <li>hitting '<code>q</code>' to exit;</li> </ul> <p>It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these:</p> <pre><code>== 2020-06-13 01:34:48,816 example INFO configuring...\n== 2020-06-13 01:34:48,817 example INFO Starting configure step\n...\n== 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure\n</code></pre> <p>If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for <code>HDF5</code>):</p> <pre><code>== 2020-06-09 13:11:19,968 run.py:222 INFO running cmd:  make install\n== 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output:\nMaking install in src\nmake[1]: Entering directory `/tmp/example/HDF5/1.10.6/gompi-2020a/hdf5-1.10.6/src'\n...\n</code></pre> <p>It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \"<code>INFO running cmd</code>\" as a search pattern, and then looking for patterns like \"<code>error:</code>\" from there.</p>"},{"location":"2020-06-isc20/troubleshooting/#inspecting-the-build-directory","title":"Inspecting the build directory","text":"<p>When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there.</p> <p>The location of the build directory is mentioned in the EasyBuild error message:</p> <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/trouble/1.0/GCC-9.3.0): ...\n</code></pre> <p>For software using a classic <code>configure</code> script, you may have to locate and inspect the <code>config.log</code> file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in <code>CMakeOutput.log</code> or <code>CMakeError.log</code> for clues, which are sneakily hidden by CMake in a <code>CMakeFiles</code> subdirectory of the build directory.</p> <p>As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the <code>buildpath</code> directory.</p>"},{"location":"2020-06-isc20/troubleshooting/#exercise","title":"Exercise","text":"<p>Let's work our way through a less smooth software installation, using the easyconfig file that is provided in <code>/easybuild/tutorial/subread.eb</code> in the tutorial container image.</p> <p>For completeness sake, the contents are shown below. Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial.</p> <pre><code>easyblock = 'MakeCp'\n\nname = 'Subread'\nversion = '2.0.1'\n\nhomepage = 'http://subread.sourceforge.net'\ndescription = \"High performance read alignment, quantification and mutation discovery\"\n\ntoolchain = {'name': 'GCC', 'version': '8.4.0'}\n\n# download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\nchecksums = ['d808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b']\n\nstart_dir = 'src'\n\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast\"'\n\nfiles_to_copy = ['bin']\n\nsanity_check_paths = {\n    'files': ['bin/featureCounts', 'bin/subread-align'],\n    'dirs': ['bin/utilities'],\n}\n\nsanity_check_commands = [\"featureCounts --version\"]\n\nmoduleclass = 'bio'\n</code></pre> <p>Do you spot any potential problems yet with this easyconfig file?</p> <p>Preparation</p> <p>Start by copying the easyconfig file to your home directory, so you can make changes to it.</p> <pre><code>cd $HOME\ncp /easybuild/tutorial/subread.eb .\n</code></pre> <p>Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself):</p> <pre><code>module use /easybuild/modules/all\nmodule load EasyBuild\n</code></pre> <p>For this exercise, make sure EasyBuild is configured to use <code>$HOME/easybuild</code> as <code>prefix</code>, and to use <code>/tmp/$USER</code> as <code>buildpath</code>:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Check your configuration via <code>eb --show-config</code>.</p> <p>Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions.</p> <p>Remember though: no peeking before you tried to solve each step yourself!</p> <p>Exercise 5.1 - Sources</p> <p>Try to install the <code>subread.eb</code> easyconfig file, see what happens.</p> <p>Can you fix the problem you run into, perhaps without even changing the easyconfig file?</p> (click to show solution) <p>The installation fails because the source file <code>subread-2.0.1-source.tar.gz</code> is not found: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars):\nCouldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either...\nPaths attempted (in order): ...\n</code></pre></p> <p>In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: <pre><code># download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre></p> <p>We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the <code>sourcepath</code> directory): <pre><code>curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nmv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/\n</code></pre></p> <p>In case download is problematic, the source tarball is also available in <code>/easybuild/tutorial/</code>:</p> <pre><code>cp /easybuild/tutorial/subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/\n</code></pre> <p>Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: <pre><code>source_urls = ['https://download.sourceforge.net/subread/']\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre> Note that the <code>source_urls</code> value is a list of candidate URLs, without the filename of the source file.</p> <p>The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while.</p> <pre><code>$ ls -lh $HOME/easybuild/sources/s/Subread\ntotal 23M\n-rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17:42 subread-2.0.1-source.tar.gz\n</code></pre> <p>Exercise 5.2 - Toolchain</p> <p>After fixing the problem with missing source file, try the installation again.</p> <p>What's wrong now? How can you fix it quickly?</p> <p>Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here...</p> (click to show solution) <p>The installation fails because the easyconfig specifies that GCC 8.4.0 should be used as toolchain: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.3.0): build failed (first 300 chars):\nNo module found for toolchain: GCC/8.4.0 (took 1 sec)\n</code></pre></p> <p>We don't have this GCC version installed, but we do have GCC 9.3.0:</p> <pre><code>$ module avail GCC/\n----------------- /easybuild/modules/all ------------------\n   GCC/9.3.0\n</code></pre> <p>So let's try using that instead.</p> <p>Edit the easyconfig file so it contains this:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '9.3.0'}\n</code></pre> <p>Or run the following <code>sed</code> command to change the toolchain version to <code>'9.3.0'</code>:</p> <pre><code>sed -i 's/8.4.0/9.3.0/' subread.eb </code></pre> <p>Exercise 5.3 - Build step</p> <p>With the first two problems fixed, now we can actually try to build the software.</p> <p>Can you fix the next problem you run into?</p> (click to show solution) <p>The compilation fails, but the error message we see is incomplete due to  EasyBuild truncating the command output (only the 300 first characters of the output are shown): <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars):\ncmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast\"\" exited with exit code 2 and output:\ngcc  -mtune=core2  -O3 -DMAKE_FOR_EXON  -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\"  -D_FILE_OFFSET_BITS=64    -fmessage-length=0  -ggdb  -fast   -c -o core.o core.c\ngcc: error: unrecognized command line opti (took 1 sec)\n</code></pre></p> <p>If you open the log file and scroll to the end, the error is pretty obvious: <pre><code>gcc: error: unrecognized command line option -fast; did you mean -Ofast?\nmake: *** [core.o] Error 1\n</code></pre></p> <p>The easyconfig file hard specifies the <code>-fast</code> compiler flag via <code>CFLAGS=</code> to the build command: <pre><code>buildopts = '-f Makefile.Linux CFLAGS=\"-fast\"'\n</code></pre></p> <p>EasyBuild sets up the build environment so there should be no need to hard specify compiler flags (certainly not incorrect ones), but it's good to keep an eye on it to make sure that the compiler flags specified by EasyBuild are actually being used.</p> <p>In this case we need to get rid of the '<code>CFLAGS=\"...\"</code>' part in the <code>buildopts</code> value, but the \"<code>-f Makefile.Linux</code>\" part should stay.</p> <p>The problem can be fixed by changing the easyconfig file as follows:</p> <pre><code>buildopts = '-f Makefile.Linux'\n</code></pre> <p>You can copy-paste and run this <code>sed</code> command to make the change without using an editor:</p> <pre><code>sed -i \"s/buildopts.*/buildopts = '-f Makefile.Linux'/\" subread.eb\n</code></pre> <p>Exercise 5.4 - Sanity check</p> <p>After fixing the compilation issue, you're really close to getting the installation working, we promise!</p> <p>Don't give up now, try one last time and fix the last problem that occurs...</p> (click to show solution) <p>Now the installation itself works but the sanity check fails, and hence the module file does not get generated: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-9.3.0): build failed (first 300 chars):\nSanity check failed: sanity check command featureCounts --version exited with code 255\n(output: featureCounts: unrecognized option '--version'\n...\n</code></pre></p> <p>If you look at the full output in the log file you can see that the correct option to check the version of the <code>featureCounts</code> command is \"<code>-v</code>\" rather than \"<code>--version</code>\", so we need to fix this in the easyconfig file.</p> <p>Make the following change in the easyconfig file: <pre><code>sanity_check_commands = [\"featureCounts -v\"]\n</code></pre></p> <p>Or you can use this <code>sed</code> command to make that change: <pre><code>sed -i 's/featureCounts --version/featureCounts -v/' subread.eb\n</code></pre></p> <p>After doing so, you don't have to redo the installation from scratch, you can use the <code>--module-only</code> option to only run the sanity check and generate the module file again: <pre><code>eb subread.eb --module-only\n</code></pre></p> <p>In the end, you should be able to install Subread 2.0.1 with the GCC 9.3.0 toolchain by fixing the problems with the <code>subread.eb</code> easyconfig file.</p> <p>Check your work by manually loading the module and checking the version via the <code>featureCounts</code> command, which should look like this:</p> <pre><code>$ featureCounts -v\nfeatureCounts v2.0.1\n</code></pre>"},{"location":"2021-isc21/","title":"ISC'21 EasyBuild tutorial","text":""},{"location":"2021-isc21/#maintaining-a-modern-scientific-software-stack-made-easy-with-easybuild","title":"Maintaining a Modern Scientific Software Stack Made Easy with EasyBuild","text":"<p>The EasyBuild tutorial at ISC'21 takes place on Friday June 25th 2021, 12:00-16:00 UTC.</p> <p>To attend the live tutorial, you must be registered to ISC'21 (more information here).</p> <p>All tutorial content, including recorded sessions, will be made available afterwards.</p>"},{"location":"2021-isc21/#slides","title":"Slides","text":"<p>The most recent version of the presentation slides are available here.</p>"},{"location":"2021-isc21/#recording","title":"Recording","text":""},{"location":"2021-isc21/#agenda","title":"Agenda","text":"<p>(all times are UTC)</p> <ul> <li>[12:00-12:10] Practical info</li> <li>[12:10-12:30] Introduction and terminology</li> <li>[12:30-13:00] Installation, configuration, and basic usage</li> <li>[13:00-13:45] Installing software + troubleshooting</li> <li>[13:45-14:15] (coffee break)</li> <li>[14:15-14:45] Module naming schemes</li> <li>[14:45-15:10] Adding support for additional software</li> <li>[15:10-15:20] EasyBuild at J\u00fclich Supercomputing Centre</li> <li>[15:20-15:30] EasyBuild at Compute Canada</li> <li>[15:30-15:45] The EasyBuild community + Contributing to EasyBuild</li> <li>[15:45-16:00] Q&amp;A + closing remarks</li> </ul>"},{"location":"2021-isc21/adding_support_additional_software/","title":"Adding support for additional software","text":"<p>We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet?</p> <p>To do this we will need to create additional easyconfig files, since every software installation performed by EasyBuild is done based on an easyconfig file.</p> <p>In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!</p>"},{"location":"2021-isc21/adding_support_additional_software/#easyconfigs-vs-easyblocks","title":"Easyconfigs vs easyblocks","text":"<p>Before we dive into writing easyconfig files, let's take a brief look at how they relate to easyblocks.</p> <p>As we discussed earlier, an easyconfig file (<code>*.eb</code>) is required for each installation performed by EasyBuild. It specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module that leverages the EasyBuild framework).</p> <p>When can we leverage a generic easyblock, perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock?</p> <p>This is not an easy question to answer in general, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the implementation of the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc.</p> <p>In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package.</p> <p>Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include:</p> <ul> <li>'critical' values for easyconfig parameters required to make installation succeed;</li> <li>toolchain-specific aspects of the build and installation procedure (e.g., configure options);</li> <li>interactive commands that need to be run;</li> <li>custom (configure) options for dependencies;</li> <li>having to create or adjust specific (configuration) files;</li> <li>'hackish' usage of a generic easyblock;</li> <li>complex or very non-standard installation procedure;</li> </ul> <p>Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation, or a more extensive version of the EasyBuild tutorial.</p>"},{"location":"2021-isc21/adding_support_additional_software/#writing-easyconfig-files","title":"Writing easyconfig files","text":"<p>Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a '<code>.eb</code>' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier).</p> <p>The syntax for easyconfig files is Python syntax: you are basically defining a bunch of Python variables that correspond to easyconfig parameters.</p> <p>The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.</p>"},{"location":"2021-isc21/adding_support_additional_software/#mandatory-parameters","title":"Mandatory parameters","text":"<p>A limited number of easyconfig parameters are mandatory, they must be defined in every easyconfig file:</p> <ul> <li><code>name</code>: the name of the software to install;</li> <li><code>version</code>: the version of the software to install;</li> <li><code>homepage</code>: a URL to the website of the software;</li> <li><code>description</code>: a short description of the software;</li> <li><code>toolchain</code>: the compiler toolchain to use for the installation;</li> </ul> <p><code>name</code>, <code>version</code></p> <p>It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install.</p> <pre><code>name = 'example'\nversion = '1.0'\n</code></pre> <p><code>homepage</code>, <code>description</code></p> <p>The homepage and description are included in the generated module file for the installation. That way the \"<code>module show</code>\" command provides some useful high-level information about the installation.</p> <pre><code>homepage = 'https://example.org'\ndescription = \"This is just an example.\"\n</code></pre> <p>Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!).</p> <p>For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax):</p> <pre><code>description = \"\"\"This is an example\n of a multi-line description.\n It is spread across multiple lines.\"\"\"\n</code></pre> <p><code>toolchain</code></p> <p>EasyBuild also requires that the compiler toolchain is specified, via the <code>toolchain</code> easyconfig parameter.</p> <p>This can either be the <code>system</code> toolchain, for which a constant named <code>SYSTEM</code> is available:</p> <pre><code>toolchain = SYSTEM\n</code></pre> <p>Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 10.2.0 which we used before, or the full toolchain <code>foss</code> 2020b. The name and version of the toolchain can be specified using a small Python dictionary, for example:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '10.2.0'}\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#commonly-used-parameters","title":"Commonly used parameters","text":"<p>You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory.</p> <p>A full overview of all known easyconfig parameters can be obtained via \"<code>eb --avail-easyconfig-params</code>\" or just \"<code>eb -a</code>\" for short, or can be consulted in the EasyBuild documentation.</p>"},{"location":"2021-isc21/adding_support_additional_software/#sources-patches-and-checksums","title":"Sources, patches, and checksums","text":"<p>In most easyconfig files you will see that a list of source files is specified via the <code>sources</code> easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via <code>source_urls</code>. There also may be patch files listed (specified via <code>patches</code>), and checksums for both the source files and patches (specified via <code>checksums</code>).</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>Here is an example of how these easyconfig parameters can be specified:</p> <pre><code>source_urls = [\n    'https://example.org/download/',\n    'https://example.org/download/archive/',\n]\nsources = ['example-1.0-src.tar.gz']\npatches = ['example-fix.patch']\nchecksums = [\n    '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa',\n    '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c',\n]\n</code></pre> <p>Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list (<code>[]</code>).</p> <p>Some things worth pointing out here:</p> <ul> <li>The download URLs specified via <code>source_urls</code> do not include the name of the file, that is added   automatically by EasyBuild when it tries to download the file (only if it's not available already.)</li> <li>If multiple download URLs are specified, they are each tried once in order until the download of the source file was   successful. This can be useful to include backup locations where source files can be downloaded from.</li> <li>Names of source files and patches should not include hardcoded software versions, they usually use a   template value like <code>%(version)s</code> instead:   <pre><code>sources = ['example-%(version)s-src.tar.gz']\n</code></pre>   EasyBuild will use the value of the <code>version</code> easyconfig parameter to determine the actual name of the source   file. This way the software version is only specified in one place and the easyconfig file is easier to   update to other software versions. A list of template values can be consulted via the EasyBuild command   line via the <code>--avail-easyconfig-templates</code> option, or in the EasyBuild documentation.</li> <li>Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information.</li> <li>Specified checksums are usually SHA256 checksum values, but other types are also supported.</li> </ul>"},{"location":"2021-isc21/adding_support_additional_software/#easyblock","title":"Easyblock","text":"<p>The easyblock that should be used for the installation can be specified via the <code>easyblock</code> easyconfig parameter.</p> <p>This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If '<code>example</code>' is specified as software name, EasyBuild will try to locate a software-specific easyblock named <code>EB_example</code> (in a Python module named <code>example.py</code>). Software-specific easyblocks follow the convention that the class name starts with <code>'EB_</code>', followed by the software name (where some characters are replaced, like '<code>-</code>' with '<code>_minus_</code>').</p> <p>Generic easyblocks</p> <p>Usually the <code>easyblock</code> value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with '<code>EB_</code>', so you can easily distinguish it from a software-specific easyblock.</p> <p>Here are a couple of commonly used generic easyblocks:</p> <ul> <li><code>ConfigureMake</code>: implements the standard <code>./configure</code>, <code>make</code>, <code>make install</code> installation procedure;</li> <li><code>CMakeMake</code>: same as <code>ConfigureMake</code>, but with <code>./configure</code> replaced with <code>cmake</code> for the configuration step;</li> <li><code>PythonPackage</code>: implements the installation procedure for a single Python package, by default using    \"<code>python setup.py install</code>\" but other methods like using \"<code>pip install</code>\" are also supported;</li> <li><code>Bundle</code>: a simple generic easyblock to bundle a set of software packages together in a single installation directory;</li> <li><code>PythonBundle</code>: a customized version of the <code>Bundle</code> generic easyblock to install a bundle of Python packages   in a single installation directory;</li> </ul> <p>A full overview of the available generic easyblocks is available in the EasyBuild documentation. You can also consult the output of <code>eb --list-easyblocks</code>, which gives an overview of all known easyblocks, and how they relate to each other.</p> <p>Custom easyconfig parameters</p> <p>Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \"<code>eb -a --easyblock</code>\" or just \"<code>eb -a -e</code>\", which results in an additional \"<code>EASYBLOCK-SPECIFIC</code>\" section to be added. See the (partial) output of this command for example:</p> <pre><code>$ eb -a -e ConfigureMake\nAvailable easyconfig parameters (* indicates specific to the ConfigureMake easyblock):\n...\nEASYBLOCK-SPECIFIC\n------------------\nbuild_cmd*              Build command to use [default: \"make\"]\nbuild_type*             Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\nconfigure_cmd*          Configure command to use [default: \"./configure\"]\nconfigure_cmd_prefix*   Prefix to be glued before ./configure [default: \"\"]\nhost_type*              Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\ninstall_cmd*            Build command to use [default: \"make install\"]\nprefix_opt*             Prefix command line option for configure script ('--prefix=' if None) [default: None]\ntar_config_opts*        Override tar settings as determined by configure. [default: False]\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#dependencies","title":"Dependencies","text":"<p>You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies.</p> <p>Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the <code>dependencies</code> easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file.</p> <p>Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the <code>builddependencies</code> easyconfig parameter. One typical example of a build dependency is <code>CMake</code>, which is only needed for configuring the build.</p> <p>Here is a simple example of specifying dependencies:</p> <pre><code>builddependencies = [('CMake', '3.18.4')]\n\ndependencies = [\n    ('Python', '3.8.2'),\n    ('HDF5', '1.10.6'),\n    ('SciPy-bundle', '2020.03', '-Python-%(pyver)s'),\n]\n</code></pre> <p>Both <code>builddependencies</code> and <code>dependencies</code> require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values).</p> <p>In some cases additional information may have to be provided, as is shown in the example above for the <code>SciPy-bundle</code> dependency where a 3rd value is specified corresponding to the <code>versionsuffix</code> value of this dependency. If this is not specified, it is assumed to be the empty string (<code>''</code>).</p> <p>Note how we use the '<code>%(pyver)s'</code> template value in the <code>SciPy-bundle</code> dependency specification, to avoid hardcoding the Python version in different places.</p> <p>See also the EasyBuild documentation for additional options on specifying dependencies.</p>"},{"location":"2021-isc21/adding_support_additional_software/#version-suffix","title":"Version suffix","text":"<p>In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation.</p> <p>The <code>versionsuffix</code> easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme.</p> <p>If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example:</p> <pre><code>versionsuffix = '-example-label'\n</code></pre> <p>This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the <code>%(pyver)s</code> template comes in useful again:</p> <pre><code>versionsuffix = '-Python-%(pyver)s'\n...\ndependencies = [('Python', '2.7.18')]\n</code></pre> <p>Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The <code>versionsuffix</code> label is helpful to inform the user that a particular Python version is required by the installation.</p>"},{"location":"2021-isc21/adding_support_additional_software/#customizing-configure-build-test-and-install-commands","title":"Customizing configure, build, test, and install commands","text":"<p>When using a generic easyblock like <code>ConfigureMake</code> or <code>CMakeMake</code>, you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them.</p> <p>For this the following standard easyconfig parameters are available:</p> <ul> <li><code>preconfigopts</code>: string value that is glued before the configure command;</li> <li><code>configopts</code>: string value that is added after the configure command, which can be used to specify configuration options;</li> </ul> <p>Equivalent easyconfig parameters are available for the <code>build</code>, <code>test</code> and <code>install</code> steps: <code>prebuildopts</code>, <code>buildopts</code>, <code>pretestopts</code>, <code>testopts</code>, <code>preinstallopts</code>, and <code>installopts</code>.</p> <p>Here is a fictitious example of how they can be used:</p> <pre><code>easyblock = 'ConfigureMake'\n...\ndependencies = [('HDF5', '1.10.6')]\n...\nconfigopts = '--enable-hdf5-support'\n\nprebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp; '\n\ninstallopts = \"PREFIX='%(installdir)s'\"\n</code></pre> <p>Here we are:</p> <ul> <li> <p>adding the <code>--enable-hdf5-support</code> configure option, to convince the <code>ConfigureMake</code> easyblock to run the following   command during the configure step:   <pre><code>./configure --prefix ... --enable-hdf5-support\n</code></pre>   The '<code>...</code>' represents the path to installation directory where the software should be installed.   The <code>--prefix</code> option is included automatically by the <code>ConfigureMake</code> easyblock.</p> </li> <li> <p>specifying that an additional command has to be run before running <code>make</code> in the build step. We use '<code>&amp;&amp;</code>' to glue the   command to the <code>make</code> command, so <code>make</code> will only be run if the command we specified ran correctly. So, the build step will run something like:   <pre><code>export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp;  make -j 4\n</code></pre>   The '<code>4</code>' value passed to the <code>-j</code> option shown here, which specifies how many commands <code>make</code> can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account <code>ulimit</code> settings, and cpuset and cgroup restrictions).</p> </li> <li> <p>passing the location where the software should be installed via the <code>PREFIX</code> argument to the <code>make install</code> command during the installation step. This results in the   following command being run:   <pre><code>make install PREFIX=...\n</code></pre>   (where the '<code>...</code>' again represents the path to installation directory).   Even though the   installation directory is already specified in the configure command, it is   apparently blatantly ignored by the software we are installing here, and we are expected to specify it   this way instead. How rude!</p> </li> </ul> <p>The <code>$EBROOTHDF5</code> environment variable that we are using in <code>prebuildopts</code> corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an <code>$EBROOT*</code> environment variable like this in every environment module file it generates (see the output of \"<code>module show HDF5</code>\").</p>"},{"location":"2021-isc21/adding_support_additional_software/#sanity-check","title":"Sanity check","text":"<p>One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step.</p> <p>By default EasyBuild does a simple sanity check that verifies whether there is a non-empty <code>bin</code> subdirectory in the installation, next to a non-empty <code>lib</code> or <code>lib64</code> directory (either is sufficient).</p> <p>It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like <code>example -V</code> or <code>example --help</code>) runs correctly.</p> <p>To specify a custom set of files and/or directories to check, you can use the <code>sanity_check_paths</code> easyconfig parameter. The expected value is Python dictionary with two keys: <code>files</code> and <code>dirs</code>. For example:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/example'],\n    'dirs': ['examples/one', 'examples/two'],\n}\n</code></pre> <p>In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the <code>sanity_check_commands</code> easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example:</p> <pre><code>sanity_check_commands = [\n    \"example --version\",\n    \"example --help\",\n]\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#module-class","title":"Module class","text":"<p>Finally, you will usually see the <code>moduleclass</code> easyconfig parameter to be defined as well, for example:</p> <pre><code>moduleclass = 'lib'\n</code></pre> <p>This is done to categorize software, and it is used to group the generated module files into smaller sets (remember what we saw when installing software earlier).</p>"},{"location":"2021-isc21/adding_support_additional_software/#generating-tweaked-easyconfigs","title":"Generating tweaked easyconfigs","text":"<p>Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too?</p> <p>We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the <code>--try-*</code> options provided by the <code>eb</code> command to make EasyBuild generate a new easyconfig file based on an existing one.</p> <p>For example, to try installing a different software version you can use the <code>--try-software-version</code> option:</p> <pre><code>eb example-1.2.3.eb --try-software-version 1.2.4\n</code></pre> <p>Or, to try using a different compiler toolchain you can use <code>--try-toolchain</code>:</p> <pre><code>eb example-1.2.3-foss-2020b.eb --try-toolchain intel,2020b\n</code></pre> <p>It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a <code>--try-*</code> option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.</p>"},{"location":"2021-isc21/adding_support_additional_software/#copying-easyconfigs","title":"Copying easyconfigs","text":"<p>One additional handy command line option we want to highlight is <code>--copy-ec</code>, which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the <code>eb</code> command using only the filename, and letting the robot search mechanism locate them.</p> <p>So to copy an easyconfig file, we would have to use <code>eb --search</code> first to get the full location to it, copy-paste that, and then use the <code>cp</code> command.</p> <p>It is a lot easier with <code>--copy-ec</code>:</p> <pre><code>$ eb --copy-ec SAMtools-1.11-GCC-10.2.0.eb SAMtools.eb\n...\nSAMtools-1.10-GCC-10.2.0.eb copied to SAMtools.eb\n</code></pre> <p>If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename.</p> <p>You can copy multiple easyconfig files at once, as long as the target location is an existing directory.</p>"},{"location":"2021-isc21/adding_support_additional_software/#example","title":"Example","text":"<p>By means of example, we are going to puzzle together an easyconfig file to install the example software package <code>eb-tutorial</code>.</p> <p>The sources for <code>eb-tutorial</code> version 1.0.1 are available at:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz\n</code></pre> <p>You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1.</p>"},{"location":"2021-isc21/adding_support_additional_software/#preparation","title":"Preparation","text":"<p>Make sure EasyBuild is properly configured before you start:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>and that the installed software in <code>/easybuild</code> is available:</p> <pre><code>module use /easybuild/modules/all\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#mandatory-parameters_1","title":"Mandatory parameters","text":"<p>Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file.</p> <p>We will use <code>GCC/10.2.0</code> as toolchain, since we know it is already installed in <code>/easybuild</code> in the prepared environment, so we define the <code>toolchain</code> easyconfig parameter:</p> <pre><code>name = 'eb-tutorial'\nversion = '1.0.1'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\ntoolchain = {'name': 'GCC', 'version': '10.2.0'}\n</code></pre> <p>In addition, we'll also specify the <code>moduleclass</code>. This is not required, but it is usually set to a sensible value:</p> <pre><code>moduleclass = 'tools'\n</code></pre> <p>The default value is '<code>base</code>', at least '<code>tools</code>' has some meaning.</p>"},{"location":"2021-isc21/adding_support_additional_software/#easyblock_1","title":"Easyblock","text":"<p>Let us see what happens if we take our current easyconfig file for a spin:</p> <pre><code>$ eb example.eb\n== temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log\nERROR: Failed to process easyconfig /home/example/example.eb:\nNo software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial\n</code></pre> <p>That didn't get us very far...</p> <p>The error shows that there is no software-specific easyblock available for installing the software with the name '<code>eb-tutorial</code>'. Does that mean we have to implement an easyblock?</p> <p>In this simple case it doesn't, since we can leverage one of the available generic easyblocks. But, which one?</p> <p>Build instructions are usually included in a <code>README</code> file, or in the documentation. In this case, there's indeed a minimal <code>README</code> file available, which tells us that we should use the <code>cmake</code> command to configure the installation, followed by <code>make</code> and <code>make install</code>.</p> <p>We briefly discussed a generic easyblock that does exactly this: <code>CMakeMake</code>.</p> <pre><code>easyblock = 'CMakeMake'\n</code></pre> <p>The \"<code>easyblock =</code>\" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).</p>"},{"location":"2021-isc21/adding_support_additional_software/#cmake-build-dependency","title":"CMake build dependency","text":"<p>Does using the <code>CMakeMake</code> generic easyblock help at all?</p> <pre><code>$ eb example.eb\n== temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log\n== found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/example.eb\n== building and installing eb-tutorial/1.0.1-GCC-10.2.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0):\nbuild failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native  (took 0 sec)\n</code></pre> <p>It did help: EasyBuild made an attempt to configure the build using the <code>cmake</code> command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message:</p> <pre><code>/bin/bash: cmake: command not found\n</code></pre> <p>Ah, that explains it, <code>cmake</code> isn't even installed on this system. Or is it?</p> <pre><code>$ module avail CMake\n\n--------------------------- /easybuild/modules/all ----------------------------\n   CMake/3.18.4-GCCcore-10.2.0\n</code></pre> <p>Since a module is available for <code>CMake</code> that is compatible with the toolchain we are using (GCC 10.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency:</p> <pre><code>builddependencies = [('CMake', '3.18.4')]\n</code></pre> <p>There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies.</p> <p>You can verify this via <code>eb -D</code> (equivalent with <code>eb --dry-run</code>):</p> <pre><code>$ eb example.eb -D\n ...\n * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0)\n * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.18.4-GCCcore-10.2.0.eb (module: CMake/3.18.4-GCCcore-10.2.0)\n * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-10.2.0)\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#sources","title":"Sources","text":"<p>If you try again after adding <code>CMake</code> as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this:</p> <pre><code>CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-10.2.0\" does not appear to contain CMakeLists.txt.\n</code></pre> <p>Wait, but there is a <code>CMakeLists.txt</code>, we can see it in the unpacked sources!</p> <p>Let's inspect the build directory:</p> <pre><code>$ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0\neasybuild_obj\n$ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0/easybuild_obj\n$\n</code></pre> <p>There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file...</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>So we need to specify one or more source files that should be used, via the <code>sources</code> easyconfig parameter which specifies a list of names of source files:</p> <pre><code>sources = ['eb-tutorial-1.0.1.tar.gz']\n</code></pre> <p>We can avoid hardcoding the version number here by using a template value:</p> <pre><code>sources = ['eb-tutorial-%(version)s.tar.gz']\n</code></pre> <p>And since this is a standard way of naming software files, there's even a constant available that we can use:</p> <pre><code>sources = [SOURCE_TAR_GZ]\n</code></pre> <p>That way, we only have the software version specified once in the easyconfig file, via the <code>version</code> easyconfig parameter. That will come in useful later (see Exercise 7.2)...</p> <p>If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere:</p> <pre><code>Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either...\n</code></pre> <p>To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via <code>source_urls</code>:</p> <pre><code>source_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#required-configure-option","title":"Required configure option","text":"<p>With <code>sources</code> and <code>source_urls</code> defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe...</p> <p>Here's what we find in the log file:</p> <pre><code>CMake Error at CMakeLists.txt:7 (message):\n  EBTUTORIAL_MSG is not set!\n</code></pre> <p>Apparently the <code>eb-tutorial</code> software has a required configure option. It's almost as if that was done on purpose, how silly!</p> <p>Options to the configure command can be specified by the <code>configopts</code> easyconfig parameter. To define the value of a CMake option, we need to use <code>-DNAME_OF_OPTION</code>, so:</p> <pre><code>configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n</code></pre> <p>We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the <code>EBTUTORIAL_MSG</code> configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1).</p>"},{"location":"2021-isc21/adding_support_additional_software/#sanity-check_1","title":"Sanity check","text":"<p>Hopefully that brings us closer to getting the installation to work...</p> <pre><code>$ eb example.eb\n....\n== sanity checking...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars):\nSanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 (took 2 sec)\n</code></pre> <p>It got all the way to the sanity check step, that's great!</p> <p>The sanity check failed because no '<code>lib</code>' or <code>'lib64'</code> directory was found. Indeed:</p> <pre><code>$ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0\nbin\n$ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0/bin\neb-tutorial\n</code></pre> <p>There is only a binary named <code>eb-tutorial</code> in the <code>bin</code> subdirectory. So we need to customize the standard sanity check:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n</code></pre> <p>Since we want to obtain a working installation, we might as well try to run this <code>eb-tutorial</code> command as well:</p> <pre><code>sanity_check_commands = ['eb-tutorial']\n</code></pre> <p>Let us now retry, but use <code>--module-only</code> rather than redoing the whole installation. <code>--module-only</code> still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via <code>--trace</code> we can get some more information too:</p> <pre><code>$ eb example.eb --module-only --trace\n...\n== sanity checking...\n  &gt;&gt; file 'bin/eb-tutorial' found: OK\n  &gt;&gt; running command 'eb-tutorial' ...\n  &gt;&gt; result for command 'eb-tutorial': OK\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> <p>Yes, great success!</p> <p>To convince yourself that the installation works as intended, try to load the <code>eb-tutorial</code> module and run the <code>eb-tutorial</code> command yourself:</p> <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial\n$ eb-tutorial\nHello from the EasyBuild tutorial!\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#complete-easyconfig","title":"Complete easyconfig","text":"<p>Here is the complete easyconfig we puzzled together for this example:</p> <pre><code>easyblock = 'CMakeMake'\n\nname = 'eb-tutorial'\nversion = '1.0.1'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\ntoolchain = {'name': 'GCC', 'version': '10.2.0'}\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9']\n\nbuilddependencies = [('CMake', '3.18.4')]\n\nconfigopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n\nsanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n\nsanity_check_commands = ['eb-tutorial']\n\nmoduleclass = 'tools'\n</code></pre> <p>One additional easyconfig parameter we defined here is <code>checksums</code>, which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation.</p> <p>You can let EasyBuild determine and inject these SHA256 checksums automatically via <code>eb --inject-checksums</code>:</p> <pre><code>$ eb example.eb --inject-checksums\n...\n== injecting sha256 checksums for sources &amp; patches in example.eb...\n== * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9\n</code></pre>"},{"location":"2021-isc21/adding_support_additional_software/#exercises","title":"Exercises","text":"<p>Exercise E.1 - Making <code>eb-tutorial</code> a bit more personal</p> <p>Change the easyconfig file for <code>eb-tutorial</code> to make the message printed by the <code>eb-tutorial</code> command a bit more personal: include the username of the account that was used to install the software in it (using the <code>$USER</code> environment variable).</p> (click to show solution) <p>For this we need to change the value that is passed to the <code>EBTUTORIAL_MSG</code> configure option: <pre><code>configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" '\n</code></pre> Here we have to use inner double quotes, to ensure that the <code>$USER</code> environment variable is expanded by the shell when running the <code>cmake</code> configure command.</p> <p>When you run the <code>eb-tutorial</code> command yourself, you should get output like this (not a message that includes a literal '<code>$USER</code>' string):</p> <pre><code>Hello from the EasyBuild tutorial! I was installed by example.\n</code></pre> <p>To re-install the <code>example.eb</code> easyconfig, you will need to use <code>eb --rebuild</code> or <code>eb --force</code>.</p> <p>Exercise E.2 - Installing eb-tutorial version 1.1.0</p> <p>Install version 1.1.0 of the <code>eb-tutorial</code> example software, which is a trivial version bump compared to version 1.0.1.</p> <p>The sources are available via:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz\n</code></pre> <p>You can leverage the <code>eb-tutorial</code> easyconfig file we have composed in the example above, but you should not make any manual changes to it!</p> (click to show solution) <p>You can use the <code>--try-software-version</code> option for this: <pre><code>$ eb example.eb --try-software-version 1.1.0\n...\n== building and installing eb-tutorial/1.1.0-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> To test: <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial/1.1.0-GCC-10.2.0\n$ eb-tutorial\nI have a message for you:\nHello from the EasyBuild tutorial!\n</code></pre> (<code>eb-tutorial</code> version 1.0.1 doesn't print \"<code>I have a message for you:</code>\")</p> <p>Exercise E.3 - Installing py-eb-tutorial 1.0.0</p> <p>Try composing an easyconfig file for the <code>py-eb-tutorial</code> example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz.</p> <p>A couple of tips:</p> <ul> <li> <p>There is a generic easyblock available for installing Python packages, which will come in useful here.</p> </li> <li> <p>By default EasyBuild performs an <code>import</code> check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the <code>options</code> easyconfig parameter in your easyconfig file:   <pre><code>options = {'modulename': 'example'}\n</code></pre>   (you will need to change '<code>example</code>' here, of course)</p> </li> <li> <p>Leverage the software that is already pre-installed in <code>/easybuild</code> in the prepared environment.   Remember that some already installed modules may be a bundle of a couple of other software packages.</p> </li> </ul> <p>Please also take this into account:</p> <ul> <li> <p>Unfortunately this software doesn't come with documentation. That is done to make it an example that   is representative for software that you may run into in the wild (it's not because   we were lazy when preparing the exercises, really!).   You can inspect the sources of this software here. Definitely take a look at the <code>setup.py</code> file, it includes some clues   about the requirements to get this software installed.</p> </li> <li> <p>Make sure the installation actually works, by checking that the <code>py-eb-tutorial</code> command runs correctly.   Maybe you will need to make sure other required software is available as well, for it to work correctly...</p> </li> </ul> (click to show solution) <p>Here is a complete working easyconfig file for <code>py-eb-tutorial</code>: <pre><code>easyblock = 'PythonPackage'\n\nname = 'py-eb-tutorial'\nversion = '1.0.0'\nversionsuffix = '-Python-%(pyver)s'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial Python example\"\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496']\n\ntoolchain = {'name': 'foss', 'version': '2020b'}\n\ndependencies = [\n    ('Python', '3.8.6'),\n    ('SciPy-bundle', '2020.11'),\n    ('eb-tutorial', '1.0.1'),\n]\n\nuse_pip = True\n\noptions = {'modulename': 'eb_tutorial'}\n\nsanity_check_paths = {\n    'files': ['bin/py-eb-tutorial'],\n    'dirs': ['lib/python%(pyshortver)s/site-packages'],\n}\n\nsanity_check_commands = [\"py-eb-tutorial\"]\n\nmoduleclass = 'tools'\n</code></pre></p> <p>Some remarks:</p> <ul> <li> <p>We used the <code>PythonPackage</code> generic easyblock. There is also a <code>PythonBundle</code> easyblock for installing   bundles of Python packages, which is used for <code>SciPy-bundle</code> for example. But we don't need that here,   since we are only dealing with a single Python package.</p> </li> <li> <p>The <code>versionsuffix</code> is not strictly needed, but it's common to tag Python packages with the Python version   for which they were installed.</p> </li> <li> <p>The SHA256 checksum for the source tarball was added automatically via <code>eb py-eb-tutorial.eb --inject-checksums</code>.</p> </li> <li> <p><code>py-eb-tutorial</code> only wants to be installed with <code>pip install</code>, so we had to set <code>use_pip = True</code>.   You can consult the custom easyconfig parameters supported by the <code>PythonPackage</code> easyblock via   \"<code>eb -a -e PythonPackage</code>\", see the <code>EASYBLOCK-SPECIFIC</code> part of the output.   Even when the default installation mechanism used by <code>PythonPackage</code>   (which consists of running <code>python setup.py install</code>) works fine,   it is recommended to instruct EasyBuild to use <code>pip install</code> instead.</p> </li> <li> <p>By default EasyBuild will try to import <code>py_eb_tutorial</code>, while the actual name of the Python package   provided by <code>py-eb-tutorial</code> is just <code>eb_tutorial</code>. We fixed this by specifying the correct Python module name to   use via <code>options</code>.</p> </li> <li> <p>Strictly speaking we don't need to specify a custom <code>sanity_check_paths</code>, since the default used   by Python package is already pretty decent (it will check for a non-empty <code>lib/python3.8/site-packages</code>   directory in the installation). We also want to make sure the <code>py-eb-tutorial</code> command is available in   the <code>bin</code> subdirectory however. Hardcoding to <code>python3.8</code> can be avoided using the <code>%(pyshortver)s</code>   template value.</p> </li> <li> <p>A good way to check whether the <code>py-eb-tutorial</code> command works correctly is by running it as a sanity check   command. If the <code>eb-tutorial</code> command is not available the <code>py-eb-tutorial</code> command will fail,   since it basically just runs the <code>eb-tutorial</code> command. So we need to include <code>eb-tutorial</code> as a (runtime)   dependency in the <code>py-eb-tutorial</code> easyconfig file.</p> </li> </ul> <p>next: EasyBuild at J\u00fclich Supercomputing Centre - (back to overview page)</p>"},{"location":"2021-isc21/basic_usage/","title":"Basic usage of Easybuild","text":"<p>Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words.</p> <p>We will look at the high-level workflow first, and then cover each aspect in more detail.</p> <p>A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!</p>"},{"location":"2021-isc21/basic_usage/#overall-workflow","title":"Overall workflow","text":"<p>Installing software with EasyBuild is as easy as specifying to the <code>eb</code> command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer).</p> <p>This is typically done by specifying the name of one or more easyconfig files, often combined with the <code>--robot</code> option to let EasyBuild also install missing dependencies.</p> <p>It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be.</p>"},{"location":"2021-isc21/basic_usage/#specifying-easyconfigs","title":"Specifying easyconfigs","text":"<p>Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the <code>--software-name</code> option won't be covered in this tutorial, since they are not commonly used.</p> <p>Arguments passed to the <code>eb</code> command, being anything that is not an option (which starts with <code>-</code> or <code>--</code>) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be:</p> <ul> <li>the (absolute or relative) path to an easyconfig file;</li> <li>the name of an easyconfig file;</li> <li>the path to a directory containing easyconfig files;</li> </ul> <p>Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message:</p> <pre><code>$ eb /tmp/does_not_exist.eb\nERROR: Can't find path /tmp/does_not_exist.eb\n</code></pre> <p>When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory. If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path.</p> <p>If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with <code>.eb</code>, and (try to) use these as easyconfig files.</p>"},{"location":"2021-isc21/basic_usage/#example-command","title":"Example command","text":"<p>Suppose we have the current situation in our home directory:</p> <ul> <li>two (easyconfig) files named <code>example1.eb</code> and <code>example2.eb</code>;</li> <li>a subdirectory named <code>some_deps</code>, which has two easyconfig files <code>dep1.eb</code> and <code>dep2.eb</code>   alongside a text file named <code>list.txt</code>;</li> <li>a subdirectory named <code>more_deps</code> located in the <code>some_deps</code> subdirectory,   which contains another easyconfig file <code>dep3.eb</code>;</li> </ul> <p>Or, visually represented:</p> <pre><code>example1.eb\nexample2.eb\nsome_deps/\n|-- dep1.eb\n|-- dep2.eb\n|-- list.txt\n|-- more_deps/\n    |-- dep3.eb\n</code></pre> <p>In this context, we run the following EasyBuild command from our home directory:</p> <pre><code>eb example1.eb bzip2-1.0.6.eb $HOME/example2.eb some_deps\n</code></pre> <p>EasyBuild will interpret each of these arguments as follows:</p> <ul> <li><code>example1.eb</code> is the name of a file in the current directory, so it can be used directly;</li> <li><code>bzip2-1.0.6.eb</code> is the name of an easyconfig file to locate via the robot search path   (since it does not exist in the current directory);</li> <li><code>$HOME/example2.eb</code> specifies the full path to an existing file, which can be used directly;</li> <li><code>some_deps</code> is the relative path to an existing directory, so EasyBuild will scan it and find three   easyconfig files: <code>some_deps/dep1.eb</code>, <code>some_deps/dep2.eb</code> and <code>some_deps/more_deps/dep3.eb</code>,   The <code>list.txt</code> file will be ignored since its name does not end with <code>.eb</code>.</li> </ul>"},{"location":"2021-isc21/basic_usage/#easyconfig-filenames","title":"Easyconfig filenames","text":"<p>Note that the <code>eb</code> command does not care how easyconfig files are named, at least to some extent: the <code>.eb</code> file extension does matter when easyconfig files are being picked up in subdirectories.</p> <p>File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the <code>eb</code> command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here).</p> <p>This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <code>&lt;name&gt;-&lt;version&gt;-&lt;toolchain&gt;&lt;versionsuffix&gt;.eb</code>, where:</p> <ul> <li><code>&lt;name&gt;</code> represents the software name;</li> <li><code>&lt;version&gt;</code> represents the software version;</li> <li><code>&lt;toolchain&gt;</code> represents the toolchain used in the easyconfig file, which consists of the toolchain name   and version separated with a dash (<code>-</code>), and which is omitted (including the preceding <code>-</code>) when the   <code>system</code> toolchain is used;</li> <li><code>&lt;versionsuffix&gt;</code> represents the value of the <code>versionsuffix</code> easyconfig parameter,   which is sometimes used to distinguish multiple variants of particular software installations   (and is empty by default);</li> </ul>"},{"location":"2021-isc21/basic_usage/#searching-for-easyconfigs","title":"Searching for easyconfigs","text":"<p>You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package.  This can be done by searching for easyconfigs using <code>eb --search</code> or <code>eb -S</code>.</p> <p>By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the <code>search-paths</code> configuration setting, or you can change the robot search path via either the <code>robot</code> or <code>robot-paths</code> configuration options.</p> <p>Both the <code>--search</code> and <code>-S</code> options trigger the same search operation, but yield different output: <code>eb --search</code> will print the full path to each easyconfig file that matches the specified search pattern, while <code>eb -S</code> produces a more concise output.</p> <p>For example, let's check which easyconfig files are available for OpenFOAM 8 with a <code>foss</code> toolchain:</p> <pre><code>$ eb --search openfoam-8-foss\n * /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb\n * /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb\n</code></pre> <p>The output is a bit more condensed when using <code>eb -S</code>:</p> <pre><code>$ eb -S openfoam-8-foss\nCFGS1=/home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/o/OpenFOAM\n * $CFGS1/OpenFOAM-8-foss-2020a.eb\n * $CFGS1/OpenFOAM-8-foss-2020b.eb\n</code></pre> <p>Note that the search is performed case-insensitive.</p> <p>The search pattern can include wildcards like <code>.*</code> and/or character groups like <code>[0-9]</code>, or other special characters like <code>^</code> or <code>$</code> to mark the start/end of the filename, but you need to be careful that <code>bash</code> does not expand these before the <code>eb</code> command is started, so it is recommended to wrap the search pattern in single quotes (<code>'...'</code>) when using wildcards.</p> <p>For example, to check which easyconfigs are available to install TensorFlow 2.4.1 with the <code>2020b</code> version of a toolchain:</p> <pre><code>$ eb -S '^tensorflow-2.4.1.*2020b'\nCFGS1=/home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/t/TensorFlow\n * $CFGS1/TensorFlow-2.4.1-foss-2020b.eb\n * $CFGS1/TensorFlow-2.4.1-fosscuda-2020b.eb\n</code></pre>"},{"location":"2021-isc21/basic_usage/#search-index","title":"Search index","text":"<p>When searching for easyconfig files, you may see a message like this pop up:</p> <pre><code>== found valid index for &lt;path&gt;, so using it...\n</code></pre> <p>This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow.</p> <p>For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using <code>eb --create-index &lt;path&gt;</code>. See the EasyBuild documentation for more information.</p>"},{"location":"2021-isc21/basic_usage/#inspecting-easyconfigs","title":"Inspecting easyconfigs","text":"<p>Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it.</p> <p>Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous <code>cat</code> command or your favorite text editor (<code>vim</code>, what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use <code>eb --show-ec</code>.</p> <p>For example, let's inspect the contents of the <code>bzip2-1.0.6.eb</code> easyconfig file:</p> <pre><code>$ eb --show-ec bzip2-1.0.6.eb\n== temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log\n== Contents of /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb:\nname = 'bzip2'\nversion = '1.0.6'\n\nhomepage = 'https://sourceware.org/bzip2'\ndescription = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically\ncompresses files to within 10% to 15% of the best available techniques (the PPM family of statistical\ncompressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\"\n\ntoolchain = SYSTEM\ntoolchainopts = {'pic': True}\n\nsource_urls = ['https://sourceware.org/pub/bzip2/']\nsources = [SOURCE_TAR_GZ]\npatches = ['bzip2-%(version)s-pkgconfig.patch']\nchecksums = [\n'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd',  # bzip2-1.0.6.tar.gz\n'5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d',  # bzip2-1.0.6-pkgconfig.patch\n]\n\nbuildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $(BIGFILES)'\"\n\n# building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...)\nwith_shared_libs = OS_TYPE == 'Linux'\n\nmoduleclass = 'tools'\n\n== Temporary log file(s) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed.\n== Temporary directory /tmp/eb-jnpzclhl has been removed.\n</code></pre> <p>We'll get back to what all of this means later...</p>"},{"location":"2021-isc21/basic_usage/#checking-dependencies","title":"Checking dependencies","text":"<p>Note</p> <p>In some of the examples below, we assume that some software is already installed with EasyBuild.</p> <p>If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \"<code>module avail</code>\" by informing the modules tool about the pre-installed software stack in <code>/easybuild</code>:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing.</p> <p>This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like <code>$HOME/.local/easybuild</code>, the default installation path).</p>"},{"location":"2021-isc21/basic_usage/#dry-run","title":"Dry run","text":"<p>To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use <code>eb --dry-run</code>.</p> <p>Since <code>--dry-run</code> produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: <code>eb --dry-run-short</code>, which is equivalent with <code>eb -D</code>.</p> <p>For example, to check which of the required dependencies for <code>SAMtools-1.11-GCC-10.2.0.eb</code> are already installed:</p> <pre><code>$ eb SAMtools-1.11-GCC-10.2.0.eb -D\n== temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log\n== found valid index for /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it...\nDry run: printing build status of easyconfigs and dependencies\nCFGS=/home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs\n ...\n * [x] $CFGS/b/bzip2/bzip2-1.0.8-GCCcore-10.2.0.eb (module: bzip2/1.0.8-GCCcore-10.2.0)\n* [x] $CFGS/x/XZ/XZ-5.2.5-GCCcore-10.2.0.eb (module: XZ/5.2.5-GCCcore-10.2.0)\n* [x] $CFGS/c/cURL/cURL-7.72.0-GCCcore-10.2.0.eb (module: cURL/7.72.0-GCCcore-10.2.0)\n* [x] $CFGS/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0)\n* [x] $CFGS/n/ncurses/ncurses-6.2-GCCcore-10.2.0.eb (module: ncurses/6.2-GCCcore-10.2.0)\n* [ ] $CFGS/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb (module: SAMtools/1.11-GCC-10.2.0)\n</code></pre> <p>(We've trimmed the output a bit here, for the sake of brevity.)</p> <p>This output tells us that all dependencies required by <code>SAMtools-1.11-GCC-10.2.0.eb</code> are already installed, since they are all marked with <code>[x]</code>, whereas the easyconfig for <code>SAMtools</code> itself is not installed yet, as indicated by lack of an <code>x</code> in <code>[ ]</code>.</p>"},{"location":"2021-isc21/basic_usage/#missing-dependencies","title":"Missing dependencies","text":"<p>If you are only interested in which dependencies are still missing, you can consult the output of <code>eb --missing</code>, or the equivalent <code>eb -M</code>.</p> <p>For example, let's see which dependencies are missing in order to get version 3.1.0 of the h5py Python package installed using the <code>2020b</code> version of the <code>foss</code> toolchain:</p> <pre><code>$ eb h5py-3.1.0-foss-2020b.eb -M\n\n2 out of 61 required modules missing:\n\n* pkgconfig/1.5.1-GCCcore-10.2.0-python (pkgconfig-1.5.1-GCCcore-10.2.0-python.eb)\n* h5py/3.1.0-foss-2020b (h5py-3.1.0-foss-2020b.eb)\n</code></pre> <p>That should be pretty self-explanatory: out of the 63 required dependencies (which includes the <code>foss</code> toolchain and everything needed to install it), only 2 dependencies are missing. Great!</p>"},{"location":"2021-isc21/basic_usage/#inspecting-install-procedures","title":"Inspecting install procedures","text":"<p>Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software.</p> <p>Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation.</p> <p>Using <code>eb --extended-dry-run</code>, or just <code>eb -x</code> for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild, in a matter of seconds.</p> <p>By means of example, let's inspect some parts of the installation procedure for <code>Boost-1.74.0-GCC-10.2.0.eb</code>:</p> <pre><code>$ eb Boost-1.74.0-GCC-10.2.0.eb -x\n...\n\npreparing... [DRY RUN]\n\n[prepare_step method]\nDefining build environment, based on toolchain (options) and specified dependencies...\n\nLoading toolchain module...\n\nmodule load GCC/10.2.0\n\nLoading modules for dependencies...\n\nmodule load bzip2/1.0.8-GCCcore-10.2.0\nmodule load zlib/1.2.11-GCCcore-10.2.0\nmodule load XZ/5.2.5-GCCcore-10.2.0\n\n...\n\nDefining build environment...\n\n  ...\n  export CXX='mpicxx'\nexport CXXFLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC'\n...\n\nconfiguring... [DRY RUN]\n\n[configure_step method]\nrunning command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.74.0/GCC-10.2.0/obj --without-libraries=python,mpi\"\n(in /tmp/example/build/Boost/1.74.0/GCC-10.2.0/Boost-1.74.0)\n\n...\n\n[sanity_check_step method]\nSanity check paths - file ['files']\n* lib/libboost_system.so\n  * lib/libboost_thread-mt-x64.so\nSanity check paths - (non-empty) directory ['dirs']\n* include/boost\nSanity check commands\n  (none)\n\n...\n</code></pre> <p>We've obviously trimmed the generated output a bit, but it should be sufficient to explain what all this output means.</p> <p>An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows:</p> <ul> <li>how the build environment will be set up during the <code>prepare</code> step, by loading the module for both the   toolchains and the dependencies, and defining a set of environment variables like <code>$CXX</code>, <code>$CXXFLAGS</code>, etc.</li> <li>which command will be executed during the configuration step, and in which directory;</li> <li>the list of files and directories that will be checked during the sanity check step;</li> </ul> <p>If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now.</p> <p>Note</p> <p>It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using <code>eb -x</code>, the reported installation procedure could be partially incorrect.</p> <p>In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by <code>eb -x</code> though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.</p>"},{"location":"2021-isc21/basic_usage/#exercises","title":"Exercises","text":"<p>Guidelines</p> <p>Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself!</p> <p>Please do not share solutions with others before they have been discussed by the tutorial organisers.</p> <p>The exercises are based on the easyconfig files included with EasyBuild 4.4.0.</p> <p>Exercise U.0 - Making installed software available</p> <p>Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available.</p> <p>We will assume that you have a small software stack installed using the <code>2020b</code> version of the <code>foss</code> toolchain.</p> <p>Tip: execute a \"<code>module use</code>\" command, and verify with \"<code>module avail</code>\" that a bunch of software modules are available for loading.</p> (click to show solution) <p>Use the following command to make the modules for the software available that is pre-installed in the prepared environment: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>If software is installed in a different location than <code>/easybuild/</code> in your environment, you should adjust the command accordingly.</p> <p>To verify that the pre-installed software is available, check whether the <code>foss/2020b</code> module is available: <pre><code>$ module avail foss/\n\n--------------------- /easybuild/modules/all ---------------------\n  foss/2020b\n</code></pre></p> <p>Exercise U.1 - Searching easyconfigs</p> <p>See if EasyBuild provides any easyconfig files for installing GROMACS version 2020/5.</p> (click to show solution) <p>To check for available easyconfig files, we can use <code>eb --search</code> or <code>eb -S</code>: <pre><code>$ eb -S gromacs-2020.5\n== found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it...\nCFGS1=/home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb\n * $CFGS1/GROMACS-2020.5_fix_threads_gpu_Gmxapitests.patch\n</code></pre> This actually shows one easyconfig file but also a patch file. We can also search specifically for GROMACS 2020.5 in the <code>foss</code> and <code>fosscuda</code> toolchains using <pre><code>$ eb -S gromacs-2020.5-foss\n== found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it...\nCFGS1=/home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb\n</code></pre> and now we find a single easyconfig file.  </p> <p>Exercise U.2 - Checking dependencies</p> <p>Check which dependencies are missing to install QuantumESPRESSO version 6.6 with the <code>2020b</code> version of the <code>foss</code> toolchain.</p> (click to show solution) <p>First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: <pre><code>$ eb -S 'QuantumESPRESSO-6.6.*foss-2020b'\n== found valid index for /home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it...\nCFGS1=/home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/q/QuantumESPRESSO\n * $CFGS1/QuantumESPRESSO-6.6-foss-2020b.eb\n</code></pre> To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use <code>--missing</code>: <pre><code>$ eb QuantumESPRESSO-6.6-foss-2020b.eb --missing\n\n3 out of 60 required modules missing:\n\n* libxc/4.3.4-GCC-10.2.0 (libxc-4.3.4-GCC-10.2.0.eb)\n* ELPA/2020.11.001-foss-2020b (ELPA-2020.11.001-foss-2020b.eb)\n* QuantumESPRESSO/6.6-foss-2020b (QuantumESPRESSO-6.6-foss-2020b.eb)\n</code></pre> (some nonessential output removed).</p> <p>Exercise U.3 - Performing a dry run</p> <p>Figure out which command EasyBuild would use to compile the software provided by the <code>Bowtie2-2.4.2-GCC-9.3.0.eb</code> easyconfig file, without actually installing <code>Bowtie2</code>.</p> <p>Also, which binaries will EasyBuild check for to sanity check the installation?</p> (click to show solution) <p>To inspect the installation procedure, we can use <code>eb -x Bowtie2-2.4.2-GCC-9.3.0.eb</code>.</p> <p>The output for the build step shows the actual compilation command that would be performed (<code>make ...</code>):</p> <pre><code>[build_step method]\n&gt;&gt; running command:\n    [started at: 2021-03-08 20:15:08]\n[working dir: /tmp/eb-0006djcd/__ROOT__/tmp/kehoste/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2]\n[output logged in /tmp/eb-0006djcd/easybuild-run_cmd-haojzisn.log]\nmake -j 8  CC=\"gcc\"  CPP=\"g++\" CXX=\"g++\"  RELEASE_FLAGS=\"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\"\n(in /tmp/kehoste/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2)\n</code></pre> <p>If the output you get is less detailed, you may not have set <code>export EASYBUILD_TRACE=1</code>.</p> <p>The output for the sanity check step shows which binaries are expected to be installed: <pre><code>[sanity_check_step method]\nSanity check paths - file ['files']\n  * bin/bowtie2\n  * bin/bowtie2-align-l\n  * bin/bowtie2-align-s\n  * bin/bowtie2-build\n  * bin/bowtie2-build-l\n  * bin/bowtie2-build-s\n  * bin/bowtie2-inspect\n  * bin/bowtie2-inspect-l\n  * bin/bowtie2-inspect-s\n</code></pre></p> <p>next: Installing software - (back to overview page)</p>"},{"location":"2021-isc21/community/","title":"The EasyBuild community","text":"<p>EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by hundreds of HPC centres and consortia worldwide.</p> <p>Since 2016, the EasyBuild community has gathered for a yearly EasyBuild User Meeting, which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins, Ansible, CernVM-FS, ReFrame etc.</p> <p>The map below shows from which cities the EasyBuild documentation has been visited in the last year (June 1st 2020 - June 1st 2021), and how often.</p> <p>HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):</p> <p> </p>"},{"location":"2021-isc21/community/#getting-help","title":"Getting help","text":""},{"location":"2021-isc21/community/#documentation","title":"Documentation","text":"<p>If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io.</p> <p>It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful.</p>"},{"location":"2021-isc21/community/#github","title":"GitHub","text":"<p>You can open an issue in one of the EasyBuild repositories in the <code>easybuilders</code> GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements.</p> <p>Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate.</p> <p>Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem.</p>"},{"location":"2021-isc21/community/#mailing-list","title":"Mailing list","text":"<p>Feel free to ask any questions or provide feedback via the EasyBuild mailing list <code>easybuild@lists.ugent.be</code>.</p> <p>Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link.</p> <p>In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel.</p>"},{"location":"2021-isc21/community/#slack","title":"Slack","text":"<p>The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 450 people have joined it so far, and there is usually somebody awake in there who may be able to help you out.</p> <p>To join the EasyBuild Slack request an invitation via https://easybuild-slack.herokuapp.com.</p> <p>If you are not a big fan of Slack, you can also consider joining the <code>#easybuild</code> IRC channel (available on the Libera IRC network). A bot relays messages between this IRC channel and the <code>#general</code> channel in the EasyBuild Slack.</p> <p>Note</p> <p>A dedicated <code>#tutorial-isc21</code> channel was created for this tutorial in the EasyBuild Slack.</p> <p>If you have any questions that are specific to this tutorial, please post them there!</p>"},{"location":"2021-isc21/community/#conference-calls","title":"Conference calls","text":"<p>Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call.</p> <p>These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013.</p> <p>More information, including the dates and times of the next calls, is available here.</p> <p>next: Contributing to EasyBuild - (back to overview page)</p>"},{"location":"2021-isc21/computecanada/","title":"EasyBuild at Compute Canada","text":"<p>(authors: Maxime Boissonneault &amp; Bart Oldeman, Compute Canada)</p>"},{"location":"2021-isc21/computecanada/#general-info","title":"General info","text":"<p>Compute Canada (https://www.computecanada.ca) is a national organization in Canada. Its role is to coordinate the work of regions and institutions to make advanced computing research infrastructures (clusters, cloud, data repositories) available to Canadian academic researchers. It is similar to XSEDE in the US.</p>"},{"location":"2021-isc21/computecanada/#staff-user-base","title":"Staff &amp; user base","text":"<p>Compute Canada has around 200 full time equivalent staff located across almost 40 different institutions, in all provinces of Canada. Its user base is composed of about 15,000 users in all disciplines, with a growth of about 20% per year.</p>"},{"location":"2021-isc21/computecanada/#resources","title":"Resources","text":"<p>Compute Canada and its partners manage 4 main clusters, and 1 main OpenStack cloud.</p> <p>Cedar is a general purpose cluster that uses Intel OmniPath, has two generations of GPUs (P100 and V100), and three generations of CPUs (Broadwell, Skylake and Cascade Lake), for a total of nearly 100,000 cores and 1,400 GPUs.</p> <p>Graham is an InfiniBand cluster with similar characteristics as Cedar, but half its size.</p> <p>B\u00e9luga is our third general purpose cluster, also using InfiniBand, with V100 GPUs and Skylake CPUs.</p> <p>Niagara is our large parallel cluster, with a Dragonfly InfiniBand network technology, with more than 80,000 cores, all 40 cores per node.</p> <p>Finally, Arbutus is our primary OpenStack cloud infrastructure with about 15,000 cores.</p>"},{"location":"2021-isc21/computecanada/#compute-canada-software-stack","title":"Compute Canada software stack","text":"<p>Software installation is amongst the activities that are centralized by Compute Canada. We provide a single user space environment that is available across all of the clusters (all 4 primary clusters, with many legacy clusters also adopting the same environment). This means that users can move across clusters seamlessly, since the same modules are available everywhere.</p> <p>For this to happen, especially given the variety of hardware we support, a couple of components are required. These were described in details in the paper presented at PEARC'19, which can be found here.</p> <p>This work was also presented at the EasyBuild User Meeting in January 2020. The recording and slides are available.</p>"},{"location":"2021-isc21/computecanada/#software-distribution","title":"Software distribution","text":"<p>One foundational part of the infrastructure comes even before installing any software: the distribution mechanism. For this, we use CVMFS. This allows any cluster, virtual machine, or even desktop or laptop computer, to access our software stack in a matter of a few minutes. We make this available to our users, as documented here. Some users use it for continuous integration, and we also use it in virtual clusters in the cloud.</p>"},{"location":"2021-isc21/computecanada/#compatibility-layer","title":"Compatibility layer","text":"<p>Because we support multiple clusters, we have to assume that they may not run exactly the same operating system, or don't have exactly the same system packages installed. To avoid issues, we therefore minimize the OS dependencies to an absolute minimum. Our stack contains all system libraries down to the GNU C Library (<code>glibc</code>) and the Linux loader. Our only dependencies are the kernel and the hardware drivers. For this layer, we started out with the Nix package manager, but have since moved to using Gentoo Prefix instead.</p>"},{"location":"2021-isc21/computecanada/#scientific-layer-and-easybuild","title":"Scientific layer and EasyBuild","text":"<p>For every scientific software, our staff go through a process that involves installing it through EasyBuild, and then deploying it to CVMFS. As of June 2021, we have almost 1000 different software packages installed. When combined with version of the software, version of the compiler/MPI/CUDA, and CPU architectures, we have respectively over 2,000, 4,200 and 8,000 combinations of builds.</p>"},{"location":"2021-isc21/computecanada/#usage-of-easybuild-within-compute-canada","title":"Usage of EasyBuild within Compute Canada","text":"<p>To illustrate EasyBuild's flexibility, in this section, we highlight some of the peculiarities of EasyBuild's usage within Compute Canada.</p>"},{"location":"2021-isc21/computecanada/#filtering-out-dependencies","title":"Filtering out dependencies","text":"<p>Compute Canada is using EasyBuild to install all packages that you would not normally find installed in an OS (i.e. through <code>yum</code> or <code>apt-get</code>). However, because we provide the compatibility layer, many of the libraries that can be installed through EasyBuild are filtered out. This includes for example <code>binutils</code>, <code>Automake</code>, <code>flex</code>, etc. This is configured through our EasyBuild configuration file.</p>"},{"location":"2021-isc21/computecanada/#custom-toolchains","title":"Custom toolchains","text":"<p>Before deploying our new infrastructures, virtually all sites had a long history of using the Intel or GNU Compilers, OpenMPI, and Intel MKL, with very little usage of OpenBLAS or Intel MPI. Therefore, our primary toolchains are based on those tools - i.e. variations on the <code>iomkl</code> or <code>gomkl</code> toolchains, which are not the ones mostly used by upstream EasyBuild (which are the common <code>foss</code> and <code>intel</code> toolchains). We therefore make a heavy use of the <code>--try-toolchain</code> option of EasyBuild, to use upstream recipes but with our preferred toolchains.</p>"},{"location":"2021-isc21/computecanada/#custom-module-naming-scheme","title":"Custom module naming scheme","text":"<p>We use a lower-case hierarchical module naming scheme which also includes the CPU architecture that a software is built for as part of the hierarchy. Our module naming scheme also completely drops <code>versionsuffix</code>. If we need to have different flavors of a given recipe, we instead use <code>modaltsoftname</code> to add the flavor to the name of the software package. This is enabled through this Python module, which implements our custom module naming scheme.</p>"},{"location":"2021-isc21/computecanada/#using-rpath-and-disabling-ld_library_path","title":"Using <code>RPATH</code> and disabling <code>LD_LIBRARY_PATH</code>","text":"<p>Our compatibility layer includes a wrapper script for the linker (<code>ld</code>) which ensures that <code>RPATH</code> is added to every shared library and executable that is compiled. This applies to both EasyBuild's builds and users' builds. We therefore filter out the <code>LD_LIBRARY_PATH</code> from the modules. This is specified in our EasyBuild configuration file.</p>"},{"location":"2021-isc21/computecanada/#usage-of-hooks","title":"Usage of hooks","text":"<p>We make a rather intensive usage of hooks. For example, we use them to</p> <ul> <li>inject specific configure options to our OpenMPI builds</li> <li>add compiler and MPI footers to the modules</li> <li>split the installation of the Intel compiler into redistributable and non-redistributable parts</li> <li>strip down the installation of Python to a small set of Python packages</li> </ul>"},{"location":"2021-isc21/computecanada/#python-specific-customizations","title":"Python specific customizations","text":"<p>Compute Canada makes heavy usage of the <code>multi_deps</code> feature for Python package installations. This allows us to install single modules that support multiple versions of Python. We also tend to install Python wrappers alongside the primary module when there is a primary module. For example, we install <code>PyQt</code> alongside <code>Qt</code>, in the same module.</p> <p>For most Python packages however, we do not install them as modules. We instead provide a large repository of binary Python packages that we have compiled against our modules, and instruct our users to install them in virtual environments. The vast majority of Python packages can be built as Python wheels with a common script, with minor differences such as loading a prerequisite module or installing a dependency. This script is available on our Github wheels_builder repository.</p> <p>next: The EasyBuild community - (back to overview page)</p>"},{"location":"2021-isc21/configuration/","title":"Configuring EasyBuild","text":"<p>After installing EasyBuild, you should configure it.</p> <p>EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information.</p> <p>Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it.</p>"},{"location":"2021-isc21/configuration/#available-configuration-settings","title":"Available configuration settings","text":"<p>One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings.</p> <p>The full list of configuration settings can be consulted via <code>eb --help</code>, which shows the corresponding command line option accompanied by a short description. At the time of writing, about 250 different configuration settings are supported by EasyBuild.</p> <p>For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones.</p> <p>We will refer to EasyBuild configuration settings using the names as they appears in the output of <code>eb --help</code>, and omit the leading dashes (<code>--</code>) for the sake of clarity.</p> <p>Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.</p>"},{"location":"2021-isc21/configuration/#overall-prefix","title":"Overall prefix","text":"<p>(default: <code>$HOME/.local/easybuild</code>)</p> <p>The <code>prefix</code> configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings:</p> <ul> <li><code>installpath</code>: <code>&lt;prefix&gt;</code></li> <li><code>buildpath</code>: <code>&lt;prefix&gt;/build</code></li> <li><code>sourcepath</code>: <code>&lt;prefix&gt;/sources</code></li> <li><code>repositorypath</code> (easyconfigs archive): <code>&lt;prefix&gt;/ebfiles_repo</code></li> <li><code>containerpath</code>: <code>&lt;prefix&gt;/containers</code></li> </ul> <p>Here, <code>&lt;prefix&gt;</code> represents the value of the <code>prefix</code> configuration setting.</p> <p>If one of the configuration settings affected by <code>prefix</code> is defined specifically, the <code>prefix</code> value becomes irrelevant for that specific configuration setting.</p>"},{"location":"2021-isc21/configuration/#install-path","title":"Install path","text":"<p>(default: <code>&lt;prefix&gt;</code>)</p> <p>The location for both the software installation directories and generated module files can be controlled via the <code>installpath</code> configuration setting. Software installation directories will be placed in <code>&lt;installpath&gt;/software</code>, while <code>&lt;installpath&gt;/modules/all</code> will be used for generated module files.</p> <p>The <code>installpath</code> location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which can be useful to test and evaluate software installations.</p> <p>Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the <code>software</code> and <code>modules/all</code> subdirectories.</p> <p>We recommend to only change the <code>installpath</code> configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default <code>software</code> and <code>modules/all</code> names for the subdirectories are used.</p>"},{"location":"2021-isc21/configuration/#build-path","title":"Build path","text":"<p>(default: <code>&lt;prefix&gt;/build</code>)</p> <p>For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the <code>buildpath</code> configuration setting.</p> <p>Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations.</p> <p>It is strongly recommend to use the path to a directory on a local filesystem for the value of the <code>buildpath</code> configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like <code>/dev/shm/$USER</code>) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like <code>noexec</code>).</p> <p>Use a directory on a local filesystem for <code>buildpath</code> for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set <code>buildpath</code> to <code>/tmp/$USER</code>, for example.</p>"},{"location":"2021-isc21/configuration/#source-path","title":"Source path","text":"<p>(default: <code>&lt;prefix&gt;/sources</code>)</p> <p>For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path.</p> <p>The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the <code>sourcepath</code> configuration setting.</p> <p>The <code>sourcepath</code> value is a colon (<code>:</code>) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named '<code>Example'</code>, EasyBuild will consider locations like <code>&lt;sourcepath&gt;/e/Example/</code>, <code>&lt;sourcepath&gt;/Example/</code>, and so on.</p> <p>The first path listed in <code>sourcepath</code> is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in <code>sourcepath</code> only read permissions are required.</p> <p>Make sure you have write permissions to the first path listed in <code>sourcepath</code>, so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere.</p>"},{"location":"2021-isc21/configuration/#easyconfigs-archive","title":"Easyconfigs archive","text":"<p>(default: <code>&lt;prefix&gt;/ebfiles_repo</code>)</p> <p>EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the <code>repositorypath</code> configuration setting.</p> <p>By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation).</p> <p>For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the <code>prefix</code> configuration setting.</p>"},{"location":"2021-isc21/configuration/#modules-tool-module-syntax","title":"Modules tool &amp; module syntax","text":"<p>(default: <code>Lmod</code> as modules tool, <code>Lua</code> as module syntax)</p> <p>By default, EasyBuild assumes you are using Lmod as modules tool. In addition, it will generate module files in Lua syntax, as supported by Lmod (next to <code>Tcl</code> syntax).</p> <p>To diverge from this, you can define the <code>modules-tool</code> configuration setting to indicate you are using a different modules tool; see the output of <code>eb --avail-modules-tools</code> for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through <code>$PATH</code> (more information on this in the EasyBuild documentation).</p> <p>If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the <code>module-syntax</code> configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in <code>Lua</code> syntax.</p> <p>We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax.</p>"},{"location":"2021-isc21/configuration/#robot-search-path","title":"Robot search path","text":"<p>(default: <code>robot-paths</code> specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled)</p> <p>When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path. This applies to both easyconfig files that were specified using only their filename as an argument to the <code>eb</code> command, as well as to easyconfigs required to resolve dependencies (more on that later).</p> <p>To control the robot search path, two configuration settings are available: <code>robot</code> and <code>robot-paths</code>. Both accept a colon-separated list of locations to consider when looking for easyconfig files, with <code>robot</code> overriding <code>robot-paths</code>.</p> <p>The key difference between these two configuration settings is that defining <code>robot</code> also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining <code>robot-paths</code> does not have the side effect of enabling dependency resolution.</p> <p>In addition, you can use the <code>--robot</code> command line option without specifying any paths to it, to only enable dependency resolution.</p> <p>Note</p> <p>Keep in mind that when either of the <code>robot</code> or <code>robot-paths</code> configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered.</p> <p>There are ways around this however, which are outside of the scope of this tutorial.</p> <p>For more information, see the EasyBuild documentation.</p>"},{"location":"2021-isc21/configuration/#module-naming-scheme","title":"Module naming scheme","text":"<p>(default: <code>EasyBuildMNS</code>)</p> <p>EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation.</p> <p>Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via <code>eb --avail-module-naming-schemes</code>.</p> <p>The default <code>EasyBuildMNS</code> module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the <code>versionsuffix</code> easyconfig parameter): <code>&lt;name&gt;/&lt;version&gt;&lt;-toolchain&gt;&lt;versionsuffix&gt;</code>. Just like with names of easyconfig files, the <code>&lt;-toolchain&gt;</code> part is omitted when the <code>system</code> toolchain is used, and the <code>&lt;versionsuffix&gt;</code> value is empty by default.</p>"},{"location":"2021-isc21/configuration/#configuration-levels","title":"Configuration levels","text":"<p>Configuring EasyBuild can be done in different ways:</p> <ul> <li>through one or more configuration files;</li> <li>via <code>$EASYBUILD_*</code> environment variables;</li> <li>using <code>eb</code> command line options;</li> </ul> <p>Each of the methods corresponds to a configuration level.</p> <p>Every configuration setting can be defined via one of these mechanisms, without exception!</p>"},{"location":"2021-isc21/configuration/#configuration-level-hierarchy","title":"Configuration level hierarchy","text":"<p>There is a strict hierarchy between the different configuration levels supported by EasyBuild.</p> <p>Settings defined via a configuration file only override default values.</p> <p>A configuration setting that is defined via the corresponding <code>$EASYBUILD_*</code> environment variable takes precedence over the value specified in a configuration file (if any).</p> <p>Finally, values specified through <code>eb</code> command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable.</p> <p>For example, let us consider a fictional configuration setting named <code>magic</code>:</p> <ul> <li>If a value for <code>magic</code> is specified in an EasyBuild configuration file,   then this value will only be used if the corresponding environment variable   (<code>$EASYBUILD_MAGIC</code>) is not defined and if the <code>--magic</code> command line option is not used;</li> <li>If the <code>$EASYBUILD_MAGIC</code> environment is defined however, then its value   will be used for the <code>this-is-magic</code> configuration setting;</li> <li>Unless the <code>--magic</code> command line option is used,   since in that case the value provided as an argument there will be used instead.</li> </ul>"},{"location":"2021-isc21/configuration/#configuration-files","title":"Configuration files","text":"<p>Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of <code>eb --show-default-configfiles</code> tells you which locations are considered, and whether any configuration files were found.</p> <p>EasyBuild configuration files are written in the standard INI format, and the configuration settings are grouped into different sections.</p> <p>To create an EasyBuild configuration file, the output of <code>eb --confighelp</code> is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax.</p> <p>Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.</p>"},{"location":"2021-isc21/configuration/#easybuild-configuration-files-vs-easyconfig-files","title":"EasyBuild configuration files vs easyconfig files","text":"<p>EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts!</p> <p>EasyBuild configuration files (usually <code>*.cfg</code>) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings, such as the location where software should be installed, or the syntax that should be used when generating module files.</p> <p>An easyconfig file (<code>*.eb</code>) on the other hand specifies the details for one particular software installation. It does this by defining a set of easyconfig parameters, which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc.</p> <p>For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.</p>"},{"location":"2021-isc21/configuration/#easybuild_-environment-variables","title":"<code>$EASYBUILD_*</code> environment variables","text":"<p>A particularly easy way to configure EasyBuild is through environment variables.</p> <p>At startup, EasyBuild will pick up any environment variable of which the name starts with '<code>EASYBUILD_</code>'. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found).</p> <p>Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes (<code>-</code>) with underscores (<code>_</code>), and prefix with <code>EASYBUILD_</code>.</p> <p>For example: the <code>module-syntax</code> configuration setting can be specified by defining the <code>$EASYBUILD_MODULE_SYNTAX</code> environment variable:</p> <pre><code>export EASYBUILD_MODULE_SYNTAX=Tcl\n</code></pre> <p>Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines <code>$EASYBUILD_*</code> environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it.</p> <p>Note</p> <p>Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example <code>$HOME/.bash_profile</code> or <code>$HOME/.bashrc</code>).</p>"},{"location":"2021-isc21/configuration/#eb-command-line-options","title":"<code>eb</code> command line options","text":"<p>Finally, you can also configure EasyBuild by specifying one or options to the <code>eb</code> command.</p> <p>As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option.</p> <p>There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the <code>eb</code> command print the EasyBuild version (via <code>eb --version</code>). Although you could configure EasyBuild to always print its version and then exit whenever the <code>eb</code> command is run, that would not be very useful...</p> <p>Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory:</p> <pre><code>eb --installpath /tmp/$USER example.eb\n</code></pre>"},{"location":"2021-isc21/configuration/#inspecting-the-current-configuration-show-config","title":"Inspecting the current configuration (<code>--show-config</code>)","text":"<p>Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured.</p> <p>Through the <code>--show-config</code> command line option you can easily inspect the currently active EasyBuild configuration.</p> <p>The output of <code>--show-config</code> includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like <code>buildpath</code>, <code>installpath</code>, <code>sourcepath</code>, and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed.</p> <p>This is the output produced by <code>eb --show-config</code> for the default EasyBuild configuration, where EasyBuild was installed via <code>pip install --user</code> (which affects the value shown for the <code>robot-paths</code> configuration setting):</p> <pre><code>#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (D) = /home/example/.local/easybuild/build\ncontainerpath  (D) = /home/example/.local/easybuild/containers\ninstallpath    (D) = /home/example/.local/easybuild\nrepositorypath (D) = /home/example/.local/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (D) = /home/example/.local/easybuild/sources\n</code></pre> <p>As shown here, all configuration settings shown follow the default <code>prefix</code> value (<code>$HOME/.local/easybuild</code>), and none of the values diverge from the default value, since all entries are marked with <code>(D)</code> for \"default value\").</p> <p>Example</p> <p>Now let us do some basic configuring and inspect the resulting output of <code>eb --show-config</code>.</p> <p>First, create a user-level EasyBuild configuration file to define the <code>prefix</code> configuration setting:</p> <pre><code>mkdir -p $HOME/.config/easybuild\necho '[config]' &gt; $HOME/.config/easybuild/config.cfg\necho 'prefix=/apps' &gt;&gt; $HOME/.config/easybuild/config.cfg\n</code></pre> <p>In addition, define the <code>buildpath</code> configuration setting using the corresponding environment variable:</p> <pre><code>export EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Then run <code>eb --show-config</code> while you specify that the <code>installpath</code> configuration setting should be defined as <code>/tmp/$USER</code>:</p> <pre><code>$ eb --show-config --installpath=/tmp/$USER\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (E) = /tmp/easybuild\ncontainerpath  (F) = /apps/containers\ninstallpath    (C) = /tmp/easybuild\npackagepath    (F) = /apps/packages\nprefix         (F) = /apps\nrepositorypath (F) = /apps/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (F) = /apps/sources\n</code></pre> <p>The output indicates that the <code>installpath</code> setting was specified through a command line option (indicated with <code>(C)</code>), that the <code>buildpath</code> setting was defined via an environment variable (indicated with <code>(E)</code>), that the <code>robot-paths</code> setting still has the default value (indicated with <code>(D)</code>), and that all other configuration settings were specified via a configuration file, some of which indirectly through the <code>prefix</code> value (indicated with <code>(F)</code>).</p>"},{"location":"2021-isc21/configuration/#exercises","title":"Exercises","text":"<p>Exercise C.1 - Configure EasyBuild</p> <p>Configure EasyBuild to use the <code>easybuild</code> subdirectory in your home directory for everything, except for:</p> <ul> <li>The location of the build directories: use <code>/tmp/$USER</code> for this;</li> <li>The locations that should be considered when searching for source files:   include both <code>$HOME/easybuild/sources</code> and <code>/easybuild/sources</code>, but make   sure that source files that are downloaded by EasyBuild are stored in   <code>$HOME/easybuild/sources</code>.</li> </ul> <p>Leave other configuration settings set to their default value.</p> (click to show solution) <p>This is pretty straightforward.</p> <p>Here we just define the corresponding environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_SOURCEPATH=$HOME/easybuild/sources:/easybuild/sources\n</code></pre> <p>The location where EasyBuild should download source files to must be listed first in the <code>sourcepath</code> configuration setting.</p> <p>The output of <code>--show-config</code> should look like this (assuming that <code>$USER</code> is set to <code>example</code>):</p> <pre><code>buildpath      (E) = /tmp/example\ncontainerpath  (E) = /home/example/easybuild/containers\ninstallpath    (E) = /home/example/easybuild\npackagepath    (E) = /home/example/easybuild/packages\nprefix         (E) = /home/example/easybuild\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs\nsourcepath     (E) = /home/example/easybuild/sources:/easybuild/sources\n</code></pre> <p>Exercise C.2 - Install a trivial software package with EasyBuild</p> <p>Try running the following command:</p> <pre><code>eb bzip2-1.0.6.eb\n</code></pre> <p>Where do you expect to find the installation?</p> (click to show solution) <p>The software was installed in <code>$HOME/easybuild</code>, since that's how we configured EasyBuild in Exercise 3.1:</p> <pre><code>$ ls $HOME/easybuild\nebfiles_repo  modules  software  sources\n</code></pre> <p>The actual installation is in <code>$HOME/easybuild/software</code>, while the module file was generated in <code>$HOME/easybuild/modules/all</code>:</p> <pre><code>$ ls $HOME/easybuild/software\nbzip2  EasyBuild\n$ ls $HOME/easybuild/software/bzip2\n1.0.6\n$ ls $HOME/easybuild/software/bzip2/1.0.6\nbin  easybuild  include  lib  man\n</code></pre> <pre><code>$ ls $HOME/easybuild/modules/all\nbzip2  EasyBuild\n$ ls $HOME/easybuild/modules/all/bzip2\n1.0.6.lua\n</code></pre> <p>The source file for bzip2 1.0.6 was downloaded to <code>$HOME/easybuild/sources</code>:</p> <pre><code>$ ls $HOME/easybuild/sources/b/bzip2\nbzip2-1.0.6.tar.gz\n</code></pre> <p>We will discuss this in more detail in the next part of the tutorial.</p> <p>Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial.</p> <p>next: Basic usage - (back to overview page)</p>"},{"location":"2021-isc21/contributing/","title":"Contributing to EasyBuild","text":"<p>To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not?</p>"},{"location":"2021-isc21/contributing/#manual-contribution-procedure","title":"Manual contribution procedure","text":"<p>0) Create and setup a GitHub account (and register your SSH public key);</p> <p>1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file:</p> <pre><code>git clone git@github.com:easybuilders/easybuild-easyconfigs.git\ncd easybuild-easyconfigs\ngit remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git\n</code></pre> <p>You should change '<code>your_github_account</code>' in the last line to your own GitHub user name!</p> <p>2) Create and check out a new branch, starting from the (up-to-date) <code>develop</code> branch:</p> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout -b example\n</code></pre> <p>3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename, and that it's located in the appropriate directory.</p> <pre><code>mkdir -p easybuild/easyconfigs/e/example/\nmv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb\ngit add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb\n</code></pre> <p>4) Commit those changes with a sensible commit message:</p> <pre><code>git commit -m \"This is just an example\"\n</code></pre> <p>5) Push your branch to your fork of the repository on GitHub:</p> <pre><code>git push my_fork example\n</code></pre> <p>6) Open the pull request through the GitHub web interface, making sure that:</p> <ul> <li>the target branch is correct (should be <code>develop</code>);</li> <li>an appropriate title is used;</li> <li>a short description of the changes is provided;</li> <li>the changes are indeed the ones you want to propose;</li> <li>clicking the (correct) green button;</li> </ul> <p>That didn't exactly motivate you to contribute, did it...</p>"},{"location":"2021-isc21/contributing/#github-integration-features","title":"Github integration features","text":"<p>Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute...</p> <p>In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with <code>git</code> you may quickly end up demotivated.</p> <p>This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures.</p> <p>At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running <code>git</code> commands and interacting with the GitHub API.</p> <p>We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation.</p>"},{"location":"2021-isc21/contributing/#requirements-configuration","title":"Requirements &amp; configuration","text":"<p>First of all, the GitHub integration features impose a couple of additional requirements and configuration.</p> <p>Additional dependencies</p> <p>Both the <code>GitPython</code> and <code>keyring</code> Python packages as well as the <code>keyrings.cryptfile</code> add-on package must be installed. In the prepared environment, you can do this via:</p> <pre><code>pip3 install --user GitPython keyring keyrings.cryptfile\n</code></pre> <p>Note</p> <p>You may experiences problems installing the <code>cryptography</code> Python packages, which is a dependency of keyring. The underlying cause is that you need to have the <code>Rust</code> compiler installed to install the latest version of <code>cryptography</code> (see here).</p> <p>You can work around this issue using:</p> <pre><code>pip3 install --user 'cryptography&lt;3.4'\n</code></pre> <p>SSH public key in GitHub account</p> <p>You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys).</p> <p>If you need to generate an SSH key pair, you can run the following command:</p> <pre><code>ssh-keygen -t rsa -b 4096\n</code></pre> <p>You can copy the SSH public key from the output of this command:</p> <pre><code>cat .ssh/id_rsa.pub\n</code></pre> <p>Forked repository in GitHub</p> <p>In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs).</p> <p>EasyBuild configuration, incl. GitHub token</p> <p>You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials.</p> <p>To do this, you should define the <code>github-user</code> configuration option and run the \"<code>eb --install-github-token</code>\" command:</p> <pre><code># replace 'ebtutorial' with your own GitHub username!\n$ export EASYBUILD_GITHUB_USER=ebtutorial\n$ eb --install-github-token\n</code></pre> <p>To create a GitHub token:</p> <ul> <li>Visit https://github.com/settings/tokens.</li> <li>Click \"Personal access tokens\".</li> <li>Click followed by \"Generate new token\".</li> <li>Give the token a name (for example \"Token for EasyBuild\").</li> <li>Select both the '<code>repo</code>' and '<code>gist</code>' scopes.</li> <li>Click the green \"Generate token\" button.</li> <li>Copy the generated token.</li> <li>Paste the token when asked by <code>--install-github-token</code> (and hit Enter).</li> <li>Enter a password to encrypt your GitHub token.</li> </ul> <p>The output should look something like this:</p> <pre><code>$ eb --install-github-token\n== temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log\nToken: \nValidating token...\nToken seems to be valid, installing it.\nPlease set a password for your new keyring: \nPlease confirm the password:\nToken 'fed..987' installed!\n</code></pre> <p>Checking status of GitHub integration</p> <p>You can check the status of the GitHub integration using \"<code>eb --check-github</code>\":</p> <pre><code>$ eb --check-github\n== temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log\n\nChecking status of GitHub integration...\n\nMaking sure we're online...OK\n\n* GitHub user...ebtutorial =&gt; OK\nPlease enter password for encrypted keyring:\n* GitHub token...fed..987 (len: 40) =&gt; OK (validated)\n* git command...OK (\"git version 1.8.3.1; \")\n* GitPython module...OK (GitPython version 3.1.3)\n* push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK\n* creating gists...OK\n* location to Git working dirs... not found (suboptimal)\n\nAll checks PASSed!\n\nStatus of GitHub integration:\n* --from-pr: OK\n* --new-pr: OK\n* --review-pr: OK\n* --update-pr: OK\n* --upload-test-report: OK\n</code></pre> <p>If you see '<code>OK</code>' for each of the status checks, you're all set to try out the GitHub integration features!</p> <p>Note</p> <p>If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \"<code>eb --check-github</code>\".</p> <p>You can avoid this by using an SSH agent.</p> <p>Note</p> <p>If you see the <code>push access</code> check fail with <code>Failed to fetch branch 'main'</code>, you will need to rename the <code>master</code> branch in your fork of the <code>easybuild-easyconfigs</code> repository from <code>master</code> to <code>main</code> (this is required since EasyBuild v4.3.3).</p> <p>This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace <code>YOUR_GITHUB_ACCOUNT</code> with the name of your GitHub account in this URL).</p>"},{"location":"2021-isc21/contributing/#creating-pull-requests","title":"Creating pull requests","text":"<p>The GitHub integration in EasyBuild allows you to create pull requests using the <code>eb</code> command, without even leaving your shell environment. How cool is that\u203d</p> <p>To create a pull request to the <code>easybuild-easyconfigs</code> repository, you can either do it in a single go by running \"<code>eb --new-pr</code>\" and passing it one or more easyconfig files to add into the pull request.</p> <p>The more detailed option is to first create a branch in your repository fork in GitHub via \"<code>eb --new-branch-github</code>\" and then later open the pull request via \"<code>eb --new-pr-from-branch</code>\". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork).</p> <p>The <code>--new-pr</code> option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa!</p> <p>You can control the target repository for your pull request using <code>--pr-target-account</code> (default is <code>easybuilders</code>) and <code>--pr-target-repo</code>.</p> <p>If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \"<code>eb --dry-run --new-pr</code>\" or \"<code>eb -D --new-pr</code>\".</p> <p>Finally, you can use \"<code>eb --preview-pr</code>\" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.</p>"},{"location":"2021-isc21/contributing/#updating-pull-requests","title":"Updating pull requests","text":"<p>To update an existing pull request with additional changes you can use \"<code>eb --update-pr</code>\" and pass the pull request ID, alongside the paths to the updated files.</p> <p>If you have only created a branch (for example via <code>eb --new-branch-github</code>) you can update it via <code>--update-branch-github</code> in the same way, passing the branch name instead of a pull request ID.</p>"},{"location":"2021-isc21/contributing/#using-a-pull-request","title":"Using a pull request","text":"<p>Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which  support is not yet included in the latest EasyBuild release.</p> <p>Using the <code>--from-pr</code> option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the <code>--robot</code> option to ensure that the easyconfig files are installed in the correct order with respect to dependencies.</p> <p>Similarly, using a new or updated easyblock from a pull request is as simple as using the <code>--include-easyblocks-from-pr</code> option. And of course you can combine it with <code>--from-pr</code>!</p> <p>Via <code>--upload-test-report</code> you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.</p>"},{"location":"2021-isc21/contributing/#demo","title":"Demo","text":"<p>That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the <code>eb-tutorial</code> example software to a fork of the <code>easybuild-easyconfigs</code> repository using the <code>eb</code> command, and submit a test report in it.</p> <p>Note</p> <p>Make sure that you have correctly configured the GitHub integration, see above.</p>"},{"location":"2021-isc21/contributing/#creating-pull-request","title":"Creating pull request","text":"<p>We first configure EasyBuild to target the <code>ebtutorial</code> GitHub account rather than the default <code>easybuilders</code> GitHub organisation, by defining the <code>pr-target-account</code> configuration setting:</p> <pre><code>export EASYBUILD_PR_TARGET_ACCOUNT=ebtutorial\n</code></pre> <p>In the output of \"<code>eb --show-config</code>\" you should see a line like this:</p> <pre><code>pr-target-account (E) = ebtutorial\n</code></pre> <p>We only do this to avoid that lots of pull requests for the <code>eb-tutorial</code> example software are opened in the central easyconfigs repository.</p> <p>Opening a pull request is as simple as running \"<code>eb --new-pr</code>\" and passing the easyconfig file:</p> <pre><code>$ eb --new-pr example.eb\n== temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n== fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git...\n== copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs...\n== pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' (git@github.com:ebtutorial/easybuild-easyconfigs.git)\nEnter passphrase for key '/home/example/.ssh/id_rsa': \nPlease enter password for encrypted keyring:\n\nOpening pull request\n* target: ebtutorial/easybuild-easyconfigs:develop\n* from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100\n* title: \"{tools}[GCC/10.2.0] eb-tutorial v1.0.1\"\n* labels: new\n* description:\n\"\"\"\n(created using `eb --new-pr`)\n\n\"\"\"\n* overview of changes:\n easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb | 26 ++++++++++++++++++++++++++\n 1 file changed, 26 insertions(+)\n\nOpened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/\n== Temporary log file(s) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed.\n== Temporary directory /tmp/eb-ggr6scbq has been removed.\n</code></pre> <p>Take a moment to grasp what we did here: we ran a single <code>eb</code> command which took care of the whole contribution procedure for us, including:</p> <ul> <li>Cloning the <code>easybuilders/easybuild-easyconfigs</code> repository and checking out the <code>develop</code> branch (in a temporary   directory);</li> <li>Picking a sensible name for a branch and creating it;</li> <li>Adding the <code>eb-tutorial</code> easyconfig file to the branch, in the correct location   (<code>easybuild/easyconfigs/e/eb-tutorial/</code>) and with the correct filename (<code>eb-tutorial-1.0.1-GCC-10.2.0.eb</code>);</li> <li>Pushing the branch to our fork (<code>example/easybuild-easyconfigs</code>);</li> <li>Actually opening the pull request, using an informative title.</li> </ul> <p>That is so... easy!</p> <p>This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the <code>develop</code> branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to).</p> <p>There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since <code>--new-pr</code> created the branch only in a temporary directory).</p> <p>If many contributions are made via <code>--new-pr</code> it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar.</p>"},{"location":"2021-isc21/contributing/#uploading-test-report","title":"Uploading test report","text":"<p>After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request.</p> <p>First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for <code>eb-tutorial</code> are already installed there:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>You can verify which dependencies are still missing using <code>--from-pr</code> combined with <code>--missing</code>:</p> <pre><code># change '1' to the ID of your own pull request (see output of --new-pr)\n$ eb --from-pr 123 --missing\n== temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log\nPlease enter password for encrypted keyring:\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n\n1 out of 20 required modules missing:\n\n* eb-tutorial/1.0.1-GCC-10.2.0 (eb-tutorial-1.0.1-GCC-10.2.0.eb)\n</code></pre> <p>Uploading a test report boils down to combining <code>--from-pr</code> with <code>--upload-test-report</code>:</p> <pre><code># change '1' to the ID of your own pull request (see output of --new-pr)\n$ eb --rebuild --from-pr 123 --upload-test-report\nPlease enter password for encrypted keyring:\n...\n== processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb\n== building and installing eb-tutorial/1.0.1-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 2 sec)\n...\nAdding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial\n**SUCCESS**\nBuild succeeded for 1 out of 1 (1 easyconfigs in this PR)\nexample - Linux centos linux 7.8.2003, x86_64, Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz (haswell), Python 3.6.8\nSee https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report.'\n== Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1\n</code></pre> <p>Note that we may need to use <code>--rebuild</code> here since <code>eb-tutorial</code> may already be installed.</p> <p>This results in a comment being added to the pull request:</p> <p>The gist linked from this comment provides more detailed information:</p> <p>(back to start page)</p>"},{"location":"2021-isc21/getting_ready/","title":"Getting ready","text":"<p>The contents of this page was moved to Practical info</p>"},{"location":"2021-isc21/installation/","title":"Installing EasyBuild","text":"<p>Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild.</p> <p>In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial.</p> <p>Summary</p> <ul> <li>Requirements: Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended).</li> <li>Installation methods:<ul> <li><code>pip install easybuild</code></li> <li>installing EasyBuild with EasyBuild</li> <li>development setup</li> </ul> </li> <li>Verify EasyBuild installation by running <code>eb</code> commands.</li> </ul>"},{"location":"2021-isc21/installation/#requirements","title":"Requirements","text":""},{"location":"2021-isc21/installation/#linux","title":"Linux","text":"<p>The main target platform for EasyBuild is Linux, since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux).</p> <p>EasyBuild is also compatible with macOS, but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project.</p>"},{"location":"2021-isc21/installation/#python","title":"Python","text":"<p>EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3).</p> <p>To check which Python version you have, use:</p> <pre><code>python -V\n</code></pre> <p>No additional Python packages are required by EasyBuild, the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.</p>"},{"location":"2021-isc21/installation/#environment-modules-tool","title":"Environment modules tool","text":"<p>An environment modules tool is required for using EasyBuild.</p> <p>We strongly recommend using Lmod, a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported.</p> <p>To check if you have a modules tool installed, use:</p> <pre><code>module --version\n</code></pre> <p>If this produces output that starts with something like \"<code>Modules based on Lua: Version 8.2.5</code>\" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. </p> <p>If you see output that starts with a line like \"<code>VERSION=3.2.10</code>\" or \"<code>Modules Release 4.5.0</code>\", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation.</p> <p>If the <code>module</code> function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.</p>"},{"location":"2021-isc21/installation/#easybuild-as-a-python-package","title":"EasyBuild as a Python package","text":"<p>EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders, as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild.</p> <p>As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation.</p> <p>Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry.</p> <p>You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like <code>pip</code>, <code>virtualenv</code>, <code>pipenv</code>, ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!</p>"},{"location":"2021-isc21/installation/#python-2-or-python-3","title":"Python 2 or Python 3?","text":"<p>For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life, we strongly recommend using Python 3 if you have the choice.</p> <p>By default EasyBuild will use the <code>python</code> command to run, but you can control this if needed via <code>$EB_PYTHON</code>.</p>"},{"location":"2021-isc21/installation/#installing-easybuild_1","title":"Installing EasyBuild","text":"<p>We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation.</p> <p>Time to get your hands dirty!</p> <ul> <li>Method 1: Using <code>pip</code></li> <li>Method 2: installing EasyBuild with EasyBuild</li> <li>Method 3: Development setup</li> </ul>"},{"location":"2021-isc21/installation/#method-1-using-pip","title":"Method 1: Using <code>pip</code>","text":"<p>Since EasyBuild is released as a Python package on PyPI you can install it using <code>pip</code>, the most commonly used tool for installing Python packages.</p> <p>You may need to take additional steps after the installation, depending on the exact installation command.</p> <p>Note</p> <p>There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like <code>virtualenv</code> or <code>pipenv</code>, feel free to use those instead to install EasyBuild.</p>"},{"location":"2021-isc21/installation/#running-pip-install","title":"Running <code>pip install</code>","text":"<p>Installing EasyBuild with <code>pip</code> is as simple as running the following command:</p> <pre><code>pip install easybuild\n</code></pre> <p>However, you may need to slightly change this command depending on the context and your personal preferences:</p> <ul> <li> <p>To install EasyBuild system-wide, you can use <code>sudo</code> (if you have admin privileges):   <pre><code>sudo pip install easybuild\n</code></pre></p> </li> <li> <p>To install EasyBuild in your personal home directory, you can use the <code>--user</code> option:   <pre><code>pip install --user easybuild\n</code></pre>   This will result in an EasyBuild installation in <code>$HOME/.local/</code>.</p> </li> <li> <p>To install EasyBuild in a specific directory you can use the <code>--prefix</code> option:   <pre><code>pip install --prefix _PREFIX_ easybuild\n</code></pre>   In this command, you should replace '<code>_PREFIX_</code>' with the location where you want to have EasyBuild installed   (for example, <code>$HOME/tools</code> or <code>/tmp/$USER</code>).</p> </li> </ul>"},{"location":"2021-isc21/installation/#pip-vs-pip3","title":"<code>pip</code> vs <code>pip3</code>","text":"<p>On systems where both Python 2 and Python 3 are installed you may also have different <code>pip</code> commands available. Or maybe <code>pip</code> is not available at all, and only \"versioned\" <code>pip</code> commands like <code>pip3</code> are available.</p> <p>If you (only) have <code>pip3</code> available, you can replace <code>pip</code> with <code>pip3</code> in any of the <code>pip install</code> commands above.</p> <p>If you want to ensure that you are using the <code>pip</code> installation that corresponds to the Python 3 installation that you intend to use, you can use <code>python3 -m pip</code> rather than <code>pip3</code>.</p>"},{"location":"2021-isc21/installation/#updating-your-environment","title":"Updating your environment","text":"<p>If you used the <code>--user</code> or <code>--prefix</code> option in the <code>pip install</code> command, or if you installed EasyBuild with a <code>pip</code> version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version.</p> <p>Note</p> <p>Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update the <code>.bashrc</code> shell startup script in your home directory.</p>"},{"location":"2021-isc21/installation/#updating-path","title":"Updating <code>$PATH</code>","text":"<p>Update the <code>$PATH</code> environment variable to make sure the <code>eb</code> command is available: <pre><code>export PATH=_PREFIX_/bin:$PATH\n</code></pre> Replace '<code>_PREFIX_</code>' in this command with the directory path where EasyBuild was installed into (use <code>$HOME/.local</code> if you used <code>pip install --user</code>).</p> <p>This is not required if you installed EasyBuild in a standard system location.</p> <p>You can check with the \"<code>which eb</code>\" command to determine whether or not you need to update the <code>$PATH</code> environment variable.</p>"},{"location":"2021-isc21/installation/#updating-pythonpath","title":"Updating <code>$PYTHONPATH</code>","text":"<p>If you installed EasyBuild to a non-standard location using <code>pip install --prefix</code>, you also need to update the Python search path environment variable <code>$PYTHONPATH</code> to instruct Python where it can find the EasyBuild Python packages.</p> <p>This is not required if you used the <code>--user</code> option, since Python will automatically consider <code>$HOME/.local</code> when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location.</p> <p>Update <code>$PYTHONPATH</code> by running a command like:</p> <pre><code>export PYTHONPATH=_PREFIX_/lib/pythonX.Y/site-packages:$PYTHONPATH\n</code></pre> <p>Here, you need to replace the <code>X</code> and <code>Y</code> with the major and minor version of your Python installation, which you can determine by running <code>python -V</code>. For example, if you are using Python 3.6, make sure you are using <code>/python3.6/</code> in the command to update <code>$PYTHONPATH</code>.</p> <p>And of course, you again need to replace '<code>_PREFIX_</code>' with the installation prefix where EasyBuild was installed into.</p> <p>For example:</p> <pre><code># update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6\nexport PYTHONPATH=$HOME/tools/lib/python3.6/site-packages:$PYTHONPATH\n</code></pre>"},{"location":"2021-isc21/installation/#setting-eb_python","title":"Setting <code>$EB_PYTHON</code>","text":"<p>If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the <code>python</code> command that should be used by the <code>eb</code> command via the <code>$EB_PYTHON</code> environment variable.</p> <p>This may be required when you installing EasyBuild with a version of <code>pip</code> that does not correspond with the default Python version.</p> <p>For example, to ensure that the <code>eb</code> command uses <code>python3.6</code>:</p> <pre><code>export EB_PYTHON=python3.6\n</code></pre>"},{"location":"2021-isc21/installation/#setting-eb_verbose","title":"Setting <code>$EB_VERBOSE</code>","text":"<p>To determine which <code>python</code> commands are being considered by the <code>eb</code> command, you can define the <code>$EB_VERBOSE</code> environment variable. For example:</p> <pre><code>$ EB_VERBOSE=1 eb --version\n&gt;&gt; Considering 'python3.6'...\n&gt;&gt; 'python3' version: 3.6.8, which matches Python 3 version requirement (&gt;= 3.5)\n&gt;&gt; Selected Python command: python3 (/usr/bin/python3.6)\n&gt;&gt; python3.6 -m easybuild.main --version\nThis is EasyBuild 4.3.3 (framework: 4.3.3, easyblocks: 4.3.3) on host example\n</code></pre>"},{"location":"2021-isc21/installation/#method-2-installing-easybuild-with-easybuild","title":"Method 2: Installing EasyBuild with EasyBuild","text":"<p>Note</p> <p>This section covers an alternative method for installing EasyBuild.</p> <p>If you already have EasyBuild installed through <code>pip</code>, you can skip ahead to the next section.</p> <p>If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps:</p> <ul> <li>Step 1: Installing EasyBuild with <code>pip</code> into a temporary location (only needed if EasyBuild is not installed yet)</li> <li>Step 2: Using EasyBuild to install EasyBuild as a module</li> <li>Step 3: Loading the EasyBuild module</li> </ul>"},{"location":"2021-isc21/installation/#step-1-installing-easybuild-into-a-temporary-location","title":"Step 1: Installing EasyBuild into a temporary location","text":"<p>If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using <code>pip</code>.</p> <p>For example, to install EasyBuild into a subdirectory <code>/tmp/$USER</code> using the default Python 3 version:</p> <pre><code># pick installation prefix, and install EasyBuild into it\nexport EB_TMPDIR=/tmp/$USER/eb_tmp\npython3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild\n</code></pre> <pre><code># update environment to use this temporary EasyBuild installation\nexport PATH=$EB_TMPDIR/bin:$PATH\nexport PYTHONPATH=$(/bin/ls -rtd -1 $EB_TMPDIR/lib*/python*/site-packages | tail -1):$PYTHONPATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2021-isc21/installation/#step-2-using-easybuild-to-install-easybuild","title":"Step 2: Using EasyBuild to install EasyBuild","text":"<p>Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too.</p> <p>You can use the <code>eb --install-latest-eb-release</code> command for this, combined with the <code>--prefix</code> option to control which directories are used by EasyBuild for the installation.</p> <p>For example, to install the latest version of EasyBuild as a module into <code>$HOME/easybuild</code>:</p> <pre><code>eb --install-latest-eb-release --prefix $HOME/easybuild\n</code></pre> <p>Note</p> <p>You may see a harmless deprecation warning popping up when performing this installation, just ignore it.</p>"},{"location":"2021-isc21/installation/#step-3-loading-the-easybuild-module","title":"Step 3: Loading the EasyBuild module","text":"<p>Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session.</p> <p>First, make the module available by running the following command (which will update the module search path environment variable <code>$MODULEPATH</code>):</p> <pre><code>module use _PREFIX_/modules/all\n</code></pre> <p>Replace '<code>_PREFIX_</code>' with the path to the directory that you used when running step 2 (for example, <code>$HOME/easybuild</code>).</p> <p>Then, load the <code>EasyBuild</code> module to update your environment and make EasyBuild available for use:</p> <pre><code>module load EasyBuild\n</code></pre> <p>Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made.</p>"},{"location":"2021-isc21/installation/#method-3-development-setup","title":"Method 3: Development setup","text":"<p>If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there.</p> <p>This can be done as follows (into <code>$HOME/easybuild</code>):</p> <pre><code>mkdir -p $HOME/easybuild\ncd $HOME/easybuild\n</code></pre> <p><pre><code># clone EasyBuild repositories from GitHub\ngit clone https://github.com/easybuilders/easybuild-framework.git\ngit clone https://github.com/easybuilders/easybuild-easyblocks.git\ngit clone https://github.com/easybuilders/easybuild-easyconfigs.git\n</code></pre> <pre><code># update environment for running EasyBuild from there\nexport PATH=$HOME/easybuild/easybuild-framework:$PATH\nexport PYTHONPATH=$HOME/easybuild/easybuild-framework:$HOME/easybuild/easybuild-easyblocks:$HOME/easybuild/easybuild-easyconfigs:$PYTHONPATH\n\n# control which Python command is used to run EasyBuild\nexport EB_PYTHON=python3\n</code></pre></p>"},{"location":"2021-isc21/installation/#verifying-the-installation","title":"Verifying the installation","text":"<p>Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:</p>"},{"location":"2021-isc21/installation/#checking-the-version","title":"Checking the version","text":"<p>To check which EasyBuild version you have installed, run:</p> <pre><code>eb --version\n</code></pre> <p>The output should match with the latest EasyBuild version.</p>"},{"location":"2021-isc21/installation/#consulting-the-help-output","title":"Consulting the help output","text":"<p>You can consult the help output of the <code>eb</code> command, which produces a long list of available options along with a short informative message.</p> <pre><code>eb --help\n</code></pre>"},{"location":"2021-isc21/installation/#showing-the-default-easybuild-configuration","title":"Showing the default EasyBuild configuration","text":"<p>To inspect the current EasyBuild configuration, you can use this command:</p> <pre><code>eb --show-config\n</code></pre> <p>This should tell you that EasyBuild (ab)uses <code>$HOME/.local/easybuild</code> as a default location. More on configuring EasyBuild in the next part of the tutorial.</p>"},{"location":"2021-isc21/installation/#system-information","title":"System information","text":"<p>You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command:</p> <pre><code>eb --show-system-info\n</code></pre>"},{"location":"2021-isc21/installation/#updating-easybuild","title":"Updating EasyBuild","text":"<p>Before we wrap up here, a brief word about updating EasyBuild.</p> <p>Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module:</p> <pre><code>eb --install-latest-eb-release\n</code></pre> <p>This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration.</p> <p>If you have installed EasyBuild through <code>pip</code>, and you prefer updating that installation, you can use <code>pip install --upgrade easybuild</code> (perhaps with additional options like <code>--user</code> or <code>--prefix</code>).</p>"},{"location":"2021-isc21/installation/#exercise","title":"Exercise","text":"<p>Install EasyBuild in your home directory.</p> <p>Make sure that the EasyBuild installation uses the <code>python3</code> command to run, rather than the standard <code>python</code> command.</p> <p>Choose your own adventure, or try all these installation methods!</p> <ul> <li>install EasyBuild with <code>pip</code> (or another very similar command...) using either the <code>--user</code> or <code>--prefix</code> option;</li> <li>perform a (manual) \"bootstrap\" installation into <code>$HOME/easybuild</code>, as outlined in installation method 2;</li> <li>set up a development installation;</li> </ul> <p>Check that the installation works by running the verification commands outlined above.</p> <p>Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial!</p> <p>next: Configuration - (back to overview page)</p>"},{"location":"2021-isc21/installing_software/","title":"Installing software with EasyBuild","text":"<p>You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require.</p> <p>As mentioned before, installing an easyconfig is as simple as passing it to the <code>eb</code> command.</p> <p>So, let's try to install SAMtools version 1.11:</p> <pre><code>$ eb SAMtools-1.11-GCC-10.2.0.eb\n== temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log\n== found valid index for /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb\n== building and installing SAMtools/1.11-GCC-10.2.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== building...\n== testing...\n== installing...\n== taking care of extensions...\n== restore after iterating...\n== postprocessing...\n== sanity checking...\n== cleaning up...\n== creating module...\n== permissions...\n== packaging...\n== COMPLETED: Installation ended successfully (took 17 sec)\n== Results of the build can be found in the log file(s) /home/example/easybuild/software/SAMtools/1.11-GCC-10.2.0/easybuild/easybuild-SAMtools-1.11-20210309.105601.log\n== Build succeeded for 1 out of 1\n== Temporary log file(s) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed.\n== Temporary directory /tmp/eb-zh7_fyre has been removed.\n</code></pre> <p>That was... easy. Is that really all there is to it? Well, almost...</p>"},{"location":"2021-isc21/installing_software/#enabling-dependency-resolution","title":"Enabling dependency resolution","text":"<p>The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see the section on checking dependencies).</p> <p>If we try this with the <code>BCFtools-1.11-GCC-10.2.0.eb</code>, for which the required <code>GSL</code> and <code>HTSlib</code> dependencies are not available yet, it's less successful:</p> <pre><code>$ eb BCFtools-1.11-GCC-10.2.0.eb -M\n\n3 out of 23 required modules missing:\n\n* GSL/2.6-GCC-10.2.0 (GSL-2.6-GCC-10.2.0.eb)\n* HTSlib/1.11-GCC-10.2.0 (HTSlib-1.11-GCC-10.2.0.eb)\n* BCFtools/1.11-GCC-10.2.0 (BCFtools-1.11-GCC-10.2.0.eb)\n</code></pre> <pre><code>$ eb BCFtools-1.11-GCC-10.2.0.eb\n...\n== preparing...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/build/BCFtools/1.11/GCC-10.2.0): build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 (took 2 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-3v1dfvnk/easybuild-BCFtools-1.11-20210308.195024.FlxkH.log\nERROR: Build of /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/b/BCFtools/BCFtools-1.11-GCC-10.2.0.eb failed (err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0')\n</code></pre> <p>Oh my, what's this all about?</p> <p>If we filter the output a bit and focus on the actual error, the problem is clear:</p> <pre><code>Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0\n</code></pre> <p>The required dependencies <code>HTSlib/1.11-GCC-10.2.0</code> and <code>GSL/2.6-GCC-10.2.0</code> are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so.</p> <p>It helpfully suggests to use the <code>--robot</code> command line option, so let's try that:</p> <pre><code>$ eb BCFtools-1.11-GCC-10.2.0.eb --robot\n...\n== resolving dependencies ...\n...\n== building and installing HTSlib/1.11-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 13 sec)\n...\n== building and installing GSL/2.6-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 1 min 10 sec)\n...\n== building and installing BCFtools/1.11-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 8 sec)\n...\n== Build succeeded for 3 out of 3\n</code></pre> <p>With dependency resolution enabled the <code>HTSlib</code> and <code>GSL</code> modules get installed first, before EasyBuild proceeds with installing <code>BCFtools</code>. Great!</p>"},{"location":"2021-isc21/installing_software/#trace-output","title":"Trace output","text":"<p>As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there?</p> <p>To provide some more feedback as the installation progresses, you can enable the \"<code>trace</code>\" configuration setting. Let's do this by defining the <code>$EASYBUILD_TRACE</code> environment variable, just to avoid having to type <code>--trace</code> over and over again.</p> <p>We will redo the installation of <code>BCFtools-1.11-GCC-10.2.0.eb</code> by passing the <code>--rebuild</code> option to the <code>eb</code> command (try yourself what happens if you don't use the <code>--rebuild</code> option!):</p> <pre><code>$ export EASYBUILD_TRACE=1\n$ eb BCFtools-1.11-GCC-10.2.0.eb --rebuild\n...\n== configuring...\n  &gt;&gt; running command:\n    [started at: 2021-03-08 19:54:53]\n[working dir: /tmp/example/build/BCFtools/1.11/GCC-10.2.0/bcftools-1.11]\n[output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-17m_he2x.log]\n./configure --prefix=/home/example/easybuild/software/BCFtools/1.11-GCC-10.2.0  --build=x86_64-pc-linux-gnu  --host=x86_64-pc-linux-gnu --with-htslib=$EBROOTHTSLIB --enable-libgsl\n== building...\n  &gt;&gt; running command:\n    [started at: 2021-03-08 19:54:54]\n[working dir: /tmp/example/BCFtools/1.11/GCC-10.2.0/bcftools-1.11]\n[output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-bhkgjxi7.log]\nmake -j 8\n&gt;&gt; command completed: exit 0, ran in 00h00m03s\n</code></pre> <p>That's a bit more comforting to stare at...</p> <p>During the configure step, the <code>./configure</code> command is run with option to enable support for leveraging <code>HTSlib</code> and <code>GSL</code>.</p> <p>During the build step, the software is actually being compiled by running the <code>make</code> command. EasyBuild automatically uses the available cores on the system (in this case 8).</p> <p>We even get a pointer to a log file that contains the output of the command being run, so we can use <code>tail -f</code> to see in detail how it progresses.</p> <p>Once the <code>make</code> command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know.</p> <p>Later during the installation, we now also see this output during the sanity check step:</p> <pre><code>== sanity checking...\n  &gt;&gt; file 'bin/bcftools' found: OK\n  &gt;&gt; file 'bin/plot-vcfstats' found: OK\n  &gt;&gt; file 'bin/vcfutils.pl' found: OK\n  &gt;&gt; (non-empty) directory 'libexec/bcftools' found: OK\n</code></pre> <p>Thanks to enabling trace mode, EasyBuild tells us which files &amp; directories it is checking for in the installation, before declaring it a success. Nice!</p> <p>The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.</p>"},{"location":"2021-isc21/installing_software/#using-installed-software","title":"Using installed software","text":"<p>So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice!</p> <p>A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation.</p> <p>That's great, but how do we now actually use these installations?</p> <p>This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous <code>module</code> command to digest them.</p> <p>First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of <code>eb --show-config</code>; the value of the <code>installpath</code> configuration setting is what we are interested in now:</p> <pre><code>$ eb --show-config\n...\ninstallpath    (E) = /home/example/easybuild\n...\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\n...\nsourcepath     (E) = /home/example/easybuild/sources\n...\n</code></pre> <p>So, what's in this directory?</p> <pre><code>$ ls -l $HOME/easybuild\ntotal 16\ndrwxrwxr-x 5 example example 4096 Jun 10 20:11 ebfiles_repo\ndrwxrwxr-x 5 example example 4096 Jun 10 20:10 modules\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 software\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 sources\n</code></pre> <p>The <code>ebfiles_repo</code> and <code>sources</code> directories correspond to the <code>repositorypath</code> and <code>sourcepath</code> configuration settings, respectively. The <code>modules</code> and <code>software</code> directories are what we need now.</p> <p>The <code>modules</code> subdirectory consists of multiple subdirectories:</p> <pre><code>$ ls $HOME/easybuild/modules\nall  bio  devel  numlib  tools\n</code></pre> <p>Directories like <code>bio</code> and <code>numlib</code> correspond to different software categories, and contain symbolic links to the module files in the <code>all</code> directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now.</p> <p>Let's inform the modules tool about the existence of these module files using <code>\"module use\"</code>:</p> <pre><code>module use $HOME/easybuild/modules/all\n</code></pre> <p>This command does little more that updating the <code>$MODULEPATH</code> environment variable, which contains a list of paths that the modules tool should consider when looking for module files.</p> <p>Now the modules tool should be aware of our brand new installations:</p> <pre><code>$ module avail\n\n---------------------- /home/example/easybuild/modules/all -----------------------\n   BCFtools/1.11-GCC-10.2.0    GSL/2.6-GCC-10.2.0       SAMtools/1.11-GCC-10.2.0\n   EasyBuild/4.3.3             HTSlib/1.11-GCC-10.2.0   bzip2/1.0.6\n\n---------------------------- /easybuild/modules/all -----------------------------\n    ...\n</code></pre> <p>This output shows both the modules for our own installations as well as the \"central\" installations in <code>/easybuild</code> (which we omitted above for brevity).</p> <p>Now we can load these modules and start using these software installations.</p> <p>Let's test this for BCFtools. In our current environment, the <code>bcftools</code> command is not available yet:</p> <pre><code>$ module list\nNo modules loaded\n\n$ bcftools\n-bash: bcftools: command not found\n</code></pre> <p>Loading the module for BCFtools changes that:</p> <pre><code>$ module load BCFtools/1.11-GCC-10.2.0\n\n$ module list\nCurrently Loaded Modules:\n  1) EasyBuild/4.4.0                7) XZ/5.2.5-GCCcore-10.2.0\n  2) GCCcore/10.2.0                 8) cURL/7.72.0-GCCcore-10.2.0\n  3) zlib/1.2.11-GCCcore-10.2.0     9) HTSlib/1.11-GCC-10.2.0\n  4) binutils/2.35-GCCcore-10.2.0  10) GSL/2.6-GCC-10.2.0\n  5) GCC/10.2.0                    11) BCFtools/1.11-GCC-10.2.0\n  6) bzip2/1.0.8-GCCcore-10.2.0\n\n$ bcftools --version\nbcftools 1.11\nUsing htslib 1.11\n...\n</code></pre> <p>Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like <code>libstdc++.so</code>), are loaded automatically. The \"<code>module load</code>\" command changes the active environment, by updating environment variables like <code>$PATH</code> for example, to make the software available for use.</p>"},{"location":"2021-isc21/installing_software/#resetting-your-environment","title":"Resetting your environment","text":"<p>To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \"<code>module unload</code>\", or you can unload all of them at once using \"<code>module purge</code>\".</p> <p>If you are using an EasyBuild installation provided by a module, don't forget to load the <code>EasyBuild</code> module again after running \"<code>module purge</code>\".</p>"},{"location":"2021-isc21/installing_software/#stacking-software","title":"Stacking software","text":"<p>Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in <code>$HOME/easybuild</code>) on top of installations that are provided in a totally different location (<code>/easybuild</code>).</p> <p>EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required.</p> <p>This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).</p>"},{"location":"2021-isc21/installing_software/#exercises","title":"Exercises","text":"<p>Guidelines</p> <p>Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself!</p> <p>Please do not spoil solutions for others before they have been discussed by the tutorial organisers.</p> <p>The exercises are based on the easyconfig files included with EasyBuild 4.4.0.</p> <p>Exercise S.1 - Installing software</p> <p>Install version 3.1.0 of the <code>h5py</code> Python package and all missing dependencies, using the <code>foss/2020b</code> toolchain, into <code>/tmp/$USER/easybuild</code>, while leveraging the already installed software available from <code>/easybuild</code>.</p> <p>Enable trace output so you can see which parts of the installation take a while.</p> (click to show solution) <p>First, determine the easyconfig file we can use for this: <pre><code>$ eb -S 'h5py-3.1.0.*foss-2020b'\nCFGS1=/home/kehoste/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs/h/h5py\n* $CFGS1/h5py-3.1.0-foss-2020b.eb\n</code></pre></p> <p>Make sure the pre-installed software in <code>/easybuild/</code> is available: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>Check which dependencies are missing to install this <code>h5py</code> easyconfig: <pre><code>$ eb h5py-3.1.0-foss-2020b.eb --missing\n\n2 out of 63 required modules missing:\n\n* pkgconfig/1.5.1-GCCcore-10.2.0-python (pkgconfig-1.5.1-GCCcore-10.2.0-python.eb)\n* h5py/3.1.0-foss-2020b (h5py-3.1.0-foss-2020b.eb)\n</code></pre></p> <p>Install <code>h5py</code> by specifying the easyconfig file and enabling dependency resolution via <code>--robot</code>, while indicating that we want to install the software into <code>/tmp/$USER/easybuild</code> using the <code>--installpath</code> option. Also make sure that trace mode is enabled by defining the <code>$EASYBUILD_TRACE</code> environment variable. <pre><code>$ export EASYBUILD_TRACE=1\n$ eb h5py-3.1.0-foss-2020b.eb --robot --installpath /tmp/$USER/easybuild\n...\n== building and installing pkgconfig/1.5.1-GCCcore-10.2.0-python...\n...\n== building and installing h5py/3.1.0-foss-2020b...\n...\n== building...\n  &gt;&gt; running command:\n        [started at: 2020-06-10 21:47:32]\n[working dir: /tmp/example/h5py/3.1.0/foss-2020b/h5py-3.1.0]\n[output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log]  python setup.py configure --mpi --hdf5=$EBROOTHDF5 &amp;&amp; /easybuild/software/Python/3.8.6-GCCcore-10.2.0/bin/python setup.py build\n  &gt;&gt; command completed: exit 0, ran in 00h01m27s\n...\n== COMPLETED: Installation ended successfully (took 2 min 46 sec)\n...\n== Build succeeded for 2 out of 2\n</code></pre></p> <p>The trace output shows that most time is spent in the build command, which runs both <code>python setup.py configure</code> and <code>python setup.py build</code>.</p> <p>Exercise S.2 - Using installed software</p> <p>Using the <code>h5py</code> installation from the previous exercise to create an empty HDF5 file, using the following Python statements:</p> <pre><code>import h5py\nf = h5py.File(\"empty.hdf5\", \"w\")\nf.close()\n</code></pre> <p>Check the resulting file using the <code>h5stat</code> command.</p> (click to show solution) <p>First, we need to make the modules tool aware of the module files that were installed into <code>/tmp/$USER/easybuild</code>: <pre><code>module use /tmp/$USER/easybuild/modules/all\n</code></pre></p> <p>Then we can check the <code>h5py</code> module is available, and load it: <pre><code>$ module avail h5py\n------------ /tmp/example/easybuild/modules/all ------------\nh5py/3.1.0-foss-2020b\n</code></pre></p> <pre><code>module load h5py/3.1.0-foss-2020b\n</code></pre> <p>The Python code snippet can be run directly on the command line using \"<code>python -c '...'</code>\", since it's tiny: <pre><code>python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()'\n</code></pre> Of course you can also copy the Python code snippet in a file named <code>test_h5py.py</code>, and then run it with <code>python test_h5py.py</code>.</p> <p>Checking with the <code>h5stat</code> command shows that the resulting <code>empty.hdf5</code> is indeed a valid HDF5 file: <pre><code>$ ls -l empty.hdf5 \n-rw-rw-r-- 1 example example 800 Jun 10 21:54 empty.hdf5\n\n$ h5stat empty.hdf5\nFilename: empty.hdf5\nFile information\n        # of unique groups: 1\n# of unique datasets: 0\n...\n</code></pre></p> <p>If you've made it through the hands-on exercises, congratulations!</p> <p>If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time...</p> <p>Feel free to ask questions in the <code>#tutorial-isc21</code> channel in the EasyBuild Slack, we're happy to help!</p> <p>next: Troubleshooting - (back to overview page)</p>"},{"location":"2021-isc21/introduction/","title":"Introduction to EasyBuild","text":""},{"location":"2021-isc21/introduction/#what-is-easybuild","title":"What is EasyBuild?","text":"<p>EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. EasyBuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack.</p>"},{"location":"2021-isc21/introduction/#history","title":"History","text":"<p>EasyBuild as a project was conceived in 2008 by the HPC team at Ghent University (Belgium). The first public release of EasyBuild was made available early 2012. EasyBuild v1.0.0 was released in November 2012, during the Supercomputing 2012 conference.</p> <p>Following the public release and the project's introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. Over the years EasyBuild has grown into a community project, which is used and developed by hundreds of HPC centres and consortia worldwide.</p> <p> </p>"},{"location":"2021-isc21/introduction/#easybuild-in-a-nutshell","title":"EasyBuild in a nutshell","text":"<p>EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems.</p> <p>It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks.</p> <p>In addition, EasyBuild can empower scientific researchers to self-manage their software stack, and it can serve as a tool that can be leveraged for building optimized container images.</p> <p>The project has grown to become a platform for collaboration among HPC sites worldwide, and has become an \"expert system\" for installing scientific software on HPC systems.</p>"},{"location":"2021-isc21/introduction/#key-features","title":"Key features","text":"<p>EasyBuild is capable of fully autonomously installing (scientific) software, including making sure that all necessary dependencies are installed, and automatically generating environment module files.</p> <p>No admin privileges are required: it is sufficient to have write permissions to the preferred software installation prefix.</p> <p>EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations.</p> <p>The installation procedure executed by EasyBuild is thoroughly logged, and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed.</p> <p>EasyBuild supports using a custom module naming scheme, allows for hierarchical module naming schemes, and integrates with various other tools ranging from  resource managers (Slurm and GC3Pie), container tools (Singularity and Docker), packaging tools (FPM), and so on.</p>"},{"location":"2021-isc21/introduction/#focus-points","title":"Focus points","text":"<p>EasyBuild was created specifically for installing scientific software on HPC systems, which is reflected in some of the design choices that were made.</p>"},{"location":"2021-isc21/introduction/#performance","title":"Performance","text":"<p>EasyBuild strongly prefers to build software from source code, whenever possible.</p> <p>This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run.</p> <p>For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like <code>-march=native</code> (GCC), <code>-xHost</code> (Intel compilers), etc. This behaviour can be changed via the <code>--optarch</code> configuration setting.</p>"},{"location":"2021-isc21/introduction/#reproducibility","title":"Reproducibility","text":"<p>In addition to performance, reproducibility of installations is a core aspect of EasyBuild.</p> <p>Most software installations performed with EasyBuild use a particular compiler toolchain, with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like <code>OpenSSL</code> for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system.</p> <p>For both toolchains and dependencies, fixed software versions are specified in the easyconfig files. That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.</p>"},{"location":"2021-isc21/introduction/#community-effort","title":"Community effort","text":"<p>In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out.</p> <p>We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the GitHub repositories or the documentation.</p> <p>Through the <code>foss</code> and <code>intel</code> common toolchains, we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository.</p> <p>Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.</p>"},{"location":"2021-isc21/introduction/#what-easybuild-is-not","title":"What EasyBuild is not","text":"<p>EasyBuild is not YABT (Yet Another Build Tool): it does not replace established build tools like CMake or <code>make</code>, it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you.</p> <p>It is not a replacement for traditional Linux package managers like <code>yum</code>, <code>dnf</code> or <code>apt</code>. EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution.</p> <p>Finally, EasyBuild is not a magic solution to all your (software installation) problems. You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you.</p> <p>next: Terminology - (back to overview page)</p>"},{"location":"2021-isc21/jsc/","title":"EasyBuild at J\u00fclich Supercomputing Centre","text":"<p>(author: Alan O'Cais, J\u00fclich Supercomputing Centre)</p>"},{"location":"2021-isc21/jsc/#general-info","title":"General info","text":"<p>The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc) at  Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process.</p>"},{"location":"2021-isc21/jsc/#staff-user-base","title":"Staff &amp; user base","text":"<p>About 200 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services.</p> <p>In cooperation with hardware and software vendors like IBM, Intel and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008.</p>"},{"location":"2021-isc21/jsc/#resources","title":"Resources","text":"<p>JSC currently manages 3 primary systems (in addition to a number of other development clusters):</p> <p>JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance. In the coming months, JUWELS will become the first supercomputer equipped with NVIDIA A100 GPU, when a new GPU module providing an additional 58 Petaflops will be installed. This module will make JUWELS the most powerful supercomputer in Europe.</p> <p>JURECA is the precursor system to JUWELS and currently has 2 modules: the JURECA DC Module with 3.54 (CPU, AMD EPYC) + 14.98 (GPU, NVIDIA A100) Petaflop per second peak performance, and the JURECA Booster Module with 5 (KNL) Petaflop per second peak performance. </p> <p>JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms.</p>"},{"location":"2021-isc21/jsc/#usage-of-easybuild-within-jsc","title":"Usage of EasyBuild within JSC","text":"<p>As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated.</p> <p>JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations.</p>"},{"location":"2021-isc21/jsc/#custom-toolchains","title":"Custom toolchains","text":"<p>As of June 2020, there are a total of 15 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers (<code>GCCcore</code>, <code>GCC</code>, <code>Intel</code> and <code>PGI</code>), MPI runtimes (<code>ParaStationMPI</code>, <code>OpenMPI</code>, <code>IntelMPI</code> and <code>MVAPICH2</code>) and mathematical libraries (<code>MKL</code>).</p> <p>Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the <code>--try-toolchain</code> option and has recently introduced the <code>--try-update-deps</code> experimental option to more easily adopt upstream changes and adapt them to our environment. </p>"},{"location":"2021-isc21/jsc/#custom-module-naming-scheme","title":"Custom module naming scheme","text":"<p>By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes).</p>"},{"location":"2021-isc21/jsc/#custom-easyconfigs","title":"Custom easyconfigs","text":"<p>The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository).</p> <p>We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild.</p>"},{"location":"2021-isc21/jsc/#hiding-dependencies","title":"Hiding dependencies","text":"<p>While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the <code>hide-deps</code> configuration setting). There are currently over 200 such hidden dependencies.  </p> <p>While hidden dependencies are not visible in the <code>module</code> view by default, users can expose them by the use of the <code>--show-hidden</code> argument in <code>Lmod</code>: <pre><code>module --show-hidden avail\n</code></pre></p>"},{"location":"2021-isc21/jsc/#usage-of-hooks","title":"Usage of hooks","text":"<p>The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely.</p> <p>We are currently integrating a new hook that provides a lot of useful functionality:</p> <ul> <li>Facilitates userspace installations alongside system provided installations</li> <li>EasyBuild is configured to allow both shared installations for a group and private     installations (group installations are automatically picked up by Lmod for other     members of the group)</li> <li>Restricts users from installing non-supported compilers (in particular we don't want     people to install their own <code>GCCcore</code> since this would likely lead to an avalanche     of required dependencies) and MPI runtimes (since MPI installations     are heavily customised)</li> <li>Restricts users to only resolve dependencies from our Golden repository (as well     as from     their own installed software) but allows them to search in the upstream repositories<ul> <li>if they try to install something from the upstream repository, the hook advises   them how to do this correctly for our systems</li> </ul> </li> <li>Customises the final module files</li> <li>Customises the names of some modules (such as <code>Intel</code> over <code>iccifort</code> and     <code>IntelMPI</code> over <code>impi</code>)</li> <li>Injects an Lmod family in the modules of our compilers and MPI runtimes</li> <li>Adds Lmod properties for GPU enabled applications and user installed software so     that they can be easily identified in the <code>module</code> view</li> <li>Adds a <code>site_contact</code> for all modules</li> <li>Updates the Lmod cache when an installation is made system-wide</li> </ul> <p>We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system.</p>"},{"location":"2021-isc21/jsc/#upgrading-and-retiring-software","title":"Upgrading and retiring software","text":"<p>The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package.</p> <p>The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. Originally, we had chosen six months as our upgrade period but found this to be cumbersome as the number of supported systems and toolchains grew, our upgrade period is now every 12 months. We chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains.</p> <p>We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. A common workflow is to create a personal installation of a package that can be tweaked, then a group installation for others to try out. Once a software package has been successfully built and tested, it is added to a Golden repository to be used in production.</p> <p>The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage.</p> <p>While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod.</p> <p>next: EasyBuild at Compute Canada - (back to overview page)</p>"},{"location":"2021-isc21/module_naming_schemes/","title":"Module naming schemes","text":"<p>Up until now we have used EasyBuild's default module naming scheme (<code>EasyBuildMNS</code>), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing <code>h5py-3.1.0-foss-2020b.eb</code> the generated module was named <code>h5py/3.1.0-foss-2020b</code>.</p> <p>EasyBuild supports several different module naming schemes:</p> <pre><code>$ eb --avail-module-naming-schemes\nList of supported module naming schemes:\n    CategorizedHMNS\n    CategorizedModuleNamingScheme\n    EasyBuildMNS\n    HierarchicalMNS\n    MigrateFromEBToHMNS\n</code></pre> <p>In this part of the tutorial we will take a closer look at <code>HierarchicalMNS</code>, which is the standard hierarchical module naming scheme included with EasyBuild.</p> <p>We will also take a quick look at implementing our own custom module naming scheme.</p>"},{"location":"2021-isc21/module_naming_schemes/#flat-vs-hierarchical","title":"Flat vs hierarchical","text":"<p>The default module naming scheme <code>EasyBuildMNS</code> is an example of regular \"flat\" module naming scheme, which is characterized by:</p> <ul> <li>all module files are directly available for loading;</li> <li>each module name uniquely identifies a particular installation;</li> </ul> <p>In contrast, a hierarchical module naming scheme consists of a hierarchy of module files.</p> <p>The typical module hierarchy has 3 levels:</p> <ul> <li>a core level, where module files for software that was installed using the   <code>system</code> toolchain are kept;</li> <li>a compiler level, where module files for software that was installed using a compiler-only toolchain are stored;</li> <li>and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component;</li> </ul> <p>Here is a simple example of such a 3-level module hierarchy:</p> <p>In this example the core level only includes a single module <code>GCC/9.3.0</code>, while  the compiler level includes two modules: <code>OpenMPI/4.0.3</code> and <code>MPICH/3.3.2</code>. In the MPI level, three modules are available: one for <code>FFTW</code>, one for <code>ScaLAPACK</code>, and one for <code>HDF5</code>.</p> <p>Initially only the modules on the top level of a module hierarchy are available for loading. If you run \"<code>module avail</code>\" with the example module hierarchy, you will only see the <code>GCC/9.3.0</code> module.</p> <p>Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the <code>GCC/9.3.0</code> module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for <code>OpenMPI</code> and <code>MPICH</code>. These correspond to installations of <code>OpenMPI</code> and <code>MPICH</code> that were built using <code>GCC/9.3.0</code> as a (compiler-only) toolchain.</p> <p>Similarly, the <code>OpenMPI/4.0.3</code> module serves as a gateway to the three modules in the MPI level. Only by loading the <code>OpenMPI</code> module will these additional three modules become available for loading. They correspond to software installations built using the <code>gompi/2020a</code> toolchain that consists of the <code>GCC/9.3.0</code> compiler module and the <code>OpenMPI/4.0.3</code> MPI module. Software installed using <code>foss/2020a</code> (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy.</p> <p>The characteristics of a module hierarchy are:</p> <ul> <li>not all module files are directly available for loading;</li> <li>some modules serve as a gateway to more modules;</li> <li>to access some software installations you will first need to load one or more gateway modules in order   to use them;</li> </ul> <p>You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.</p>"},{"location":"2021-isc21/module_naming_schemes/#pros-cons","title":"Pros &amp; cons","text":"<p>So why go through all this trouble of organizing modules hierarchically?</p> <p>There are a couple of advantages to this approach:</p> <ul> <li>shorter module names;</li> <li>less overwhelming list of available modules;</li> <li>only compatible modules can be loaded together;</li> </ul> <p>However, the are some minor disadvantages too:</p> <ul> <li>not all existing modules are directly visible;</li> <li>gateway modules may have little meaning to end users;</li> </ul>"},{"location":"2021-isc21/module_naming_schemes/#length-of-module-names","title":"Length of module names","text":"<p>When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our <code>HDF5</code> installation for example, we have <code>HDF5/1.10.6-gompi-2020a</code> as module name. The <code>-gompi-2020a</code> part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!).</p> <p>In the example module hierarchy shown above, the module for <code>HDF5</code> is named <code>HDF5/1.10.6</code> which is basically the bare essentials: software name and version. That's way better, nice and clean!</p>"},{"location":"2021-isc21/module_naming_schemes/#amount-of-available-modules","title":"Amount of available modules","text":"<p>The output of \"<code>module avail</code>\" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands...</p> <p>This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded.</p>"},{"location":"2021-isc21/module_naming_schemes/#loading-compatible-modules","title":"Loading compatible modules","text":"<p>Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other.</p> <p>Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful...</p> <p>In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily.</p>"},{"location":"2021-isc21/module_naming_schemes/#visibility-of-existing-modules","title":"Visibility of existing modules","text":"<p>One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \"<code>module avail</code>\" only shows a subset of all modules.</p> <p>Lmod has a solution for this though: it provides a separate \"<code>module spider</code>\" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \"<code>module spider</code>\" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.</p>"},{"location":"2021-isc21/module_naming_schemes/#semantics-of-gateway-modules","title":"Semantics of gateway modules","text":"<p>An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline...</p> <p>This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \"<code>module spider</code>\" command to navigate the module hierarchy.</p>"},{"location":"2021-isc21/module_naming_schemes/#using-a-custom-module-naming-scheme","title":"Using a custom module naming scheme","text":"<p>Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it.</p>"},{"location":"2021-isc21/module_naming_schemes/#implementation","title":"Implementation","text":"<p>To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general <code>ModuleNamingScheme</code> class.</p> <p>For a flat module naming scheme, it is sufficient to implement the <code>det_full_module_name</code> method, which should return a string value (the full module name). You may also need to customize the <code>is_short_modname_for</code> method, which verifies whether a given (short) module name is for the software with a particular given name (or not).</p> <p>The argument provided to <code>det_full_module_name</code> can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters (<code>name</code>, <code>version</code>, <code>toolchain</code>, and <code>versionsuffix</code>), or an <code>EasyConfig</code> instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters.</p> <p>For simple module naming schemes, just have <code>name</code>, <code>version</code>, <code>toolchain</code>, and <code>versionsuffix</code> available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant <code>REQUIRED_KEYS</code>.</p> <p>A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme <code>EasyBuildMNS</code>.</p> <p>For a hierarchical module naming scheme, various additional methods have to be implemented.</p> <p>Some of these, like <code>det_module_subdir</code> and <code>det_short_module_name</code>, determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like <code>det_modpath_extensions</code>, determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the <code>$MODULEPATH</code>).</p> <p>A typical example of a hierarchical module naming scheme is <code>HierarchicalMNS</code> that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional <code>Core</code>-<code>Compiler</code>-<code>MPI</code> module hierarchy we discussed above.</p>"},{"location":"2021-isc21/module_naming_schemes/#configuring-easybuild","title":"Configuring EasyBuild","text":"<p>To let EasyBuild use a custom module naming scheme, you need to:</p> <ul> <li> <p>specify the path to the Python module file implementing it via the <code>include-module-naming-schemes</code>   EasyBuild configuration option;</p> </li> <li> <p>indicate that you also want to use this custom module naming scheme via the <code>module-naming-scheme</code>   EasyBuild configuration option.</p> </li> </ul> <p>For example:</p> <pre><code>export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES=$HOME/easybuild/example_mns.py\nexport EASYBUILD_MODULE_NAMING_SCHEME=ExampleMNS\n</code></pre>"},{"location":"2021-isc21/module_naming_schemes/#example-custom-module-naming-scheme","title":"Example custom module naming scheme","text":"<p>Here is an example of a custom module naming scheme, where:</p> <ul> <li>the <code>versionsuffix</code> goes directly after the <code>version</code>;</li> <li>all dashes are replaced by underscores;</li> <li>all module names are lowercase;</li> </ul> <p>Note that we also need to customise the <code>is_short_modname_for</code> method, to make sure it returns <code>True</code> when the EasyBuild framework checks whether <code>scipy_bundle/2020.11_foss_2020b</code> is a module name for <code>SciPy-bundle</code>.</p> <pre><code>import os\n\nfrom easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme\n\n\nclass ExampleMNS(ModuleNamingScheme):\n\n    REQUIRED_KEYS = ['name', 'version', 'versionsuffix', 'toolchain']\n\n    def det_full_module_name(self, ec):\n\"\"\"\n        Determine full module name:\n        - all lowercase\n        - replace all dashes with underscores\n        \"\"\"\n        parts = [ec['version']]\n\n        # versionsuffix directly after version (but only if it's not empty)\n        if ec['versionsuffix']:\n            parts.append(ec['versionsuffix'])\n\n        # only add toolchain name/version for non-system toolchain\n        tc = ec['toolchain']\n        if tc['name'].lower() != 'system':\n            parts.extend([tc['name'], tc['version']])\n\n        modname = ec['name'] + '/' + '_'.join(parts)\n\n        modname = modname.replace('-', '_').replace('__', '_')\n\n        return modname.lower()\n\n    def is_short_modname_for(self, short_modname, name):\n\"\"\"Determine whether short module name is a module for the software with specified name.\"\"\"\n        return short_modname.startswith(name.lower().replace('-', '_') + '/')\n</code></pre> <p>We can see what the module names with this module naming scheme would like like via <code>eb -D</code>:</p> <pre><code>$ eb SciPy-bundle-2020.11-foss-2020b-Python-2.7.18.eb -D\n ...\n * [ ] $CFGS/g/GCC/GCC-10.2.0.eb (module: gcc/10.2.0)\n ...\n * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-10.2.0.eb (module: python/2.7.18_gcccore_10.2.0)\n ...\n * [ ] $CFGS/o/OpenMPI/OpenMPI-4.0.5-GCC-10.2.0.eb (module: openmpi/4.0.5_gcc_10.2.0)\n ...\n * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2020.03-foss-2020a-Python-2.7.18.eb (module: scipy_bundle/2020.03_python_2.7.18_foss_2020a)\n</code></pre>"},{"location":"2021-isc21/module_naming_schemes/#example-module-hierarchy-hdf5","title":"Example module hierarchy: HDF5","text":"<p>Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree.</p> <p>In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment.</p> <p>The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.</p>"},{"location":"2021-isc21/module_naming_schemes/#preparing-the-environment","title":"Preparing the environment","text":"<p>Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment.</p> <p>We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme!</p> <p>Some module files will have the same name in both module trees (like <code>GCC/10.2.0</code> for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems...</p> <p>So we have to make sure that the module files we already have in <code>/easybuild</code> are not visible. The easiest way to do this is to unload all modules (using \"<code>module purge</code>\") and resetting the module search path to be empty, which we can do with \"<code>module unuse $MODULEPATH</code>\".</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> <p>In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue.</p> <p>We strongly recommend using an EasyBuild installation that was installed via \"<code>pip install</code>\" or \"<code>pip3 install</code>\" in this part of the tutorial.</p> <p>An easy way to do this is in the prepared environment is to run:</p> <pre><code>unset PIP_PREFIX\npip3 install --user easybuild\nexport PATH=$HOME/.local/bin:$PATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2021-isc21/module_naming_schemes/#configuring-easybuild_1","title":"Configuring EasyBuild","text":"<p>First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_INSTALLPATH_SOFTWARE=/easybuild/software\nexport EASYBUILD_MODULE_NAMING_SCHEME=HierarchicalMNS\nexport EASYBUILD_INSTALLPATH_MODULES=$HOME/hmns/modules\n</code></pre> <p>To make sure we didn't make any silly mistakes, we double check using <code>eb --show-config</code>:</p> <pre><code>$ eb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath            (E) = /tmp/example\ncontainerpath        (E) = /home/example/easybuild/containers\ninstallpath          (E) = /home/example/easybuild\ninstallpath-modules  (E) = /home/example/hmns/modules\ninstallpath-software (E) = /easybuild/software\nmodule-naming-scheme (E) = HierarchicalMNS\npackagepath          (E) = /home/example/easybuild/packages\nprefix               (E) = /home/example/easybuild\nrepositorypath       (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths          (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath           (E) = /home/example/easybuild/sources\n</code></pre> <p>There are a couple of things worth pointing out here:</p> <ul> <li>We have defined the <code>module-naming-scheme</code> configuration setting to <code>HierarchicalMNS</code>,   which makes EasyBuild use the included standard hierarchical module naming scheme (the classic   core / compiler / MPI one we discussed above).</li> <li>We have specified different locations for the software (via <code>installpath-software</code>)   and the module files (via <code>installpath-modules</code>). This is important because we want to   reuse the software that is already installed in <code>/easybuild/software</code> while we want to   generate an entirely new module tree for it (in <code>$HOME/hmns/modules</code>).</li> </ul> <p>The other configuration settings are the same as before, and mostly irrelevant for this example.</p>"},{"location":"2021-isc21/module_naming_schemes/#generating-modules-for-hdf5","title":"Generating modules for HDF5","text":"<p>Let's now generate a hierarchical module tree for <code>HDF5</code> and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us.</p> <p>The steps we will have to go through are:</p> <ul> <li>Tell EasyBuild we want to \"install\" the <code>HDF5-1.10.7-gompi-2020b.eb</code> easyconfig file;</li> <li>Enable dependency resolution via <code>--robot</code>;</li> <li>Instruct EasyBuild to only generate the module files, not to install the software (since it is   there already in <code>/easybuild/software</code>), via the <code>--module-only</code> option.</li> </ul> <p>These steps translate to this single <code>eb</code> command:</p> <pre><code>$ eb HDF5-1.10.7-gompi-2020b.eb --robot --module-only\n...\n== building and installing MPI/GCC/10.2.0/OpenMPI/4.0.5/HDF5/1.10.7...\n...\n== sanity checking...\n== cleaning up [skipped]\n== creating module...\n...\n== COMPLETED: Installation ended successfully (took 9 sec)\n...\n== Build succeeded for 41 out of 41\n</code></pre> <p>This should take a couple of minutes in total, for generating 41 modules. Remember that this also includes generating module files for the toolchain and all of its components.</p> <p>In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using <code>--module-only</code> to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...</p>"},{"location":"2021-isc21/module_naming_schemes/#loading-the-hdf5-module","title":"Loading the HDF5 module","text":"<p>After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it?</p> <p>Here's what the module tree looks like on disk:</p> <pre><code>$ ls $HOME/hmns/modules/all\nCompiler  Core  MPI\n</code></pre> <p>Those are basically the 3 levels in the module hierarchy we showed in our example earlier.</p> <p>The starting point is the top level of the module hierarchy named <code>Core</code>:</p> <pre><code>module use $HOME/hmns/modules/all/Core\n</code></pre> <p>Let's see what that gives us in terms of available modules:</p> <pre><code>$ module avail\n\n--------------------- /home/easybuild/hmns/modules/all/Core ---------------------\n   Bison/3.5.3        GCCcore/10.2.0    flex/2.6.4      help2man/1.47.4\n   Bison/3.7.1 (D)    M4/1.4.18         gettext/0.21    ncurses/6.2\n   GCC/10.2.0         binutils/2.35     gompi/2020b     zlib/1.2.11\n</code></pre> <p>Nice and short module names, but only a limited set of them.</p> <p>We know a module file exists for <code>HDF5</code>, but we can't see it yet (and hence we can't load it either).</p> <pre><code>$ module avail HDF5\nNo module(s) or extension(s) found!\nUse \"module spider\" to find all possible modules and extensions.\n</code></pre> <p>Let's see if <code>module spider</code> is of any help, as \"<code>module avail</code>\" so kindly suggests:</p> <pre><code>$ module spider HDF5\n...\n\n    You will need to load all module(s) on any one of the lines below\n    before the \"HDF5/1.10.7\" module is available to load.\n\n      GCC/10.2.0  OpenMPI/4.0.5\n</code></pre> <p>This tells us we need to load two gateway modules before we can load the module for HDF5.</p> <p>Let's start with loading the <code>GCC</code> compiler module:</p> <pre><code>module load GCC/10.2.0\n</code></pre> <p>And then check again which modules are available:</p> <pre><code>$ module avail\n\n-------------- /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 --------------\n   OpenMPI/4.0.5\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/10.2.0 ------------\n   Autoconf/2.69             UCX/1.9.0                 libpciaccess/0.16\n   ...\n   Szip/2.1.1                libfabric/1.11.0          zlib/1.2.11        (L,D)\n   Autoconf/2.69         XZ/5.2.5                libtool/2.4.6\n\n--------------------- /home/easybuild/hmns/modules/all/Core ---------------------\n   Bison/3.5.3        GCCcore/10.2.0 (L)  flex/2.6.4      help2man/1.47.4\n   Bison/3.7.1 (D)    M4/1.4.18           gettext/0.21    ncurses/6.2\n   GCC/10.2.0  (L)    binutils/2.35       gompi/2020b     zlib/1.2.11\n</code></pre> <p>Good news, we now have additional modules available!</p> <p>The compiler level of our hierarchy actually consists of two directories here: <code>Compiler/GCCcore/10.2.0</code> and <code>Compiler/GCC/10.2.0</code>. The modules in the <code>GCCcore</code> directory are ones we can use in other compiler toolchains that use GCC 10.2.0 as a base compiler (the details of that are out of scope here).</p> <p>The module we are interested in is <code>OpenMPI/4.0.5</code>, which is another gateway module.</p> <p>Remember that the \"<code>module spider</code>\" output told us that there does indeed exist a module for <code>HDF5</code>, but that we need to load both the <code>GCC/10.2.0</code> and <code>OpenMPI/4.0.5</code> modules first.</p> <p>So, let us do exactly that (remember that <code>GCC/10.2.0</code> is already loaded):</p> <pre><code>module load OpenMPI/4.0.5\n</code></pre> <p>If you now check the output of \"<code>module avail</code>\" again, you should see the <code>HDF5/1.10.7</code> module:</p> <pre><code>$ module avail\n\n-------- /home/easybuild/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 -------\n   HDF5/1.10.7\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 ------------\n   OpenMPI/4.0.5 (L)\n\n...\n</code></pre> <p>To use HDF5, we need to load this <code>HDF5/1.10.7</code> module. We can verify that the installation works using one of the commands provided by HDF5, <code>h5dump</code> for example:</p> <pre><code>module load HDF5/1.10.7\n</code></pre> <pre><code>$ h5dump --version\nh5dump: Version 1.10.7\n</code></pre> <p>If you now check which modules are loaded via \"<code>module list</code>\", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree:</p> <pre><code>$ module list\n\nCurrently Loaded Modules:\n  1) GCCcore/10.2.0   5) numactl/2.0.13      9) hwloc/2.2.0       13) PMIx/3.1.5\n  2) zlib/1.2.11      6) XZ/5.2.5           10) libevent/2.1.12   14) OpenMPI/4.0.5\n  3) binutils/2.35    7) libxml2/2.9.10     11) UCX/1.9.0         15) Szip/2.1.1\n  4) GCC/10.2.0       8) libpciaccess/0.16  12) libfabric/1.11.0  16) HDF5/1.10.7\n</code></pre>"},{"location":"2021-isc21/module_naming_schemes/#exercise","title":"Exercise","text":"<p>Now it is your turn!</p> <p>Try to get a feeling for how a hierarchical module tree works by:</p> <ul> <li>installing the missing modules for the <code>SciPy-bundle-2020.11-foss-2020b.eb</code> in the module hierarchy we   generated for HDF5;</li> <li>figure out where the <code>SciPy-bundle</code> module is located in the hierarchy, and then also load it;</li> </ul> <p>You can verify your work by running this command (since <code>pandas</code> is one of the Python packages included in the <code>SciPy-bundle</code> installation):</p> <pre><code>python -c 'import pandas; print(pandas.__version__)'\n</code></pre> <p>Start from a clean slate, by first running:</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> (click to show solution) <ul> <li> <p>Step 0: check which modules are still missing, using <code>--missing</code> or <code>-M</code>:   <pre><code>eb SciPy-bundle-2020.11-foss-2020b.eb -M\n</code></pre>   The output should tell you that 15 out of 50 required modules are still missing.</p> </li> <li> <p>Install the missing modules in the module hierarchy we have generated in <code>$HOME/hmns/modules</code>:   <pre><code>eb SciPy-bundle-2020.11-foss-2020b.eb --robot --module-only\n</code></pre>   Don't forget to use both <code>--robot</code> (to enable dependency resolution) and <code>--module-only</code>   (to only run the sanity check and generate module files, not install the software again).</p> </li> <li> <p>Start at the top of the module hierarchy (the <code>Core</code> level),   and run module spider to check which gateway modules to load to make <code>SciPy-bundle</code> available:   <pre><code>module use $HOME/hmns/modules/all/Core\nmodule spider SciPy-bundle/2020.11\n</code></pre></p> </li> <li>Load the gateway modules:   <pre><code>module load GCC/10.2.0 OpenMPI/4.0.5\n</code></pre></li> <li>Check that the <code>SciPy-bundle</code> module is available, and load it:   <pre><code>$ module avail SciPy-bundle\n----- /home/example/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------\n   SciPy-bundle/2020.11\n</code></pre> <pre><code>module load SciPy-bundle/2020.11\n</code></pre></li> <li>Run the test command:   <pre><code>$ python -c 'import pandas; print(pandas.__version__)'\n1.1.4\n</code></pre></li> </ul> <p>next: Adding support for additional software - (back to overview page)</p>"},{"location":"2021-isc21/practical_info/","title":"Practical info for the ISC'21 EasyBuild tutorial","text":"<p>This page explains how you can prepare for the EasyBuild tutorial that takes place at ISC'21 (registration required!).</p>"},{"location":"2021-isc21/practical_info/#prepared-environment","title":"Prepared environment","text":"<p>Tutorial attendees will be able to log in to a prepared environment where they can follow along with hands-on examples, or solve the tutorial exercises.</p> <p>You can create an account for the prepared environment by filling out the account form. The accounts will not be approved until the day before the event, so  please remember to keep a record of your username and password.</p> <p>Once the account is approved, you will be able to access the system at https://isc21.learnhpc.eu/, or via <code>ssh</code>:</p> <pre><code>ssh isc21.learnhpc.eu\n</code></pre>"},{"location":"2021-isc21/practical_info/#slack","title":"Slack","text":"<p>We strongly recommend joining the #tutorial-isc21 channel in the EasyBuild Slack.</p> <p>In this channel, you can:</p> <ul> <li>raise questions both during the live tutorial session, and afterwards;</li> <li>get help with following the hands-on examples or solving the exercises;</li> </ul> <p>The <code>#tutorial-isc21</code> channel will remain available after the live tutorial session.</p> <p>You can self-request an invitation to join the EasyBuild Slack via https://easybuild.io/join-slack.</p> <p>next: Introduction - (back to overview page)</p>"},{"location":"2021-isc21/terminology/","title":"EasyBuild terminology","text":"<p>Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software.</p> <p>It is important to be familiar with these terms, so we'll briefly cover them one by one.</p>"},{"location":"2021-isc21/terminology/#framework","title":"Framework","text":"<p>The EasyBuild framework consists of a set of Python modules organised in packages (<code>easybuild.framework</code>, <code>easybuild.toolchains</code>, <code>easybuild.tools</code>, etc.) that collectively form the core of EasyBuild, and is developed in the <code>easybuild-framework</code> repository on GitHub.</p> <p>It implements the common functionality that you need when building software from source, providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc.</p> <p>The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this.</p>"},{"location":"2021-isc21/terminology/#easyblocks","title":"Easyblocks","text":"<p>An easyblock is a Python module that implements a specific software installation procedure, and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific.</p> <p>A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the <code>ConfigureMake</code> easyblock which implements the ubiquitous <code>configure</code>-<code>make</code>-<code>make install</code> procedure, and the <code>PythonPackage</code> easyblock that can be used to install a Python package.</p> <p>A software-specific easyblock implements an installation procedure that is specific to a particular software package. Infamous examples include the easyblocks we have for <code>GCC</code>, <code>OpenFOAM</code>, <code>TensorFlow</code>, <code>WRF</code>, ...</p> <p>The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file.</p> <p>A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the <code>easybuild-easyblocks</code> repository on GitHub.</p>"},{"location":"2021-isc21/terminology/#easyconfig-parameters","title":"Easyconfig parameters","text":"<p>An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild.</p> <p>Some easyconfig parameters are mandatory. The following parameters must be defined in every easyconfig file:</p> <ul> <li><code>name</code> and <code>version</code>, which specify the name and version of the software to install;</li> <li><code>homepage</code> and <code>description</code>, which provide key metadata for the software;</li> <li><code>toolchain</code>, which specifies the compiler toolchain to use to install the software (see   <code>toolchains</code> section);</li> </ul> <p>Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock.</p> <p>Some commonly used optional easyconfig parameters include:</p> <ul> <li><code>easyblock</code>, which specifies which (generic) easyblock should be used for the installation;</li> <li><code>sources</code> and <code>source_urls</code>, which specify the list of source files and where to download them;</li> <li><code>dependencies</code> and <code>builddependencies</code>, which specify the list of (build) dependencies;</li> <li><code>configopts</code>, <code>buildopts</code>, and <code>installopts</code>, which specify options for the configuration/build/install commands, respectively;</li> </ul> <p>If no value is specified for an optional easyconfig parameter, the corresponding default value will be used.</p> <p>There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software.</p>"},{"location":"2021-isc21/terminology/#easyconfig-files","title":"Easyconfig files","text":"<p>Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install. Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation.</p> <p>The filename of an easyconfig file usually ends with the <code>.eb</code> extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: <code>name</code>, <code>version</code>, <code>toolchain</code> and <code>versionsuffix</code>. The general format for the filename of an easyconfig file is: <code>&lt;name&gt;-&lt;version&gt;&lt;toolchain&gt;&lt;versionsuffix&gt;.eb</code>, where the toolchain part is omitted when a <code>system</code> toolchain is used, and the <code>&lt;versionsuffix&gt;</code> can be empty.</p> <p>The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive.</p> <p>In the <code>easybuild-easyconfigs</code> repository on GitHub, the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software.</p>"},{"location":"2021-isc21/terminology/#easystack-files","title":"Easystack files","text":"<p>Easystack files are a new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild.</p> <p>They are written in YAML syntax, and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels.</p> <p>The support for using easystack files is currently marked as experimental, which means it is subject to change in future EasyBuild releases, and may be prone to errors.</p>"},{"location":"2021-isc21/terminology/#extensions","title":"Extensions","text":"<p>Extensions is the collective term we use for additional software packages that can be installed on top of another software package. Common examples are Python packages, R libraries, and Perl modules.</p> <p>As you can tell the common terminology here is a bit messy, so we came up with a unifying term...</p> <p>Extensions can be installed in different ways:</p> <ul> <li>stand-alone, as a separate installation on top of one or more other installations;</li> <li>as a part of a bundle of extensions that collectively form a separate installation;</li> <li>or as an actual extension to a specific installation to yield a \"batteries included\"   type of installation (for examples by adding a bunch of Python packages from PyPI into   a Python installation);</li> </ul>"},{"location":"2021-isc21/terminology/#dependencies","title":"Dependencies","text":"<p>A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features).</p> <p>There are three main types of dependencies for computer software:</p> <ul> <li>a build dependency is only required when building/installing a software package;   once the software package is installed, it is no longer needed to use that software   (examples: <code>CMake</code>, <code>pkg-config</code>);</li> <li>a run-time dependency (often referred to simply as dependency) is a software package that is   required to use (or run) another software package (example: <code>Python</code>);</li> <li>a link-time dependency is somewhere in between a build and runtime dependency:   it is only needed when linking a software package; it can become either a build or runtime   dependency, depending on exactly how the software is installed (example: <code>OpenBLAS</code>);</li> </ul> <p>The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies.</p>"},{"location":"2021-isc21/terminology/#toolchains","title":"Toolchains","text":"<p>A compiler toolchain (or just toolchain for short) is a set of compilers, which are used to build software from source, together with a set of additional libraries that provide further core functionality.</p> <p>We refer to the different parts of a toolchain as toolchain components.</p> <p>The compiler component typically consists of C, C++, and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included.</p> <p>Additional toolchain components are usually special-purpose libraries:</p> <ul> <li>an MPI library to support distributed computations (for example, Open MPI);</li> <li>libraries providing efficient linear algebra routines (BLAS,   LAPACK);</li> <li>a library supporting computing Fast Fourier Transformations (for example, FFTW);</li> </ul> <p>A toolchain that includes all of these libraries is referred to as a full toolchain, while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).</p>"},{"location":"2021-isc21/terminology/#system-toolchain","title":"System toolchain","text":"<p>The <code>system</code> toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system, rather than using toolchain components that were installed using EasyBuild.</p> <p>It is used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.</p>"},{"location":"2021-isc21/terminology/#common-toolchains","title":"Common toolchains","text":"<p>The <code>foss</code> and <code>intel</code> toolchains are also known as the common toolchains, because they are widely adopted by the EasyBuild community.</p> <p>The <code>foss</code> toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free &amp; Open Source Software): GCC, Open MPI, OpenBLAS, ScaLAPACK and FFTW.</p> <p>The <code>intel</code> toolchain consists of the Intel C, C++ and Fortran compilers (on top of a <code>GCC</code> version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries.</p> <p>Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing.</p> <p>More information on these toolchains is available in the EasyBuild documentation.</p>"},{"location":"2021-isc21/terminology/#modules","title":"Modules","text":"<p>Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file).</p> <p>Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell-agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state.</p> <p>Environment module files are processed via a modules tool, of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod, a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones.</p> <p>Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.</p>"},{"location":"2021-isc21/terminology/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions, using a particular compiler toolchain, as specified in easyconfig files which each define a set of easyconfig parameters.</p> <p>EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.</p> <p>An easystack file can be used to specify a collection of software to install with EasyBuild.</p> <p>next: Installation - (back to overview page)</p>"},{"location":"2021-isc21/troubleshooting/","title":"Troubleshooting","text":"<p>When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild...</p> <p>In this part we take a look at how you can troubleshoot a failing installation, and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild, the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed.</p> <p>At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!</p>"},{"location":"2021-isc21/troubleshooting/#easybuild-error-messages","title":"EasyBuild error messages","text":"<p>When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message.</p> <p>Things that could go wrong during an installation include:</p> <ul> <li>missing source or patch files;</li> <li>a checksum error on a downloaded source or patch file;</li> <li>required dependencies that are not specified in the easyconfig file;</li> <li>failing shell commands;</li> <li>running out of available memory or disk space;</li> <li>a segmentation fault caused by a flipped bit triggered by a cosmic ray (really, it happens!);</li> </ul> <p>Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation...</p> <p>For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure.</p> <p>If the exit status of the shell command is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted.</p>"},{"location":"2021-isc21/troubleshooting/#example","title":"Example","text":"<p>Here is an example of an EasyBuild error message (slightly reformatted for clarity):</p> <pre><code>$ eb example.eb\n...\n== building...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0):\nbuild failed (first 300 chars): cmd \"make\" exited with exit code 2 and output:\n/usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp\ng++: error: unrecognized command line option '-std=c++14' (took 1 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log\nERROR: Build of /home/easybuild/subread.eb failed (err: ...)\n</code></pre> <p>Let's break this down a bit: during the <code>build</code> step of the installation procedure EasyBuild was running <code>make</code> as a shell command, which failed (exit code 2, so not zero). The <code>make</code> command tripped over the compilation of <code>core.cpp</code> that failed because <code>-std=c++14</code> is not a known option to the <code>g++</code> command.</p> <p>OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is <code>make</code> using <code>/usr/bin/g++</code> for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under <code>/easybuild/software</code>.</p> <p>Let's see what <code>/usr/bin/g++</code> is:</p> <pre><code>$ /usr/bin/g++ --version\ng++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)\n</code></pre> <p>Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet...</p> <p>Your next step in this case should probably be figuring out why <code>/usr/bin/g++</code> is being used rather than just <code>g++</code>, which would result in using the right compiler version because EasyBuild sets up the build environment carefully.</p> <p>This is a imaginary example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.</p>"},{"location":"2021-isc21/troubleshooting/#easybuild-log-files","title":"EasyBuild log files","text":"<p>Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward...</p> <p>EasyBuild includes (only) the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed.</p> <p>In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes.</p> <p>In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session.</p> <p>See for example this output line from our earlier example error message:</p> <pre><code>== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log\n</code></pre> <p>You can open this file with your favorite text editor or a tool like <code>less</code> to take a look at the information collected in the log file, which includes things like:</p> <ul> <li>informative messages produced by both the EasyBuild framework and the easyblock   describing how the installation is progressing;</li> <li>how the build environment was set up: which modules were loaded, which environment variables were set;</li> <li>the exact shell commands that were executed, and in which directory they were run;</li> <li>the full output produced by these commands, and their exit code;</li> </ul> <p>Note that the installation log is also copied into each software installation directory for successful installation, into the <code>easybuild</code> subdirectory. For example:</p> <pre><code>/easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210616.055237.log\n</code></pre>"},{"location":"2021-isc21/troubleshooting/#last-log","title":"Last log","text":"<p>The <code>eb</code> command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor:</p> <pre><code>vim $(eb --last-log)\n</code></pre>"},{"location":"2021-isc21/troubleshooting/#navigating-log-files","title":"Navigating log files","text":"<p>Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors:</p> <ul> <li><code>ERROR</code></li> <li><code>Error 1</code></li> <li><code>error:</code></li> <li><code>failure</code></li> <li><code>not found</code></li> <li><code>No such file or directory</code></li> <li><code>bazel</code></li> <li><code>Segmentation fault</code></li> </ul> <p>Using \"<code>error</code>\" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an <code>error.c</code> file), and you will miss others that do include errors but mention <code>ERROR</code> or <code>Error</code> rather than <code>error</code>.</p> <p>When using <code>less</code> to view a log file, you can navigate it by:</p> <ul> <li>hitting '<code>$</code>' followed by '<code>G</code>' to go to the end of the log file;</li> <li>using your arrow keys to scroll up/down;</li> <li>typing '<code>?</code>' followed by some text and Enter to search backwards for a particular pattern ('<code>/</code>' to search forwards, '<code>n</code>' for next match);</li> <li>hitting '<code>q</code>' to exit;</li> </ul> <p>It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these:</p> <pre><code>== 2020-06-13 01:34:48,816 example INFO configuring...\n== 2020-06-13 01:34:48,817 example INFO Starting configure step\n...\n== 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure\n</code></pre> <p>If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for <code>HDF5</code>):</p> <pre><code>== 2020-06-09 13:11:19,968 run.py:222 INFO running cmd:  make install\n== 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output:\nMaking install in src\nmake[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src'\n...\n</code></pre> <p>It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \"<code>INFO running cmd</code>\" as a search pattern, and then looking for patterns like \"<code>error:</code>\" from there.</p>"},{"location":"2021-isc21/troubleshooting/#inspecting-the-build-directory","title":"Inspecting the build directory","text":"<p>When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there.</p> <p>The location of the build directory is mentioned in the EasyBuild error message:</p> <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): ...\n</code></pre> <p>For software using a classic <code>configure</code> script, you may have to locate and inspect the <code>config.log</code> file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in <code>CMakeOutput.log</code> or <code>CMakeError.log</code> for clues, which are sneakily hidden by CMake in a <code>CMakeFiles</code> subdirectory of the build directory.</p> <p>As a side note here: as EasyBuild does not clean out build directories for failed builds, you will need to eventually manually remove them from the <code>buildpath</code> directory.</p>"},{"location":"2021-isc21/troubleshooting/#exercise","title":"Exercise","text":"<p>Let's work our way through a less smooth software installation, using the easyconfig file that is provided below.</p> <p>Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial.</p> <pre><code>easyblock = 'MakeCp'\n\nname = 'Subread'\nversion = '2.0.1'\n\nhomepage = 'http://subread.sourceforge.net'\ndescription = \"High performance read alignment, quantification and mutation discovery\"\n\ntoolchain = {'name': 'GCC', 'version': '8.5.0'}\n\n# download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\nchecksums = ['d808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b']\n\nstart_dir = 'src'\n\n# -fcommon is required to compile Subread 2.0.1 with GCC 10,\n# which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html)\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"'\n\nfiles_to_copy = ['bin']\n\nsanity_check_paths = {\n    'files': ['bin/featureCounts', 'bin/subread-align'],\n    'dirs': ['bin/utilities'],\n}\n\nsanity_check_commands = [\"featureCounts --version\"]\n\nmoduleclass = 'bio'\n</code></pre> <p>Do you spot any potential problems yet with this easyconfig file?</p> <p>Preparation</p> <p>Start by copying the text above in a file named <code>subread.eb</code>, so you can gradually fix the problem you'll encounter.</p> <p>Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself):</p> <pre><code>module use /easybuild/modules/all\nmodule load EasyBuild\n</code></pre> <p>For this exercise, make sure EasyBuild is configured to use <code>$HOME/easybuild</code> as <code>prefix</code>, and to use <code>/tmp/$USER</code> as <code>buildpath</code>:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Check your configuration via <code>eb --show-config</code>.</p> <p>Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions.</p> <p>Remember though: no peeking before you tried to solve each step yourself!</p> <p>Exercise T.1 - Sources</p> <p>Try to install the <code>subread.eb</code> easyconfig file, see what happens.</p> <p>Can you fix the problem you run into, perhaps without even changing the easyconfig file?</p> (click to show solution) <p>The installation fails because the source file <code>subread-2.0.1-source.tar.gz</code> is not found: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars):\nCouldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either...\nPaths attempted (in order): ...\n</code></pre></p> <p>In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: <pre><code># download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre></p> <p>We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the <code>sourcepath</code> directory): <pre><code>curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nmv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/\n</code></pre></p> <p>If downloading is problematic for some reason, the source tarball is also available in <code>/easybuild/sources/s/Subread</code>.</p> <p>Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: <pre><code>source_urls = ['https://download.sourceforge.net/subread/']\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre> Note that the <code>source_urls</code> value is a list of candidate download URLs, without the filename of the source file itself.</p> <p>This way, EasyBuild will download the source file when running <code>eb subread.eb</code>.</p> <p>The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while.</p> <pre><code>$ ls -lh $HOME/easybuild/sources/s/Subread\ntotal 23M\n-rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17:42 subread-2.0.1-source.tar.gz\n</code></pre> <p>Exercise T.2 - Toolchain</p> <p>After fixing the problem with missing source file, try the installation again.</p> <p>What's wrong now? How can you fix it quickly?</p> <p>Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here...</p> (click to show solution) <p>The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars):\nNo module found for toolchain: GCC/8.5.0 (took 1 sec)\n</code></pre></p> <p>We don't have this GCC version installed, but we do have GCC 10.2.0:</p> <pre><code>$ module avail GCC/\n----------------- /easybuild/modules/all ------------------\n   GCC/10.2.0\n</code></pre> <p>So let's try using that instead.</p> <p>Edit the easyconfig file so it contains this:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '10.2.0'}\n</code></pre> <p>Exercise T.3 - Build step</p> <p>With the first two problems fixed, now we can actually try to build the software.</p> <p>Can you fix the next problem you run into?</p> (click to show solution) <p>The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars):\ncmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output:\ngcc  -mtune=core2  -O3 -DMAKE_FOR_EXON  -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\"  -D_FILE_OFFSET_BITS=64    -fmessage-length=0  -ggdb  -fast -fcommon  -c -o core.o core.c\ngcc: error: unrecognized command line opti (took 1 sec)\n</code></pre></p> <p>If you open the log file and scroll to the end, the error is pretty obvious: <pre><code>gcc: error: unrecognized command line option -fast; did you mean -Ofast?\nmake: *** [core.o] Error 1\n</code></pre></p> <p>The easyconfig file hard specifies the <code>-fast</code> compiler flag via the <code>CFLAGS</code> argument to the build command: <pre><code># -fcommon is required to compile Subread 2.0.1 with GCC 10,\n# which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html)\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"'\n</code></pre></p> <p>EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the <code>buildopts</code> definition makes it clear that the <code>-fcommon</code> flag is required though, because GCC 10 became a bit stricter by using <code>-fno-common</code> by default. Note that we are using <code>-fcommon</code> as an escape mechanism here: it would be better to fix the source code and create a patch file instead.</p> <p>An easy way to fix this problem is to replace the <code>-fast</code> with <code>-Ofast</code>, as the compiler error suggests.</p> <p>In this case it is advised to change the <code>CFLAGS</code> argument that is added to be build command to replace the <code>-fast</code> with <code>$CFLAGS</code>, which is defined in the build environment by EasyBuild.</p> <pre><code>buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"'\n</code></pre> <p>Note that we need to be careful with quotes here: we use inner double quotes to ensure that <code>$CFLAGS</code> will be expanded to its value when the build command is run.</p> <p>Exercise T.4 - Sanity check</p> <p>After fixing the compilation issue, you're really close to getting the installation working, we promise!</p> <p>Don't give up now, try one last time and fix the last problem that occurs...</p> (click to show solution) <p>Now the installation itself works but the sanity check fails, and hence the module file does not get generated: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars):\nSanity check failed: sanity check command featureCounts --version exited with code 255\n(output: featureCounts: unrecognized option '--version'\n...\n</code></pre></p> <p>If you look at the full output in the log file you can see that the correct option to check the version of the <code>featureCounts</code> command is \"<code>-v</code>\" rather than \"<code>--version</code>\", so we need to fix this in the easyconfig file.</p> <p>Make the following change in the easyconfig file: <pre><code>sanity_check_commands = [\"featureCounts -v\"]\n</code></pre></p> <p>After doing so, you don't have to redo the installation from scratch, you can use the <code>--module-only</code> option to only run the sanity check and generate the module file again: <pre><code>eb subread.eb --module-only\n</code></pre></p> <p>In the end, you should be able to install Subread 2.0.1 with the GCC 10.2.0 toolchain by fixing the problems with the <code>subread.eb</code> easyconfig file.</p> <p>Check your work by manually loading the module and checking the version via the <code>featureCounts</code> command, which should look like this:</p> <pre><code>$ featureCounts -v\nfeatureCounts v2.0.1\n</code></pre> <p>next: Module naming schemes - (back to overview page)</p>"},{"location":"2021-lust/","title":"EasyBuild tutorial for LUST","text":"<p>Overview page of the introductory tutorial on EasyBuild for the LUMI User Support team (LUST).</p> <ul> <li>Part I: Introduction to EasyBuild (Tue March 9th 2021, 9am-12 CET)<ul> <li>What is EasyBuild?</li> <li>Terminology</li> <li>Installation (hands-on)</li> <li>Configuration (hands-on)</li> <li>Basic usage (hands-on)</li> </ul> </li> <li>Part II: Using EasyBuild (Tue March 23rd 2021, 9am-12 CET)<ul> <li>Troubleshooting (hands-on)</li> <li>Creating easyconfig files (hands-on)</li> <li>Implementing easyblocks (hands-on)</li> </ul> </li> <li>Part III: Advanced topics (Tue March 30th 2021, 9am-12 CEST)<ul> <li>Using EasyBuild as a library (hands-on)</li> <li>Using hooks to customise EasyBuild (hands-on)</li> <li>Submitting installations as Slurm jobs (hands-on)</li> <li>Module naming schemes (incl. hierarchical) (hands-on)</li> <li>GitHub integration to facilitate contributing to EasyBuild (hands-on)</li> </ul> </li> <li>Part IV: EasyBuild on Cray systems (Friday June 18th 2021, 09-12 CEST)<ul> <li>Introduction to Cray Programming Environment (hands-on)</li> <li>Cray External Modules (hands-on)</li> <li>Cray Custom Toolchains (hands-on)</li> <li>EasyBuild at CSCS (hands-on)</li> </ul> </li> </ul>"},{"location":"2021-lust/basic_usage/","title":"Basic usage","text":"<p>[back: Configuring EasyBuild]</p> <p>Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words.</p> <p>We will look at the high-level workflow first, and then cover each aspect in more detail.</p> <p>A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!</p>"},{"location":"2021-lust/basic_usage/#overall-workflow","title":"Overall workflow","text":"<p>Installing software with EasyBuild is as easy as specifying to the <code>eb</code> command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer).</p> <p>This is typically done by specifying the name of one or more easyconfig files, often combined with the <code>--robot</code> option to let EasyBuild also install missing dependencies.</p> <p>It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be.</p>"},{"location":"2021-lust/basic_usage/#specifying-easyconfigs","title":"Specifying easyconfigs","text":"<p>Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the <code>--software-name</code> option won't be covered in this tutorial, since they are not commonly used.</p> <p>Arguments passed to the <code>eb</code> command, being anything that is not an option (which starts with <code>-</code> or <code>--</code>) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be:</p> <ul> <li>the (absolute or relative) path to an easyconfig file;</li> <li>the name of an easyconfig file;</li> <li>the path to a directory containing easyconfig files;</li> </ul> <p>Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message:</p> <pre><code>$ eb /tmp/does_not_exist.eb\nERROR: Can't find path /tmp/does_not_exist.eb\n</code></pre> <p>When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory. If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path.</p> <p>If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with <code>.eb</code>, and (try to) use these as easyconfig files.</p>"},{"location":"2021-lust/basic_usage/#example-command","title":"Example command","text":"<p>Suppose we have the current situation in our home directory:</p> <ul> <li>two (easyconfig) files named <code>example1.eb</code> and <code>example2.eb</code>;</li> <li>a subdirectory named <code>some_deps</code>, which has two easyconfig files <code>dep1.eb</code> and <code>dep2.eb</code>   alongside a text file named <code>list.txt</code>;</li> <li>a subdirectory named <code>more_deps</code> located in the <code>some_deps</code> subdirectory,   which contains another easyconfig file <code>dep3.eb</code>;</li> </ul> <p>Or, visually represented:</p> <pre><code>example1.eb\nexample2.eb\nsome_deps/\n|-- dep1.eb\n|-- dep2.eb\n|-- list.txt\n|-- more_deps/\n    |-- dep3.eb\n</code></pre> <p>In this context, we run the following EasyBuild command from our home directory:</p> <pre><code>eb example1.eb bzip2-1.0.6.eb $HOME/example2.eb some_deps\n</code></pre> <p>EasyBuild will interpret each of these arguments as follows:</p> <ul> <li><code>example1.eb</code> is the name of a file in the current directory, so it can be used directly;</li> <li><code>bzip2-1.0.6.eb</code> is the name of an easyconfig file to locate via the robot search path   (since it does not exist in the current directory);</li> <li><code>$HOME/example2.eb</code> specifies the full path to an existing file, which can be used directly;</li> <li><code>some_deps</code> is the relative path to an existing directory, so EasyBuild will scan it and find three   easyconfig files: <code>some_deps/dep1.eb</code>, <code>some_deps/dep2.eb</code> and <code>some_deps/more_deps/dep3.eb</code>,   The <code>list.txt</code> file will be ignored since its name does not end with <code>.eb</code>.</li> </ul>"},{"location":"2021-lust/basic_usage/#easyconfig-filenames","title":"Easyconfig filenames","text":"<p>Note that the <code>eb</code> command does not care how easyconfig files are named, at least to some extent: the <code>.eb</code> file extension does matter when easyconfig files are being picked up in subdirectories.</p> <p>File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the <code>eb</code> command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here).</p> <p>This explains why easyconfig files usually adher to a very specific naming scheme, corresponding to <code>&lt;name&gt;-&lt;version&gt;-&lt;toolchain&gt;&lt;versionsuffix&gt;.eb</code>, where:</p> <ul> <li><code>&lt;name&gt;</code> represents the software name;</li> <li><code>&lt;version&gt;</code> represents the software version;</li> <li><code>&lt;toolchain&gt;</code> represents the toolchain used in the easyconfig file, which consists of the toolchain name   and version separated with a dash (<code>-</code>), and which is omitted (including the preceding <code>-</code>) when the   <code>system</code> toolchain is used;</li> <li><code>&lt;versionsuffix&gt;</code> represents the value of the <code>versionsuffix</code> easyconfig parameter,   which is sometimes used to distinguish multiple variants of particular software installations   (and is empty by default);</li> </ul>"},{"location":"2021-lust/basic_usage/#searching-for-easyconfigs","title":"Searching for easyconfigs","text":"<p>You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package.  This can be done by searching for easyconfigs using <code>eb --search</code> or <code>eb -S</code>.</p> <p>By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the <code>search-paths</code> configuration setting, or you can change the robot search path via either the <code>robot</code> or <code>robot-paths</code> configuration options.</p> <p>Both the <code>--search</code> and <code>-S</code> options trigger the same search operation, but yield different output: <code>eb --search</code> will print the full path to each easyconfig file that matches the specified search pattern, while <code>eb -S</code> produces a more concise output.</p> <p>For example, let's check which easyconfig files are available for OpenFOAM 8 with a <code>foss</code> toolchain:</p> <pre><code>$ eb --search openfoam-8-foss\n * /home/example/.local/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb\n * /home/example/.local/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb\n</code></pre> <p>The output is a bit more condensed when using <code>eb -S</code>:</p> <pre><code>$ eb -S openfoam-8-foss\nCFGS1=/home/example/.local/easybuild/easyconfigs/o/OpenFOAM\n * $CFGS1/OpenFOAM-8-foss-2020a.eb\n * $CFGS1/OpenFOAM-8-foss-2020b.eb\n</code></pre> <p>Note that the search is performed case-insensitive.</p> <p>The search pattern can include wildcards like <code>.*</code> and/or character groups like <code>[0-9]</code>, or other special characters like <code>^</code> or <code>$</code> to mark the start/end of the filename, but you need to be careful that <code>bash</code> does not expand these before the <code>eb</code> command is started, so it is recommended to wrap the search pattern in single quotes (<code>'...'</code>) when using wildcards.</p> <p>For example, to check which easyconfigs are available to install TensorFlow 2.4.1 with the <code>2020b</code> version of a toolchain:</p> <pre><code>$ eb -S '^tensorflow-2.4.1.*2020b'\nCFGS1=/home/example/.local/easybuild/easyconfigs/t/TensorFlow\n * $CFGS1/TensorFlow-2.4.1-foss-2020b.eb\n * $CFGS1/TensorFlow-2.4.1-fosscuda-2020b.eb\n</code></pre>"},{"location":"2021-lust/basic_usage/#search-index","title":"Search index","text":"<p>When searching for easyconfig files, you may see a message like this pop up:</p> <pre><code>== found valid index for &lt;path&gt;, so using it...\n</code></pre> <p>This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow.</p> <p>For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using <code>eb --create-index &lt;path&gt;</code>. See the EasyBuild documentation for more information.</p>"},{"location":"2021-lust/basic_usage/#inspecting-easyconfigs","title":"Inspecting easyconfigs","text":"<p>Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it.</p> <p>Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous <code>cat</code> command or your favorite text editor (<code>vim</code>, what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use <code>eb --show-ec</code>.</p> <p>For example, let's inspect the contents of the <code>bzip2-1.0.6.eb</code> easyconfig file:</p> <pre><code>$ eb --show-ec bzip2-1.0.6.eb\n== temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log\n== Contents of /home/example/.local/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb:\nname = 'bzip2'\nversion = '1.0.6'\n\nhomepage = 'https://sourceware.org/bzip2'\ndescription = \"\"\"bzip2 is a freely available, patent free, high-quality data compressor. It typically\ncompresses files to within 10% to 15% of the best available techniques (the PPM family of statistical\ncompressors), whilst being around twice as fast at compression and six times faster at decompression.\"\"\"\n\ntoolchain = SYSTEM\ntoolchainopts = {'pic': True}\n\nsource_urls = ['https://sourceware.org/pub/bzip2/']\nsources = [SOURCE_TAR_GZ]\npatches = ['bzip2-%(version)s-pkgconfig.patch']\nchecksums = [\n'a2848f34fcd5d6cf47def00461fcb528a0484d8edef8208d6d2e2909dc61d9cd',  # bzip2-1.0.6.tar.gz\n'5a823e820b332eca3684416894f58edc125ac3dace9f46e62f98e45362aa8a6d',  # bzip2-1.0.6-pkgconfig.patch\n]\n\nbuildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $(BIGFILES)'\"\n\n# building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...)\nwith_shared_libs = OS_TYPE == 'Linux'\n\nmoduleclass = 'tools'\n\n== Temporary log file(s) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed.\n== Temporary directory /tmp/eb-jnpzclhl has been removed.\n</code></pre> <p>We'll get back to what all of this means later...</p>"},{"location":"2021-lust/basic_usage/#checking-dependencies","title":"Checking dependencies","text":"<p>Note</p> <p>In some of the examples below, we assume that some software is already installed with EasyBuild.</p> <p>If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \"<code>module avail</code>\".</p> <p>Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing.</p> <p>This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like <code>$HOME/.local/easybuild</code>, the default installation path).</p>"},{"location":"2021-lust/basic_usage/#dry-run","title":"Dry run","text":"<p>To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use <code>eb --dry-run</code>.</p> <p>Since <code>--dry-run</code> produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: <code>eb --dry-run-short</code>, which is equivalent with <code>eb -D</code>.</p> <p>For example, to check which of the required dependencies for <code>SAMtools-1.11-GCC-10.2.0.eb</code> are already installed:</p> <pre><code>$ eb SAMtools-1.11-GCC-10.2.0.eb -D\n== temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\nDry run: printing build status of easyconfigs and dependencies\nCFGS=/home/example/.local/easybuild/easyconfigs\n ...\n * [x] $CFGS/b/bzip2/bzip2-1.0.8-GCCcore-10.2.0.eb (module: bzip2/1.0.8-GCCcore-10.2.0)\n* [x] $CFGS/x/XZ/XZ-5.2.5-GCCcore-10.2.0.eb (module: XZ/5.2.5-GCCcore-10.2.0)\n* [x] $CFGS/c/cURL/cURL-7.72.0-GCCcore-10.2.0.eb (module: cURL/7.72.0-GCCcore-10.2.0)\n* [x] $CFGS/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0)\n* [x] $CFGS/n/ncurses/ncurses-6.2-GCCcore-10.2.0.eb (module: ncurses/6.2-GCCcore-10.2.0)\n* [ ] $CFGS/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb (module: SAMtools/1.11-GCC-10.2.0)\n</code></pre> <p>(We've trimmed the output a bit here, for the sake of brevity.)</p> <p>This output tells us that all dependencies required by <code>SAMtools-1.11-GCC-10.2.0.eb</code> are already installed, since they are all marked with <code>[x]</code>, whereas the easyconfig for <code>SAMtools</code> itself is not installed yet, as indicated by lack of an <code>x</code> in <code>[ ]</code>.</p>"},{"location":"2021-lust/basic_usage/#missing-dependencies","title":"Missing dependencies","text":"<p>If you are only interested in which dependencies are still missing, you can consult the output of <code>eb --missing</code>, or the equivalent <code>eb -M</code>.</p> <p>For example, let's see which dependencies are missing in order to get version 3.1.0 of the h5py Python package installed using the <code>2020b</code> version of the <code>foss</code> toolchain:</p> <pre><code>$ eb h5py-3.1.0-foss-2020b.eb -M\n\n2 out of 61 required modules missing:\n\n* pkgconfig/1.5.1-GCCcore-10.2.0-python (pkgconfig-1.5.1-GCCcore-10.2.0-python.eb)\n* h5py/3.1.0-foss-2020b (h5py-3.1.0-foss-2020b.eb)\n</code></pre> <p>That should be pretty self-explanatory: out of the 63 required dependencies (which includes the <code>foss</code> toolchain and everything needed to install it), only 2 dependencies are missing. Great!</p>"},{"location":"2021-lust/basic_usage/#inspecting-install-procedures","title":"Inspecting install procedures","text":"<p>Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software.</p> <p>Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation.</p> <p>Using <code>eb --extended-dry-run</code>, or just <code>eb -x</code> for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild, in a matter of seconds.</p> <p>By means of example, let's inspect some parts of the installation procedure for <code>Boost-1.74.0-GCC-10.2.0.eb</code>:</p> <pre><code>$ eb Boost-1.74.0-GCC-10.2.0.eb -x\n...\n\npreparing... [DRY RUN]\n\n[prepare_step method]\nDefining build environment, based on toolchain (options) and specified dependencies...\n\nLoading toolchain module...\n\nmodule load GCC/10.2.0\n\nLoading modules for dependencies...\n\nmodule load bzip2/1.0.8-GCCcore-10.2.0\nmodule load zlib/1.2.11-GCCcore-10.2.0\nmodule load XZ/5.2.5-GCCcore-10.2.0\n\n...\n\nDefining build environment...\n\n  ...\n  export CXX='mpicxx'\nexport CXXFLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC'\n...\n\nconfiguring... [DRY RUN]\n\n[configure_step method]\nrunning command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.74.0/GCC-10.2.0/obj --without-libraries=python,mpi\"\n(in /tmp/example/build/Boost/1.74.0/GCC-10.2.0/Boost-1.74.0)\n\n...\n\n[sanity_check_step method]\nSanity check paths - file ['files']\n* lib/libboost_system.so\n  * lib/libboost_thread-mt-x64.so\nSanity check paths - (non-empty) directory ['dirs']\n* include/boost\nSanity check commands\n  (none)\n\n...\n</code></pre> <p>We've obviously trimmed the generated output a bit, but it should be sufficient.</p> <p>An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows:</p> <ul> <li>how the build environment will be set up during the <code>prepare</code> step, by loading the module for both the   toolchains and the dependencies, and defining a set of environment variables like <code>$CXX</code>, <code>$CXXFLAGS</code>, etc.</li> <li>which command will be executed during the configuration step, and in which directory;</li> <li>the list of files and directories that will be checked during the sanity check step;</li> </ul> <p>If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now.</p> <p>Note</p> <p>It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using <code>eb -x</code>, the reported installation procedure could be partially incorrect.</p> <p>In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by <code>eb -x</code> though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.</p>"},{"location":"2021-lust/basic_usage/#installing-software","title":"Installing software","text":"<p>You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require.</p> <p>As mentioned before, installing an easyconfig is as simple as passing it to the <code>eb</code> command.</p> <p>So, let's try to install SAMtools version 1.11:</p> <pre><code>$ eb SAMtools-1.11-GCC-10.2.0.eb\n== temporary log file in case of crash /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/.local/easybuild/easyconfigs/s/SAMtools/SAMtools-1.11-GCC-10.2.0.eb\n== building and installing SAMtools/1.11-GCC-10.2.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== building...\n== testing...\n== installing...\n== taking care of extensions...\n== restore after iterating...\n== postprocessing...\n== sanity checking...\n== cleaning up...\n== creating module...\n== permissions...\n== packaging...\n== COMPLETED: Installation ended successfully (took 17 sec)\n== Results of the build can be found in the log file(s) /home/example/easybuild/software/SAMtools/1.11-GCC-10.2.0/easybuild/easybuild-SAMtools-1.11-20210309.105601.log\n== Build succeeded for 1 out of 1\n== Temporary log file(s) /tmp/eb-zh7_fyre/easybuild-4q_lo57b.log* have been removed.\n== Temporary directory /tmp/eb-zh7_fyre has been removed.\n</code></pre> <p>That was... easy. Is that really all there is to it? Well, almost...</p>"},{"location":"2021-lust/basic_usage/#enabling-dependency-resolution","title":"Enabling dependency resolution","text":"<p>The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see above).</p> <p>If we try this with the <code>BCFtools-1.11-GCC-10.2.0.eb</code>, for which the required <code>GSL</code> and <code>HTSlib</code> dependencies are not available yet, it's less successful:</p> <pre><code>$ eb BCFtools-1.11-GCC-10.2.0.eb -M\n\n3 out of 23 required modules missing:\n\n* GSL/2.6-GCC-10.2.0 (GSL-2.6-GCC-10.2.0.eb)\n* HTSlib/1.11-GCC-10.2.0 (HTSlib-1.11-GCC-10.2.0.eb)\n* BCFtools/1.11-GCC-10.2.0 (BCFtools-1.11-GCC-10.2.0.eb)\n</code></pre> <pre><code>$ eb BCFtools-1.11-GCC-10.2.0.eb\n...\n== preparing...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/build/BCFtools/1.11/GCC-10.2.0): build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0 (took 2 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-3v1dfvnk/easybuild-BCFtools-1.11-20210308.195024.FlxkH.log\nERROR: Build of /home/example/.local/easybuild/easyconfigs/b/BCFtools/BCFtools-1.11-GCC-10.2.0.eb failed (err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0')\n</code></pre> <p>Oh my, what's this all about?</p> <p>If we filter the output a bit and focus on the actual error, the problem is clear:</p> <pre><code>Missing modules for dependencies (use --robot?): HTSlib/1.11-GCC-10.2.0, GSL/2.6-GCC-10.2.0\n</code></pre> <p>The required dependencies <code>HTSlib/1.11-GCC-10.2.0</code> and <code>GSL/2.6-GCC-10.2.0</code> are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so.</p> <p>It helpfully suggests to use the <code>--robot</code> command line option, so let's try that:</p> <pre><code>$ eb BCFtools-1.11-GCC-10.2.0.eb --robot\n...\n== resolving dependencies ...\n...\n== building and installing HTSlib/1.11-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 13 sec)\n...\n== building and installing GSL/2.6-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 1 min 10 sec)\n...\n== building and installing BCFtools/1.11-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 8 sec)\n...\n== Build succeeded for 3 out of 3\n</code></pre> <p>With dependency resolution enabled the <code>HTSlib</code> and <code>GSL</code> modules get installed first, before EasyBuild proceeds with installing <code>BCFtools</code>. Great!</p>"},{"location":"2021-lust/basic_usage/#trace-output","title":"Trace output","text":"<p>As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there?</p> <p>To provide some more feedback as the installation progresses, you can enable the \"<code>trace</code>\" configuration setting. Let's do this by defining the <code>$EASYBUILD_TRACE</code> environment variable, just to avoid having to type <code>--trace</code> over and over again.</p> <p>We will redo the installation of <code>BCFtools-1.11-GCC-10.2.0.eb</code> by passing the <code>--rebuild</code> option to the <code>eb</code> command (try yourself what happens if you don't use the <code>--rebuild</code> option!):</p> <pre><code>$ export EASYBUILD_TRACE=1\n$ eb BCFtools-1.11-GCC-10.2.0.eb --rebuild\n...\n== configuring...\n  &gt;&gt; running command:\n    [started at: 2021-03-08 19:54:53]\n[working dir: /tmp/example/build/BCFtools/1.11/GCC-10.2.0/bcftools-1.11]\n[output logged in /tmp/eb-9u_ac0nv/easybuild-run_cmd-17m_he2x.log]\n./configure --prefix=/home/example/easybuild/software/BCFtools/1.11-GCC-10.2.0  --build=x86_64-pc-linux-gnu  --host=x86_64-pc-linux-gnu --with-htslib=$EBROOTHTSLIB --enable-libgsl\n== building...\n  &gt;&gt; running command:\n    [started at: 2021-03-08 19:54:54]\n[working dir: /tmp/example/BCFtools/1.11/GCC-10.2.0/bcftools-1.11]\n[output logged in /tmp/example/eb-9u_ac0nv/easybuild-run_cmd-bhkgjxi7.log]\nmake -j 8\n&gt;&gt; command completed: exit 0, ran in 00h00m03s\n</code></pre> <p>That's a bit more comforting to stare at...</p> <p>During the configure step, the <code>./configure</code> command is run with option to enable support for leveraging <code>HTSlib</code> and <code>GSL</code>.</p> <p>During the build step, the software is actually being compiled by running the <code>make</code> command. EasyBuild automatically uses the available cores on the system (in this case 8).</p> <p>We even get a pointer to a log file that contains the output of the command being run, so we can use <code>tail -f</code> to see in detail how it progresses.</p> <p>Once the <code>make</code> command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know.</p> <p>Later during the installation, we now also see this output during the sanity check step:</p> <pre><code>== sanity checking...\n  &gt;&gt; file 'bin/bcftools' found: OK\n  &gt;&gt; file 'bin/plot-vcfstats' found: OK\n  &gt;&gt; file 'bin/vcfutils.pl' found: OK\n  &gt;&gt; (non-empty) directory 'libexec/bcftools' found: OK\n</code></pre> <p>Thanks to enabling trace mode, EasyBuild tells us which files &amp; directories it is checking for in the installation, before declaring it a success. Nice!</p> <p>The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.</p>"},{"location":"2021-lust/basic_usage/#using-installed-software","title":"Using installed software","text":"<p>So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice!</p> <p>A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation.</p> <p>That's great, but how do we now actually use these installations?</p> <p>This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous <code>module</code> command to digest them.</p> <p>First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of <code>eb --show-config</code>; the value of the <code>installpath</code> configuration setting is what we are interested in now:</p> <pre><code>$ eb --show-config\n...\ninstallpath    (E) = /home/example/easybuild\n...\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\n...\nsourcepath     (E) = /home/example/easybuild/sources\n...\n</code></pre> <p>So, what's in this directory?</p> <pre><code>$ ls -l $HOME/easybuild\ntotal 16\ndrwxrwxr-x 5 example example 4096 Jun 10 20:11 ebfiles_repo\ndrwxrwxr-x 5 example example 4096 Jun 10 20:10 modules\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 software\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 sources\n</code></pre> <p>The <code>ebfiles_repo</code> and <code>sources</code> directories correspond to the <code>repositorypath</code> and <code>sourcepath</code> configuration settings, respectively. The <code>modules</code> and <code>software</code> directories are what we need now.</p> <p>The <code>modules</code> subdirectory consists of multiple subdirectories:</p> <pre><code>$ ls $HOME/easybuild/modules\nall  bio  devel  numlib  tools\n</code></pre> <p>Directories like <code>bio</code> and <code>numlib</code> correspond to different software categories, and contain symbolic links to the module files in the <code>all</code> directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now.</p> <p>Let's inform the modules tool about the existence of these module files using <code>\"module use\"</code>:</p> <pre><code>module use $HOME/easybuild/modules/all\n</code></pre> <p>This command does little more that updating the <code>$MODULEPATH</code> environment variable, which contains a list of paths that the modules tool should consider when looking for module files.</p> <p>Now the modules tool should be aware of our brand new installations:</p> <pre><code>$ module avail\n\n---------------------- /home/example/easybuild/modules/all -----------------------\n   BCFtools/1.11-GCC-10.2.0    GSL/2.6-GCC-10.2.0       SAMtools/1.11-GCC-10.2.0\n   EasyBuild/4.3.3             HTSlib/1.11-GCC-10.2.0   bzip2/1.0.6\n\n---------------------------- /easybuild/modules/all -----------------------------\n    ...\n</code></pre> <p>This output shows both the modules for our own installations as well as the \"central\" installations in <code>/easybuild</code> (which we omitted above for brevity).</p> <p>Now we can load these modules and start using these software installations.</p> <p>Let's test this for BCFtools. In our current environment, the <code>bcftools</code> command is not available yet:</p> <pre><code>$ module list\nNo modules loaded\n\n$ bcftools\n-bash: bcftools: command not found\n</code></pre> <p>Loading the module for BCFtools changes that:</p> <pre><code>$ module load BCFtools/1.11-GCC-10.2.0\n\n$ module list\nCurrently Loaded Modules:\n  1) GCCcore/10.2.0                 6) XZ/5.2.5-GCCcore-10.2.0\n  2) zlib/1.2.11-GCCcore-10.2.0     7) cURL/7.72.0-GCCcore-10.2.0\n  3) binutils/2.35-GCCcore-10.2.0   8) HTSlib/1.11-GCC-10.2.0\n  4) GCC/10.2.0                     9) GSL/2.6-GCC-10.2.0\n  5) bzip2/1.0.8-GCCcore-10.2.0    10) BCFtools/1.11-GCC-10.2.0\n\n$ bcftools --version\nbcftools 1.11\nUsing htslib 1.11\n...\n</code></pre> <p>Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like <code>libstdc++.so</code>), are loaded automatically. The \"<code>module load</code>\" command changes the active environment, by updating environment variables like <code>$PATH</code> for example, to make the software available for use.</p>"},{"location":"2021-lust/basic_usage/#resetting-your-environment","title":"Resetting your environment","text":"<p>To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \"<code>module unload</code>\", or you can unload all of them at once using \"<code>module purge</code>\".</p> <p>If you are using an EasyBuild installation provided by a module, don't forget to load the <code>EasyBuild</code> module again after running \"<code>module purge</code>\".</p>"},{"location":"2021-lust/basic_usage/#stacking-software","title":"Stacking software","text":"<p>Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in <code>$HOME/easybuild</code>) on top of installations that are provided in a totally different location (<code>/easybuild</code>).</p> <p>EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required.</p> <p>This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).</p>"},{"location":"2021-lust/basic_usage/#exercises","title":"Exercises","text":"<p>Guidelines</p> <p>Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself!</p> <p>Please do not spoil solutions to others before they have been discussed by the tutorial organisers.</p> <p>The exercises are based on the easyconfig files included with EasyBuild 4.3.3.</p> <p>Exercise U.0 - Making installed software available</p> <p>Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available.</p> <p>We will assume that you have a small software stack installed using the <code>2020b</code> version of the <code>foss</code> toolchain.</p> <p>Tip: execute a \"<code>module use</code>\" command, and verify with \"<code>module avail</code>\" that a bunch of software modules are available for loading.</p> (click to show solution) <p>Use the following command to make the modules for the software available that is pre-installed in the prepared environment: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>If software is installed in a different location than <code>/easybuild/</code> in your environment, you should adjust the command accordingly.</p> <p>Exercise U.1 - Searching easyconfigs</p> <p>See if EasyBuild provides any easyconfig files for installing GROMACS version 2020/5.</p> (click to show solution) <p>To check for available easyconfig files, we can use <code>eb --search</code> or <code>eb -S</code>: <pre><code>$ eb -S gromacs-2020.5\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\nCFGS1=/home/example/.local/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb\n * $CFGS1/GROMACS-2020.5_fix_threads_gpu_Gmxapitests.patch\n</code></pre> This actually shows one easyconfig file but also a patch file. We can also search specifically for GROMACS 2020.5 in the <code>foss</code> and <code>fosscuda</code> toolchains using <pre><code>$ eb -S gromacs-2020.5-foss\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\nCFGS1=/home/example/.local/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2020.5-fosscuda-2020a-Python-3.8.2.eb\n</code></pre> and now we find a single easyconfig file.  </p> <p>Exercise U.2 - Checking dependencies</p> <p>Check which dependencies are missing to install QuantumESPRESSO version 6.6 with the <code>2020b</code> version of the <code>foss</code> toolchain.</p> (click to show solution) <p>First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: <pre><code>$ eb -S 'QuantumESPRESSO-6.6.*foss-2020b'\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\nCFGS1=/home/example/.local/easybuild/easyconfigs/q/QuantumESPRESSO\n * $CFGS1/QuantumESPRESSO-6.6-foss-2020b.eb\n</code></pre> To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use <code>--missing</code>: <pre><code>$ eb QuantumESPRESSO-6.6-foss-2020b.eb --missing\n\n3 out of 58 required modules missing:\n\n* libxc/4.3.4-GCC-10.2.0 (libxc-4.3.4-GCC-10.2.0.eb)\n* ELPA/2020.11.001-foss-2020b (ELPA-2020.11.001-foss-2020b.eb)\n* QuantumESPRESSO/6.6-foss-2020b (QuantumESPRESSO-6.6-foss-2020b.eb)\n</code></pre> (some nonessential output removed).</p> <p>Exercise U.3 - Performing a dry run</p> <p>Figure out which command EasyBuild would use to compile the software provided by the <code>Bowtie2-2.4.2-GCC-9.3.0.eb</code> easyconfig file, without actually installing <code>Bowtie2</code>.</p> <p>Also, which binaries will EasyBuild check for to sanity check the installation?</p> (click to show solution) <p>To inspect the installation procedure, we can use <code>eb -x Bowtie2-2.4.2-GCC-9.3.0.eb</code>.</p> <p>The output for the build step shows the actual compilation command that would be performed (<code>make ...</code>):</p> <pre><code>[build_step method]\n&gt;&gt; running command:\n    [started at: 2021-03-08 20:15:08]\n[working dir: /local_scratch/hkenneth/eb-1wodfohg/__ROOT__/local_scratch/hkenneth/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2]\n[output logged in /local_scratch/hkenneth/eb-1wodfohg/easybuild-run_cmd-haojzisn.log]\nmake -j 48  CC=\"gcc\"  CPP=\"g++\" CXX=\"g++\"  RELEASE_FLAGS=\"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\"\n(in /local_scratch/hkenneth/Bowtie2/2.4.2/GCC-9.3.0/Bowtie2-2.4.2)\n</code></pre> <p>If the output you get is less detailed, you may not have set <code>export EASYBUILD_TRACE=1</code>.</p> <p>The output for the sanity check step shows which binaries are expected to be installed: <pre><code>[sanity_check_step method]\nSanity check paths - file ['files']\n  * bin/bowtie2\n  * bin/bowtie2-align-l\n  * bin/bowtie2-align-s\n  * bin/bowtie2-build\n  * bin/bowtie2-build-l\n  * bin/bowtie2-build-s\n  * bin/bowtie2-inspect\n  * bin/bowtie2-inspect-l\n  * bin/bowtie2-inspect-s\n</code></pre></p> <p>Exercise U.4 - Installing software</p> <p>Install version 3.1.0 of the <code>h5py</code> Python package and all missing dependencies, using the <code>foss/2020b</code> toolchain, into <code>/tmp/$USER/easybuild</code>, while leveraging the already installed software available from <code>/easybuild</code>.</p> <p>Enable trace output so you can see which parts of the installation take a while.</p> (click to show solution) <p>First, determine the easyconfig file we can use for this: <pre><code>$ eb -S 'h5py-3.1.0.*foss-2020b'\nCFGS1=/home/example/.local/easybuild/easyconfigs/h/h5py\n* $CFGS1/h5py-3.1.0-foss-2020b.eb\n</code></pre></p> <p>Make sure the pre-install software in <code>/easybuild/</code> is available: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>Check which dependencies are missing to install this <code>h5py</code> easyconfig: <pre><code>$ eb h5py-3.1.0-foss-2020b.eb --missing\n\n2 out of 63 required modules missing:\n\n* pkgconfig/1.5.1-GCCcore-10.2.0-python (pkgconfig-1.5.1-GCCcore-10.2.0-python.eb)\n* h5py/3.1.0-foss-2020b (h5py-3.1.0-foss-2020b.eb)\n</code></pre></p> <p>Install <code>h5py</code> by specifying the easyconfig file and enabling dependency resolution via <code>--robot</code>, while indicating that we want to install the software into <code>/tmp/$USER/easybuild</code> using the <code>--installpath</code> option. Also make sure that trace mode is enabled by defining the <code>$EASYBUILD_TRACE</code> environment variable. <pre><code>$ export EASYBUILD_TRACE=1\n$ eb h5py-3.1.0-foss-2020b.eb --robot --installpath /tmp/$USER/easybuild\n...\n== building and installing pkgconfig/1.5.1-GCCcore-10.2.0-python...\n...\n== building and installing h5py/3.1.0-foss-2020b...\n...\n== building...\n  &gt;&gt; running command:\n        [started at: 2020-06-10 21:47:32]\n[working dir: /tmp/example/h5py/3.1.0/foss-2020b/h5py-3.1.0]\n[output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log]  python setup.py configure --mpi --hdf5=$EBROOTHDF5 &amp;&amp; /easybuild/software/Python/3.8.6-GCCcore-10.2.0/bin/python setup.py build\n  &gt;&gt; command completed: exit 0, ran in 00h01m27s\n...\n== COMPLETED: Installation ended successfully (took 2 min 46 sec)\n...\n== Build succeeded for 2 out of 2\n</code></pre></p> <p>The trace output shows that most time is spent in the build command, which runs both <code>python setup.py configure</code> and <code>python setup.py build</code>.</p> <p>Exercise U.5 - Using installed software</p> <p>Using the <code>h5py</code> installation from the previous exercise to create an empty HDF5 file, using the following Python statements:</p> <pre><code>import h5py\nf = h5py.File(\"empty.hdf5\", \"w\")\nf.close()\n</code></pre> <p>Check the resulting file using the <code>h5stat</code> command.</p> (click to show solution) <p>First, we need to make the modules tool aware of the module files that were installed into <code>/tmp/$USER/easybuild</code>: <pre><code>module use /tmp/$USER/easybuild/modules/all\n</code></pre></p> <p>Then we can check the <code>h5py</code> module is available, and load it: <pre><code>$ module avail h5py\n------------ /tmp/example/easybuild/modules/all ------------\nh5py/3.1.0-foss-2020b\n</code></pre></p> <pre><code>module load h5py/3.1.0-foss-2020b\n</code></pre> <p>The Python code snippet can be run directly on the command line using \"<code>python -c '...'</code>\", since it's tiny: <pre><code>python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()'\n</code></pre> Of course you can also copy the Python code snippet in a file named <code>test_h5py.py</code>, and then run it with <code>python test_h5py.py</code>.</p> <p>Checking with the <code>h5stat</code> command shows that the resulting <code>empty.hdf5</code> is indeed a valid HDF5 file: <pre><code>$ ls -l empty.hdf5 \n-rw-rw-r-- 1 example example 800 Jun 10 21:54 empty.hdf5\n\n$ h5stat empty.hdf5\nFilename: empty.hdf5\nFile information\n        # of unique groups: 1\n# of unique datasets: 0\n...\n</code></pre></p> <p>If you've made it through the hands-on exercises, congratulations!</p> <p>If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time...</p> <p>Feel free to ask question in the <code>#tutorial</code> channel in the EasyBuild Slack, we're happy to help!</p> <p>[next: Part 2: Using EasyBuild]</p>"},{"location":"2021-lust/configuration/","title":"Configuring EasyBuild","text":"<p>[back: Installation]</p> <p>After installing EasyBuild, you should configure it.</p> <p>EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information.</p> <p>Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it.</p>"},{"location":"2021-lust/configuration/#available-configuration-settings","title":"Available configuration settings","text":"<p>One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings.</p> <p>The full list of configuration settings can be consulted via <code>eb --help</code>, which shows the corresponding command line option accompanied by a short description. At the time of writing, over 240 different configuration settings are supported by EasyBuild.</p> <p>For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones.</p> <p>We will refer to EasyBuild configuration settings using the names as they appears in the output of <code>eb --help</code>, and omit the leading dashes (<code>--</code>) for the sake of clarity.</p> <p>Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.</p>"},{"location":"2021-lust/configuration/#overall-prefix","title":"Overall prefix","text":"<p>(default: <code>HOME/.local/easybuild</code>)</p> <p>The <code>prefix</code> configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings:</p> <ul> <li><code>installpath</code>: <code>&lt;prefix&gt;</code></li> <li><code>buildpath</code>: <code>&lt;prefix&gt;/build</code></li> <li><code>sourcepath</code>: <code>&lt;prefix&gt;/sources</code></li> <li><code>repositorypath</code> (easyconfigs archive): <code>&lt;prefix&gt;/ebfiles_repo</code></li> <li><code>containerpath</code>: <code>&lt;prefix&gt;/containers</code></li> </ul> <p>Here, <code>&lt;prefix&gt;</code> represents the value of the <code>prefix</code> configuration setting.</p> <p>If one of the configuration settings affected by <code>prefix</code> is defined specifically, the <code>prefix</code> value becomes irrelevant for that specific configuration setting.</p>"},{"location":"2021-lust/configuration/#install-path","title":"Install path","text":"<p>(default: <code>&lt;prefix&gt;</code>)</p> <p>The location for both the software installation directories and generated module files can be controlled via the <code>installpath</code> configuration setting. Software installation directories will be placed in <code>&lt;installpath&gt;/software</code>, while <code>&lt;installpath&gt;/modules/all</code> will be used for generated module files.</p> <p>The <code>installpath</code> location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which is particularly useful to test and evaluate software installations.</p> <p>Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the <code>software</code> and <code>modules/all</code> subdirectories.</p> <p>We recommend to only change the <code>installpath</code> configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default <code>software</code> and <code>modules/all</code> names for the subdirectories are used.</p>"},{"location":"2021-lust/configuration/#build-path","title":"Build path","text":"<p>(default: <code>&lt;prefix&gt;/build</code>)</p> <p>For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the <code>buildpath</code> configuration setting.</p> <p>Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations.</p> <p>It is strongly recommend to use the path to a directory on a local filesystem for the value of the <code>buildpath</code> configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like <code>/dev/shm/$USER</code>) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like <code>noexec</code>).</p> <p>Use a directory on a local filesystem for <code>buildpath</code> for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set <code>buildpath</code> to <code>/tmp/$USER</code>, for example.</p>"},{"location":"2021-lust/configuration/#source-path","title":"Source path","text":"<p>(default: <code>&lt;prefix&gt;/sources</code>)</p> <p>For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path.</p> <p>The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the <code>sourcepath</code> configuration setting.</p> <p>The <code>sourcepath</code> value is a colon (<code>:</code>) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named '<code>Example'</code>, EasyBuild will consider locations like <code>&lt;sourcepath&gt;/e/Example/</code>, <code>&lt;sourcepath&gt;/Example/</code>, and so on.</p> <p>The first path listed in <code>sourcepath</code> is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in <code>sourcepath</code> only read permissions are required.</p> <p>Make sure you have write permissions to the first path listed in <code>sourcepath</code>, so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere.</p>"},{"location":"2021-lust/configuration/#easyconfigs-archive","title":"Easyconfigs archive","text":"<p>(default: <code>&lt;prefix&gt;/ebfiles_repo</code>)</p> <p>EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the <code>repositorypath</code> configuration setting.</p> <p>By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation).</p> <p>For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the <code>prefix</code> configuration setting.</p>"},{"location":"2021-lust/configuration/#modules-tool-module-syntax","title":"Modules tool &amp; module syntax","text":"<p>(default: <code>Lmod</code> as modules tool, <code>Lua</code> as module syntax)</p> <p>By default, EasyBuild assumes you are using Lmod as modules tool. In addition, it will generate module files in Lua syntax, as supported by Lmod (next to <code>Tcl</code> syntax).</p> <p>To diverge from this, you can define the <code>modules-tool</code> configuration setting to indicate you are using a different modules tool; see the output of <code>eb --avail-modules-tools</code> for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through <code>$PATH</code> (more information on this in the EasyBuild documentation).</p> <p>If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the <code>module-syntax</code> configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in <code>Lua</code> syntax.</p> <p>We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax.</p>"},{"location":"2021-lust/configuration/#robot-search-path","title":"Robot search path","text":"<p>(default: <code>robot-paths</code> specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled)</p> <p>When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path. This applies to both easyconfig files that were specified using only their filename as an argument to the <code>eb</code> command, as well as to easyconfigs required to resolve dependencies (more on that later).</p> <p>To control the robot search path, two configuration settings are available: <code>robot</code> and <code>robot-paths</code>. Both accept a colon-separated list of locations to consider when looking for easyconfig files, with <code>robot</code> overriding <code>robot-paths</code>.</p> <p>The key difference between these two configuration settings is that defining <code>robot</code> also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining <code>robot-paths</code> does not have the side effect of enabling dependency resolution.</p> <p>In addition, you can use the <code>--robot</code> command line option without specifying any paths to it, to only enable dependency resolution.</p> <p>Note</p> <p>Keep in mind that when either of the <code>robot</code> or <code>robot-paths</code> configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered.</p> <p>There are ways around this however, which are outside of the scope of this tutorial.</p> <p>For more information, see the EasyBuild documentation.</p>"},{"location":"2021-lust/configuration/#module-naming-scheme","title":"Module naming scheme","text":"<p>(default: <code>EasyBuildMNS</code>)</p> <p>EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation.</p> <p>Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via <code>eb --avail-module-naming-schemes</code>.</p> <p>The default <code>EasyBuildMNS</code> module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the <code>versionsuffix</code> easyconfig parameter): <code>&lt;name&gt;/&lt;version&gt;&lt;-toolchain&gt;&lt;versionsuffix&gt;</code>. Just like with names of easyconfig files, the <code>&lt;-toolchain&gt;</code> part is omitted when the <code>system</code> toolchain is used, and the <code>&lt;versionsuffix&gt;</code> value is empty by default.</p>"},{"location":"2021-lust/configuration/#configuration-levels","title":"Configuration levels","text":"<p>Configuring EasyBuild can be done in different ways:</p> <ul> <li>through one or more configuration files;</li> <li>via <code>$EASYBUILD_*</code> environment variables;</li> <li>using <code>eb</code> command line options;</li> </ul> <p>Each of the methods corresponds to a configuration level.</p> <p>Every configuration setting can be defined via one of these mechanisms, without exception!</p>"},{"location":"2021-lust/configuration/#configuration-level-hierarchy","title":"Configuration level hierarchy","text":"<p>There is a strict hierarchy between the different configuration levels supported by EasyBuild.</p> <p>Settings defined via a configuration file only override default values.</p> <p>A configuration setting that is defined via the corresponding <code>$EASYBUILD_*</code> environment variable takes precedence over the value specified in a configuration file (if any).</p> <p>Finally, values specified through <code>eb</code> command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable.</p> <p>For example, let us consider a fictional configuration setting named <code>magic</code>:</p> <ul> <li>If a value for <code>magic</code> is specified in an EasyBuild configuration file,   then this value will only be used if the corresponding environment variable   (<code>$EASYBUILD_MAGIC</code>) is not defined and if the <code>--magic</code> command line option is not used;</li> <li>If the <code>$EASYBUILD_MAGIC</code> environment is defined however, then its value   will be used for the <code>this-is-magic</code> configuration setting;</li> <li>Unless the <code>--magic</code> command line option is used,   since in that case the value provided as an argument there will be used instead.</li> </ul>"},{"location":"2021-lust/configuration/#configuration-files","title":"Configuration files","text":"<p>Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of <code>eb --show-default-configfiles</code> tells you which locations are considered, and whether any configuration files were found.</p> <p>EasyBuild configuration files are written in the standard INI format, and the configuration settings are grouped into different sections.</p> <p>To create an EasyBuild configuration file, the output of <code>eb --confighelp</code> is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax.</p> <p>Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.</p>"},{"location":"2021-lust/configuration/#easybuild-configuration-files-vs-easyconfig-files","title":"EasyBuild configuration files vs easyconfig files","text":"<p>EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts!</p> <p>EasyBuild configuration files (usually <code>*.cfg</code>) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings, such as the location where software should be installed, or the syntax that should be used when generating module files.</p> <p>An easyconfig file (<code>*.eb</code>) on the other hand specifies the details for one particular software installation. It does this by defining a set of easyconfig parameters, which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc.</p> <p>For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.</p>"},{"location":"2021-lust/configuration/#easybuild_-environment-variables","title":"<code>$EASYBUILD_*</code> environment variables","text":"<p>A particularly easy way to configure EasyBuild is through environment variables.</p> <p>At startup, EasyBuild will pick up any environment variable of which the name starts with '<code>EASYBUILD_</code>'. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found).</p> <p>Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes (<code>-</code>) with underscores (<code>_</code>), and prefix with <code>EASYBUILD_</code>.</p> <p>For example: the <code>module-syntax</code> configuration setting can be specified by defining the <code>$EASYBUILD_MODULE_SYNTAX</code> environment variable:</p> <pre><code>export EASYBUILD_MODULE_SYNTAX=Tcl\n</code></pre> <p>Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines <code>$EASYBUILD_*</code> environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it.</p> <p>Note</p> <p>Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example <code>$HOME/.bash_profile</code> or <code>$HOME/.bashrc</code>).</p>"},{"location":"2021-lust/configuration/#eb-command-line-options","title":"<code>eb</code> command line options","text":"<p>Finally, you can also configure EasyBuild by specifying one or options to the <code>eb</code> command.</p> <p>As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option.</p> <p>There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the <code>eb</code> command print the EasyBuild version (via <code>eb --version</code>). Although you could configure EasyBuild to always print its version and then exit whenever the <code>eb</code> command is run, that would not be very useful...</p> <p>Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory:</p> <pre><code>eb --installpath /tmp/$USER example.eb\n</code></pre>"},{"location":"2021-lust/configuration/#inspecting-the-current-configuration-show-config","title":"Inspecting the current configuration (<code>--show-config</code>)","text":"<p>Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured.</p> <p>Through the <code>--show-config</code> command line option you can easily inspect the currently active EasyBuild configuration.</p> <p>The output of <code>--show-config</code> includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like <code>buildpath</code>, <code>installpath</code>, <code>sourcepath</code>, and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed.</p> <p>This is the output produced by <code>eb --show-config</code> for the default EasyBuild configuration, where EasyBuild was installed via <code>pip install --user</code> (which results in the value shown for the <code>robot-paths</code> configuration setting):</p> <pre><code>#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (D) = /home/example/.local/easybuild/build\ncontainerpath  (D) = /home/example/.local/easybuild/containers\ninstallpath    (D) = /home/example/.local/easybuild\nrepositorypath (D) = /home/example/.local/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (D) = /home/example/.local/easybuild/sources\n</code></pre> <p>As shown here, all configuration settings shown follow the default <code>prefix</code> value (<code>$HOME/.local/easybuild</code>), and none of the values diverge from the default value, since all entries are marked with <code>(D)</code> for \"default value\").</p> <p>Example</p> <p>Now let us do some basic configuring and inspect the resulting output of <code>--show-config</code>.</p> <p>First, create a user-level EasyBuild configuration file to define the <code>prefix</code> configuration setting:</p> <pre><code>mkdir -p $HOME/.config/easybuild\necho '[config]' &gt; $HOME/.config/easybuild/config.cfg\necho 'prefix=/apps' &gt;&gt; $HOME/.config/easybuild/config.cfg\n</code></pre> <p>In addition, define the <code>buildpath</code> configuration setting using the corresponding environment variable:</p> <pre><code>export EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Then run <code>--show-config</code> while you specify that the <code>installpath</code> configuration setting should be defined as <code>/tmp/$USER</code>:</p> <pre><code>$ eb --installpath=/tmp/$USER --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (E) = /tmp/easybuild\ncontainerpath  (F) = /apps/containers\ninstallpath    (C) = /tmp/easybuild\npackagepath    (F) = /apps/packages\nprefix         (F) = /apps\nrepositorypath (F) = /apps/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (F) = /apps/sources\n</code></pre> <p>The output indicates that the <code>installpath</code> setting was specified through a command line option (indicated with <code>(C)</code>), that the <code>buildpath</code> setting was defined via an environment variable (indicated with <code>(E)</code>), that the <code>robot-paths</code> setting still has the default value (indicated with <code>(D)</code>), and that all other configuration settings were specified via a configuration file, some of which indirectly through the <code>prefix</code> value (indicated with <code>(F)</code>).</p>"},{"location":"2021-lust/configuration/#exercises","title":"Exercises","text":"<p>Exercise C.1 - Configure EasyBuild</p> <p>Configure EasyBuild to use the <code>easybuild</code> subdirectory in your home directory for everything, except for:</p> <ul> <li>The location of the build directories: use <code>/tmp/$USER</code> for this;</li> <li>The locations that should be considered when searching for source files:   include both <code>$HOME/easybuild/sources</code> and <code>/easybuild/sources</code>, but make   sure that source files that are downloaded by EasyBuild are stored in   <code>$HOME/easybuild/sources</code>.</li> </ul> <p>Leave other configuration settings set to their default value.</p> (click to show solution) <p>This is pretty straightforward.</p> <p>Here we just define the corresponding environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_SOURCEPATH=$HOME/easybuild/sources:/easybuild/sources\n</code></pre> <p>The location where EasyBuild should download source files to must be listed first in the <code>sourcepath</code> configuration setting.</p> <p>The output of <code>--show-config</code> should look like this:</p> <pre><code>buildpath      (E) = /tmp/example\ncontainerpath  (E) = /home/example/easybuild/containers\ninstallpath    (E) = /home/example/easybuild\npackagepath    (E) = /home/example/easybuild/packages\nprefix         (E) = /home/example/easybuild\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/easybuild/easyconfigs\nsourcepath     (E) = /home/example/easybuild/sources:/easybuild/sources\n</code></pre> <p>Exercise C.2 - Install a trivial software package with EasyBuild</p> <p>Try running the following command:</p> <pre><code>eb bzip2-1.0.6.eb\n</code></pre> <p>Where do you expect to find the installation?</p> (click to show solution) <p>The software was installed in <code>$HOME/easybuild</code>, since that's how we configured EasyBuild in Exercise 3.1:</p> <pre><code>$ ls $HOME/easybuild\nebfiles_repo  modules  software  sources\n</code></pre> <p>The actual installation is in <code>$HOME/easybuild/software</code>, while the module file was generated in <code>$HOME/easybuild/modules/all</code>:</p> <pre><code>$ ls $HOME/easybuild/software\nbzip2\n$ ls $HOME/easybuild/software/bzip2\n1.0.6\n$ ls $HOME/easybuild/software/bzip2/1.0.6\nbin  easybuild  include  lib  man\n</code></pre> <pre><code>$ ls $HOME/easybuild/modules/all\nbzip2\n$ ls $HOME/easybuild/modules/all/bzip2\n1.0.6.lua\n</code></pre> <p>The source file for bzip2 1.0.6 was downloaded to <code>$HOME/easybuild/sources</code>:</p> <pre><code>$ ls $HOME/easybuild/sources/b/bzip2\nbzip2-1.0.6.tar.gz\n</code></pre> <p>We will discuss this in more detail in the next part of the tutorial.</p> <p>Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial.</p> <p>[next: Basic usage]</p>"},{"location":"2021-lust/creating_easyconfig_files/","title":"Creating easyconfig files","text":"<p>We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet?</p> <p>To do this we will need to create additional easyconfig files, since every software installation performed by EasyBuild is done based on an easyconfig file.</p> <p>In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!</p>"},{"location":"2021-lust/creating_easyconfig_files/#easyconfigs-vs-easyblocks","title":"Easyconfigs vs easyblocks","text":"<p>Before we dive into writing easyconfig files, let us take a brief look at how they relate to easyblocks.</p> <p>As we discussed earlier, an easyconfig file (<code>*.eb</code>) is required for each installation performed by EasyBuild which specifies the details of the installation (which software version, toolchain, etc.), while the installation procedure is implemented in an easyblock (a Python module).</p> <p>When can we leverage a generic easyblock, perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock?</p> <p>This is not an easy question to answer in a general sense, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc.</p> <p>In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central solution to peculiarities in the installation procedure of a particular software package.</p> <p>Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include:</p> <ul> <li>'critical' values for easyconfig parameters required to make installation succeed;</li> <li>toolchain-specific aspects of the build and installation procedure (e.g., configure options);</li> <li>interactive commands that need to be run;</li> <li>custom (configure) options for dependencies;</li> <li>having to create or adjust specific (configuration) files;</li> <li>'hackish' usage of a generic easyblock;</li> <li>complex or very non-standard installation procedure;</li> </ul> <p>Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation.</p>"},{"location":"2021-lust/creating_easyconfig_files/#writing-easyconfig-files","title":"Writing easyconfig files","text":"<p>Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a '<code>.eb</code>' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (as we discussed earlier).</p> <p>The syntax for easyconfig files is Python syntax: you are basically defining a bunch of Python variables that correspond to easyconfig parameters.</p> <p>The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.</p>"},{"location":"2021-lust/creating_easyconfig_files/#mandatory-parameters","title":"Mandatory parameters","text":"<p>A limited number of easyconfig parameters are mandatory, they must be defined in every easyconfig file:</p> <ul> <li><code>name</code>: the name of the software to install;</li> <li><code>version</code>: the version of the software to install;</li> <li><code>homepage</code>: a URL to the website of the software;</li> <li><code>description</code>: a short description of the software;</li> <li><code>toolchain</code>: the compiler toolchain to use for the installation;</li> </ul> <p><code>name</code>, <code>version</code></p> <p>It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file), and is also used to the determine the name of the module file to install.</p> <pre><code>name = 'example'\nversion = '1.0'\n</code></pre> <p><code>homepage</code>, <code>description</code></p> <p>The homepage and description are included in the generated module file for the installation. That way the \"<code>module show</code>\" command provides some useful high-level information about the installation.</p> <pre><code>homepage = 'https://example.org'\ndescription = \"This is just an example.\"\n</code></pre> <p>Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!).</p> <p>For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax):</p> <pre><code>description = \"\"\"This is an example\n of a multi-line description.\n It is spread across multiple lines.\"\"\"\n</code></pre> <p><code>toolchain</code></p> <p>EasyBuild also requires that the compiler toolchain is specified, via the <code>toolchain</code> easyconfig parameter.</p> <p>This can either be the <code>system</code> toolchain, for which a constant named <code>SYSTEM</code> is available:</p> <pre><code>toolchain = SYSTEM\n</code></pre> <p>Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 10.2.0 which we used before, or the full toolchain <code>foss</code> 2020b. The name and version of the toolchain can be specified using a small Python dictionary, for example:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '10.2.0'}\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#commonly-used-parameters","title":"Commonly used parameters","text":"<p>You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, but keep in mind that these are not mandatory.</p> <p>A full overview of all known easyconfig parameters can be obtained via \"<code>eb --avail-easyconfig-params</code>\" or just \"<code>eb -a</code>\" for short, or can be consulted in the EasyBuild documentation.</p>"},{"location":"2021-lust/creating_easyconfig_files/#sources-patches-and-checksums","title":"Sources, patches, and checksums","text":"<p>In most easyconfig files you will see that a list of source files is specified via the <code>sources</code> easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via <code>source_urls</code>. There also may be patch files listed (specified via <code>patches</code>), and checksums for both the source files and patches (specified via <code>checksums</code>).</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>Here is an example of how these easyconfig parameters can be specified:</p> <pre><code>source_urls = [\n    'https://example.org/download/',\n    'https://example.org/download/archive/',\n]\nsources = ['example-1.0-src.tar.gz']\npatches = ['example-fix.patch']\nchecksums = [\n    '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa',\n    '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c',\n]\n</code></pre> <p>Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list (<code>[]</code>).</p> <p>Some things worth pointing out here:</p> <ul> <li>The download URLs specified via <code>source_urls</code> do not include the name of the file, that is added   automatically by EasyBuild when it tries to download the file (only if it's not available already.)</li> <li>If multiple download URLs are specified, they are each tried once in order until the download of the source file was   successful. This can be useful to include backup locations where source files can be downloaded from.</li> <li>Names of source files and patches should not include hardcoded software versions, they usually use a   template value like <code>%(version)s</code> instead:   <pre><code>sources = ['example-%(version)s-src.tar.gz']\n</code></pre>   EasyBuild will use the value of the <code>version</code> easyconfig parameter to determine the actual name of the source   file. This way the software version is only specified in one place and the easyconfig file is easier to   update to other software versions. A list of template values can be consulted via the EasyBuild command   line via the <code>--avail-easyconfig-templates</code> option, or in the EasyBuild documentation.</li> <li>Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information.</li> <li>Specified checksums are usually SHA256 checksum values, but other types are also supported.</li> </ul>"},{"location":"2021-lust/creating_easyconfig_files/#easyblock","title":"Easyblock","text":"<p>The easyblock that should be used for the installation can be specified via the <code>easyblock</code> easyconfig parameter.</p> <p>This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If '<code>example</code>' is specified as software name, EasyBuild will try to locate a software-specific easyblock named <code>EB_example</code> (in a Python module named <code>example.py</code>). Software-specific easyblocks follow the convention that the class name starts with <code>'EB_</code>', followed by the software name (where some characters are replaced, like '<code>-</code>' with '<code>_minus_</code>').</p> <p>Generic easyblocks</p> <p>Usually the <code>easyblock</code> value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with '<code>EB_</code>', so you can easily distinguish it from a software-specific easyblock.</p> <p>Here are a couple of commonly used generic easyblocks:</p> <ul> <li><code>ConfigureMake</code>: implements the standard <code>./configure</code>, <code>make</code>, <code>make install</code> installation procedure;</li> <li><code>CMakeMake</code>: same as <code>ConfigureMake</code>, but with <code>./configure</code> replaced with <code>cmake</code> for the configuration step;</li> <li><code>PythonPackage</code>: implements the installation procedure for a single Python package, by default using    \"<code>python setup.py install</code>\" but other methods like using \"<code>pip install</code>\" are also supported;</li> <li><code>Bundle</code>: a simple generic easyblock to bundle a set of software packages together in a single installation directory;</li> <li><code>PythonBundle</code>: a customized version of the <code>Bundle</code> generic easyblock to install a bundle of Python packages   in a single installation directory;</li> </ul> <p>A full overview of the available generic easyblocks is available in the EasyBuild documentation. You can also consult the output of <code>eb --list-easyblocks</code>, which gives an overview of all known easyblocks, and how they relate to each other.</p> <p>Custom easyconfig parameters</p> <p>Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \"<code>eb -a --easyblock</code>\" or just \"<code>eb -a -e</code>\", which results in an additional \"<code>EASYBLOCK-SPECIFIC</code>\" section to be added. See the (partial) output of this command for example:</p> <pre><code>$ eb -a -e ConfigureMake\nAvailable easyconfig parameters (* indicates specific to the ConfigureMake easyblock):\n...\nEASYBLOCK-SPECIFIC\n------------------\nbuild_cmd*              Build command to use [default: \"make\"]\nbuild_type*             Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\nconfigure_cmd*          Configure command to use [default: \"./configure\"]\nconfigure_cmd_prefix*   Prefix to be glued before ./configure [default: \"\"]\nhost_type*              Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\ninstall_cmd*            Build command to use [default: \"make install\"]\nprefix_opt*             Prefix command line option for configure script ('--prefix=' if None) [default: None]\ntar_config_opts*        Override tar settings as determined by configure. [default: False]\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#dependencies","title":"Dependencies","text":"<p>You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies.</p> <p>Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the <code>dependencies</code> easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file.</p> <p>Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the <code>builddependencies</code> easyconfig parameter. One typical example of a build dependency is <code>CMake</code>, which is only needed for configuring the build.</p> <p>Here is a simple example of specifying dependencies:</p> <pre><code>builddependencies = [('CMake', '3.18.4')]\n\ndependencies = [\n    ('Python', '3.8.2'),\n    ('HDF5', '1.10.6'),\n    ('SciPy-bundle', '2020.03', '-Python-%(pyver)s'),\n]\n</code></pre> <p>Both <code>builddependencies</code> and <code>dependencies</code> require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values).</p> <p>In some cases additional information may have to be provided, as is shown in the example above for the <code>SciPy-bundle</code> dependency where a 3rd value is specified corresponding to the <code>versionsuffix</code> value of this dependency. If this is not specified, it is assumed to be the empty string (<code>''</code>).</p> <p>Note how we use the '<code>%(pyver)s'</code> template value in the <code>SciPy-bundle</code> dependency specification, to avoid hardcoding the Python version in different places.</p> <p>See also the EasyBuild documentation for additional options on specifying dependencies.</p>"},{"location":"2021-lust/creating_easyconfig_files/#version-suffix","title":"Version suffix","text":"<p>In some cases you may want to build a particular software package in different configurations, or include a label in the module name to highlight a particular aspect of the installation.</p> <p>The <code>versionsuffix</code> easyconfig parameter can be used for this purpose. The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme.</p> <p>If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example:</p> <pre><code>versionsuffix = '-example-label'\n</code></pre> <p>This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the <code>%(pyver)s</code> template comes in useful again:</p> <pre><code>versionsuffix = '-Python-%(pyver)s'\n...\ndependencies = [('Python', '2.7.18')]\n</code></pre> <p>Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The <code>versionsuffix</code> label is helpful to inform the user that a particular Python version is required by the installation.</p>"},{"location":"2021-lust/creating_easyconfig_files/#customizing-configure-build-test-and-install-commands","title":"Customizing configure, build, test, and install commands","text":"<p>When using a generic easyblock like <code>ConfigureMake</code> or <code>CMakeMake</code>, you will often find yourself having to specify options to the configure, build, test, or install commands, or to inject additional commands right before them.</p> <p>For this the following standard easyconfig parameters are available:</p> <ul> <li><code>preconfigopts</code>: string value that is glued before the configure command;</li> <li><code>configopts</code>: string value that is added after the configure command, which can be used to specify configuration options;</li> </ul> <p>Equivalent easyconfig parameters are available for the <code>build</code>, <code>test</code> and <code>install</code> steps: <code>prebuildopts</code>, <code>buildopts</code>, <code>pretestopts</code>, <code>testopts</code>, <code>preinstallopts</code>, and <code>installopts</code>.</p> <p>Here is a fictitious example of how they can be used:</p> <pre><code>easyblock = 'ConfigureMake'\n...\ndependencies = [('HDF5', '1.10.6')]\n...\nconfigopts = '--enable-hdf5-support'\n\nprebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp; '\n\ninstallopts = \"PREFIX='%(installdir)s'\"\n</code></pre> <p>Here we are:</p> <ul> <li> <p>Adding the <code>--enable-hdf5-support</code> configure option, to convince the <code>ConfigureMake</code> easyblock to run the following   command during the configure step:   <pre><code>./configure --prefix ... --enable-hdf5-support\n</code></pre>   (where the '<code>...</code>' represents the path to installation directory where the software should be installed).</p> </li> <li> <p>Specifying that an additional command has to be run before running <code>make</code> in the build step. We use '<code>&amp;&amp;</code>' to glue the   command to the <code>make</code> command, so <code>make</code> will only be run if the command we specified ran correctly. So, the build step will run something like:   <pre><code>export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp;  make -j 4\n</code></pre>   The '<code>4</code>' value passed to the <code>-j</code> option shown here, which specifies how many commands <code>make</code> can run in parallel, is automatically determined by EasyBuild based on the number of available cores (taking into account <code>ulimit</code> settings, and cpuset and cgroup restrictions).</p> </li> <li> <p>Passing the location where the software should be installed via the <code>PREFIX</code> argument to the <code>make install</code> command during the installation step. This results in the   following command being run:   <pre><code>make install PREFIX=...\n</code></pre>   (where the '<code>...</code>' again represents the path to installation directory).   Even though the   installation directory is already specified in the configure command, it is   apparently blatantly ignored by the software we are installing here, and we are expected to specify it   this way instead. How rude!</p> </li> </ul> <p>The <code>$EBROOTHDF5</code> environment variable that we are using in <code>prebuildopts</code> corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an <code>$EBROOT*</code> environment variable like this in every environment module file it generates (see the output of \"<code>module show HDF5</code>\").</p>"},{"location":"2021-lust/creating_easyconfig_files/#sanity-check","title":"Sanity check","text":"<p>One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step.</p> <p>By default EasyBuild does a simple sanity check that verifies whether there is a non-empty <code>bin</code> subdirectory in the installation, next to a non-empty <code>lib</code> or <code>lib64</code> directory (either is sufficient).</p> <p>It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like <code>example -V</code> or <code>example --help</code>) runs correctly.</p> <p>To specify a custom set of files and/or directories to check, you can use the <code>sanity_check_paths</code> easyconfig parameter. The expected value is Python dictionary with two keys: <code>files</code> and <code>dirs</code>. For example:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/example'],\n    'dirs': ['examples/one', 'examples/two'],\n}\n</code></pre> <p>In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the <code>sanity_check_commands</code> easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example:</p> <pre><code>sanity_check_commands = [\n    \"example --version\",\n    \"example --help\",\n]\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#module-class","title":"Module class","text":"<p>Finally, you will usually see the <code>moduleclass</code> easyconfig parameter to be defined as well, for example:</p> <pre><code>moduleclass = 'lib'\n</code></pre> <p>This is done to categorize software, and it is used to group the generated module files into smaller sets (remember what we saw when installing software earlier).</p>"},{"location":"2021-lust/creating_easyconfig_files/#generating-tweaked-easyconfigs","title":"Generating tweaked easyconfigs","text":"<p>Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too?</p> <p>We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the <code>--try-*</code> options provided by the <code>eb</code> command to make EasyBuild generate a new easyconfig file based on an existing one.</p> <p>For example, to try installing a different software version you can use the <code>--try-software-version</code> option:</p> <pre><code>eb example-1.2.3.eb --try-software-version 1.2.4\n</code></pre> <p>Or, to try using a different compiler toolchain you can use <code>--try-toolchain</code>:</p> <pre><code>eb example-1.2.3-foss-2020b.eb --try-toolchain intel,2020b\n</code></pre> <p>It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a <code>--try-*</code> option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.</p>"},{"location":"2021-lust/creating_easyconfig_files/#copying-easyconfigs","title":"Copying easyconfigs","text":"<p>One additional handy command line option we want to highlight is <code>--copy-ec</code>, which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the <code>eb</code> command using only the filename, and letting the robot search mechanism locate them.</p> <p>So to copy an easyconfig file, we would have to use <code>eb --search</code> first to get the full location to it, copy-paste that, and then use the <code>cp</code> command.</p> <p>It is a lot easier with <code>--copy-ec</code>:</p> <pre><code>$ eb --copy-ec SAMtools-1.11-GCC-10.2.0.eb SAMtools.eb\n...\nSAMtools-1.10-GCC-10.2.0.eb copied to SAMtools.eb\n</code></pre> <p>If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename.</p> <p>You can copy multiple easyconfig files at once, as long as the target location is an existing directory.</p>"},{"location":"2021-lust/creating_easyconfig_files/#example","title":"Example","text":"<p>By means of example, we are going to puzzle together an easyconfig file to install the example software package <code>eb-tutorial</code>.</p> <p>The sources for <code>eb-tutorial</code> version 1.0.1 are available at:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz\n</code></pre> <p>You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1.</p>"},{"location":"2021-lust/creating_easyconfig_files/#preparation","title":"Preparation","text":"<p>Make sure EasyBuild is properly configured before you start:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>and that the installed software in <code>/easybuild</code> is available:</p> <pre><code>module use /easybuild/modules/all\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#mandatory-parameters_1","title":"Mandatory parameters","text":"<p>Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file:</p> <pre><code>name = 'eb-tutorial'\nversion = '1.0.1'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n</code></pre> <p>If we try using this (very) minimal easyconfig file, EasyBuild will inform us that we failed to specify one of the mandatory easyconfig parameters: <code>toolchain</code>:</p> <pre><code>$ eb example.eb\n== Temporary log file in case of crash /tmp/eb-90j723rl/easybuild-q21plqvx.log\n== found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it...\nERROR: Failed to process easyconfig /home/example/example.eb: mandatory parameters not provided in pyheader: toolchain\n</code></pre> <p>We will use <code>GCC/10.2.0</code> as toolchain, since we know it is already installed in <code>/easybuild</code> in the prepared environment, so we also define the <code>toolchain</code> easyconfig parameter:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '10.2.0'}\n</code></pre> <p>In addition, we'll also specify the <code>moduleclass</code>. This is not required, but it is usually set to a sensible value:</p> <pre><code>moduleclass = 'tools'\n</code></pre> <p>The default value is '<code>base</code>', at least '<code>tools</code>' has some meaning.</p>"},{"location":"2021-lust/creating_easyconfig_files/#easyblock_1","title":"Easyblock","text":"<p>Let us see what happens if we take our current easyconfig file for a spin:</p> <pre><code>$ eb example.eb\n== temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log\nERROR: Failed to process easyconfig /home/example/example.eb:\nNo software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial\n</code></pre> <p>That didn't get us very far...</p> <p>The error shows that there is no software-specific easyblock available for installing the software with the name '<code>eb-tutorial</code>'. Does that mean we have to implement an easyblock?</p> <p>In this simple case it doesn't, since we can leverage one of the available generic easyblocks. But, which one?</p> <p>Build instructions are usually included in a <code>README</code> file, or in the documentation. In this case, there's indeed a minimal <code>README</code> file available, which tells us that we should use the <code>cmake</code> command to configure the installation, followed by <code>make</code> and <code>make install</code>.</p> <p>We briefly discussed a generic easyblock that does exactly this: <code>CMakeMake</code>.</p> <pre><code>easyblock = 'CMakeMake'\n</code></pre> <p>The \"<code>easyblock =</code>\" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).</p>"},{"location":"2021-lust/creating_easyconfig_files/#cmake-build-dependency","title":"CMake build dependency","text":"<p>Does using the <code>CMakeMake</code> generic easyblock help at all?</p> <pre><code>$ eb example.eb\n== temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log\n== found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/example.eb\n== building and installing eb-tutorial/1.0.1-GCC-10.2.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0):\nbuild failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native  (took 0 sec)\n</code></pre> <p>It did help: EasyBuild made an attempt to configure the build using the <code>cmake</code> command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message:</p> <pre><code>/bin/bash: cmake: command not found\n</code></pre> <p>Ah, that explains it, <code>cmake</code> isn't even installed on this system. Or is it?</p> <pre><code>$ module avail CMake\n\n--------------------------- /easybuild/modules/all ----------------------------\n   CMake/3.18.4-GCCcore-10.2.0\n</code></pre> <p>Since a module is available for <code>CMake</code> that is compatible with the toolchain we are using (GCC 10.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency:</p> <pre><code>builddependencies = [('CMake', '3.18.4')]\n</code></pre> <p>There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies.</p> <p>You can verify this via <code>eb -D</code> (equivalent with <code>eb --dry-run</code>):</p> <pre><code>$ eb example.eb -D\n ...\n * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-10.2.0.eb (module: GCC/10.2.0)\n * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.18.4-GCCcore-10.2.0.eb (module: CMake/3.18.4-GCCcore-10.2.0)\n * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-10.2.0)\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#sources","title":"Sources","text":"<p>If you try again after adding <code>CMake</code> as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this:</p> <pre><code>CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-10.2.0\" does not appear to contain CMakeLists.txt.\n</code></pre> <p>Wait, but there is a <code>CMakeLists.txt</code>, we can see it in the unpacked sources!</p> <p>Let's inspect the build directory:</p> <pre><code>$ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0\neasybuild_obj\n$ ls /tmp/$USER/ebtutorial/1.0.1/GCC-10.2.0/easybuild_obj\n$\n</code></pre> <p>There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file...</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>So we need to specify one or more source files that should be used, via the <code>sources</code> easyconfig parameter which specifies a list of names of source files:</p> <pre><code>sources = ['eb-tutorial-1.0.1.tar.gz']\n</code></pre> <p>We can avoid hardcoding the version number here by using a template value:</p> <pre><code>sources = ['eb-tutorial-%(version)s.tar.gz']\n</code></pre> <p>And since this is a standard way of naming software files, there's even a constant available that we can use:</p> <pre><code>sources = [SOURCE_TAR_GZ]\n</code></pre> <p>That way, we only have the software version specified once in the easyconfig file, via the <code>version</code> easyconfig parameter. That will come in useful later (see Exercise 7.2)...</p> <p>If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere:</p> <pre><code>Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either...\n</code></pre> <p>To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via <code>source_urls</code>:</p> <pre><code>source_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#required-configure-option","title":"Required configure option","text":"<p>With <code>sources</code> and <code>source_urls</code> defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe...</p> <p>Here's what we find in the log file:</p> <pre><code>CMake Error at CMakeLists.txt:7 (message):\n  EBTUTORIAL_MSG is not set!\n</code></pre> <p>Apparently the <code>eb-tutorial</code> software has a required configure option. It's almost as if that was done on purpose, how silly!</p> <p>Options to the configure command can be specified by the <code>configopts</code> easyconfig parameter. To define the value of a CMake option, we need to use <code>-DNAME_OF_OPTION</code>, so:</p> <pre><code>configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n</code></pre> <p>We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the <code>EBTUTORIAL_MSG</code> configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise 7.1).</p>"},{"location":"2021-lust/creating_easyconfig_files/#sanity-check_1","title":"Sanity check","text":"<p>Hopefully that brings us closer to getting the installation to work...</p> <pre><code>$ eb example.eb\n....\n== sanity checking...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-10.2.0): build failed (first 300 chars):\nSanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0 (took 2 sec)\n</code></pre> <p>It got all the way to the sanity check step, that's great!</p> <p>The sanity check failed because no '<code>lib</code>' or <code>'lib64'</code> directory was found. Indeed:</p> <pre><code>$ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0\nbin\n$ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-10.2.0/bin\neb-tutorial\n</code></pre> <p>There is only a binary named <code>eb-tutorial</code> in the <code>bin</code> subdirectory. So we need to customize the standard sanity check:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n</code></pre> <p>Since we want to obtain a working installation, we might as well try to run this <code>eb-tutorial</code> command as well:</p> <pre><code>sanity_check_commands = ['eb-tutorial']\n</code></pre> <p>Let us now retry, but use <code>--module-only</code> rather than redoing the whole installation. <code>--module-only</code> still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via <code>--trace</code> we can get some more information too:</p> <pre><code>$ eb example.eb --module-only --trace\n...\n== sanity checking...\n  &gt;&gt; file 'bin/eb-tutorial' found: OK\n  &gt;&gt; running command 'eb-tutorial' ...\n  &gt;&gt; result for command 'eb-tutorial': OK\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> <p>Yes, great success!</p> <p>To convince yourself that the installation works as intended, try to load the <code>eb-tutorial</code> module and run the <code>eb-tutorial</code> command yourself:</p> <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial\n$ eb-tutorial\nHello from the EasyBuild tutorial!\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#complete-easyconfig","title":"Complete easyconfig","text":"<p>Here is the complete easyconfig we puzzled together for this example:</p> <pre><code>easyblock = 'CMakeMake'\n\nname = 'eb-tutorial'\nversion = '1.0.1'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\ntoolchain = {'name': 'GCC', 'version': '10.2.0'}\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9']\n\nbuilddependencies = [('CMake', '3.18.4')]\n\nconfigopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n\nsanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n\nsanity_check_commands = ['eb-tutorial']\n\nmoduleclass = 'tools'\n</code></pre> <p>One additional easyconfig parameter we defined here is <code>checksums</code>, which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation.</p> <p>You can let EasyBuild determine and inject these SHA256 checksums automatically via <code>eb --inject-checksums</code>:</p> <pre><code>$ eb example.eb --inject-checksums\n...\n== injecting sha256 checksums for sources &amp; patches in example.eb...\n== * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9\n</code></pre>"},{"location":"2021-lust/creating_easyconfig_files/#exercises","title":"Exercises","text":"<p>Exercise E.1 - Making <code>eb-tutorial</code> a bit more personal</p> <p>Change the easyconfig file for <code>eb-tutorial</code> to make the message printed by the <code>eb-tutorial</code> command a bit more personal: include the username of the account that was used to install the software in it (using the <code>$USER</code> environment variable).</p> (click to show solution) <p>For this we need to change the value that is passed to the <code>EBTUTORIAL_MSG</code> configure option: <pre><code>configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" '\n</code></pre> Here we have to use inner double quotes, to ensure that the <code>$USER</code> environment variable is expanded by the shell when running the <code>cmake</code> configure command.</p> <p>When you run the <code>eb-tutorial</code> command yourself, you should get output like this (not a message that includes a literal '<code>$USER</code>' string):</p> <pre><code>Hello from the EasyBuild tutorial! I was installed by example.\n</code></pre> <p>To re-install the <code>example.eb</code> easyconfig, you will need to use <code>eb --rebuild</code> or <code>eb --force</code>.</p> <p>Exercise E.2 - Installing eb-tutorial version 1.1.0</p> <p>Install version 1.1.0 of the <code>eb-tutorial</code> example software, which is a trivial version bump compared to version 1.0.1.</p> <p>The sources are available via:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz\n</code></pre> <p>You can leverage the <code>eb-tutorial</code> easyconfig file we have composed in the example above, but you should not make any manual changes to it!</p> (click to show solution) <p>You can use the <code>--try-software-version</code> option for this: <pre><code>$ eb example.eb --try-software-version 1.1.0\n...\n== building and installing eb-tutorial/1.1.0-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> To test: <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial/1.1.0-GCC-10.2.0\n$ eb-tutorial\nI have a message for you:\nHello from the EasyBuild tutorial!\n</code></pre> (<code>eb-tutorial</code> version 1.0.1 doesn't print \"<code>I have a message for you:</code>\")</p> <p>Exercise E.3 - Installing py-eb-tutorial 1.0.0</p> <p>Try composing an easyconfig file for the <code>py-eb-tutorial</code> example software, which is a tiny Python package. The source tarball can be downloaded from this link: py-eb-tutorial-1.0.0.tar.gz.</p> <p>A couple of tips:</p> <ul> <li> <p>There is a generic easyblock available for installing Python packages, which will come in useful here.</p> </li> <li> <p>By default EasyBuild performs an <code>import</code> check when install Python packages, using a Python module name that is derived from the software name by default, which will be incorrect in this case. You can specify the correct name to use in the import check by specifying it via the <code>options</code> easyconfig parameter in your easyconfig file:   <pre><code>options = {'modulename': 'example'}\n</code></pre>   (you will need to change '<code>example</code>' here, of course)</p> </li> <li> <p>Leverage the software that is already pre-installed in <code>/easybuild</code> in the prepared environment.   Remember that some already installed modules may be a bundle of a couple of other software packages.</p> </li> </ul> <p>Please also take this into account:</p> <ul> <li> <p>Unfortunately this software doesn't come with documentation. That is done to make it an example that   is representative for software that you may run into in the wild (it's not because   we were lazy when preparing the exercises, really!).   You can inspect the sources of this software here. Definitely take a look at the <code>setup.py</code> file, it includes some clues   about the requirements to get this software installed.</p> </li> <li> <p>Make sure the installation actually works, by checking that the <code>py-eb-tutorial</code> command runs correctly.   Maybe you will need to make sure other required software is available as well, for it to work correctly...</p> </li> </ul> (click to show solution) <p>Here is a complete working easyconfig file for <code>py-eb-tutorial</code>: <pre><code>easyblock = 'PythonPackage'\n\nname = 'py-eb-tutorial'\nversion = '1.0.0'\nversionsuffix = '-Python-%(pyver)s'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial Python example\"\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496']\n\ntoolchain = {'name': 'foss', 'version': '2020b'}\n\ndependencies = [\n    ('Python', '3.8.6'),\n    ('SciPy-bundle', '2020.11'),\n    ('eb-tutorial', '1.0.1'),\n]\n\nuse_pip = True\n\noptions = {'modulename': 'eb_tutorial'}\n\nsanity_check_paths = {\n    'files': ['bin/py-eb-tutorial'],\n    'dirs': ['lib/python%(pyshortver)s/site-packages'],\n}\n\nsanity_check_commands = [\"py-eb-tutorial\"]\n\nmoduleclass = 'tools'\n</code></pre></p> <p>Some remarks:</p> <ul> <li> <p>We used the <code>PythonPackage</code> generic easyblock. There is also a <code>PythonBundle</code> easyblock for installing   bundles of Python packages, which is used for <code>SciPy-bundle</code> for example. But we don't need that here,   since we are only dealing with a single Python package.</p> </li> <li> <p>The <code>versionsuffix</code> is not strictly needed, but it's common to tag Python packages with the Python version   for which they were installed.</p> </li> <li> <p>The SHA256 checksum for the source tarball was added automatically via <code>eb py-eb-tutorial.eb --inject-checksums</code>.</p> </li> <li> <p><code>py-eb-tutorial</code> only wants to be installed with <code>pip install</code>, so we had to set <code>use_pip = True</code>.   You can consult the custom easyconfig parameters supported by the <code>PythonPackage</code> easyblock via   \"<code>eb -a -e PythonPackage</code>\", see the <code>EASYBLOCK-SPECIFIC</code> part of the output.   Even when the default installation mechanism used by <code>PythonPackage</code>   (which consists of running <code>python setup.py install</code>) works fine,   it is recommended to instruct EasyBuild to use <code>pip install</code> instead.</p> </li> <li> <p>By default EasyBuild will try to import <code>py_eb_tutorial</code>, while the actual name of the Python package   provided by <code>py-eb-tutorial</code> is just <code>eb_tutorial</code>. We fixed this by specifying the correct Python module name to   use via <code>options</code>.</p> </li> <li> <p>Strictly speaking we don't need to specify a custom <code>sanity_check_paths</code>, since the default used   by Python package is already pretty decent (it will check for a non-empty <code>lib/python3.8/site-packages</code>   directory in the installation). We also want to make sure the <code>py-eb-tutorial</code> command is available in   the <code>bin</code> subdirectory however. Hardcoding to <code>python3.8</code> can be avoided using the <code>%(pyshortver)s</code>   template value.</p> </li> <li> <p>A good way to check whether the <code>py-eb-tutorial</code> command works correctly is by running it as a sanity check   command. If the <code>eb-tutorial</code> command is not available the <code>py-eb-tutorial</code> command will fail,   since it basically just runs the <code>eb-tutorial</code> command. So we need to include <code>eb-tutorial</code> as a (runtime)   dependency in the <code>py-eb-tutorial</code> easyconfig file.</p> </li> </ul>"},{"location":"2021-lust/easybuild_library/","title":"Using EasyBuild as a library","text":"<p>You can use EasyBuild as a Python library and implement a script to automate a particular task.</p> <p>All the functionality provided by the EasyBuild framework can be leveraged, so you only have to glue things together and add the missing pieces.</p>"},{"location":"2021-lust/easybuild_library/#setting-up-the-easybuild-configuration","title":"Setting up the EasyBuild configuration","text":"<p>Before you call any of the functions provided by the EasyBuild framework, you should initialize EasyBuild by setting up the configuration. Some of the EasyBuild framework functions assume that EasyBuild has been initialized properly, and calling them without doing so will result in errors.</p> <p>To set up the EasyBuild configuration, you should call the <code>set_up_configuration</code> function that is provided by the <code>easybuild.tools.options</code> module.</p> <p>This function takes a couple of optional arguments that are useful in the context of a Python script that uses EasyBuild as a library:</p> <ul> <li>Via <code>args</code> you can provide a list of command line arguments that should be passed to the option parser.   By default, the standard command line arguments are picked up via <code>sys.args</code>, which may not be what you want.</li> <li>By passing <code>silent=True</code> you can specify that the <code>set_up_configuration</code> function should not print   anything when it is called. By default, it will print the location to the temporary EasyBuild log file.</li> </ul>"},{"location":"2021-lust/easybuild_library/#cleaning-up-the-temporary-directory","title":"Cleaning up the temporary directory","text":"<p>When EasyBuild is configured, a temporary directory specific to that EasyBuild session will be created automatically. You should clean up that directory, especially if you will be creating temporary files, or if the script will be run often.</p> <p>Note that cleaning up the temporary directory implies removes the temporary log files, so you probably only want to do this if no errors occurred.</p>"},{"location":"2021-lust/easybuild_library/#minimal-example-script","title":"Minimal example script","text":"<p>Here is a minimal (and pretty useless) example Python script, which sets up the EasyBuild configuration and cleans up the temporary directory:</p> <pre><code>#!/usr/bin/env python3\nfrom easybuild.tools.filetools import remove_dir\nfrom easybuild.tools.options import set_up_configuration\n\nopts, _ = set_up_configuration(args=[], silent=True)\n\nremove_dir(opts.tmpdir)\n</code></pre>"},{"location":"2021-lust/easybuild_library/#example-use-cases","title":"Example use cases","text":"<p>Once the EasyBuild configuration has been set up, the functions provided by the EasyBuild framework can be called from a Python script (or directly from the Python interpreter).</p> <p>A full overview of all functions is available via the EasyBuild API documentation.</p> <p>We highlight a couple commonly used functions in the sections below.</p>"},{"location":"2021-lust/easybuild_library/#file-operations","title":"File operations","text":"<p>The <code>easybuild.tools.filetools</code> module provides a bunch of functions for performing file operations.</p> <p>That includes straightforward things like reading, writing, and copying files (see <code>read_file</code>, <code>write_file</code>, <code>copy_file</code>), but also more specific functionality like applying a patch file (<code>apply_patch</code>), computing different types of checksums for a file (<code>compute_checksum</code>), and downloading files (<code>download_file</code>).</p> <p>Here is a trivial example where we download a file from a specified URL to a temporary directory, compute the SHA256 checksum, and then copy the downloaded file to the current working directory:</p> <pre><code>#!/usr/bin/env python3\nimport os\nimport sys\nimport tempfile\n\nfrom easybuild.tools.filetools import download_file, compute_checksum, copy_file, remove_dir\nfrom easybuild.tools.options import set_up_configuration\n\nurl = sys.argv[1]\n\nopts, _ = set_up_configuration()\n\nfn = os.path.basename(url)\ntmp_path = os.path.join(opts.tmpdir, fn)\ndownload_file(fn, url, tmp_path)\n\nsha256 = compute_checksum(tmp_path, checksum_type='sha256')\nprint(\"SHA256 checksum for %s: %s\" % (fn, sha256))\n\ntarget_dir = os.getcwd()\ncopy_file(tmp_path, target_dir)\nprint(\"%s copied to %s\" % (fn, target_dir))\n\n# cleanup temp dir\nremove_dir(opts.tmpdir)\n</code></pre> <p>Example output: <pre><code>$ export TEST_URL='https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz'\n$ python3 download_and_copy.py $TEST_URL\n== Temporary log file in case of crash /tmp/eb-or_xhaw8/easybuild-ewooa00c.log\nSHA256 checksum for eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9\neb-tutorial-1.0.1.tar.gz copied to /home/example\n</code></pre> We are deliberately not specifying the <code>args</code> optional argument to the <code>set_up_configuration</code> call here, so we can pass EasyBuild configuration options as command line arguments to this script. Of course, only those configuration options that are taken into account by the EasyBuild framework functions being called have any impact. For example:</p> <pre><code># wait for max. 1h for the download to complete\npython3 download_and_copy.py $TEST_URL --download-timeout 3600\n</code></pre>"},{"location":"2021-lust/easybuild_library/#running-shell-commands","title":"Running shell commands","text":"<p>To run shell commands, we can leverage the <code>run_cmd</code> functions from the <code>easybuild.tools.run</code> module.</p> <p>Here is a simple example for running the '<code>make</code>' command via a Python script:</p> <pre><code>#!/usr/bin/env python3\nimport sys\n\nfrom easybuild.tools.filetools import remove_dir, which\nfrom easybuild.tools.run import run_cmd\nfrom easybuild.tools.options import set_up_configuration\n\nopts, _ = set_up_configuration(args=[])\n\ncmd = 'make'\ncmd_path = which(cmd)\nif cmd_path:\n    print(\"&gt;&gt;&gt; '%s' command found at %s\" % (cmd, cmd_path))\nelse:\n    sys.stderr.write(\"ERROR: '%s' command not found!\\n\" % cmd)\n    sys.exit(1)\n\ncmd = ' '.join([\"make\"] + sys.argv[1:])\nout, ec = run_cmd(cmd)\n\nprint(\"\\n&gt;&gt;&gt; Output of '%s' (exit code %s):\\n\\n%s\" % (cmd, ec, out))\n\nremove_dir(opts.tmpdir)\n</code></pre> <p>Note that in this case it is important to use <code>args=[]</code> when calling <code>set_up_configuration</code>, to avoid that the additional script arguments which are options for the '<code>make</code>' command are picked up by the EasyBuild option parser.</p> <p>Example usage:</p> <pre><code>$ python3 run_make.py --version\n== Temporary log file in case of crash /tmp/eb-zfvbceg6/easybuild-7tynetaj.log\n\n&gt;&gt; Output of 'make --version' (exit code 0):\n\nGNU Make 3.81\n</code></pre>"},{"location":"2021-lust/easybuild_library/#interacting-with-the-modules-tool","title":"Interacting with the modules tool","text":"<p>You can interact with the environment modules tool in a Python script using the <code>easybuild.tools.modules</code> Python module that is a part of the EasyBuild framework. The modules tool that will be used is determined by the active EasyBuild configuration.</p> <p>Here is an example script that checks which modules are available and currently loaded, loads the default module file for <code>bzip2</code>, and inspects the resulting changes to the environment.</p> <pre><code>#!/usr/bin/env python3\nimport os\nimport sys\n\nfrom easybuild.tools.filetools import remove_dir\nfrom easybuild.tools.modules import get_software_root_env_var_name, modules_tool\nfrom easybuild.tools.options import set_up_configuration\n\nopts, _ = set_up_configuration()\n\n# obtain ModulesTool instance for preferred modules tool (determined by active EasyBuild configuration)\nmod_tool = modules_tool()\nprint(\"Active modules tool: %s version %s\" % (mod_tool.NAME, mod_tool.version))\n\navail_modules = mod_tool.available()\nprint(\"Found %d available modules in total\" % len(avail_modules))\n\navail_eb_modules = mod_tool.available('EasyBuild')\nprint(\"Found %d available modules for EasyBuild: %s\" % (len(avail_eb_modules), ', '.join(avail_eb_modules)))\n\nloaded_modules = mod_tool.loaded_modules()\nprint(\"%d modules are currently loaded: %s\" % (len(loaded_modules), ', '.join(loaded_modules)))\n\n# load default module for bzip2, check changes to environment\nname = 'bzip2'\nenv_var_name = get_software_root_env_var_name(name)\nif any(m.startswith(name + '/') for m in avail_modules):\n\n    print(\"Current $%s value: %s\" % (env_var_name, os.getenv(env_var_name, '(no set)')))\n    print(\"Loading (default) '%s' module...\" % name)\n\n    mod_tool.load([name])\n    print(\"Loaded modules: %s\" % ', '.join(mod_tool.loaded_modules()))\n\n    # inspect $_LMFILES_ environment variable to determine path to loaded bzip2 module file\n    for mod_file_path in os.getenv('_LMFILES_').split(':'):\n        if name in mod_file_path:\n            print(\"Path to loaded %s module: %s\" % (name, mod_file_path))\n            break\n\n    # $EBROOTBZIP2 should be set now (if the bzip2 module was installed with EasyBuild)\n    print(\"Current $%s value: %s\" % (env_var_name, os.getenv(env_var_name, '(no set)')))\nelse:\n    sys.stderr.write(\"No modules available for %s\\n\" % name)\n    sys.exit(1)\n\nremove_dir(opts.tmpdir)\n</code></pre>"},{"location":"2021-lust/easybuild_library/#parsing-easyconfig-files","title":"Parsing easyconfig files","text":"<p>Here is another small example Python script, which uses the EasyBuild framework functionality to locate and parse an easyconfig file, and inspect the value of specific easyconfig parameters.</p> <p>We define a small helper function named <code>parse_easyconfig</code>, because the EasyBuild framework API is a bit awkward to use for this simple use case.</p> <pre><code>#!/usr/bin/env python3\nimport sys\n\nfrom easybuild.framework.easyconfig.tools import det_easyconfig_paths, parse_easyconfigs\nfrom easybuild.tools.options import set_up_configuration\n\n\ndef parse_easyconfig(ec_fn):\n\"\"\"\n    Helper function: find and parse easyconfig with specified filename,\n    and return parsed easyconfig file (an EasyConfig instance).\n    \"\"\"\n    # determine path to easyconfig file\n    ec_path = det_easyconfig_paths([ec_fn])[0]\n\n    # parse easyconfig file;\n    # the 'parse_easyconfigs' function expects a list of tuples,\n    # where the second item indicates whether or not the easyconfig file was automatically generated or not\n    ec_dicts, _ = parse_easyconfigs([(ec_path, False)])\n\n    # only retain first parsed easyconfig, ignore any others (which are unlikely anyway)\n    return ec_path, ec_dicts[0]['ec']\n\n\n# check whether required arguments are provided\nif len(sys.argv) &lt; 3:\n    sys.stderr.write(\"ERROR: Usage: %s &lt;name of easyconfig file&gt; &lt;easyconfig parameter name(s)&gt;\")\n    sys.exit(1)\n\nec_fn = sys.argv[1]\nkeys = sys.argv[2:]\n\nset_up_configuration(args=[], silent=True)\n\nec_path, ec = parse_easyconfig(ec_fn)\n\nprint(\"Inspecting %s ...\" % ec_path)\nfor key in keys:\n    print(\"%s: %s\" % (key, ec[key]))\n</code></pre> <p>Example usage:</p> <pre><code>$ ./inspect_easyconfig.py Subread-2.0.0-GCC-8.3.0.eb name version sources sanity_check_paths\nname: Subread\nversion: 2.0.0\nsources: ['subread-2.0.0-source.tar.gz']\nsanity_check_paths: {'files': ['bin/exactSNP', 'bin/featureCounts', 'bin/subindel', 'bin/subjunc', 'bin/sublong', 'bin/subread-align', 'bin/subread-buildindex'], 'dirs': ['bin/utilities']}\n</code></pre>"},{"location":"2021-lust/github_integration/","title":"GitHub integration to facilitate contributing to EasyBuild","text":"<p>To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not?</p>"},{"location":"2021-lust/github_integration/#manual-contribution-procedure","title":"Manual contribution procedure","text":"<p>0) Create and setup a GitHub account (and register your SSH public key);</p> <p>1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file:</p> <pre><code>git clone git@github.com:easybuilders/easybuild-easyconfigs.git\ncd easybuild-easyconfigs\ngit remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git\n</code></pre> <p>You should change '<code>your_github_account</code>' in the last line to your own GitHub user name!</p> <p>2) Create and check out a new branch, starting from the (up-to-date) <code>develop</code> branch:</p> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout -b example\n</code></pre> <p>3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename, and that it's located in the appropriate directory.</p> <pre><code>mkdir -p easybuild/easyconfigs/e/example/\nmv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb\ngit add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb\n</code></pre> <p>4) Commit those changes with a sensible commit message:</p> <pre><code>git commit -m \"This is just an example\"\n</code></pre> <p>5) Push your branch to your fork of the repository on GitHub:</p> <pre><code>git push my_fork example\n</code></pre> <p>6) Open the pull request through the GitHub web interface, making sure that:</p> <ul> <li>the target branch is correct (should be <code>develop</code>);</li> <li>an appropriate title is used;</li> <li>a short description of the changes is provided;</li> <li>the changes are indeed the ones you want to propose;</li> <li>clicking the (correct) green button;</li> </ul> <p>That didn't exactly motivate you to contribute, did it...</p>"},{"location":"2021-lust/github_integration/#github-integration-features","title":"Github integration features","text":"<p>Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute...</p> <p>In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with <code>git</code> you may quickly end up demotivated.</p> <p>This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures.</p> <p>At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running <code>git</code> commands and interacting with the GitHub API.</p> <p>We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation.</p>"},{"location":"2021-lust/github_integration/#requirements-configuration","title":"Requirements &amp; configuration","text":"<p>First of all, the GitHub integration features impose a couple of additional requirements and configuration.</p> <p>Additional dependencies</p> <p>Both the <code>GitPython</code> and <code>keyring</code> Python packages as well as the <code>keyrings.cryptfile</code> add-on package must be installed. In the prepared environment, you can do this via:</p> <pre><code>pip3 install --user GitPython keyring keyrings.cryptfile\n</code></pre> <p>Note</p> <p>You may experiences problems installing the <code>cryptography</code> Python packages, which is a dependency of keyring. The underlying cause is that you need to have the <code>Rust</code> compiler installed to install the latest version of <code>cryptography</code> (see here).</p> <p>You can work around this issue using:</p> <pre><code>pip3 install --user 'cryptography&lt;3.4'\n</code></pre> <p>SSH public key in GitHub account</p> <p>You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys).</p> <p>If you need to generate an SSH key pair, you can run the following command:</p> <pre><code>ssh-keygen -t rsa -b 4096\n</code></pre> <p>You can copy the SSH public key from the output of this command:</p> <pre><code>cat .ssh/id_rsa.pub\n</code></pre> <p>Forked repository in GitHub</p> <p>In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs).</p> <p>EasyBuild configuration, incl. GitHub token</p> <p>You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials.</p> <p>To do this, you should define the <code>github-user</code> configuration option and run the \"<code>eb --install-github-token</code>\" command:</p> <pre><code># replace 'ebtutorial' with your own GitHub username!\n$ export EASYBUILD_GITHUB_USER=ebtutorial\n$ eb --install-github-token\n</code></pre> <p>To create a GitHub token:</p> <ul> <li>Visit https://github.com/settings/tokens.</li> <li>Click \"Personal access tokens\".</li> <li>Click followed by \"Generate new token\".</li> <li>Give the token a name (for example \"Token for EasyBuild\").</li> <li>Select both the '<code>repo</code>' and '<code>gist</code>' scopes.</li> <li>Click the green \"Generate token\" button.</li> <li>Copy the generated token.</li> <li>Paste the token when asked by <code>--install-github-token</code> (and hit Enter).</li> <li>Enter a password to encrypt your GitHub token.</li> </ul> <p>The output should look something like this:</p> <pre><code>$ eb --install-github-token\n== temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log\nToken: \nValidating token...\nToken seems to be valid, installing it.\nPlease set a password for your new keyring: \nPlease confirm the password:\nToken 'fed..987' installed!\n</code></pre> <p>Checking status of GitHub integration</p> <p>You can check the status of the GitHub integration using \"<code>eb --check-github</code>\":</p> <pre><code>$ eb --check-github\n== temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log\n\nChecking status of GitHub integration...\n\nMaking sure we're online...OK\n\n* GitHub user...ebtutorial =&gt; OK\nPlease enter password for encrypted keyring:\n* GitHub token...fed..987 (len: 40) =&gt; OK (validated)\n* git command...OK (\"git version 1.8.3.1; \")\n* GitPython module...OK (GitPython version 3.1.3)\n* push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK\n* creating gists...OK\n* location to Git working dirs... not found (suboptimal)\n\nAll checks PASSed!\n\nStatus of GitHub integration:\n* --from-pr: OK\n* --new-pr: OK\n* --review-pr: OK\n* --update-pr: OK\n* --upload-test-report: OK\n</code></pre> <p>If you see '<code>OK</code>' for each of the status checks, you're all set to try out the GitHub integration features!</p> <p>Note</p> <p>If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \"<code>eb --check-github</code>\".</p> <p>You can avoid this by using an SSH agent.</p> <p>Note</p> <p>If you see the <code>push access</code> check fail with <code>Failed to fetch branch 'main'</code>, you will need to rename the <code>master</code> branch in your fork of the <code>easybuild-easyconfigs</code> repository from <code>master</code> to <code>main</code> (this is required since EasyBuild v4.3.3).</p> <p>This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace <code>YOUR_GITHUB_ACCOUNT</code> with the name of your GitHub account in this URL).</p>"},{"location":"2021-lust/github_integration/#creating-pull-requests","title":"Creating pull requests","text":"<p>The GitHub integration in EasyBuild allows you to create pull requests using the <code>eb</code> command, without even leaving your shell environment. How cool is that\u203d</p> <p>To create a pull request to the <code>easybuild-easyconfigs</code> repository, you can either do it in a single go by running \"<code>eb --new-pr</code>\" and passing it one or more easyconfig files to add into the pull request.</p> <p>The more detailed option is to first create a branch in your repository fork in GitHub via \"<code>eb --new-branch-github</code>\" and then later open the pull request via \"<code>eb --new-pr-from-branch</code>\". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork).</p> <p>The <code>--new-pr</code> option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa!</p> <p>You can control the target repository for your pull request using <code>--pr-target-account</code> (default is <code>easybuilders</code>) and <code>--pr-target-repo</code>.</p> <p>If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \"<code>eb --dry-run --new-pr</code>\" or \"<code>eb -D --new-pr</code>\".</p> <p>Finally, you can use \"<code>eb --preview-pr</code>\" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.</p>"},{"location":"2021-lust/github_integration/#updating-pull-requests","title":"Updating pull requests","text":"<p>To update an existing pull request with additional changes you can use \"<code>eb --update-pr</code>\" and pass the pull request ID, alongside the paths to the updated files.</p> <p>If you have only created a branch (for example via <code>eb --new-branch-github</code>) you can update it via <code>--update-branch-github</code> in the same way, passing the branch name instead of a pull request ID.</p>"},{"location":"2021-lust/github_integration/#using-a-pull-request","title":"Using a pull request","text":"<p>Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which  support is not yet included in the latest EasyBuild release.</p> <p>Using the <code>--from-pr</code> option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the <code>--robot</code> option to ensure that the easyconfig files are installed in the correct order with respect to dependencies.</p> <p>Similarly, using a new or updated easyblock from a pull request is as simple as using the <code>--include-easyblocks-from-pr</code> option. And of course you can combine it with <code>--from-pr</code>!</p> <p>Via <code>--upload-test-report</code> you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.</p>"},{"location":"2021-lust/github_integration/#demo","title":"Demo","text":"<p>That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the <code>eb-tutorial</code> example software to a fork of the <code>easybuild-easyconfigs</code> repository using the <code>eb</code> command, and submit a test report in it.</p> <p>Note</p> <p>Make sure that you have correctly configured the GitHub integration, see above.</p>"},{"location":"2021-lust/github_integration/#creating-pull-request","title":"Creating pull request","text":"<p>We first configure EasyBuild to target the <code>ebtutorial</code> GitHub account rather than the default <code>easybuilders</code> GitHub organisation, by defining the <code>pr-target-account</code> configuration setting:</p> <pre><code>export EASYBUILD_PR_TARGET_ACCOUNT=ebtutorial\n</code></pre> <p>In the output of \"<code>eb --show-config</code>\" you should see a line like this:</p> <pre><code>pr-target-account (E) = ebtutorial\n</code></pre> <p>We only do this to avoid that lots of pull requests for the <code>eb-tutorial</code> example software are opened in the central easyconfigs repository.</p> <p>Opening a pull request is as simple as running \"<code>eb --new-pr</code>\" and passing the easyconfig file:</p> <pre><code>$ eb --new-pr example.eb\n== temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n== fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git...\n== copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs...\n== pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' (git@github.com:ebtutorial/easybuild-easyconfigs.git)\nEnter passphrase for key '/home/example/.ssh/id_rsa': \nPlease enter password for encrypted keyring: \n\nOpening pull request\n* target: ebtutorial/easybuild-easyconfigs:develop\n* from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100\n* title: \"{tools}[GCC/10.2.0] eb-tutorial v1.0.1\"\n* labels: new\n* description:\n\"\"\"\n(created using `eb --new-pr`)\n\n\"\"\"\n* overview of changes:\n easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb | 26 ++++++++++++++++++++++++++\n 1 file changed, 26 insertions(+)\n\nOpened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/\n== Temporary log file(s) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed.\n== Temporary directory /tmp/eb-ggr6scbq has been removed.\n</code></pre> <p>Take a moment to grasp what we did here: we ran a single <code>eb</code> command which took care of the whole contribution procedure for us, including:</p> <ul> <li>Cloning the <code>easybuilders/easybuild-easyconfigs</code> repository and checking out the <code>develop</code> branch (in a temporary   directory);</li> <li>Picking a sensible name for a branch and creating it;</li> <li>Adding the <code>eb-tutorial</code> easyconfig file to the branch, in the correct location   (<code>easybuild/easyconfigs/e/eb-tutorial/</code>) and with the correct filename (<code>eb-tutorial-1.0.1-GCC-10.2.0.eb</code>);</li> <li>Pushing the branch to our fork (<code>example/easybuild-easyconfigs</code>);</li> <li>Actually opening the pull request, using an informative title.</li> </ul> <p>That is so... easy!</p> <p>This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the <code>develop</code> branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to).</p> <p>There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since <code>--new-pr</code> created the branch only in a temporary directory).</p> <p>If many contributions are made via <code>--new-pr</code> it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar.</p>"},{"location":"2021-lust/github_integration/#uploading-test-report","title":"Uploading test report","text":"<p>After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request.</p> <p>First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for <code>eb-tutorial</code> are already installed there:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>You can verify which dependencies are still missing using <code>--from-pr</code> combined with <code>--missing</code>:</p> <pre><code># change '1' to the ID of your own pull request (see output of --new-pr)\n$ eb --from-pr 1 --missing\n== temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log\nPlease enter password for encrypted keyring: == found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n\n1 out of 20 required modules missing:\n\n* eb-tutorial/1.0.1-GCC-10.2.0 (eb-tutorial-1.0.1-GCC-10.2.0.eb)\n</code></pre> <p>Uploading a test report boils down to combining <code>--from-pr</code> with <code>--upload-test-report</code>:</p> <pre><code># change '1' to the ID of your own pull request (see output of --new-pr)\n$ eb --rebuild --from-pr 1 --upload-test-report\nPlease enter password for encrypted keyring: \n...\n== processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-10.2.0.eb\n== building and installing eb-tutorial/1.0.1-GCC-10.2.0...\n...\n== COMPLETED: Installation ended successfully (took 2 sec)\n...\nAdding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial\n**SUCCESS**\nBuild succeeded for 1 out of 1 (1 easyconfigs in this PR)\nexample - Linux centos linux 7.8.2003, x86_64, Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz (haswell), Python 3.6.8\nSee https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report.'\n== Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1\n</code></pre> <p>Note that we may need to use <code>--rebuild</code> here since <code>eb-tutorial</code> may already be installed.</p> <p>This results in a comment being added to the pull request:</p> <p>The gist linked from this comment provides more detailed information:</p>"},{"location":"2021-lust/hooks/","title":"Using hooks to customise EasyBuild","text":"<p>Sometimes you may have the need to customise the behaviour of EasyBuild, while you want to avoid copying easyconfig files in order to make small changes (like adding an additional configuration option), having to maintain a set of modified easyblocks, or using a patched version of the EasyBuild framework.</p> <p>EasyBuild provides support for implementing so-called hooks, which are small functions that are triggered automatically at specific times.</p> <p>Through these hook functions you can take additional actions, or even tweak internal data structures, to change the software installation procedure that EasyBuild would normally execute.</p> <p>This is a very powerful feature, but it is important to aware of some details in order to make good use of it.</p> <p>Support for hooks is also covered in detail in the EasyBuild documentation, see here.</p>"},{"location":"2021-lust/hooks/#implementing-and-using-hooks","title":"Implementing and using hooks","text":"<p>Using hooks is done by implementing functions with specific names in a Python module, and configuring EasyBuild to use them by specifying the path to the file that contains them via the <code>hooks</code> configuration option.</p> <p>For example, if the file named <code>my_eb_hooks.py</code> in your home directory contains the implementation of your hooks, you can configure EasyBuild to use them by defining the <code>$EASYBUILD_HOOKS</code> environment variable:</p> <pre><code>export EASYBUILD_HOOKS=$HOME/my_eb_hooks.py\n</code></pre>"},{"location":"2021-lust/hooks/#available-hooks","title":"Available hooks","text":"<p>EasyBuild supports various hooks, the full list can be consulted via <code>eb --avail-hooks</code>.</p> <p>There are 3 different types of hooks:</p> <ul> <li>start/end hooks</li> <li>parse hook</li> <li>pre/post-step hooks</li> </ul> <p>These are discussed in more details in the sections below.</p>"},{"location":"2021-lust/hooks/#startend-hooks","title":"Start/end hooks","text":"<p>The first type of hooks are the <code>start</code> and <code>end</code> hooks, which are respectively triggered at the very start of the EasyBuild session (right after setting up the EasyBuild configuration), and at the very end of the session (right before stopping the logger and doing final cleanup).</p> <p>These hooks are only called once for every EasyBuild session, no matter how many installations are performed during that session.</p> <p>The <code>end</code> hook is not triggered if an error occurred during one of the installations, only on successful completion of the EasyBuild session.</p> <p>These hooks can be implementing by defining a function named <code>start_hook</code> and <code>end_hook</code> in the Python module file that is provided via the <code>hooks</code> configuration option. No arguments are provided when calling these hooks.</p>"},{"location":"2021-lust/hooks/#parse-hook","title":"Parse hook","text":"<p>The <code>parse</code> hook is triggered right after an easyconfig file is being parsed, before EasyBuild sets up its internal data structures based on the parsed easyconfig.</p> <p>If you want to dynamically change one or more easyconfig parameters without changing the corresponding easyconfig files, using this hook may be appropriate.</p> <p>Note that parsing an easyconfig file can happen for a variety of reasons, not only when the easyconfig file will actually be installed. EasyBuild will also parse easyconfig files to check whether they resolve required dependencies, to check whether the corresponding module file is already installed, etc.</p> <p>This hook can be implemented via a function named <code>parse_hook</code>, and exactly one argument is provided when it is called: the <code>EasyConfig</code> instance that represents the parsed easyconfig file.</p>"},{"location":"2021-lust/hooks/#prepost-step-hooks","title":"Pre/post-step hooks","text":"<p>The third type of hooks are pre/post-step hooks, which are triggered right before or after a particular installation step is executed.</p> <p>EasyBuild performs each software installation by stepping through over a dozen different methods, and for each of these steps there a pre- and post-hook is triggered, which results in over 30 additional hooks.</p> <p>To use any of these hooks, you need to implement a function that follow a strict naming scheme: <code>&lt;pre|post&gt;_&lt;step-name&gt;_hook</code>. For example, the hook that is triggered right before the <code>configure</code> step is run is a function named <code>pre_configure_hook</code>.</p> <p>Every time these hooks are called, a single argument is provided: an <code>EasyBlock</code> instance that represents the easyblock that is being used to perform the installation. The parsed easyconfig file can be accessed via the <code>cfg</code> class variable of the <code>EasyBlock</code> instance.</p> <p>These hooks are useful for influencing the installation procedure at a particular stage.</p>"},{"location":"2021-lust/hooks/#caveats","title":"Caveats","text":"<p>There are a couple of important caveats to take into account when implementing hooks.</p>"},{"location":"2021-lust/hooks/#breaking-easybuild-with-hooks","title":"Breaking EasyBuild with hooks","text":"<p>Since hooks allow you to inject custom code into EasyBuild at runtime, it is also easy to break EasyBuild by using hooks...</p> <p>Make sure to carefully test your hook implementations, and constrain the actions you take a much as possible, for example by adding conditions to control for which software names you will actually modify the installation procedure, etc.</p> <p>Any errors that are triggered or raised while a hook function is running will interrupt the EasyBuild session.</p> <p>So don't forget: with great power comes great responsibility!</p>"},{"location":"2021-lust/hooks/#template-values","title":"Template values","text":"<p>Depending on the type of hook, you may observe \"raw\" values of easyconfig parameters where template values have not been resolved yet, or values in which template values have been resolved already.</p> <p>In the <code>parse</code> hook, you will always see unresolved template values.</p> <p>In the pre/post-step hooks you will see resolved template values, unless you explicitly disable templating.</p> <p>To obtain easyconfig parameter values with unresolved template values in step hooks, you can use the <code>disable_templating</code> context manager. For example:</p> <pre><code>from easybuild.framework.easyconfig.easyconfig import disable_templating\nfrom easybuild.tools.build_log import print_warning\n\ndef pre_source_hook(eb):\n\"\"\"Print warning when software version was found in 'raw' name of source file.\"\"\"\n    with disable_templating(eb.cfg):\n        for src in eb.cfg['sources']:\n            if eb.version in src:\n                msg = \"Software version '%s' found in name of source file (%s), \" % (eb.version, src)\n                msg += \"please use %(version)s template value instead!\"\n                print_warning(msg)\n</code></pre>"},{"location":"2021-lust/hooks/#manipulating-easyconfig-parameters","title":"Manipulating easyconfig parameters","text":"<p>If you want update a particular easyconfig parameter without overwriting the existing value, a bit of care has to be taken: you should use the <code>update</code> method of the <code>EasyConfig</code> instance for this, unless you disable template resolution. This is particularly important when updating easyconfig parameters that have mutable value (like a <code>list</code> or <code>dict</code>).</p> <p>Here's a correct example of a pre-install hook:</p> <pre><code>def pre_install_hook(eb):\n    if eb.name == 'pigz':\n        # always copy the README directory too when installing pigz\n        eb.cfg.update('files_to_copy', 'README')\n</code></pre> <p>This seemingly equivalent implementation will not work (the value of the <code>files_to_copy</code> easyconfig parameter will not be updated):</p> <pre><code>def pre_install_hook(eb):\n    if eb.name == 'pigz':\n        # incorrect way of adding 'README' to 'files_to_copy' (DON'T USE THIS!)\n        eb.cfg['files_to_copy'].append('README')\n</code></pre> <p>To use this coding style successfully, you have to disable the templating mechanism when updating the easyconfig parameter:</p> <pre><code>def pre_install_hook(eb):\n    if eb.name == 'pigz':\n        # this works, but it is better to use the 'update' method instead...\n        with disable_templating(eb.cfg):\n            eb.cfg['files_to_copy'].append('README')\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/","title":"Implementing easyblocks","text":""},{"location":"2021-lust/implementing_easyblocks/#the-basics","title":"The basics","text":"<p>An easyblock is a Python module that implements a software build and installation procedure.</p> <p>This concept is essentially implemented as a Python script that plugs into the EasyBuild framework.</p> <p>EasyBuild will leverage easyblocks as needed, depending on which software packages it needs to install. Which easyblock is required is determined by the <code>easyblock</code> easyconfig parameter, if it is present, or by the software name.</p>"},{"location":"2021-lust/implementing_easyblocks/#generic-vs-software-specific-easyblocks","title":"Generic vs software-specific easyblocks","text":"<p>Easyblocks can either be generic or software-specific.</p> <p>Generic easyblocks implement a \"standard\" software build and installation procedure that is used by multiple different software packages. A commonly used example is the <code>ConfigureMake</code> generic easyblock, which implements the standard <code>configure</code> - <code>make</code> - <code>make install</code> installation procedure used by most GNU software packages.</p> <p>Software-specific easyblocks implement the build and installation procedure for a particular software package. Typically this involves highly customised steps, for example specifying dedicated configuration options, creating or adjusting specific files, executing non-standard shell commands, etc. Usually a custom implementation of the sanity check is also included.</p> <p>Using a generic easyblock requires specifying the <code>easyblock</code> parameter in the easyconfig file. If it is not specified, EasyBuild will try and find the software-specific easyblock derived from the software name.</p> <p>The distinction between generic and software-specific easyblocks can be made based on the naming scheme that is used for an easyblock (see below).</p>"},{"location":"2021-lust/implementing_easyblocks/#naming","title":"Naming","text":"<p>Easyblocks need to follow a strict naming scheme, to ensure that EasyBuild can pick them up as needed. This involves two aspects:</p> <ul> <li>the name of the Python class;</li> <li>the name and location of the Python module file.</li> </ul>"},{"location":"2021-lust/implementing_easyblocks/#python-class-name","title":"Python class name","text":"<p>The name of the Python class is determined by the software name for software-specific easyblocks. It consists of a prefix '<code>EB_</code>', followed by the (encoded) software name.</p> <p>Because of limitations in Python on characters allowed in names of Python classes, only alphanumeric characters and underscores (<code>_</code>) are allowed. Any other characters are replaced following an encoding scheme:</p> <ul> <li>spaces are replaced by underscores (<code>_</code>);</li> <li>dashes <code>-</code> are replaced by <code>_minus_</code>;</li> <li>underscores are replaced by <code>_underscore_</code>;</li> </ul> <p>The <code>encode_class_name</code> function provided in <code>easybuild.tools.filetools</code> returns the expected class name for a given software name; for example:</p> <pre><code>$ python3 -c \"from easybuild.tools.filetools import encode_class_name; print(encode_class_name('netCDF-Fortran'))\"\nEB_netCDF_minus_Fortran\n</code></pre> <p>Python class name for generic easyblocks</p> <p>For generic easyblocks, the class name does not include an <code>EB_</code> prefix (since there is no need for an escaping mechanism) and hence the name is fully free to choose, taking into account the restriction to alphanumeric characters and underscores.</p> <p>For code style reasons, the class name should start with a capital letter and use CamelCasing.</p> <p>Examples include <code>Bundle</code>, <code>ConfigureMake</code>, <code>CMakePythonPackage</code>.</p>"},{"location":"2021-lust/implementing_easyblocks/#python-module-name-and-location","title":"Python module name and location","text":"<p>The filename of the Python module is directly related to the name of Python class it provides.</p> <p>It should:</p> <ul> <li>not include the <code>EB_</code> prefix of the class name for software-specific easyblocks;</li> <li>consists only of lower-case alphanumeric characters (<code>[a-z0-9]</code>) and underscores (<code>_</code>);<ul> <li>dashes (<code>-</code>) are replaced by underscores (<code>_</code>);</li> <li>any other non-alphanumeric characters (incl. spaces) are simply dropped;</li> </ul> </li> </ul> <p>Examples include:</p> <ul> <li><code>gcc.py</code> (for GCC)</li> <li><code>netcdf_fortran.py</code> (for netCDF-Fortran)</li> <li><code>gamess_us.py</code> (for GAMESS (US))</li> </ul> <p>The <code>get_module_path</code> function provided by the EasyBuild framework in the <code>easybuild.framework.easyconfig.easyconfig</code> module returns the (full) module location for a particular software name or easyblock class name. For example:</p> <pre><code>&gt;&gt;&gt; from easybuild.framework.easyconfig.easyconfig import get_module_path\n&gt;&gt;&gt; get_module_path('netCDF-Fortran')\n'easybuild.easyblocks.netcdf_fortran'\n&gt;&gt;&gt; get_module_path('EB_netCDF_minus_Fortran')\n'easybuild.easyblocks.netcdf_fortran'\n</code></pre> <p>The location of the Python module is determined by whether the easyblock is generic or software-specific. Generic easyblocks are located in the <code>easybuid.easyblocks.generic</code> namespace, while software-specific easyblocks live in the <code>easybuild.easyblocks</code> namespace directly.</p> <p>To keep things organised, the actual Python module files for software-specific easyblocks are kept in 'letter' subdirectories, rather than in one large '<code>easyblocks</code>' directory (see https://github.com/easybuilders/easybuild-easyblocks/tree/main/easybuild/easyblocks), but this namespace is collapsed transparently by EasyBuild (you don't need to import from letter subpackages).</p> <p>To let EasyBuild pick up one or more new or customized easyblocks, you can use the <code>--include-easyblocks</code> configuration option. As long as both the filename of the Python module and the name of the Python class are correct, EasyBuild will use these easyblocks when needed.</p>"},{"location":"2021-lust/implementing_easyblocks/#structure-of-an-easyblock","title":"Structure of an easyblock","text":"<p>The example below shows the overall structure of an easyblock:</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\nfrom easybuild.tools.run import run_cmd\n\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def configure_step(self):\n\"\"\"Custom implementation of configure step for Example\"\"\"\n\n        # run configure.sh to configure the build\n        run_cmd(\"./configure.sh --install-prefix=%s\" % self.installdir)\n</code></pre> <p>Each easyblock includes an implementation of a <code>class</code> that (directly or indirectly) derives from the abstract <code>EasyBlock</code> class.</p> <p>Typically some useful functions provided by the EasyBuild framework are imported at the top of the Python module.</p> <p>In the class definition, one or more '<code>*_step</code>' methods (and perhaps a couple of others) are redefined, to implement the corresponding step in the build and installation procedure.</p> <p>Each easyblock must implement the <code>configure</code>, <code>build</code> and <code>install</code> steps, since these are not implemented in the abstract <code>EasyBlock</code> class. This could be done explicitly by redefining the corresponding <code>*_step</code> methods, or implicitly by deriving from existing (generic) easyblocks.</p> <p>The full list of methods that can be redefined in an easyblock can be consulted in the API documentation.</p>"},{"location":"2021-lust/implementing_easyblocks/#deriving-from-existing-easyblocks","title":"Deriving from existing easyblocks","text":"<p>When implementing an easyblock, it is common to derive from an existing (usually generic) easyblock, and to leverage the functionality provided by it. This approach is typically used when only a specific part of the build and installation procedure needs to be customised.</p> <p>In the (fictitious) example below, we derive from the generic <code>ConfigureMake</code> easyblock to redefine the <code>configure</code> step. In this case, we are extending the <code>configure</code> step as implemented by <code>ConfigureMake</code> rather than redefining it entirely, since we call out to the original <code>configure_step</code> method at the end.</p> <pre><code>from easybuild.easyblocks.generic.configuremake import ConfigureMake\nfrom easybuild.tools.filetools import copy_file\n\n\nclass EB_Example(ConfigureMake):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def configure_step(self):\n\"\"\"Custom implementation of configure step for Example\"\"\"\n\n        # use example make.cfg for x86-64\n        copy_file('make.cfg.x86', 'make.cfg')\n\n        # call out to original configure_step implementation of ConfigureMake easyblock\n        super(EB_Example, self).configure_step()\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#easyconfig-parameters","title":"Easyconfig parameters","text":"<p>All of the easyconfig parameters that are defined in an easyconfig file are available via the <code>EasyConfig</code> instance that can be accessed through <code>self.cfg</code> in an easyblock. For instance, if the easyconfig file specifies</p> <pre><code>name = 'example'\nversion = '2.5.3'\nversionsuffix = '-Python-3.7.4'\n</code></pre> <p>then these three parameters are accessible within an easyblock via <code>self.cfg['name']</code>, <code>self.cfg['version']</code> and <code>self.cfg['versionsuffix']</code>.</p> <p>A few of the most commonly used parameters can be referenced directly:</p> <ul> <li><code>self.name</code> is equivalent with <code>self.cfg['name']</code>;</li> <li><code>self.version</code> is equivalent with <code>self.cfg['version']</code>;</li> <li><code>self.toolchain</code> is equivalent with <code>self.cfg['toolchain']</code>;</li> </ul>"},{"location":"2021-lust/implementing_easyblocks/#updating-parameters","title":"Updating parameters","text":"<p>You will often find that you need to update some easyconfig parameters in an easyblock, for example <code>configopts</code> which specifies options for the configure command.</p> <p>Because of implementation details (related to how template values like <code>%(version)s</code> are handled), you need to be a bit careful here...</p> <p>To completely redefine the value of an easyconfig parameter, you can use simple assignment. For example:</p> <pre><code>self.cfg['example'] = \"A new value for the example easyconfig parameter.\"\n</code></pre> <p>If want to add to the existing value however, you must use the <code>self.cfg.update</code> method. For example:</p> <pre><code>self.cfg.update('some_list', 'example')\n</code></pre> <p>This will not work (because <code>self.cfg['some_list']</code> does not return a reference to the original value, but to a temporary copy thereof):</p> <pre><code># anti-pattern, this does NOT work as expected!\nself.cfg['some_list'].append('example')\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#custom-parameters","title":"Custom parameters","text":"<p>Additional custom easyconfig parameters can be defined in an easyblock to allowing steering its behaviour. This is done via the <code>extra_options</code> static method. Custom parameters can be specified to be mandatory.</p> <p>The example below shows how this can be implemented:</p> <pre><code>from easybuild.easyblocks.generic.configuremake import ConfigureMake\nfrom easybuild.framework.easyconfig import CUSTOM, MANDATORY\n\n\nclass EB_Example(ConfigureMake):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    @staticmethod\n    def extra_options():\n\"\"\"Custom easyconfig parameters for Example\"\"\"\n        extra_vars = {\n            'required_example_param': [None, \"Example required custom parameter\", MANDATORY],\n            'optional_example_param': [None, \"Example optional custom parameter\", CUSTOM],\n        }\n        return ConfigureMake.extra_options(extra_vars)\n</code></pre> <p>The first element in the list of a defined custom parameter corresponds to the default value for that parameter (both <code>None</code> in the example above). The second element provides some informative help text, and the last element indicates whether the parameter is mandatory (<code>MANDATORY</code>) or just an optional custom parameter (<code>CUSTOM</code>).</p>"},{"location":"2021-lust/implementing_easyblocks/#easyblock-constructor","title":"Easyblock constructor","text":"<p>In the <code>class</code> constructor of the easyblock, i.e. the <code>__init__</code> method, one or more class variables can be initialised. These can be used for sharing information between different <code>*_step</code> methods in the easyblock.</p> <p>For example:</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\n\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def __init__(self, *args, **kwargs):\n\"\"\"Constructor for Example easyblock, initialises class variables.\"\"\"\n\n        # call out to original constructor first, so 'self' (i.e. the class instance) is initialised\n        super(EB_Example, self).__init__(*args, **kwargs)\n\n        # initialise class variables\n        self.example_value = None\n        self.example_list = []\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#file-operations","title":"File operations","text":"<p>File operations is a common use case for implementing easyblocks, hence the EasyBuild framework provides a number of useful functions related to this, including:</p> <ul> <li> <p><code>read_file(&lt;path&gt;)</code>: read file at a specified location and returns its contents;</p> </li> <li> <p><code>write_file(&lt;path&gt;, &lt;text&gt;)</code> at a specified location with provided contents;   to append to an existing file, use <code>append=True</code> as an extra argument;</p> </li> <li> <p><code>copy_file(&lt;src&gt;, &lt;dest&gt;)</code> to copy an existing file;</p> </li> <li> <p><code>apply_regex_substitutions(&lt;path&gt;, &lt;list of regex substitutions&gt;)</code> to patch an existing file;</p> </li> </ul> <p>All of these functions are provided by the <code>easybuild.tools.filetools</code> module.</p>"},{"location":"2021-lust/implementing_easyblocks/#executing-shell-commands","title":"Executing shell commands","text":"<p>For executing shell commands two functions are provided by the <code>easybuild.tools.run</code> module:</p> <ul> <li> <p><code>run_cmd(&lt;cmd&gt;)</code> to run a non-interactive shell command;</p> </li> <li> <p><code>run_cmd_qa(&lt;cmd&gt;, &lt;dict with questions &amp; answers&gt;)</code> to run an interactive shell command;</p> </li> </ul> <p>Both of these accept a number of optional arguments:</p> <ul> <li> <p><code>simple=True</code> to just return <code>True</code> or <code>False</code> to indicate a successful execution,   rather than the default return value, i.e., a tuple that provides the command output and the exit code (in that   order);</p> </li> <li> <p><code>path=&lt;path&gt;</code> to run the command in a specific subdirectory;</p> </li> </ul> <p>The <code>run_cmd_qa</code> function takes two additional specific arguments:</p> <ul> <li> <p><code>no_qa=&lt;list&gt;</code> to specify a list of patterns to recognize non-questions;</p> </li> <li> <p><code>std_qa=&lt;dict&gt;</code> to specify regular expression patterns for common questions, and the matching answer;</p> </li> </ul>"},{"location":"2021-lust/implementing_easyblocks/#manipulating-environment-variables","title":"Manipulating environment variables","text":"<p>To (re)define environment variables, the <code>setvar</code> function provided by the <code>easybuild.tools.environment</code> module should be used.</p> <p>This makes sure that the changes being made to the specified environment variable are kept track of, and that they are handled correctly under <code>--extended-dry-run</code>.</p>"},{"location":"2021-lust/implementing_easyblocks/#logging-and-errors","title":"Logging and errors","text":"<p>It is good practice to include meaningful log messages in the <code>*_step</code> methods being customised in the easyblock, to enrich the EasyBuild log with useful information for later debugging or diagnostics.</p> <p>For logging, the provided <code>self.log</code> logger class should be used. You can use the <code>self.log.info</code> method to log an informative message. Similar methods are available for logging debug messages (<code>self.log.debug</code>), which are only emitted when <code>eb</code> is run with debugging mode enabled (<code>--debug</code> or <code>-d</code>), and for logging warning messages (<code>self.log.warning</code>).</p> <p>If something goes wrong, you can raise an <code>EasyBuildError</code> instance to report the error.</p> <p>For example:</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\nfrom easybuild.tools.build_log import EasyBuildError\nfrom easybuild.tools.run import run_cmd\n\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def configure_step(self):\n\"\"\"Custom implementation of configure step for Example\"\"\"\n\n        cmd = \"./configure --prefix %s\" % self.installdir)\n        out, ec = run_cmd(cmd)\n\n        success = 'SUCCESS'\n        if success in out:\n            self.log.info(\"Configuration command '%s' completed with success.\" % cmd)\n        else:\n            raise EasyBuildError(\"Pattern '%s' was not found in output of '%s'.\" % (success, cmd))\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#custom-sanity-check","title":"Custom sanity check","text":"<p>For software-specific easyblocks, a custom sanity check is usually included to verify that the installation was successful or not.</p> <p>This is done by redefining the <code>sanity_check_step</code> method in the easyblock. For example:</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def sanity_check_step(self):\n\"\"\"Custom sanity check for Example.\"\"\"\n\n        custom_paths = {\n            'files': ['bin/example'],\n            'dirs': ['lib/examples/'],\n        }\n        custom_commands = ['example --version']\n\n        # call out to parent to do the actual sanity checking, pass through custom paths and commands\n        super(EB_Example, self).sanity_check_step(custom_paths=custom_paths, custom_commands=custom_commands)\n</code></pre> <p>You can both specify file paths and subdirectories to check for, which are specified relative to the installation directory, as well as simple commands that should execute successfully after completing the installation and loading the generated module file.</p> <p>It is up to you how extensive you make the sanity check, but it is recommended to make the check as complete as possible to catch any potential build or installation problems that may occur, while ensuring that it can run relatively quickly (in seconds, or at most a couple of minutes).</p>"},{"location":"2021-lust/implementing_easyblocks/#version-specific-parts","title":"Version-specific parts","text":"<p>In some cases version-specific actions or checks need to be included in an easyblock. For this, it is recommended to use <code>LooseVersion</code> rather than directly comparing version numbers using string values.</p> <p>For example:</p> <pre><code>from distutils.version import LooseVersion\nfrom easybuild.framework.easyblock import EasyBlock\n\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def sanity_check_step(self):\n\"\"\"Custom sanity check for Example.\"\"\"\n\n        custom_paths = {\n            'files': [],\n            'dirs': [],\n        }\n\n        # in older versions, the binary used to be named 'EXAMPLE' rather than 'example'\n        if LooseVersion(self.version) &lt; LooseVersion('1.0'):\n            custom_paths['files'].append('bin/EXAMPLE')\n        else:\n            custom_paths['files'].append('bin/example')\n\n        super(EB_Example, self).sanity_check_step(custom_paths=custom_paths)\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#compatibility-with-extended-dry-run-and-module-only","title":"Compatibility with <code>--extended-dry-run</code> and <code>--module-only</code>","text":"<p>Some special care must be taken to ensure that an easyblock is fully compatible with <code>--extended-dry-run</code> / <code>-x</code> (see Inspecting install procedures) and <code>--module-only</code>.</p> <p>For compatibility with <code>--extended-dry-run</code>, you need to take into account that specified operations like manipulating files or running shell commands will not actually be executed. You can check whether an easyblock is being run in dry run mode via <code>self.dry_run</code>.</p> <p>For example:</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\nfrom easybuild.tools.build_log import EasyBuildError\nfrom easybuild.tools.run import run_cmd\n\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def configure_step(self):\n\"\"\"Custom implementation of configure step for Example\"\"\"\n\n        cmd = \"./configure --prefix %s\" % self.installdir)\n        out, ec = run_cmd(cmd)\n\n        success = 'SUCCESS'\n        if success in out:\n            self.log.info(\"Configuration command '%s' completed with success.\" % cmd)\n\n        # take into account that in dry run mode we won't get any output at all\n        elif self.dry_run:\n            self.log.info(\"Ignoring missing '%s' pattern since we're running in dry run mode.\" % success)\n\n        else:\n            raise EasyBuildError(\"Pattern '%s' was not found in output of '%s'.\" % (success, cmd))\n</code></pre> <p>For <code>--module-only</code>, you should make sure that both the <code>make_module_step</code>, including the <code>make_module_*</code> submethods, and the <code>sanity_check_step</code> methods do not make any assumptions about the presence of certain environment variables, or that class variables have been defined already.</p> <p>This is required because under <code>--module-only</code> the large majority of the <code>*_step</code> functions are simply skipped entirely. So, if the <code>configure_step</code> method is responsible for defining class variables that are picked up in <code>sanity_check_step</code>, the latter may run into unexpected initial values like <code>None</code>. A possible workaround is to define a separate custom method to define the class variables, and to call out to this method from <code>configure_step</code> and <code>sanity_check_step</code> (for the latter, conditionally, i.e., only if the class variables still have the initial values).</p> <p>For example:</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\n\n\nclass EB_Example(EasyBlock):\n\"\"\"Custom easyblock for Example\"\"\"\n\n    def __init__(self, *args, **kwargs):\n\"\"\"Easyblock constructor.\"\"\"\n        super(EB_Example, self).__init__(*args, **kwargs)\n\n        self.command = None\n\n    def set_command(self):\n\"\"\"Initialize 'command' class variable.\"\"\"\n        # $CC environment variable set by 'prepare' step determines exact command\n        self.command = self.name + '-' + os.getenv('CC')\n\n    def configure_step(self):\n\"\"\"Custom configure step for Example.\"\"\"\n\n        self.set_command()\n        self.cfg.update('configopts', \"COMMAND=%s\" % self.command)\n\n        super(EB_Example, self).configure_step()\n\n    def sanity_check_step(self):\n\"\"\"Custom implementation of configure step for Example\"\"\"\n\n        if self.command is None:\n            self.set_command()\n\n        super(EB_Example, self).sanity_check_step(custom_commands=[self.command])\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#exercise","title":"Exercise","text":""},{"location":"2021-lust/implementing_easyblocks/#exercise-i1","title":"Exercise I.1","text":"<p>Try implementing a new custom easyblock for <code>eb-tutorial</code>, which derives directly from the base <code>EasyBlock</code> class.</p> <p>Your easyblock should:</p> <ul> <li>define a custom mandatory easyconfig parameter named <code>message</code>;</li> <li>run <code>cmake</code> to configure the installation, which includes at least:<ul> <li>specifying the correct installation prefix (using the <code>-DCMAKE_INSTALL_PREFIX=...</code> option);</li> <li>passing down the value of <code>message</code> easyconfig parameter via <code>-DEBTUTORIAL_MSG=...</code></li> </ul> </li> <li>run <code>make</code> to build <code>eb-tutorial</code>;</li> <li>run <code>make install</code> to install the generated binary;</li> <li>perform a custom sanity check to ensure the installation is correct;</li> <li>pick up on commonly used easyconfig parameters like <code>configopts</code> and <code>preinstallopts</code> where appropriate;</li> </ul> (click to show solution) <p>Here's a complete custom easyblock for <code>eb-tutorial</code> that derives from the base <code>EasyBlock</code> class, which should be included in a file named <code>eb_tutorial.py</code>.</p> <p>We need to implement the <code>configure_step</code>, <code>build_step</code>, and <code>install_step</code> methods in order to have a fully functional easyblock.</p> <p>The configure, build, and install steps take into account the corresponding easyconfig parameters that allow customizing these commands from an easyconfig file.</p> <pre><code>from easybuild.framework.easyblock import EasyBlock\nfrom easybuild.framework.easyconfig import MANDATORY\nfrom easybuild.tools.run import run_cmd\n\n\nclass EB_eb_minus_tutorial(EasyBlock):\n\"\"\"Custom easyblock for eb-tutorial.\"\"\"\n\n    @staticmethod\n    def extra_options():\n        extra = EasyBlock.extra_options()\n        extra.update({\n            'message': [None, \"Message that eb-tutorial command should print\", MANDATORY],\n        })\n        return extra\n\n    def configure_step(self):\n\"\"\"Custom configure step for eb-tutorial: define EBTUTORIAL_MSG configuration option.\"\"\"\n\n        cmd = ' '.join([\n            self.cfg['preconfigopts'],\n            \"cmake\",\n            \"-DCMAKE_INSTALL_PREFIX='%s'\" % self.installdir,\n            \"-DEBTUTORIAL_MSG='%s'\" % self.cfg['message'],\n            self.cfg['configopts'],\n        ])\n        run_cmd(cmd)\n\n    def build_step(self):\n\"\"\"Build step for eb-tutorial\"\"\"\n\n        cmd = ' '.join([\n            self.cfg['prebuildopts'],\n            \"make\",\n            self.cfg['buildopts'],\n        ])\n        run_cmd(cmd)\n\n    def install_step(self):\n\"\"\"Install step for eb-tutorial\"\"\"\n\n        cmd = ' '.join([\n            self.cfg['preinstallopts'],\n            \"make install\",\n            self.cfg['installopts'],\n        ])\n        run_cmd(cmd)\n\n    def sanity_check_step(self):\n        custom_paths = {\n            'files': ['bin/eb-tutorial'],\n            'dirs': [],\n        }\n        custom_commands = ['eb-tutorial']\n        return super(EB_eb_minus_tutorial, self).sanity_check_step(custom_paths=custom_paths,\n                                                                   custom_commands=custom_commands)\n</code></pre>"},{"location":"2021-lust/implementing_easyblocks/#exercise-i2","title":"Exercise I.2","text":"<p>Try implementing another new custom easyblock for <code>eb-tutorial</code>, which derives from the generic <code>CMakeMake</code> easyblock.</p> <p>Your easyblock should only:</p> <ul> <li>define a custom mandatory easyconfig parameter named <code>message</code>;</li> <li>pass down the value of <code>message</code> easyconfig parameter via <code>-DEBTUTORIAL_MSG=...</code></li> <li>perform a custom sanity check to ensure the installation is correct;</li> </ul> (click to show solution) <p>When deriving from the <code>CMakeMake</code> generic easyblock, there is a lot less to worry about.</p> <p>We only need to customize the <code>configure_step</code> method to ensure that the <code>-DEBTUTORIAL_MSG</code> configuration option is specified; the <code>CMakeMake</code> easyblock already takes care of specifying the location of the installation directory (and a bunch of other configuration options, like compiler commands and flags, etc.).</p> <p>Implementing the <code>build_step</code> and <code>install_step</code> methods is no longer needed, the standard procedure that is run by the <code>CMakeMake</code> generic easyblock is fine, and even goes beyond what we did in the previous exercise (like building in parallel with <code>make -j</code>).</p> <pre><code>from easybuild.easyblocks.generic.cmakemake import CMakeMake\nfrom easybuild.framework.easyconfig import MANDATORY\nfrom easybuild.tools.run import run_cmd\n\nclass EB_eb_minus_tutorial(CMakeMake):\n\"\"\"Custom easyblock for eb-tutorial.\"\"\"\n\n    @staticmethod\n    def extra_options():\n        extra = CMakeMake.extra_options()\n        extra.update({\n            'message': [None, \"Message that eb-tutorial command should print\", MANDATORY],\n        })\n        return extra\n\n    def configure_step(self):\n\"\"\"Custom configure step for eb-tutorial: define EBTUTORIAL_MSG configuration option.\"\"\"\n        self.cfg.update('configopts', \"-DEBTUTORIAL_MSG='%s'\" % self.cfg['message'])\n\n        super(EB_eb_minus_tutorial, self).configure_step()\n\n    def sanity_check_step(self):\n        custom_paths = {\n            'files': ['bin/eb-tutorial'],\n            'dirs': [],\n        }\n        custom_commands = ['eb-tutorial']\n        return super(EB_eb_minus_tutorial, self).sanity_check_step(custom_paths=custom_paths,\n                                                                   custom_commands=custom_commands)\n</code></pre>"},{"location":"2021-lust/installation/","title":"Installing EasyBuild","text":"<p>[back: Terminology]</p> <p>Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild.</p> <p>In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial.</p> <p>Summary</p> <ul> <li>Requirements: Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended).</li> <li>Installation methods:<ul> <li><code>pip install easybuild</code></li> <li>installing EasyBuild with EasyBuild</li> <li>development setup</li> </ul> </li> <li>Verify EasyBuild installation using <code>eb --version</code> and <code>eb --help</code>.</li> </ul>"},{"location":"2021-lust/installation/#requirements","title":"Requirements","text":""},{"location":"2021-lust/installation/#linux","title":"Linux","text":"<p>The main target platform for EasyBuild is Linux, since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux).</p> <p>EasyBuild is also compatible with macOS, but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project.</p>"},{"location":"2021-lust/installation/#python","title":"Python","text":"<p>EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3).</p> <p>To check which Python version you have, use:</p> <pre><code>python -V\n</code></pre> <p>No additional Python packages are required by EasyBuild, the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.</p>"},{"location":"2021-lust/installation/#environment-modules-tool","title":"Environment modules tool","text":"<p>An environment modules tool is required for using EasyBuild.</p> <p>We strongly recommend using Lmod, a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported.</p> <p>To check if you have a modules tool installed, use:</p> <pre><code>module --version\n</code></pre> <p>If this produces output that starts with something like \"<code>Modules based on Lua: Version 8.2.5</code>\" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. </p> <p>If you see output that starts with a line like \"<code>VERSION=3.2.10</code>\" or \"<code>Modules Release 4.5.0</code>\", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation.</p> <p>If the <code>module</code> function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.</p>"},{"location":"2021-lust/installation/#easybuild-as-a-python-package","title":"EasyBuild as a Python package","text":"<p>EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders, as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild.</p> <p>As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation.</p> <p>Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry.</p> <p>You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like <code>pip</code>, <code>virtualenv</code>, <code>pipenv</code>, ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!</p>"},{"location":"2021-lust/installation/#python-2-or-python-3","title":"Python 2 or Python 3?","text":"<p>For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life, we strongly recommend using Python 3 if you have the choice.</p> <p>By default EasyBuild will use the <code>python</code> command to run, but you can control this if needed via <code>$EB_PYTHON</code>.</p>"},{"location":"2021-lust/installation/#installing-easybuild_1","title":"Installing EasyBuild","text":"<p>We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation.</p> <p>Time to get your hands dirty!</p> <ul> <li>Method 1: Using <code>pip</code></li> <li>Method 2: installing EasyBuild with EasyBuild</li> <li>Method 3: Development setup</li> </ul>"},{"location":"2021-lust/installation/#method-1-using-pip","title":"Method 1: Using <code>pip</code>","text":"<p>Since EasyBuild is released as a Python package on PyPI you can install it using <code>pip</code>, the most commonly used tool for installing Python packages.</p> <p>You may need to take additional steps after the installation, depending on the exact installation command.</p> <p>Note</p> <p>There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like <code>virtualenv</code> or <code>pipenv</code>, feel free to use those instead to install EasyBuild.</p>"},{"location":"2021-lust/installation/#running-pip-install","title":"Running <code>pip install</code>","text":"<p>Installing EasyBuild with <code>pip</code> is as simple as running the following command:</p> <pre><code>pip install easybuild\n</code></pre> <p>However, you may need to slightly change this command depending on the context and your personal preferences:</p> <ul> <li> <p>To install EasyBuild system-wide, you can use <code>sudo</code> (if you have admin privileges):   <pre><code>sudo pip install easybuild\n</code></pre></p> </li> <li> <p>To install EasyBuild in your personal home directory, you can use the <code>--user</code> option:   <pre><code>pip install --user easybuild\n</code></pre>   This will result in an EasyBuild installation in <code>$HOME/.local/</code>.</p> </li> <li> <p>To install EasyBuild in a specific directory you can use the <code>--prefix</code> option:   <pre><code>pip install --prefix _PREFIX_ easybuild\n</code></pre>   In this command, you should replace '<code>_PREFIX_</code>' with the location where you want to have EasyBuild installed   (for example, <code>$HOME/tools</code> or <code>/tmp/$USER</code>).</p> </li> </ul>"},{"location":"2021-lust/installation/#pip-vs-pip3","title":"<code>pip</code> vs <code>pip3</code>","text":"<p>On systems where both Python 2 and Python 3 are installed you may also have different <code>pip</code> commands available. Or maybe <code>pip</code> is not available at all, and only \"versioned\" <code>pip</code> commands like <code>pip3</code> are available.</p> <p>If you (only) have <code>pip3</code> available, you can replace <code>pip</code> with <code>pip3</code> in any of the <code>pip install</code> commands above.</p> <p>If you want to ensure that you are using the <code>pip</code> installation that corresponds to the Python 3 installation that you intend to use, you can use <code>python3 -m pip</code> rather than <code>pip3</code>.</p>"},{"location":"2021-lust/installation/#updating-your-environment","title":"Updating your environment","text":"<p>If you used the <code>--user</code> or <code>--prefix</code> option in the <code>pip install</code> command, or if you installed EasyBuild with a <code>pip</code> version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version.</p> <p>Note</p> <p>Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update one of the shell startup scripts in your home directory (<code>.bashrc</code> for example).</p>"},{"location":"2021-lust/installation/#updating-path","title":"Updating <code>$PATH</code>","text":"<p>Update the <code>$PATH</code> environment variable to make sure the <code>eb</code> command is available: <pre><code>export PATH=_PREFIX_/bin:$PATH\n</code></pre> Replace '<code>_PREFIX_</code>' in this command with the directory path where EasyBuild was installed into (use <code>$HOME/.local</code> if you used <code>pip install --user</code>).</p> <p>This is not required if you installing EasyBuild in a standard system location.</p> <p>You can check with the <code>which eb</code> command to determine whether or not you need to update the <code>$PATH</code> environment variable.</p>"},{"location":"2021-lust/installation/#updating-pythonpath","title":"Updating <code>$PYTHONPATH</code>","text":"<p>If you installed EasyBuild to a non-standard location using <code>pip install --prefix</code>, you also need to update the Python search path environment variable <code>$PYTHONPATH</code> to instruct Python where it can find the EasyBuild Python packages.</p> <p>This is not required if you used the <code>--user</code> option, since Python will automatically consider <code>$HOME/.local</code> when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location.</p> <p>Update <code>$PYTHONPATH</code> by running a command like:</p> <pre><code>export PYTHONPATH=_PREFIX_/lib/pythonX.Y/site-packages:$PYTHONPATH\n</code></pre> <p>Here, you need to replace the <code>X</code> and <code>Y</code> with the major and minor version of your Python installation, which you can determine by running <code>python -V</code>. For example, if you are using Python 3.6, make sure you are using <code>/python3.6/</code> in the command to update <code>$PYTHONPATH</code>.</p> <p>And of course, you again need to replace '<code>_PREFIX_</code>' with the installation prefix where EasyBuild was installed into.</p> <p>For example:</p> <pre><code># update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6\nexport PYTHONPATH=$HOME/tools/lib/python3.6/site-packages:$PYTHONPATH\n</code></pre>"},{"location":"2021-lust/installation/#setting-eb_python","title":"Setting <code>$EB_PYTHON</code>","text":"<p>If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the <code>python</code> command that should be used by the <code>eb</code> command via the <code>$EB_PYTHON</code> environment variable.</p> <p>This may be required when you installing EasyBuild with a version of <code>pip</code> that does not correspond with the default Python version.</p> <p>For example, to ensure that <code>eb</code> uses <code>python3.6</code>:</p> <pre><code>export EB_PYTHON=python3.6\n</code></pre>"},{"location":"2021-lust/installation/#setting-eb_verbose","title":"Setting <code>$EB_VERBOSE</code>","text":"<p>To determine which <code>python</code> commands are being considered by the <code>eb</code> command, you can define the <code>$EB_VERBOSE</code> environment variable. For example:</p> <pre><code>$ EB_VERBOSE=1 eb --version\n&gt;&gt; Considering 'python3.6'...\n&gt;&gt; 'python3' version: 3.6.8, which matches Python 3 version requirement (&gt;= 3.5)\n&gt;&gt; Selected Python command: python3 (/usr/bin/python3.6)\n&gt;&gt; python3.6 -m easybuild.main --version\nThis is EasyBuild 4.3.3 (framework: 4.3.3, easyblocks: 4.3.3) on host example\n</code></pre>"},{"location":"2021-lust/installation/#method-2-installing-easybuild-with-easybuild","title":"Method 2: Installing EasyBuild with EasyBuild","text":"<p>Note</p> <p>This section covers an alternative method for installing EasyBuild.</p> <p>If you already have EasyBuild installed through <code>pip</code>, you can skip ahead to the next section.</p> <p>If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps:</p> <ul> <li>Step 1: Installing EasyBuild with <code>pip</code> into a temporary location (only needed if EasyBuild is not installed yet)</li> <li>Step 2: Using EasyBuild to install EasyBuild as a module</li> <li>Step 3: Loading the EasyBuild module</li> </ul> <p>Note</p> <p>A bootstrap script is available that automates this procedure, but is known to be problematic in some contexts, and is not being actively maintained anymore.</p> <p>As a result, we do not recommend using the bootstrap script anymore.</p>"},{"location":"2021-lust/installation/#step-1-installing-easybuild-into-a-temporary-location","title":"Step 1: Installing EasyBuild into a temporary location","text":"<p>If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using <code>pip</code>.</p> <p>For example, to install EasyBuild into a subdirectory <code>/tmp/$USER</code> using the default Python 3 version:</p> <pre><code># pick installation prefix, and install EasyBuild into it\nexport EB_TMPDIR=/tmp/$USER/eb_tmp\npython3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild\n</code></pre> <pre><code># update environment to use this temporary EasyBuild installation\nexport PATH=$EB_TMPDIR/bin:$PATH\nexport PYTHONPATH=$(/bin/ls -rtd -1 $EB_TMPDIR/lib*/python*/site-packages | tail -1):$PYTHONPATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2021-lust/installation/#step-2-using-easybuild-to-install-easybuild","title":"Step 2: Using EasyBuild to install EasyBuild","text":"<p>Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too.</p> <p>You can use the <code>eb --install-latest-eb-release</code> command for this, combined with the <code>--prefix</code> option to control which directories are used by EasyBuild for the installation.</p> <p>For example, to install the latest version of EasyBuild as a module into <code>$HOME/easybuild</code>:</p> <pre><code>eb --install-latest-eb-release --prefix $HOME/easybuild\n</code></pre> <p>Note</p> <p>You may see a harmless deprecation warning popping up when performing this installation, just ignore it.</p>"},{"location":"2021-lust/installation/#step-3-loading-the-easybuild-module","title":"Step 3: Loading the EasyBuild module","text":"<p>Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session.</p> <p>First, make the module available by running the following command (which will update the module search path environment variable <code>$MODULEPATH</code>):</p> <pre><code>module use _PREFIX_/modules/all\n</code></pre> <p>Replace '<code>_PREFIX_</code>' with the path to the directory that you used when running step 2 (for example, <code>$HOME/easybuild</code>).</p> <p>Then, load the <code>EasyBuild</code> module to update your environment and make EasyBuild available for use:</p> <pre><code>module load EasyBuild\n</code></pre> <p>Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made.</p>"},{"location":"2021-lust/installation/#method-3-development-setup","title":"Method 3: Development setup","text":"<p>If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there.</p> <p>This can be done as follows (into <code>$HOME/easybuild</code>):</p> <pre><code>mkdir -p $HOME/easybuild\ncd $HOME/easybuild\n</code></pre> <p><pre><code># clone EasyBuild repositories from GitHub\ngit clone https://github.com/easybuilders/easybuild-framework.git\ngit clone https://github.com/easybuilders/easybuild-easyblocks.git\ngit clone https://github.com/easybuilders/easybuild-easyconfigs.git\n</code></pre> <pre><code># update environment for running EasyBuild from there\nexport PATH=$HOME/easybuild/easybuild-framework:$PATH\nexport PYTHONPATH=$HOME/easybuild/easybuild-framework:$HOME/easybuild/easybuild-easyblocks:$HOME/easybuild/easybuild-easyconfigs:$PYTHONPATH\n\n# control which Python command is used to run EasyBuild\nexport EB_PYTHON=python3\n</code></pre></p>"},{"location":"2021-lust/installation/#verifying-the-installation","title":"Verifying the installation","text":"<p>Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:</p>"},{"location":"2021-lust/installation/#checking-the-version","title":"Checking the version","text":"<p>To check which EasyBuild version you have installed, run:</p> <pre><code>eb --version\n</code></pre> <p>The output should match with the latest EasyBuild version.</p>"},{"location":"2021-lust/installation/#consulting-the-help-output","title":"Consulting the help output","text":"<p>You can consult the help output of the <code>eb</code> command, which produces a long list of available options along with a short informative message.</p> <pre><code>eb --help\n</code></pre>"},{"location":"2021-lust/installation/#showing-the-default-easybuild-configuration","title":"Showing the default EasyBuild configuration","text":"<p>To inspect the current EasyBuild configuration, you can use this command:</p> <pre><code>eb --show-config\n</code></pre> <p>This should tell you that EasyBuild (ab)uses <code>$HOME/.local/easybuild</code> as a default location. More on configuring EasyBuild in the next part of the tutorial.</p>"},{"location":"2021-lust/installation/#system-information","title":"System information","text":"<p>You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command:</p> <pre><code>eb --show-system-info\n</code></pre>"},{"location":"2021-lust/installation/#updating-easybuild","title":"Updating EasyBuild","text":"<p>Before we wrap up here, a brief word about updating EasyBuild.</p> <p>Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module:</p> <pre><code>eb --install-latest-eb-release\n</code></pre> <p>This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration.</p> <p>If you have installed EasyBuild through <code>pip</code>, and you prefer updating that installation, you can use <code>pip install --upgrade easybuild</code> (perhaps with additional options like <code>--user</code> or <code>--prefix</code>).</p>"},{"location":"2021-lust/installation/#exercise","title":"Exercise","text":"<p>Install EasyBuild in your home directory.</p> <p>Make sure that the EasyBuild installation uses the <code>python3</code> command to run, rather than the standard <code>python</code> command.</p> <p>Choose your own adventure, or try all these installation methods!</p> <ul> <li>install EasyBuild with <code>pip</code> (or another very similar command...) using either the <code>--user</code> or <code>--prefix</code> option;</li> <li>perform a (manual) \"bootstrap\" installation into <code>$HOME/easybuild</code>, as outlined in installation method 2;</li> <li>set up a development installation;</li> </ul> <p>Check that the installation works by running the verification commands outlined above.</p> <p>Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial!</p> <p>[next: Configuring EasyBuild]</p>"},{"location":"2021-lust/module_naming_schemes/","title":"Module naming schemes","text":"<p>Up until now we have used EasyBuild's default module naming scheme (<code>EasyBuildMNS</code>), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing <code>h5py-3.1.0-foss-2020b.eb</code> the generated module was named <code>h5py/3.1.0-foss-2020b</code>.</p> <p>EasyBuild supports several different module naming schemes:</p> <pre><code>$ eb --avail-module-naming-schemes\nList of supported module naming schemes:\n    CategorizedHMNS\n    CategorizedModuleNamingScheme\n    EasyBuildMNS\n    HierarchicalMNS\n    MigrateFromEBToHMNS\n</code></pre> <p>In this part of the tutorial we will take a closer look at <code>HierarchicalMNS</code>, which is the standard hierarchical module naming scheme included with EasyBuild.</p> <p>We will also take a quick look at implementing our own custom module naming scheme.</p>"},{"location":"2021-lust/module_naming_schemes/#flat-vs-hierarchical","title":"Flat vs hierarchical","text":"<p>The default module naming scheme <code>EasyBuildMNS</code> is an example of regular \"flat\" module naming scheme, which is characterized by:</p> <ul> <li>all module files are directly available for loading;</li> <li>each module name uniquely identifies a particular installation;</li> </ul> <p>In contrast, a hierarchical module naming scheme consists of a hierarchy of module files.</p> <p>The typical module hierarchy has 3 levels:</p> <ul> <li>a core level, where module files for software that was installed using the   <code>system</code> toolchain are kept;</li> <li>a compiler level, where module files for software that was installed using a compiler-only toolchain are stored;</li> <li>and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component;</li> </ul> <p>Here is a simple example of such a 3-level module hierarchy:</p> <p>In this example the core level only includes a single module <code>GCC/9.3.0</code>, while  the compiler level includes two modules: <code>OpenMPI/4.0.3</code> and <code>MPICH/3.3.2</code>. In the MPI level, three modules are available: one for <code>FFTW</code>, one for <code>ScaLAPACK</code>, and one for <code>HDF5</code>.</p> <p>Initially only the modules on the top level of a module hierarchy are available for loading. If you run \"<code>module avail</code>\" with the example module hierarchy, you will only see the <code>GCC/9.3.0</code> module.</p> <p>Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our exampe, loading the <code>GCC/9.3.0</code> module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for <code>OpenMPI</code> and <code>MPICH</code>. These correspond to installations of <code>OpenMPI</code> and <code>MPICH</code> that were built using <code>GCC/9.3.0</code> as a (compiler-only) toolchain.</p> <p>Similarly, the <code>OpenMPI/4.0.3</code> module serves as a gateway to the three modules in the MPI level. Only by loading the <code>OpenMPI</code> module will these additional three modules become available for loading. They correspond to software installations built using the <code>gompi/2020a</code> toolchain that consists of the <code>GCC/9.3.0</code> compiler module and the <code>OpenMPI/4.0.3</code> MPI module. Software installed using <code>foss/2020a</code> (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy.</p> <p>The characteristics of a module hierarchy are:</p> <ul> <li>not all module files are directly available for loading;</li> <li>some modules serve as a gateway to more modules;</li> <li>to access some software installations you will first need to load one or more gateway modules in order   to use them;</li> </ul> <p>You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard core / compiler / MPI hierarchy.</p>"},{"location":"2021-lust/module_naming_schemes/#pros-cons","title":"Pros &amp; cons","text":"<p>So why go through all this trouble of organizing modules hierarchically?</p> <p>There are a couple of advantages to this approach:</p> <ul> <li>shorter module names;</li> <li>less overwhelming list of available modules;</li> <li>only compatible modules can be loaded together;</li> </ul> <p>However, the are some minor disadvantages too:</p> <ul> <li>not all existing modules are directly visible;</li> <li>gateway modules may have little meaning to end users;</li> </ul>"},{"location":"2021-lust/module_naming_schemes/#length-of-module-names","title":"Length of module names","text":"<p>When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our <code>HDF5</code> installation for example, we have <code>HDF5/1.10.6-gompi-2020a</code> as module name. The <code>-gompi-2020a</code> part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!).</p> <p>In the example module hierarchy shown above, the module for <code>HDF5</code> is named <code>HDF5/1.10.6</code> which is basically the bare essentials: software name and version. That's way better, nice and clean!</p>"},{"location":"2021-lust/module_naming_schemes/#amount-of-available-modules","title":"Amount of available modules","text":"<p>The output of \"<code>module avail</code>\" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands...</p> <p>This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded.</p>"},{"location":"2021-lust/module_naming_schemes/#loading-compatible-modules","title":"Loading compatible modules","text":"<p>Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other.</p> <p>Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful...</p> <p>In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily.</p>"},{"location":"2021-lust/module_naming_schemes/#visibility-of-existing-modules","title":"Visibility of existing modules","text":"<p>One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \"<code>module avail</code>\" only shows a subset of all modules.</p> <p>Lmod has a solution for this though: it provides a separate \"<code>module spider</code>\" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \"<code>module spider</code>\" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.</p>"},{"location":"2021-lust/module_naming_schemes/#semantics-of-gateway-modules","title":"Semantics of gateway modules","text":"<p>An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline...</p> <p>This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \"<code>module spider</code>\" command to navigate the module hierarchy.</p>"},{"location":"2021-lust/module_naming_schemes/#using-a-custom-module-naming-scheme","title":"Using a custom module naming scheme","text":"<p>Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it.</p>"},{"location":"2021-lust/module_naming_schemes/#implementation","title":"Implementation","text":"<p>To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general <code>ModuleNamingScheme</code> class.</p> <p>For a flat module naming scheme, it is sufficient to implement the <code>det_full_module_name</code> method, which should return a string value (the full module name). You may also need to customize the <code>is_short_modname_for</code> method, which verifies whether a given (short) module name is for the software with a particular given name (or not).</p> <p>The argument provided to <code>det_full_module_name</code> can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters (<code>name</code>, <code>version</code>, <code>toolchain</code>, and <code>versionsuffix</code>), or an <code>EasyConfig</code> instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters.</p> <p>For simple module naming schemes, just have <code>name</code>, <code>version</code>, <code>toolchain</code>, and <code>versionsuffix</code> available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant <code>REQUIRED_KEYS</code>.</p> <p>A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme <code>EasyBuildMNS</code>.</p> <p>For a hierarchical module naming scheme, various additional methods have to be implemented.</p> <p>Some of these, like <code>det_module_subdir</code> and <code>det_short_module_name</code>, determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like <code>det_modpath_extensions</code>, determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the <code>$MODULEPATH</code>).</p> <p>A typical example of a hierarchical module naming scheme is <code>HierarchicalMNS</code> that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional <code>Core</code>-<code>Compiler</code>-<code>MPI</code> module hierarchy we discussed above.</p>"},{"location":"2021-lust/module_naming_schemes/#configuring-easybuild","title":"Configuring EasyBuild","text":"<p>To let EasyBuild use a custom module naming scheme, you need to:</p> <ul> <li> <p>specify the path to the Python module file implementing it via the <code>include-module-naming-schemes</code>   EasyBuild configuration option;</p> </li> <li> <p>indicate that you also want to use this custom module naming scheme via the <code>module-naming-scheme</code>   EasyBuild configuration option.</p> </li> </ul> <p>For example:</p> <pre><code>export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES=$HOME/easybuild/example_mns.py\nexport EASYBUILD_MODULE_NAMING_SCHEME=ExampleMNS\n</code></pre>"},{"location":"2021-lust/module_naming_schemes/#example-custom-module-naming-scheme","title":"Example custom module naming scheme","text":"<p>Here is an example of a custom module naming scheme, where:</p> <ul> <li>the <code>versionsuffix</code> goes directly after the <code>version</code>;</li> <li>all dashes are replaced by underscores;</li> <li>all module names are lowercase;</li> </ul> <p>Note that we also need to customise the <code>is_short_modname_for</code> method, to make sure it returns <code>True</code> when the EasyBuild framework checks whether <code>scipy_bundle/2020.11_foss_2020b</code> is a module name for <code>SciPy-bundle</code>.</p> <pre><code>import os\n\nfrom easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme\n\n\nclass ExampleMNS(ModuleNamingScheme):\n\n    REQUIRED_KEYS = ['name', 'version', 'versionsuffix', 'toolchain']\n\n    def det_full_module_name(self, ec):\n\"\"\"\n        Determine full module name:\n        - all lowercase\n        - replace all dashes with underscores\n        \"\"\"\n        parts = [ec['version']]\n\n        # versionsuffix directly after version (but only if it's not empty)\n        if ec['versionsuffix']:\n            parts.append(ec['versionsuffix'])\n\n        # only add toolchain name/version for non-system toolchain\n        tc = ec['toolchain']\n        if tc['name'].lower() != 'system':\n            parts.extend([tc['name'], tc['version']])\n\n        modname = ec['name'] + '/' + '_'.join(parts)\n\n        modname = modname.replace('-', '_').replace('__', '_')\n\n        return modname.lower()\n\n    def is_short_modname_for(self, short_modname, name):\n\"\"\"Determine whether short module name is a module for the software with specified name.\"\"\"\n        return short_modname.startswith(name.lower().replace('-', '_') + '/')\n</code></pre> <p>We can see what the module names with this module naming scheme would like like via <code>eb -D</code>:</p> <pre><code>$ eb SciPy-bundle-2020.11-foss-2020b-Python-2.7.18.eb -D\n ...\n * [ ] $CFGS/g/GCC/GCC-10.2.0.eb (module: gcc/10.2.0)\n ...\n * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-10.2.0.eb (module: python/2.7.18_gcccore_10.2.0)\n ...\n * [ ] $CFGS/o/OpenMPI/OpenMPI-4.0.5-GCC-10.2.0.eb (module: openmpi/4.0.5_gcc_10.2.0)\n ...\n * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2020.03-foss-2020a-Python-2.7.18.eb (module: scipy_bundle/2020.03_python_2.7.18_foss_2020a)\n</code></pre>"},{"location":"2021-lust/module_naming_schemes/#example-module-hierarchy-hdf5","title":"Example module hierarchy: HDF5","text":"<p>Warning</p> <p>This exercise will only work if you have write access to the software installation prefix, because EasyBuild will try to copy the installation log file to each installlation directory.</p> <p>Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree.</p> <p>In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment.</p> <p>The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.</p>"},{"location":"2021-lust/module_naming_schemes/#preparing-the-environment","title":"Preparing the environment","text":"<p>Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment.</p> <p>We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme!</p> <p>Some module files will have the same name in both module trees (like <code>GCC/10.2.0</code> for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems...</p> <p>So we have to make sure that the module files we already have in <code>/easybuild</code> are not visible. The easiest way to do this is to unload all modules (using \"<code>module purge</code>\") and resetting the module search path to be empty, which we can do with \"<code>module unuse $MODULEPATH</code>\".</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> <p>In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue.</p> <p>We strongly recommend using an EasyBuild installation that was installed via \"<code>pip install</code>\" or \"<code>pip3 install</code>\" in this part of the tutorial.</p> <p>An easy way to do this is in the prepared environment is to run:</p> <pre><code>pip3 install --user easybuild\nexport PATH=$HOME/.local/bin:$PATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2021-lust/module_naming_schemes/#configuring-easybuild_1","title":"Configuring EasyBuild","text":"<p>First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_INSTALLPATH_SOFTWARE=/easybuild/software\nexport EASYBUILD_MODULE_NAMING_SCHEME=HierarchicalMNS\nexport EASYBUILD_INSTALLPATH_MODULES=$HOME/hmns/modules\n</code></pre> <p>To make sure we didn't make any silly mistakes, we double check using <code>eb --show-config</code>:</p> <pre><code>$ eb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath            (E) = /tmp/example\ncontainerpath        (E) = /home/example/easybuild/containers\ninstallpath          (E) = /home/example/easybuild\ninstallpath-modules  (E) = /home/example/hmns/modules\ninstallpath-software (E) = /easybuild/software\nmodule-naming-scheme (E) = HierarchicalMNS\npackagepath          (E) = /home/example/easybuild/packages\nprefix               (E) = /home/example/easybuild\nrepositorypath       (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths          (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath           (E) = /home/example/easybuild/sources\n</code></pre> <p>There are a couple of things worth pointing out here:</p> <ul> <li>We have defined the <code>module-naming-scheme</code> configuration setting to <code>HierarchicalMNS</code>,   which makes EasyBuild use the included standard hierarchical module naming scheme (the classic   core / compiler / MPI one we discussed above).</li> <li>We have specified different locations for the software (via <code>installpath-software</code>)   and the module files (via <code>installpath-modules</code>). This is important because we want to   reuse the software that is already installed in <code>/easybuild/software</code> while we want to   generate an entirely new module tree for it (in <code>$HOME/hmns/modules</code>).</li> </ul> <p>The other configuration settings are the same as before, and mostly irrelevant for this example.</p>"},{"location":"2021-lust/module_naming_schemes/#generating-modules-for-hdf5","title":"Generating modules for HDF5","text":"<p>Let us now generate a hierarchical module tree for <code>HDF5</code> and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us.</p> <p>The steps we will have to go through are:</p> <ul> <li>Tell EasyBuild we want to \"install\" the <code>HDF5-1.10.7-gompi-2020b.eb</code> easyconfig file;</li> <li>Enable dependency resolution via <code>--robot</code>;</li> <li>Instruct EasyBuild to only generate the module files, not to install the software (since it is   there already in <code>/easybuild/software</code>), via the <code>--module-only</code> option.</li> </ul> <p>These steps translate to this single <code>eb</code> command:</p> <pre><code>$ eb HDF5-1.10.7-gompi-2020b.eb --robot --module-only\n...\n== building and installing MPI/GCC/10.2.0/OpenMPI/4.0.5/HDF5/1.10.7...\n...\n== sanity checking...\n== cleaning up [skipped]\n== creating module...\n...\n== COMPLETED: Installation ended successfully (took 9 sec)\n...\n== Build succeeded for 41 out of 41\n</code></pre> <p>This should take a couple of minutes in total, for generating 41 modules. Remember that this also includes generating module files for the toolchain and all of its components.</p> <p>In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using <code>--module-only</code> to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...</p>"},{"location":"2021-lust/module_naming_schemes/#loading-the-hdf5-module","title":"Loading the HDF5 module","text":"<p>After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it?</p> <p>Here's what the module tree looks like on disk:</p> <pre><code>$ ls $HOME/hmns/modules/all\nCompiler  Core  MPI\n</code></pre> <p>Those are basically the 3 levels in the module hierarchy we showed in our example earlier.</p> <p>The starting point is the top level of the module hierarchy named <code>Core</code>:</p> <pre><code>module use $HOME/hmns/modules/all/Core\n</code></pre> <p>Let us see what that gives us in terms of available modules:</p> <pre><code>$ module avail\n\n--------------------- /home/easybuild/hmns/modules/all/Core ---------------------\n   Bison/3.5.3        GCCcore/10.2.0    flex/2.6.4      help2man/1.47.4\n   Bison/3.7.1 (D)    M4/1.4.18         gettext/0.21    ncurses/6.2\n   GCC/10.2.0         binutils/2.35     gompi/2020b     zlib/1.2.11\n</code></pre> <p>Nice and short module names, but only a limited set of them.</p> <p>We know a module file exists for <code>HDF5</code>, but we can't see it yet (and hence we can't load it either).</p> <pre><code>$ module avail HDF5\nNo module(s) or extension(s) found!\nUse \"module spider\" to find all possible modules and extensions.\n</code></pre> <p>Let us see if <code>module spider</code> is of any help, as \"<code>module avail</code>\" so kindly suggests:</p> <pre><code>$ module spider HDF5\n...\n\n    You will need to load all module(s) on any one of the lines below\n    before the \"HDF5/1.10.7\" module is available to load.\n\n      GCC/10.2.0  OpenMPI/4.0.5\n</code></pre> <p>This tells us we need to load two gateway modules before we can load the module for HDF5.</p> <p>Let us start with loading the <code>GCC</code> compiler module:</p> <pre><code>module load GCC/10.2.0\n</code></pre> <p>And then check again which modules are available:</p> <pre><code>$ module avail\n\n-------------- /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 --------------\n   OpenMPI/4.0.5\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCCcore/10.2.0 ------------\n   Autoconf/2.69             UCX/1.9.0                 libpciaccess/0.16\n   ...\n   Szip/2.1.1                libfabric/1.11.0          zlib/1.2.11        (L,D)\n   Autoconf/2.69         XZ/5.2.5                libtool/2.4.6\n\n--------------------- /home/easybuild/hmns/modules/all/Core ---------------------\n   Bison/3.5.3        GCCcore/10.2.0 (L)  flex/2.6.4      help2man/1.47.4\n   Bison/3.7.1 (D)    M4/1.4.18           gettext/0.21    ncurses/6.2\n   GCC/10.2.0  (L)    binutils/2.35       gompi/2020b     zlib/1.2.11\n</code></pre> <p>Good news, we now have additional modules available!</p> <p>The compiler level of our hierarchy actually consists of two directories here: <code>Compiler/GCCcore/10.2.0</code> and <code>Compiler/GCC/10.2.0</code>. The modules in the <code>GCCcore</code> directory are ones we can use in other compiler toolchains that use GCC 10.2.0 as a base compiler (the details of that are out of scope here).</p> <p>The module we are interested in is <code>OpenMPI/4.0.5</code>, which is another gateway module.</p> <p>Remember that the \"<code>module spider</code>\" output told us that there does indeed exist a module for <code>HDF5</code>, but that we need to load both the <code>GCC/10.2.0</code> and <code>OpenMPI/4.0.5</code> modules first.</p> <p>So, let us do exactly that (remember that <code>GCC/10.2.0</code> is already loaded):</p> <pre><code>module load OpenMPI/4.0.5\n</code></pre> <p>If you now check the output of \"<code>module avail</code>\" again, you should see the <code>HDF5/1.10.7</code> module:</p> <pre><code>$ module avail\n\n-------- /home/easybuild/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 -------\n   HDF5/1.10.7\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCC/10.2.0 ------------\n   OpenMPI/4.0.5 (L)\n\n...\n</code></pre> <p>To use HDF5, we need to load this <code>HDF5/1.10.7</code> module. We can verify that the installation works using one of the commands provided by HDF5, <code>h5dump</code> for example:</p> <pre><code>module load HDF5/1.10.7\n</code></pre> <pre><code>$ h5dump --version\nh5dump: Version 1.10.7\n</code></pre> <p>If you now check which modules are loaded via \"<code>module list</code>\", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree:</p> <pre><code>$ module list\n\nCurrently Loaded Modules:\n  1) GCCcore/10.2.0   5) numactl/2.0.13      9) hwloc/2.2.0       13) PMIx/3.1.5\n  2) zlib/1.2.11      6) XZ/5.2.5           10) libevent/2.1.12   14) OpenMPI/4.0.5\n  3) binutils/2.35    7) libxml2/2.9.10     11) UCX/1.9.0         15) Szip/2.1.1\n  4) GCC/10.2.0       8) libpciaccess/0.16  12) libfabric/1.11.0  16) HDF5/1.10.7\n</code></pre>"},{"location":"2021-lust/module_naming_schemes/#exercise","title":"Exercise","text":"<p>Now it is your turn!</p> <p>Try to get a feeling for how a hierarchical module tree works by:</p> <ul> <li>installing the missing modules for the <code>SciPy-bundle-2020.11-foss-2020b.eb</code> in the module hierarchy we   generated for HDF5;</li> <li>figure out where the <code>SciPy-bundle</code> module is located in the hierarchy, and then also load it;</li> </ul> <p>You can verify your work by running this command (since <code>pandas</code> is one of the Python packages included in the <code>SciPy-bundle</code> installation):</p> <pre><code>python -c 'import pandas; print(pandas.__version__)'\n</code></pre> <p>Start from a clean slate, by first running:</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> (click to show solution) <ul> <li> <p>Step 0: check which modules are still missing, using <code>--missing</code> or <code>-M</code>:   <pre><code>eb SciPy-bundle-2020.11-foss-2020b.eb -M\n</code></pre>   The output should tell you that 15 out of 50 required modules are still missing.</p> </li> <li> <p>Install the missing modules in the module hierarchy we have generated in <code>$HOME/hmns/modules</code>:   <pre><code>eb SciPy-bundle-2020.11-foss-2020b.eb --robot --module-only\n</code></pre>   Don't forget to use both <code>--robot</code> (to enable dependency resolution) and <code>--module-only</code>   (to only run the sanity check and generate module files, not install the software again).</p> </li> <li> <p>Start at the top of the module hierarchy (the <code>Core</code> level),   and run module spider to check which gateway modules to load to make <code>SciPy-bundle</code> available:   <pre><code>module use $HOME/hmns/modules/all/Core\nmodule spider SciPy-bundle/2020.11\n</code></pre></p> </li> <li>Load the gateway modules:   <pre><code>module load GCC/10.2.0 OpenMPI/4.0.5\n</code></pre></li> <li>Check that the <code>SciPy-bundle</code> module is available, and load it:   <pre><code>$ module avail SciPy-bundle\n----- /home/example/hmns/modules/all/MPI/GCC/10.2.0/OpenMPI/4.0.5 ------\n   SciPy-bundle/2020.11\n</code></pre> <pre><code>module load SciPy-bundle/2020.11\n</code></pre></li> <li>Run the test command:   <pre><code>$ python -c 'import pandas; print(pandas.__version__)'\n1.1.4\n</code></pre></li> </ul> <p>Warning</p> <p>This exercise will only work if you have write access to the software installation prefix, because EasyBuild will try to copy the installation log file to each installlation directory.</p>"},{"location":"2021-lust/part1_intro/","title":"Part I: Introduction to EasyBuild","text":"<p>[back to start page]</p> <p>(Tue March 4th 2021, 9am-12 CET)</p> <ul> <li>What is EasyBuild?</li> <li>Terminology</li> <li>Installation (hands-on)</li> <li>Configuration (hands-on)</li> <li>Basic usage (hands-on)</li> </ul>"},{"location":"2021-lust/part2_using/","title":"Part II: Using EasyBuild","text":"<p>[back to start page]</p> <p>(Tue March 23rd 2021, 9am-12 CET)</p> <ul> <li>Troubleshooting (hands-on)</li> <li>Creating easyconfig files (hands-on)</li> <li>Implementing easyblocks (hands-on)</li> </ul>"},{"location":"2021-lust/part3_advanced/","title":"Part III: Advanced topics","text":"<p>[back to start page]</p> <p>(Tue March 30th 2021, 9am-12 CET)</p> <ul> <li>Using EasyBuild as a library (hands-on)</li> <li>Using hooks to customise EasyBuild (hands-on)</li> <li>Submitting installations as Slurm jobs (hands-on)</li> <li>Module naming schemes (incl. hierarchical) (hands-on)</li> <li>GitHub integration to facilitate contributing to EasyBuild (hands-on)</li> </ul>"},{"location":"2021-lust/part4_cray/","title":"Part IV: EasyBuild on Cray systems","text":"<p>[back to start page]</p> <p>How to use EasyBuild on Cray systems</p> <p>(Friday June 18th 2021, 09-12 CEST)</p> <ul> <li>Introduction to Cray Programming Environment (hands-on)</li> <li>Using external modules (hands-on)</li> <li>Custom Cray toolchains (hands-on)</li> <li>EasyBuild at CSCS (hands-on)</li> </ul>"},{"location":"2021-lust/slurm_jobs/","title":"Submitting installations as Slurm jobs","text":"<p>EasyBuild can submit jobs to different backends including Slurm to install software, to distribute the often time-consuming installation of a set of software applications and the dependencies they require to a cluster.</p> <p>This is done via the <code>--job</code> command line option.</p> <p>It is important to be aware of some details before you start using this, which we'll cover here.</p>"},{"location":"2021-lust/slurm_jobs/#configuration","title":"Configuration","text":"<p>The EasyBuild configuration that is active at the time that <code>eb --job</code> is used will be passed down into the submitted job automatically, via command line options to the <code>eb</code> command that is run in the job script.</p> <p>This includes not only command line options used next to <code>--job</code>, but also configuration settings that are specified via an EasyBuild configuration file or through <code>$EASYBUILD_*</code> environment variables.</p> <p>This implies that any EasyBuild configuration files or <code>$EASYBUILD_*</code> environment variables that are in place in the job environment are most likely irrelevant, since configuration settings they specify they will most likely be overruled by the corresponding command line options.</p>"},{"location":"2021-lust/slurm_jobs/#using-eb-job","title":"Using <code>eb --job</code>","text":""},{"location":"2021-lust/slurm_jobs/#job-backend","title":"Job backend","text":"<p>The default job backend in EasyBuild v4.x is <code>GC3Pie</code>. To let EasyBuild submit jobs to Slurm instead, you should set the <code>job-backend</code> configuration setting to <code>Slurm</code>, for example by setting the corresponding environment variable:</p> <pre><code>export EASYBUILD_JOB_BACKEND='Slurm'\n</code></pre>"},{"location":"2021-lust/slurm_jobs/#job-resources","title":"Job resources","text":"<p>To submit an installation as a job, simply use <code>eb --job</code>:</p> <pre><code>eb example.eb --job\n</code></pre> <p>By default, EasyBuild will submit single-core jobs requesting for 24 hours of walltime. You can tweak the requested resources via the <code>job-cores</code> and <code>job-max-walltime</code> configuration options. For example:</p> <pre><code># submit job to install example, using 5 cores and 2 hours of max. walltime\neb example.eb --job --job-cores 5 --job-max-walltime 2\n</code></pre> <p>Note that not all <code>job-*</code> configuration settings apply to all job backends, see the EasyBuild documentation for more details.</p>"},{"location":"2021-lust/slurm_jobs/#controlling-slurm-submission-options","title":"Controlling Slurm submission options","text":"<p>When using Slurm as a job backend, EasyBuild will automatically generate job scripts which use the <code>eb</code> command to perform a single installation. These scripts will be submitted using the <code>sbatch</code> command.</p> <p>EasyBuild currently doesn't provide away to customize the Slurm submission options, for example to submit to a particular partition, or to use a particular account, build you can set the corresponding <code>$SBATCH_*</code> environment variables prior to running <code>eb --job</code>.</p> <p>For example, to specify a particular account that should be used for the jobs submitted by EasyBuild (equivalent with using the <code>-A</code> or <code>--account</code> command line option for <code>sbatch</code>):</p> <pre><code>export SBATCH_ACCOUNT='example_project'\n</code></pre> <p>Or to submit to a particular Slurm partition (equivalent with the <code>-p</code> or <code>--partition</code> option for <code>sbatch</code>):</p> <pre><code>export SBATCH_PARTITION='example_partition'\n</code></pre> <p>For more information about supported <code>$SBATCH_*</code> environment variables, see the Slurm documentation.</p>"},{"location":"2021-lust/slurm_jobs/#combining-job-and-robot","title":"Combining <code>--job</code> and <code>--robot</code>","text":"<p>If one or more dependencies are still missing for the software you want to install, you can combine <code>--job</code> and <code>--robot</code> to get EasyBuild to submit a separate job for each of the installations. These jobs will not <code>--robot</code>, they will each only perform a single installation.</p> <p>Dependencies between jobs will be \"registered\" at submission time, so Slurm will put jobs on hold until the jobs that install the required (build) dependencies have completed successfully, and cancel jobs if the job to install a dependency failed for some reason.</p>"},{"location":"2021-lust/slurm_jobs/#attention-points","title":"Attention points","text":"<p>There are a couple of important things to keep an eye on when submitting installations as jobs...</p>"},{"location":"2021-lust/slurm_jobs/#differences-on-cluster-workernodes","title":"Differences on cluster workernodes","text":"<p>Sometimes the resources available on the login nodes and cluster workernodes are slightly different, and you may need to take this into account in your EasyBuild configuration.</p> <p>For example, plenty of disk space may be available in the <code>/tmp</code> temporary filesystem on a login node, while the workernodes require you to use a different location for temporary files and directories. As a result, you may need to slightly change your EasyBuild configuration when submitting installations as jobs, to avoid that they fail almost instantly due to a lack of disk space.</p> <p>Keep in mind that the active EasyBuild configuration is passed down into the submitted jobs, so any configuration that is present on the workernodes may not have any effect.</p> <p>For example, if you commonly use <code>/tmp/$USER</code> for build directories on a login node, you may need to tweak that when submitting jobs to use a different location:</p> <pre><code># EasByuild is configured to use /tmp/$USER on the login node\nlogin01 $ eb --show-config | grep buildpath\nbuildpath      (E) = /tmp/example\n\n# use /localdisk/$USER for build directories when submitting installations as jobs\nlogin01 $ eb --job --buildpath /localdisk/$USER example.eb --robot\n</code></pre>"},{"location":"2021-lust/slurm_jobs/#temporary-log-files-and-build-directories","title":"Temporary log files and build directories","text":"<p>The temporary log file that EasyBuild creates is most likely going to end up on the local disk of the workernode on which the job was started (by default in <code>$TMPDIR</code> or <code>/tmp</code>). If an installation fails, the job will finish and temporary files will likely be cleaned up instantly, which may leave you wondering about the actual cause of the failing installation...</p> <p>To remedy this, there are a couple of EasyBuild configuration options you can use:</p> <ul> <li> <p>You can use <code>--tmp-logdir</code> to specify a different location where EasyBuild should store temporary log files,   for example:   <pre><code>$ eb --job example.eb --tmp-logdir $HOME/eb_tmplogs\n</code></pre></p> </li> <li> <p>If you prefer having the entire log file stored in the Slurm job output files,   you can use <code>--logtostdout</code> when submitting the jobs. This will result in extensive logging   to your terminal window when submitting the jobs, but it will also make EasyBuild   log to <code>stdout</code> when the installation is running in the job, and hence the log messages will be   captured in the job output files.</p> </li> </ul> <p>The same remark applies to build directories: they should be on a local filesystem (to avoid problems that often occur when building software on a parallel filesystem like GPFS or Lustre), which will probably be cleaned up automatically when a job fails. Here it is less easy to provide general advice on how to deal with this, but one thing you can consider is retrying the installation in an interactive job, so you can inspect the build directory after the installation fails.</p>"},{"location":"2021-lust/slurm_jobs/#lock-files","title":"Lock files","text":"<p>EasyBuild creates locks to prevent that the same installation is started multiple times on different system to the same installation directory.</p> <p>If an installation fails or gets interrupted, EasyBuild cleans up those locks automatically.</p> <p>However, if a Slurm job that is using EasyBuild to install software gets cancelled (because it ran out of walltime, tried to consume too much memory, through an <code>scancel</code> command, etc.), EasyBuild will not get the chance to clean up the lock file.</p> <p>If this occurs you will need to either clean up the lock file (which is located in the <code>software/.locks</code> subdirectory of <code>installpath</code>) manually, or re-submit the job with <code>eb --job --ignore-locks</code>.</p>"},{"location":"2021-lust/slurm_jobs/#example","title":"Example","text":"<p>As an example, we will let EasyBuild submit jobs to install <code>AUGUSTUS</code> with the <code>foss/2020b</code> toolchain.</p>"},{"location":"2021-lust/slurm_jobs/#configuration_1","title":"Configuration","text":"<p>Before using <code>--job</code>, let's make sure that EasyBuild is properly configured:</p> <pre><code># use $HOME/easybuild for software, modules, sources, etc.\nexport EASYBUILD_PREFIX=$HOME/easybuild\n\n# use ramdisk for build directories\nexport EASYBUILD_BUILDPATH=/dev/shm/$USER\n\n# use Slurm as job backend\nexport EASYBUILD_JOB_BACKEND=Slurm\n</code></pre> <p>In addition, add the path to the centrally installed software to <code>$MODULEPATH</code> via <code>module use</code>:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>Load the EasyBuild module:</p> <pre><code>module load EasyBuild\n</code></pre> <p>Let's assume that we also need to inform Slurm that jobs should be submitted into a particular account:</p> <pre><code>export SBATCH_ACCOUNT=example_project\n</code></pre> <p>This will be picked up by the <code>sbatch</code> commands that EasyBuild will run to submit the software installation jobs.</p>"},{"location":"2021-lust/slurm_jobs/#submitting-jobs-to-install-augustus","title":"Submitting jobs to install AUGUSTUS","text":"<p>Now we can let EasyBuild submit jobs for AUGUSTUS.</p> <p>Let's first check what is still missing:</p> <pre><code>$ eb AUGUSTUS-3.4.0-foss-2020b.eb --missing\n...\n11 out of 61 required modules missing:\n\n* HTSlib/1.11-GCC-10.2.0 (HTSlib-1.11-GCC-10.2.0.eb)\n* lpsolve/5.5.2.11-GCC-10.2.0 (lpsolve-5.5.2.11-GCC-10.2.0.eb)\n* Boost/1.74.0-GCC-10.2.0 (Boost-1.74.0-GCC-10.2.0.eb)\n* GSL/2.6-GCC-10.2.0 (GSL-2.6-GCC-10.2.0.eb)\n* SAMtools/1.11-GCC-10.2.0 (SAMtools-1.11-GCC-10.2.0.eb)\n* BCFtools/1.11-GCC-10.2.0 (BCFtools-1.11-GCC-10.2.0.eb)\n* METIS/5.1.0-GCCcore-10.2.0 (METIS-5.1.0-GCCcore-10.2.0.eb)\n* BamTools/2.5.1-GCC-10.2.0 (BamTools-2.5.1-GCC-10.2.0.eb)\n* MPFR/4.1.0-GCCcore-10.2.0 (MPFR-4.1.0-GCCcore-10.2.0.eb)\n* SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0 (SuiteSparse-5.8.1-foss-2020b-METIS-5.1.0.eb)\n* AUGUSTUS/3.4.0-foss-2020b (AUGUSTUS-3.4.0-foss-2020b.eb)\n</code></pre> <p>Several dependencies are not installed yet, so we will need to use <code>--robot</code> to ensure that EasyBuild also submits jobs to install these first.</p> <p>To speed up the installations a bit, we will request 10 cores for each submitted job (via <code>--job-cores</code>). That should be sufficient to let each installation finish in (well) under 1 hour, so we only request 1 hour of walltime per job (via <code>--job-max-walltime</code>).</p> <p>In order to have some meaningful job output files, we also enable trace mode (via <code>--trace</code>).</p> <pre><code>$ eb AUGUSTUS-3.4.0-foss-2020b.eb --job --job-cores 10 --job-max-walltime 1 --robot --trace\n...\n== resolving dependencies ...\n...\n== List of submitted jobs (11): Boost-1.74.0-GCC-10.2.0 (Boost/1.74.0-GCC-10.2.0): 1000011; GSL-2.6-GCC-10.2.0 (GSL/2.6-GCC-10.2.0): 1000004; SAMtools-1.11-GCC-10.2.0 (SAMtools/1.11-GCC-10.2.0): 1000005; HTSlib-1.11-GCC-10.2.0 (HTSlib/1.11-GCC-10.2.0): 1000006; BCFtools-1.11-GCC-10.2.0 (BCFtools/1.11-GCC-10.2.0): 1000001; lpsolve-5.5.2.11-GCC-10.2.0 (lpsolve/5.5.2.11-GCC-10.2.0): 1000007; BamTools-2.5.1-GCC-10.2.0 (BamTools/2.5.1-GCC-10.2.0): 1000008; METIS-5.1.0-GCCcore-10.2.0 (METIS/5.1.0-GCCcore-10.2.0): 1000009; MPFR-4.1.0-GCCcore-10.2.0 (MPFR/4.1.0-GCCcore-10.2.0): 1000010; SuiteSparse-5.8.1-foss-2020b-METIS-5.1.0 (SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0): 1000002; AUGUSTUS-3.4.0-foss-2020b (AUGUSTUS/3.4.0-foss-2020b): 1000003\n== Submitted parallel build jobs, exiting now\n</code></pre>"},{"location":"2021-lust/slurm_jobs/#inspecting-the-submitted-jobs","title":"Inspecting the submitted jobs","text":"<p>Once EasyBuild has submitted the jobs, we can inspect them via Slurm's <code>squeue</code> command:</p> <pre><code>$ squeue -u $USER -la\n  JOBID PARTITION     NAME     USER    STATE   TIME TIME_LIMI  NODES NODELIST(REASON)\n1000001     small BCFtools  user123  PENDING   0:00   2:00:00      1 (Dependency)\n1000002     small SuiteSpa  user123  PENDING   0:00   2:00:00      1 (Dependency)\n1000003     small AUGUSTUS  user123  PENDING   0:00   2:00:00      1 (Dependency)\n1000004     small GSL-2.6-  user123  RUNNING   0:21   2:00:00      1 node003\n1000005     small SAMtools  user123  RUNNING   0:21   2:00:00      1 node007\n1000006     small HTSlib-1  user123  RUNNING   0:21   2:00:00      1 node007\n1000007     small lpsolve-  user123  RUNNING   0:21   2:00:00      1 node011\n1000008     small BamTools  user123  RUNNING   0:21   2:00:00      1 node011\n1000009     small METIS-5.  user123  RUNNING   0:21   2:00:00      1 node013\n1000010     small MPFR-4.1  user123  RUNNING   0:21   2:00:00      1 node029\n1000011     small Boost-1.  user123  RUNNING   0:24   2:00:00      1 node029\n</code></pre> <p>Note that 3 jobs can not be started yet, because those installations require on one or more missing dependencies. As soon as the jobs for those dependencies (successfully) complete, these jobs will be able to start.</p>"},{"location":"2021-lust/slurm_jobs/#final-result","title":"Final result","text":"<p>After about 20 minutes, AUGUSTUS and all missing dependencies should be installed:</p> <pre><code>$ ls -lrt $HOME/easybuild/modules/all/*/*.lua | tail -11\n-rw-rw----. 1 example  example  1634 Mar 29 10:13 /users/example/easybuild/modules/all/HTSlib/1.11-GCC-10.2.0.lua\n-rw-rw----. 1 example  example  1792 Mar 29 10:13 /users/example/easybuild/modules/all/SAMtools/1.11-GCC-10.2.0.lua\n-rw-rw----. 1 example  example  1147 Mar 29 10:13 /users/example/easybuild/modules/all/BamTools/2.5.1-GCC-10.2.0.lua\n-rw-rw----. 1 example  example   957 Mar 29 10:13 /users/example/easybuild/modules/all/lpsolve/5.5.2.11-GCC-10.2.0.lua\n-rw-rw----. 1 example  example  1549 Mar 29 10:13 /users/example/easybuild/modules/all/METIS/5.1.0-GCCcore-10.2.0.lua\n-rw-rw----. 1 example  example  1525 Mar 29 10:14 /users/example/easybuild/modules/all/GSL/2.6-GCC-10.2.0.lua\n-rw-rw----. 1 example  example  1221 Mar 29 10:15 /users/example/easybuild/modules/all/MPFR/4.1.0-GCCcore-10.2.0.lua\n-rw-rw----. 1 example  example  1678 Mar 29 10:15 /users/example/easybuild/modules/all/BCFtools/1.11-GCC-10.2.0.lua\n-rw-rw----. 1 example  example  1292 Mar 29 10:21 /users/example/easybuild/modules/all/Boost/1.74.0-GCC-10.2.0.lua\n-rw-rw----. 1 example  example  1365 Mar 29 10:28 /users/example/easybuild/modules/all/SuiteSparse/5.8.1-foss-2020b-METIS-5.1.0.lua\n-rw-rw----. 1 example  example  2233 Mar 29 10:30 /users/example/easybuild/modules/all/AUGUSTUS/3.4.0-foss-2020b.lua\n\n$ module use $HOME/easybuild/modules/all\n\n$ module avail AUGUSTUS\n\n-------- /users/hkenneth/easybuild/modules/all --------\n   AUGUSTUS/3.4.0-foss-2020b\n</code></pre>"},{"location":"2021-lust/terminology/","title":"Terminology","text":"<p>[back: What is EasyBuild?]</p> <p>Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software.</p> <p>It is important to be familiar with these terms, so we'll briefly cover them one by one.</p>"},{"location":"2021-lust/terminology/#framework","title":"Framework","text":"<p>The EasyBuild framework consists of a set of Python modules organised in packages (<code>easybuild.framework</code>, <code>easybuild.toolchains</code>, <code>easybuild.tools</code>, etc.) that collectively form the core of EasyBuild, and is developed in the <code>easybuild-framework</code> repository on GitHub.</p> <p>It implements the common functionality that you need when building software from source, providing functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc.</p> <p>The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this.</p>"},{"location":"2021-lust/terminology/#easyblocks","title":"Easyblocks","text":"<p>An easyblock is a Python module that implements a specific software installation procedure, and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific.</p> <p>A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the <code>ConfigureMake</code> easyblock which implements the ubiquitous <code>configure</code>-<code>make</code>-<code>make install</code> procedure, and the <code>PythonPackage</code> easyblock that can be used to install a Python package.</p> <p>A software-specific easyblock implements an installation procedure that is specific to a particular software packages. Infamous examples include the easyblocks we have for <code>GCC</code>, <code>OpenFOAM</code>, <code>TensorFlow</code>, <code>WRF</code>, ...</p> <p>The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file.</p> <p>A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the <code>easybuild-easyblocks</code> repository on GitHub.</p>"},{"location":"2021-lust/terminology/#easyconfig-parameters","title":"Easyconfig parameters","text":"<p>An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild.</p> <p>Some easyconfig parameters are mandatory. The following parameters must be defined in every easyconfig file:</p> <ul> <li><code>name</code> and <code>version</code>, which specify the name and version of the software to install;</li> <li><code>homepage</code> and <code>description</code>, which provide key metadata for the software;</li> <li><code>toolchain</code>, which specifies the compiler toolchain to use to install the software (see   <code>toolchains</code> tab);</li> </ul> <p>Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock.</p> <p>Some commonly used optional easyconfig parameters include:</p> <ul> <li><code>easyblock</code>, which specifies which (generic) easyblock should be used for the installation;</li> <li><code>sources</code> and <code>source_urls</code>, which specify the list of source files and where to download them;</li> <li><code>dependencies</code> and <code>builddependencies</code>, which specify the list of (build) dependencies;</li> <li><code>configopts</code>, <code>buildopts</code>, and <code>installopts</code>, which specify options for the configuration/build/install commands, respectively;</li> </ul> <p>If no value is specified for an optional easyconfig parameter, the corresponding default value will be used.</p> <p>There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software.</p>"},{"location":"2021-lust/terminology/#easyconfig-files","title":"Easyconfig files","text":"<p>Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install. Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation.</p> <p>The filename of an easyconfig file usually ends with the <code>.eb</code> extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: <code>name</code>, <code>version</code>, <code>toolchain</code> and <code>versionsuffix</code>. The general format for the filename of an easyconfig file is: <code>&lt;name&gt;-&lt;version&gt;&lt;toolchain&gt;-&lt;versionsuffix&gt;.eb</code>, where the toolchain part is omitted when a <code>system</code> toolchain is used, and the <code>&lt;versionsuffix&gt;</code> can be empty.</p> <p>The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive.</p> <p>In the <code>easybuild-easyconfigs</code> repository on GitHub, the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software.</p>"},{"location":"2021-lust/terminology/#easystack-files","title":"Easystack files","text":"<p>Easystack files are a new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild.</p> <p>They are written in YAML syntax, and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels.</p> <p>The support for using easystack files is currently marked as experimental, which means it is subject to change in future EasyBuild releases, and may be prone to errors.</p>"},{"location":"2021-lust/terminology/#extensions","title":"Extensions","text":"<p>Extensions is the collective term we use for additional software packages that can be installed on top of another software package. Common examples are Python packages, R libraries, and Perl modules.</p> <p>As you can tell the common terminology here is a bit messy, so we came up with a unifying term...</p> <p>Extensions can be installed in different ways:</p> <ul> <li>stand-alone, as a separate installation on top of one or more other installations;</li> <li>as a part of a bundle of extensions that collectively form a separate installation;</li> <li>or as an actual extension to a specific installation to yield a \"batteries included\"   type of installation (for examples by adding a bunch of Python packages from PyPI into   a Python installation);</li> </ul>"},{"location":"2021-lust/terminology/#dependencies","title":"Dependencies","text":"<p>A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features).</p> <p>There are three main types of dependencies for computer software:</p> <ul> <li>a build dependency is only required when building/installing a software package;   once the software package is installed, it is no longer needed to use that software   (examples: <code>CMake</code>, <code>pkg-config</code>);</li> <li>a run-time dependency (often referred to simply as dependency) is a software package that is   required to use (or run) another software package (example: <code>Python</code>);</li> <li>a link-time dependency is somewhere in between a build and runtime dependency:   it is only needed when linking a software package; it can become either a build or runtime   dependency, depending on exactly how the software is installed (example: <code>OpenBLAS</code>);</li> </ul> <p>The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies.</p>"},{"location":"2021-lust/terminology/#toolchains","title":"Toolchains","text":"<p>A compiler toolchain (or just toolchain for short) is a set of compilers, which are used to build software from source, together with a set of additional libraries that provide further core functionality.</p> <p>We refer to the different parts of a toolchain as toolchain components.</p> <p>The compiler component typically consists of C, C++, and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included.</p> <p>Additional toolchain components are usually special-purpose libraries:</p> <ul> <li>an MPI library to support distributed computations (for example, Open MPI);</li> <li>libraries providing efficient linear algebra routines (BLAS,   LAPACK);</li> <li>a library supporting computing Fast Fourier Transformations (for example, FFTW);</li> </ul> <p>A toolchain that includes all of these libraries is referred to as a full toolchain, while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).</p>"},{"location":"2021-lust/terminology/#system-toolchain","title":"System toolchain","text":"<p>The <code>system</code> toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system, rather than using toolchain components that were installed using EasyBuild.</p> <p>It used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.</p>"},{"location":"2021-lust/terminology/#common-toolchains","title":"Common toolchains","text":"<p>The <code>foss</code> and <code>intel</code> toolchains are also known as the common toolchains, because they are widely adopted by the EasyBuild community.</p> <p>The <code>foss</code> toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free &amp; Open Source Software): GCC, Open MPI, OpenBLAS, ScaLAPACK and FFTW.</p> <p>The <code>intel</code> toolchain consists of the Intel C, C++ and Fortran compilers (on top of a <code>GCC</code> version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries.</p> <p>Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing.</p> <p>More information on these toolchains is available in the EasyBuild documentation.</p>"},{"location":"2021-lust/terminology/#modules","title":"Modules","text":"<p>Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file).</p> <p>Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell-agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading the environment module will restore the shell environment to its previous state.</p> <p>Environment module files are processed via a modules tool, of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod, a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones.</p> <p>Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.</p>"},{"location":"2021-lust/terminology/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions, using a particular compiler toolchain, as specified in easyconfig files which each define a set of easyconfig parameters.</p> <p>EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.</p> <p>An easystack file can be used to specify a collection of software to install with EasyBuild.</p> <p>[next: Installation]</p>"},{"location":"2021-lust/troubleshooting/","title":"Troubleshooting","text":"<p>When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild.</p> <p>In this part we take a look at how you can troubleshoot a failing installation, and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild, the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed.</p> <p>At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!</p>"},{"location":"2021-lust/troubleshooting/#easybuild-error-messages","title":"EasyBuild error messages","text":"<p>When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message.</p> <p>Things that could go wrong during an installation include:</p> <ul> <li>missing source or patch files;</li> <li>a checksum error on a downloaded source or patch file;</li> <li>required dependencies that are not specified in the easyconfig file;</li> <li>failing shell commands;</li> <li>running out of available memory or disk space;</li> <li>a segmentation fault caused by a flipped bit triggered by a cosmic ray (really, it happens!);</li> </ul> <p>Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation...</p> <p>For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure. If the exit status is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted.</p>"},{"location":"2021-lust/troubleshooting/#example","title":"Example","text":"<p>Here is an example of an EasyBuild error message (slightly reformatted for clarity):</p> <pre><code>$ eb example.eb\n...\n== building...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0):\nbuild failed (first 300 chars): cmd \"make\" exited with exit code 2 and output:\n/usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp\ng++: error: unrecognized command line option '-std=c++14' (took 1 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log\nERROR: Build of /home/easybuild/subread.eb failed (err: ...)\n</code></pre> <p>Let's break this down a bit: during the <code>build</code> step of the installation procedure EasyBuild was running <code>make</code> as a shell command, which failed (exit code 2, so not zero). The <code>make</code> command tripped over the compilation of <code>core.cpp</code> that failed because <code>-std=c++14</code> is not a known option to the <code>g++</code> command.</p> <p>OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is <code>make</code> using <code>/usr/bin/g++</code> for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under <code>/easybuild/software</code>.</p> <p>Let's see what <code>/usr/bin/g++</code> is:</p> <pre><code>$ /usr/bin/g++ --version\ng++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39)\n</code></pre> <p>Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet...</p> <p>Your next step in this case should probably be figuring out why <code>/usr/bin/g++</code> is being used rather than just <code>g++</code>, which would result in using the right compiler version because EasyBuild sets up the build environment carefully.</p> <p>This is a fictitious example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.</p>"},{"location":"2021-lust/troubleshooting/#easybuild-log-files","title":"EasyBuild log files","text":"<p>Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward...</p> <p>EasyBuild includes the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed.</p> <p>In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes.</p> <p>In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session.</p> <p>See for example this output line from our earlier example error message:</p> <pre><code>== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log\n</code></pre> <p>You can open this file with your favorite text editor or a tool like <code>less</code> to take a look at the information collected in the log file, which includes things like:</p> <ul> <li>informative messages produced by both the EasyBuild framework and the easyblock   describing how the installation is progressing;</li> <li>how the build environment was set up: which modules were loaded, which environment variables were set;</li> <li>the exact shell commands that were executed, and in which directory they were run;</li> <li>the full output produced by these commands, and their exit code;</li> </ul> <p>Note that the installation log is also copied into each software installation directory for successful installation, into the <code>easybuild</code> subdirectory. For example:</p> <pre><code>/easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210308.214453.log\n</code></pre>"},{"location":"2021-lust/troubleshooting/#last-log","title":"Last log","text":"<p>The <code>eb</code> command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor:</p> <pre><code>vim $(eb --last-log)\n</code></pre>"},{"location":"2021-lust/troubleshooting/#navigating-log-files","title":"Navigating log files","text":"<p>Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors:</p> <ul> <li><code>ERROR</code></li> <li><code>Error 1</code></li> <li><code>error:</code></li> <li><code>failure</code></li> <li><code>not found</code></li> <li><code>No such file or directory</code></li> <li><code>bazel</code></li> <li><code>Segmentation fault</code></li> </ul> <p>Using \"<code>error</code>\" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an <code>error.c</code> file), and you'll miss others that do include errors but mention <code>ERROR</code> or <code>Error</code> rather than <code>error</code>.</p> <p>When using <code>less</code> to view a log file, you can navigate it by:</p> <ul> <li>hitting '<code>$</code>' followed by '<code>G</code>' to go to the end of the log file;</li> <li>using your arrow keys to scroll up/down;</li> <li>typing '<code>?</code>' followed by some text and Enter to search backwards for a particular pattern ('<code>/</code>' to search forwards, '<code>n</code>' for next match);</li> <li>hitting '<code>q</code>' to exit;</li> </ul> <p>It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these:</p> <pre><code>== 2020-06-13 01:34:48,816 example INFO configuring...\n== 2020-06-13 01:34:48,817 example INFO Starting configure step\n...\n== 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure\n</code></pre> <p>If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for <code>HDF5</code>):</p> <pre><code>== 2020-06-09 13:11:19,968 run.py:222 INFO running cmd:  make install\n== 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output:\nMaking install in src\nmake[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src'\n...\n</code></pre> <p>It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \"<code>INFO running cmd</code>\" as a search pattern, and then looking for patterns like \"<code>error:</code>\" from there.</p>"},{"location":"2021-lust/troubleshooting/#inspecting-the-build-directory","title":"Inspecting the build directory","text":"<p>When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there.</p> <p>The location of the build directory is mentioned in the EasyBuild error message:</p> <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-10.2.0): ...\n</code></pre> <p>For software using a classic <code>configure</code> script, you may have to locate and inspect the <code>config.log</code> file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in <code>CMakeOutput.log</code> or <code>CMakeError.log</code> for clues, which are sneakily hidden by CMake in a <code>CMakeFiles</code> subdirectory of the build directory.</p> <p>As a side note here: as EasyBuild does not clean out old and failed builds you will need to eventually manually remove these build directories from the <code>buildpath</code> directory.</p>"},{"location":"2021-lust/troubleshooting/#exercise","title":"Exercise","text":"<p>Let's work our way through a less smooth software installation, using the easyconfig file that is provided below.</p> <p>Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial.</p> <pre><code>easyblock = 'MakeCp'\n\nname = 'Subread'\nversion = '2.0.1'\n\nhomepage = 'http://subread.sourceforge.net'\ndescription = \"High performance read alignment, quantification and mutation discovery\"\n\ntoolchain = {'name': 'GCC', 'version': '8.5.0'}\n\n# download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\nchecksums = ['d808eb5b1823c572cb45a97c95a3c5acb3d8e29aa47ec74e3ca1eb345787c17b']\n\nstart_dir = 'src'\n\n# -fcommon is required to compile Subread 2.0.1 with GCC 10,\n# which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html)\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"'\n\nfiles_to_copy = ['bin']\n\nsanity_check_paths = {\n    'files': ['bin/featureCounts', 'bin/subread-align'],\n    'dirs': ['bin/utilities'],\n}\n\nsanity_check_commands = [\"featureCounts --version\"]\n\nmoduleclass = 'bio'\n</code></pre> <p>Do you spot any potential problems yet with this easyconfig file?</p> <p>Preparation</p> <p>Start by copying the text above in a file named <code>subread.eb</code>, so you can gradually fix the problem you'll encounter.</p> <p>Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself):</p> <pre><code>module use /easybuild/modules/all\nmodule load EasyBuild\n</code></pre> <p>For this exercise, make sure EasyBuild is configured to use <code>$HOME/easybuild</code> as <code>prefix</code>, and to use <code>/tmp/$USER</code> as <code>buildpath</code>:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Check your configuration via <code>eb --show-config</code>.</p> <p>Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions.</p> <p>Remember though: no peeking before you tried to solve each step yourself!</p> <p>Exercise T.1 - Sources</p> <p>Try to install the <code>subread.eb</code> easyconfig file, see what happens.</p> <p>Can you fix the problem you run into, perhaps without even changing the easyconfig file?</p> (click to show solution) <p>The installation fails because the source file <code>subread-2.0.1-source.tar.gz</code> is not found: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars):\nCouldn't find file subread-2.0.1-source.tar.gz anywhere, and downloading it didn't work either...\nPaths attempted (in order): ...\n</code></pre></p> <p>In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: <pre><code># download from https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre></p> <p>We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the <code>sourcepath</code> directory): <pre><code>curl -OL https://download.sourceforge.net/subread/subread-2.0.1-source.tar.gz\nmv subread-2.0.1-source.tar.gz $HOME/easybuild/sources/s/Subread/\n</code></pre></p> <p>If downloading is problematic for some reason, the source tarball is also available in <code>/easybuild/sources/s/Subread</code>.</p> <p>Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: <pre><code>source_urls = ['https://download.sourceforge.net/subread/']\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre> Note that the <code>source_urls</code> value is a list of candidate download URLs, without the filename of the source file itself.</p> <p>This way, EasyBuild will download the source file when running <code>eb subread.eb</code>.</p> <p>The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while.</p> <pre><code>$ ls -lh $HOME/easybuild/sources/s/Subread\ntotal 23M\n-rw-rw-r-- 1 easybuild easybuild 23M Jun 13 17:42 subread-2.0.1-source.tar.gz\n</code></pre> <p>Exercise T.2 - Toolchain</p> <p>After fixing the problem with missing source file, try the installation again.</p> <p>What's wrong now? How can you fix it quickly?</p> <p>Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here...</p> (click to show solution) <p>The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-8.5.0): build failed (first 300 chars):\nNo module found for toolchain: GCC/8.5.0 (took 1 sec)\n</code></pre></p> <p>We don't have this GCC version installed, but we do have GCC 10.2.0:</p> <pre><code>$ module avail GCC/\n----------------- /easybuild/modules/all ------------------\n   GCC/10.2.0\n</code></pre> <p>So let's try using that instead.</p> <p>Edit the easyconfig file so it contains this:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '10.2.0'}\n</code></pre> <p>Exercise T.3 - Build step</p> <p>With the first two problems fixed, now we can actually try to build the software.</p> <p>Can you fix the next problem you run into?</p> (click to show solution) <p>The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars):\ncmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output:\ngcc  -mtune=core2  -O3 -DMAKE_FOR_EXON  -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.1\"\\\"  -D_FILE_OFFSET_BITS=64    -fmessage-length=0  -ggdb  -fast -fcommon  -c -o core.o core.c\ngcc: error: unrecognized command line opti (took 1 sec)\n</code></pre></p> <p>If you open the log file and scroll to the end, the error is pretty obvious: <pre><code>gcc: error: unrecognized command line option -fast; did you mean -Ofast?\nmake: *** [core.o] Error 1\n</code></pre></p> <p>The easyconfig file hard specifies the <code>-fast</code> compiler flag via the <code>CFLAGS</code> argument to the build command: <pre><code># -fcommon is required to compile Subread 2.0.1 with GCC 10,\n# which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html)\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"'\n</code></pre></p> <p>EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the <code>buildopts</code> definition makes it clear that the <code>-fcommon</code> flag is required though, because GCC 10 became a bit stricter by using <code>-fno-common</code> by default. Note that we are using <code>-fcommon</code> as an escape mechanism here: it would be better to fix the source code and create a patch file instead.</p> <p>An easy way to fix this problem is to replace the <code>-fast</code> with <code>-Ofast</code>, as the compiler error suggests.</p> <p>In this case it is advised to change the <code>CFLAGS</code> argument that is added to be build command to replace the <code>-fast</code> with <code>$CFLAGS</code>, which is defined in the build environment by EasyBuild.</p> <pre><code>buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"'\n</code></pre> <p>Note that we need to be careful with quotes here: we use inner double quotes to ensure that <code>$CFLAGS</code> will be expanded to its value when the build command is run.</p> <p>Exercise T.4 - Sanity check</p> <p>After fixing the compilation issue, you're really close to getting the installation working, we promise!</p> <p>Don't give up now, try one last time and fix the last problem that occurs...</p> (click to show solution) <p>Now the installation itself works but the sanity check fails, and hence the module file does not get generated: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.1/GCC-10.2.0): build failed (first 300 chars):\nSanity check failed: sanity check command featureCounts --version exited with code 255\n(output: featureCounts: unrecognized option '--version'\n...\n</code></pre></p> <p>If you look at the full output in the log file you can see that the correct option to check the version of the <code>featureCounts</code> command is \"<code>-v</code>\" rather than \"<code>--version</code>\", so we need to fix this in the easyconfig file.</p> <p>Make the following change in the easyconfig file: <pre><code>sanity_check_commands = [\"featureCounts -v\"]\n</code></pre></p> <p>After doing so, you don't have to redo the installation from scratch, you can use the <code>--module-only</code> option to only run the sanity check and generate the module file again: <pre><code>eb subread.eb --module-only\n</code></pre></p> <p>In the end, you should be able to install Subread 2.0.1 with the GCC 10.2.0 toolchain by fixing the problems with the <code>subread.eb</code> easyconfig file.</p> <p>Check your work by manually loading the module and checking the version via the <code>featureCounts</code> command, which should look like this:</p> <pre><code>$ featureCounts -v\nfeatureCounts v2.0.1\n</code></pre>"},{"location":"2021-lust/what_is_easybuild/","title":"What is EasyBuild?","text":"<p>[back: Overview]</p> <p></p> <p>EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. Easybuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack.</p> <p> </p>"},{"location":"2021-lust/what_is_easybuild/#elevator-pitch","title":"Elevator pitch","text":"<p>EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems.</p> <p>It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks. </p> <p>In addition, EasyBuild can empower scientific researchers to self-manage their software stack, and it can serve as a tool that can be leveraged for building optimized container images.</p> <p>The project has grown to become a platform for collaboration among HPC sites worldwide.</p>"},{"location":"2021-lust/what_is_easybuild/#key-features","title":"Key features","text":"<p>EasyBuild is capable of fully autonomously installing (scientific) software, including making sure that all necessary dependencies are installed, and automatically generating environment module files.</p> <p>No admin privileges are required: it is sufficient to have write permissions to the preferred software installation prefix.</p> <p>EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations.</p> <p>The installation procedure executed by EasyBuild is thoroughly logged, and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed.</p> <p>EasyBuild supports using a custom module naming scheme, allows for hierarchical module naming schemes, and integrates with various other tools ranging from  resource managers (Slurm and GC3Pie), container tools (Singularity and Docker), packaging tools (FPM), and so on.</p>"},{"location":"2021-lust/what_is_easybuild/#focus-points","title":"Focus points","text":"<p>EasyBuild was created specifically for installing scientific software on HPC systems, which is reflected in some of the design choices that were made.</p>"},{"location":"2021-lust/what_is_easybuild/#performance","title":"Performance","text":"<p>EasyBuild strongly prefers to build software from source code, whenever possible.</p> <p>This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run.</p> <p>For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like <code>-march=native</code> (GCC), <code>-xHost</code> (Intel compilers), etc. This behaviour can be changed via the <code>--optarch</code> configuration setting.</p>"},{"location":"2021-lust/what_is_easybuild/#reproducibility","title":"Reproducibility","text":"<p>In addition to performance, reproducibility of installations is a core aspect of EasyBuild.</p> <p>Most software installations performed with EasyBuild use a particular compiler toolchain, with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like <code>OpenSSL</code> for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system.</p> <p>For both toolchains and dependencies, fixed software versions are specified in the easyconfig files. That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.</p>"},{"location":"2021-lust/what_is_easybuild/#community-effort","title":"Community effort","text":"<p>In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out.</p> <p>We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, be it by opening pull requests to the GitHub repositories or the documentation.</p> <p>Through the <code>foss</code> and <code>intel</code> common toolchains, we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository.</p> <p>Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.</p>"},{"location":"2021-lust/what_is_easybuild/#what-easybuild-is-not","title":"What EasyBuild is not","text":"<p>EasyBuild is not YABT (Yet Another Build Tool): it does not replace established build tools like CMake or <code>make</code>, it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you.</p> <p>It is not a replacement for traditional Linux package managers like <code>yum</code>, <code>dnf</code> or <code>apt</code>. EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution.</p> <p>Finally, EasyBuild is not a magic solution to all your (software installation) problems. You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you.</p>"},{"location":"2021-lust/what_is_easybuild/#requirements","title":"Requirements","text":"<p>Since EasyBuild is primarily intended for installing (scientific) software on HPC systems, the main target is systems running some flavor of GNU/Linux. EasyBuild also works on macOS, but significant effort would be required to use it extensively there.</p> <p></p> <p>EasyBuild is implemented in Python, and is compatible with Python 2.7 and 3.5+. Since Python 2 is no longer maintained, it is recommended to use a recent version of Python 3 for running EasyBuild.</p> <p>An environment modules tool is required for running EasyBuild. The modern Lua-based implementation Lmod is strongly recommended, but other (Tcl-based) implementations are also supported. Both Tcl and Lua are supported as syntax for environment module files.</p>"},{"location":"2021-lust/what_is_easybuild/#development","title":"Development","text":"<p> EasyBuild is actively developed by a worldwide community under the GPLv2 open source license via the <code>easybuilders</code> organisation on GitHub, in the following repositories:</p> <ul> <li>easybuild-framework</li> <li>easybuild-easyblocks</li> <li>easybuild-easyconfigs</li> <li>easybuild (website, documentation)</li> <li>easybuild-tutorial (this tutorial)</li> </ul> <p>Stable versions of EasyBuild have been released roughly every 6-8 weeks since 2012, and are published via the Python Package Index (PyPI), see https://pypi.org/project/easybuild.</p> <p>Comprehensive testing practices are applied throughout the development cycle, with extensive suites of unit and integration tests being run in a CI environment (GitHub Actions), consistent testing of incoming contributions (pull requests), and thorough regression testing before every release.</p>"},{"location":"2021-lust/what_is_easybuild/#a-worldwide-community","title":"A worldwide community","text":"<p>EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by dozens (hundreds?) of HPC centres and consortia worldwide.</p> <p>Since 2016 the EasyBuild community has gathered for a yearly EasyBuild User Meeting, which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it, and integrate it with other tools like Jenkins, Ansible, CernVM-FS, ReFrame etc.</p> <p>The map below shows from which cities the EasyBuild documentation has been visited in the last year (March 1st 2020 - March 1st 2021), and how often.</p> <p>HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):</p> <p> </p>"},{"location":"2021-lust/what_is_easybuild/#getting-help","title":"Getting help","text":""},{"location":"2021-lust/what_is_easybuild/#documentation","title":"Documentation","text":"<p>If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io.</p> <p>It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful.</p>"},{"location":"2021-lust/what_is_easybuild/#github","title":"GitHub","text":"<p>You can open an issue in one of the EasyBuild repositories in the <code>easybuilders</code> GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements.</p> <p>Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate.</p> <p>Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem.</p>"},{"location":"2021-lust/what_is_easybuild/#mailing-list","title":"Mailing list","text":"<p>Feel free to ask any questions or provide feedback via the EasyBuild mailing list <code>easybuild@lists.ugent.be</code>.</p> <p>Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link.</p> <p>In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel.</p>"},{"location":"2021-lust/what_is_easybuild/#slack","title":"Slack","text":"<p>The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 400 people have joined it so far, and there is usually somebody awake in there who may be able to help you out.</p> <p>To join the EasyBuild Slack request an invitation via https://easybuild-slack.herokuapp.com.</p> <p>If you are not a big fan of Slack, you can also consider joining the <code>#easybuild</code> IRC channel (available on the Freenode IRC network). A bot relays messages between this IRC channel and the <code>#general</code> channel in the EasyBuild Slack.</p> <p>Note</p> <p>A dedicated <code>#tutorial</code> channel was created for this tutorial in the EasyBuild Slack.</p> <p>If you have any questions that are specific to this tutorial, please post them there.</p>"},{"location":"2021-lust/what_is_easybuild/#conference-calls","title":"Conference calls","text":"<p>Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call.</p> <p>These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013.</p> <p>More information, including the dates and times of the next calls, is available here.</p> <p>[next: Terminology]</p>"},{"location":"2021-lust/cray/custom_toolchains/","title":"Custom Cray toolchains","text":"<p>EasyBuild Cray and CPE toolchains have been created to address the Cray PE on different Cray systems. </p> <p>Cray toolchains were designed for the Cray PE on the Cray XC system,  while the CPE toolchains targeted specifically the Cray PE on the Cray EX system.</p> <p>As of Cray PE 21.04 though, the difference between the Cray PE on the XC and the EX systems is not relevant any longer, since they rely both on PrgEnv meta-modules.</p> <p>Nonetheless, the versions of the CPE components that come with a Cray PE release might change  depending on the target system, therefore a different external metadata file is required:</p> <ul> <li> <p>see https://github.com/eth-cscs/production/tree/master/easybuild to inspect the difference between two metadata file referring to the same version </p> </li> <li> <p>E.g.: <code>cpe_external_modules_metadata-21.05.cfg</code> vs. <code>cray_external_modules_metadata-20.05.cfg</code></p> </li> </ul> <p>Furthermore, different easyconfig files might be needed to build the same software on the  two systems even with the same Cray PE, therefore the maintainers would need to provide  anyway two versions of the easyconfig file.   </p>"},{"location":"2021-lust/cray/custom_toolchains/#cray-toolchains","title":"Cray Toolchains","text":"<p>EasyBuild supports Cray systems as of version 2.7.0, enabling building and installing software using  the Programming Environment modulefiles provided by Cray. </p> <p>The EasyBuild Cray toolchains currently supported in the GitHub repository  are the following ones:</p> <ul> <li><code>CrayCCE</code></li> <li><code>CrayGNU</code></li> <li><code>CrayIntel</code></li> <li><code>CrayPGI</code></li> </ul> <p>Each Cray toolchain comes with a version matching the corresponding Cray Development Toolkit (CDT) modulefile on the  Cray XC system. </p> <p>Therefore, the toolchain will load the corresponding Cray Programming Environment, together with the compiler,  the Cray MPICH library and the Cray mathematical library with versions matching the definition of the CDT. </p> <p>Please note that the toolchains follow the naming convention of the Cray Programming Environment,  that is released on a monthly basis: as a consequence, the version of the toolchain modules has  the format <code>YY.MM</code> (two digits for the year, two digits for the month). </p>"},{"location":"2021-lust/cray/custom_toolchains/#cpe-toolchains","title":"CPE Toolchains","text":"<p>The CPE toolchains were created initially to match the modules of the Cray EX system up to Cray PE 21.03:</p> <ul> <li><code>cpe-cray</code></li> <li><code>cpe-aocc</code></li> <li><code>cpe-gnu</code></li> <li><code>cpe-intel</code></li> </ul> <p>As of CPE 21.04 though, the Cray PE of the Cray EX system features <code>PrgEnv</code> meta-modules too,  therefore the difference with respect to the standard Cray toolchain has disappeared.</p> <p>The CPE toolchains are defined by the custom easyblock <code>cpetoolchain.py</code>: <pre><code>KNOWN_PRGENVS = ['PrgEnv-aocc', 'PrgEnv-cray', 'PrgEnv-gnu', 'PrgEnv-intel']\n</code></pre></p> <p>The file is available in the CSCS production repository on GitHub, that is also mirrored under the EasyBuilders GitHub project at https://github.com/easybuilders/CSCS. </p>"},{"location":"2021-lust/cray/custom_toolchains/#cpe-compilers","title":"CPE Compilers","text":"<p>The CPE toolchains rely on specific files of the local EasyBuild framework: <pre><code>cpeamd.py\ncpecray.py\ncpegnu.py\ncpeintel.py\n</code></pre></p> <p>The first one will look for the custom compiler <code>aocc.py</code>, while the other ones are compatible  with the compilers defined by the Cray toolchains initially defined on the XC system.</p> <p>The custom toolchains above will look for the file <code>cpe.py</code> supporting the Cray PE compiler drivers. </p> <p>Please note that as well as the custom easyblock <code>cpetoolchain.py</code>, the custom files are available in the toolchains and the compiler folders of the CSCS production repository on GitHub.</p>"},{"location":"2021-lust/cray/custom_toolchains/#target-architecture","title":"Target Architecture","text":"<p>The module <code>craype-&lt;target&gt;</code> matching the target architecture must be specified using the EasyBuild flag <code>--optarch</code>.</p> <p>E.g.: <code>--optarch=x86-rome results in module</code>craype-x86-rome` being loaded in the build environment used by EasyBuild.</p> <p>You can also export this option as a shell variable. Example for AMD EPYC 7742 (\"Rome\"): <pre><code>export $EASYBUILD_OPTARCH=x86-rome\n</code></pre></p> <p>The definition of the correct module to load with the <code>--optarch</code> is also given by the environment variable <code>CRAY_CPU_TARGET</code>: this variable is defined as well by the corresponding module <code>craype-&lt;target&gt;</code>, already available at the login. </p> <p>Note</p> <p>The custom EasyBuild modulefile used on CSCS systems will look for <code>CRAY_CPU_TARGET</code> to define <code>--optarch</code>,  therefore users are strongly discouraged from purging the modules already available at login on the system</p>"},{"location":"2021-lust/cray/custom_toolchains/#easyconfig-for-custom-toolchains","title":"Easyconfig for custom toolchains","text":"<p>The easyconfig files of the current default custom toolchains were using a footer to address two issues that have been fixed in the latest EasyBuild release 4.4.0.</p> <p>Therefore, when using the latest EasyBuild release one could write a much shorter easyconfig file for the custom toolchains. </p> <p>For instance, the cpeGNU custom toolchain easyconfig file would like the following: <pre><code># Compiler toolchain for Cray EX Programming Environment GNU compiler (cpe-gnu)\neasyblock = 'cpeToolchain'\n\nname = 'cpeGNU'\nversion = \"21.04\"\n\nhomepage = 'https://pubs.cray.com'\ndescription = \"\"\"Toolchain using Cray compiler wrapper with gcc module (CPE release: %s).\\n\"\"\" % version\n\ntoolchain = SYSTEM\n\ndependencies = [\n   ('cpe/%(version)s', EXTERNAL_MODULE),\n   ('PrgEnv-gnu', EXTERNAL_MODULE)\n]\n</code></pre></p> <p>The meta-module <code>cpe</code> will ensure that the additional modules loaded by a user will be compatible with the default CPE selected.</p> <p>The advantage of the approach is to avoid pinning directly the versions of CPE components in the custom toolchain definitions. </p> <p>Of course the maintainers could also decide to pin directl the version of each CPE component in the easyconfig,  however this approach is less easy to fit in an automated pipeline for updating recipes when new CPEs are installed. </p> <p>[next: EasyBuild at CSCS]</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/","title":"EasyBuild at CSCS","text":"<p>EasyBuild has been used at CSCS since 2015 on multiple systems, using both Cray and standard toolchains.</p> <p>CSCS staff has integrated EasyBuild within the automated pipelines used to maintain supported applications and  libraries for CSCS users. The pipelines are stored on GitHub and are currently launched on a Jenkins server.</p> <p>CSCS Production Repository on GitHub: https://github.com/eth-cscs/production</p> <p>Jenkins Pipelines: https://github.com/eth-cscs/production/tree/master/jenkins</p> <p>How to use EasyBuild at CSCS: https://user.cscs.ch/computing/compilation/easybuild</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#custom-easybuild-module","title":"Custom EasyBuild module","text":"<p>The EasyBuild framework is available at CSCS through the custom module <code>EasyBuild-custom</code>. </p> <p>This module defines the location of the EasyBuild configuration files, recipes and installation directories. <pre><code>module load EasyBuild-custom\n</code></pre> The default installation folder is instead the following: <pre><code>$HOME/easybuild/&lt;system-name&gt;\n</code></pre></p> <p>Where <code>&lt;system-name&gt;</code> is the lowercase name of the system, e.g.: <code>eiger</code>.</p> <p>The custom EasyBuild modulefile is available both in Tcl and Lua syntax on the CSCS production repository:</p> <ul> <li>a system using Lmod for module management will load the Lua modulefile, which is ignored by systems using  Environment modules instead.</li> </ul> <p>The modulefile defines the location of the EasyBuild configuration files, the recipes and the installation directories. </p> <p>Once you have loaded the EasyBuild modulefile, you can check the EasyBuild version loaded and the default configuration  executing the EasyBuild command <code>eb</code>  with the options <code>--version</code>  or <code>--show-config</code> as usual.</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#how-to-use-easybuild-at-cscs","title":"How to use EasyBuild at CSCS","text":"<p>Example on the Cray EX supercomputing system Eiger: <pre><code>ml show EasyBuild-custom\n\n---------------------------------------------------------------------------------------------------------------------------------\n   /apps/eiger/UES/modulefiles/EasyBuild-custom/cscs.lua:\n---------------------------------------------------------------------------------------------------------------------------------\nhelp([[\nDescription\n===========\nProduction EasyBuild @ CSCS\n\nMore information\n================\n - Homepage: https://github.com/eth-cscs/production/wiki\n]])\nwhatis(\"Description: Production EasyBuild @ CSCS  \")\nwhatis(\"Homepage: https://github.com/eth-cscs/production/wiki\")\nconflict(\"EasyBuild-custom\")\nsetenv(\"EBROOTEASYBUILDMINCUSTOM\",\"/apps/common/UES/jenkins/easybuild/software/EasyBuild-custom/cscs\")\nsetenv(\"EBVERSIONEASYBUILDMINCUSTOM\",\"cscs\")\nsetenv(\"EBDEVELEASYBUILDMINCUSTOM\",\"/apps/common/UES/jenkins/easybuild/software/EasyBuild-custom/cscs/easybuild/EasyBuild-custom-cscs-easybuild-devel\")\nsetenv(\"XDG_CONFIG_DIRS\",\"/apps/common/UES/jenkins/production/easybuild\")\nsetenv(\"EASYBUILD_ROBOT_PATHS\",\"/apps/common/UES/jenkins/production/easybuild/easyconfigs/:\")\nsetenv(\"EASYBUILD_INCLUDE_EASYBLOCKS\",\"/apps/common/UES/jenkins/production/easybuild/easyblocks/*.py\")\nsetenv(\"EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES\",\"/apps/common/UES/jenkins/production/easybuild/tools/module_naming_scheme/*.py\")\nsetenv(\"EASYBUILD_INCLUDE_TOOLCHAINS\",\"/apps/common/UES/jenkins/production/easybuild/toolchains/*.py,/apps/common/UES/jenkins/production/easybuild/toolchains/compiler/*.py\")\nsetenv(\"EASYBUILD_BUILDPATH\",\"/run/user/21827/build\")\nsetenv(\"EASYBUILD_TMPDIR\",\"/run/user/21827/tmp\")\nsetenv(\"EASYBUILD_SOURCEPATH\",\"/apps/common/UES/easybuild/sources\")\nsetenv(\"EASYBUILD_EXTERNAL_MODULES_METADATA\",\"/apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg\")\nsetenv(\"EASYBUILD_MODULE_NAMING_SCHEME\",\"HierarchicalMNS\")\nsetenv(\"EASYBUILD_MODULE_SYNTAX\",\"Lua\")\nsetenv(\"EASYBUILD_MODULES_TOOL\",\"Lmod\")\nsetenv(\"EASYBUILD_OPTARCH\",\"x86-rome\")\nsetenv(\"EASYBUILD_RECURSIVE_MODULE_UNLOAD\",\"0\")\nsetenv(\"EASYBUILD_PREFIX\",\"/users/lucamar/easybuild/eiger\")\n</code></pre></p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#cscs-easybuild-configuration","title":"CSCS EasyBuild configuration","text":"<pre><code>eb --version\nThis is EasyBuild 4.4.0 (framework: 4.4.0, easyblocks: 4.4.0) on host uan01.\n\neb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nallow-loaded-modules          (F) = ddt, EasyBuild-custom, EasyBuild, xalt\nbuildpath                     (E) = /run/user/21827/build\ncontainerpath                 (E) = /users/lucamar/easybuild/eiger/containers\nexternal-modules-metadata     (E) = /apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg\nhide-deps                     (F) = absl, ANTLR, APR, APR-util, arpack-ng, Autoconf, Automake, Autotools, backports.weakref, Bazel, binutils, Bison, bokeh, byacc, bzip2, cairo, cloudpickle, configurable-http-proxy, Coreutils, Cube, CUDA, cuDNN, cURL, DB, Doxygen, Eigen, expat, flex, FLTK, fontconfig, freetype, funcsigs, gc, GCCcore, gettext, GL2PS, GLib, glmnet, GLPK, GMP, gnuplot, go, gperf, GPGME, GraphicsMagick, groff, GTS, guile, help2man, hwloc, inputproto, IPython, JasPer, jemalloc, kbproto, Libassuan, libcerf, libdrm, libevent, libfabric, libffi, libgd, libGLU, libgpuarray, libiberty, libjpeg-turbo, libjpeg-turbo, libpciaccess, Libpgp-error, libpng, libpthread-stubs, libQGLViewer, libreadline, libsodium, libspatialindex, LibTIFF, libtool, libunistring, libunwind, libutempter, libX11, libXau, libxcb, libXdmcp, libXext, libxml2, libXrender, libxshmfence, libyaml, LLVM, LOKI, Loki, LVM2, M4, make, makeinfo, Mako, Mesa, minieigen, mock, mxml, NASM, NASM, ncurses, nettle, networkx, nodejs, nose-parameterized, numactl, OPARI2, OpenMPI, OpenPGM, parameterized, PCRE, PDT, Perl, PIL, Pillow, pixman, pkg-config, ploticus, PMIx, popt, prereq, protobuf, protobuf-core, PyGTS, PyQt, Python-bare, Python-Xlib, PyYAML, PyZMQ, Qhull, qrupdate, Qt, renderproto, runc, scikit-image, scikit-learn, SCons, SCOTCH, Serf, SIP, SQLite, SWIG, Szip, Tcl, Tk, UCX, UDUNITS, UnZip, util-linux, Werkzeug, wheel, X11, xcb-proto, xextproto, xorg-macros, xproto, xtrans, XZ, ZeroMQ, zlib, zstd\nhide-toolchains               (F) = CrayCCE, CrayGNU, CrayIntel, CrayPGI, GCCcore, gmvapich2, gmvolf, foss, fosscuda, gompi\ninclude-easyblocks            (E) = /apps/common/UES/jenkins/production/easybuild/easyblocks/*.py\ninclude-module-naming-schemes (E) = /apps/common/UES/jenkins/production/easybuild/tools/module_naming_scheme/*.py\ninclude-toolchains            (E) = /apps/common/UES/jenkins/production/easybuild/toolchains/*.py, /apps/common/UES/jenkins/production/easybuild/toolchains/compiler/*.py\ninstallpath                   (E) = /users/lucamar/easybuild/eiger\nmodule-naming-scheme          (E) = HierarchicalMNS\noptarch                       (E) = x86-rome\npackagepath                   (E) = /users/lucamar/easybuild/eiger/packages\nprefix                        (E) = /users/lucamar/easybuild/eiger\nrepositorypath                (E) = /users/lucamar/easybuild/eiger/ebfiles_repo\nrobot-paths                   (E) = /apps/common/UES/jenkins/production/easybuild/easyconfigs/, /apps/common/UES/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs\nsourcepath                    (E) = /apps/common/UES/easybuild/sources\ntmpdir                        (E) = /run/user/21827/tmp\n</code></pre>"},{"location":"2021-lust/cray/easybuild_at_cscs/#configuration-options","title":"Configuration options","text":"<p>As reported in the output of the command <code>eb --show-config</code>, the configuration items labeled with <code>(E)</code>  are defined by an environment variable of the form <code>EASYBUILD_&lt;item&gt;</code>, where <code>item</code> is in uppercase letters. </p> <p>Therefore the buildpath is defined by the variable <code>EASYBUILD_BUILDPATH</code>, whereas the prefix that defines  the installpath of the modules created by EasyBuild is defined by <code>EASYBUILD_PREFIX</code>. </p> <p>You can change these configuration items editing the corresponding environment variable. </p> <p>Please note that in general the prefix might be different with respect to the installpath: special care is required in particular when users would like to build additional modules in their local folders on top of EasyBuild modules  already provided by the HPC centre staff.</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#choosing-your-custom-folders","title":"Choosing your custom folders","text":"<p>You can override the default installation folder by exporting the environment variables listed below,  before loading the EasyBuild modulefile: <pre><code>export EASYBUILD_PREFIX=/your/preferred/installation/folder\nexport EB_CUSTOM_REPOSITORY=/your/local/repository/easybuild\nmodule load EasyBuild-custom\n</code></pre></p> <p>The first environment variable is generally set before loading the EasyBuild modulefiles. </p> <p>The second one is instead specific to the CSCS EasyBuild-custom modulefile and corresponds  to the EasyBuild variable <code>XDG_CONFIG_DIRS</code>: therefore, the custom modulefile expects to find  the subfolders of the easybuild directory under the CSCS GitHub production repository. </p> <p>Note</p> <p>The variable <code>XDG_CONFIG_DIRS</code> might be used by other programs as well: in this case,  you might consider alternative ways to provide  EasyBuild configuration files</p> <p>The following environment variables depend on <code>EB_CUSTOM_REPOSITORY</code>: <pre><code>setenv XDG_CONFIG_DIRS                          $::env(EB_CUSTOM_REPOSITORY)\nsetenv EASYBUILD_ROBOT_PATHS                    $::env(EB_CUSTOM_REPOSITORY)/easyconfigs/:\nsetenv EASYBUILD_INCLUDE_EASYBLOCKS             $::env(EB_CUSTOM_REPOSITORY)/easyblocks/*.py\nsetenv EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES  $::env(EB_CUSTOM_REPOSITORY)/tools/module_naming_scheme/*.py\nsetenv EASYBUILD_INCLUDE_TOOLCHAINS             $::env(EB_CUSTOM_REPOSITORY)/toolchains/*.py,$::env(EB_CUSTOM_REPOSITORY)/toolchains/compiler/*.py\n</code></pre> Users will find the CSCS EasyBuild configuration file under the folder <code>easybuild.d</code> of the <code>EB_CUSTOM_REPOSITORY</code>  and the CSCS custom recipes under the <code>easyconfigs</code> folder, listed as usual in alphabetical order.</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#customizing-your-build-recipes","title":"Customizing your build recipes","text":"<p>If you wish to extend or customize the CSCS EasyBuild recipes, you can clone the  CSCS production project from GitHub and have your private repository: <pre><code>git clone https://github.com/eth-cscs/production.git\n</code></pre></p> <p>The command will download the project files under a newly created folder production.  If you wish to use it as your custom repository, you need to export the corresponding EasyBuild environment variable: <pre><code>export EB_CUSTOM_REPOSITORY=/&lt;your_local_path&gt;/production/easybuild\nmodule load EasyBuild-custom\n</code></pre></p> <p>You will find the CSCS EasyBuild build recipes files under <code>/&lt;your_local_path&gt;/production/easybuild/easyconfigs</code>,  with application folders listed in alphabetical order.</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#site-wide-configuration-file","title":"Site wide configuration file","text":"<p>The custom configuration of EasyBuild at CSCS is completed by the site wide configuration file available in the folder <code>easybuild.d</code> under <code>XDG_CONFIG_DIRS</code>, referenced in the modulefile <code>EasyBuild-custom</code>.</p> <p>The file defines the following:</p> <ul> <li> <p>the list of hidden dependencies</p> </li> <li> <p>the list of hidden toolchains</p> </li> <li> <p>the list of allowed loaded modules</p> </li> </ul> <p>The current content of the file is reported below: <pre><code>[override]\n# Comma separated list of dependencies that you want automatically hidden, (e.g. --hide-deps=zlib,ncurses) (type comma-separated list)\nhide-deps=absl,ANTLR,APR,APR-util,arpack-ng,Autoconf,Automake,Autotools,backports.weakref,Bazel,binutils,Bison,bokeh,byacc,bzip2,cairo,cloudpickle,configurable-http-proxy,Coreutils,Cube,CUDA,cuDNN,cURL,DB,Doxygen,Eigen,expat,flex,FLTK,fontconfig,freetype,funcsigs,gc,GCCcore,gettext,GL2PS,GLib,glmnet,GLPK,GMP,gnuplot,go,gperf,GPGME,GraphicsMagick,groff,GTS,guile,help2man,hwloc,inputproto,IPython,JasPer,jemalloc,kbproto,Libassuan,libcerf,libdrm,libevent,libfabric,libffi,libgd,libGLU,libgpuarray,libiberty,libjpeg-turbo,libjpeg-turbo,libpciaccess,Libpgp-error,libpng,libpthread-stubs,libQGLViewer,libreadline,libsodium,libspatialindex,LibTIFF,libtool,libunistring,libunwind,libutempter,libX11,libXau,libxcb,libXdmcp,libXext,libxml2,libXrender,libxshmfence,libyaml,LLVM,LOKI,Loki,LVM2,M4,make,makeinfo,Mako,Mesa,minieigen,mock,mxml,NASM,NASM,ncurses,nettle,networkx,nodejs,nose-parameterized,numactl,OPARI2,OpenMPI,OpenPGM,parameterized,PCRE,PDT,Perl,PIL,Pillow,pixman,pkg-config,ploticus,PMIx,popt,prereq,protobuf,protobuf-core,PyGTS,PyQt,Python-bare,Python-Xlib,PyYAML,PyZMQ,Qhull,qrupdate,Qt,renderproto,runc,scikit-image,scikit-learn,SCons,SCOTCH,Serf,SIP,SQLite,SWIG,Szip,Tcl,Tk,UCX,UDUNITS,UnZip,util-linux,Werkzeug,wheel,X11,xcb-proto,xextproto,xorg-macros,xproto,xtrans,XZ,ZeroMQ,zlib,zstd\nmodule-syntax=Tcl\nhide-toolchains=CrayCCE,CrayGNU,CrayIntel,CrayPGI,GCCcore,gmvapich2,gmvolf,foss,fosscuda,gompi\nallow-loaded-modules=ddt,EasyBuild-custom,EasyBuild,xalt\n</code></pre></p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#easybuild-on-piz-daint","title":"EasyBuild on Piz Daint","text":"<p>On Piz Daint, which is a heterogeneous system, you need to select which architecture  should be targeted when building software. </p> <p>You can target the Intel Haswell architecture accessing the gpu software stack using the command: <pre><code>module load daint-gpu EasyBuild-custom\n</code></pre></p> <p>Alternatively, you can target the Intel Broadwell architecture and the mc (multicore) software stack: <pre><code>module load daint-mc EasyBuild-custom\n</code></pre></p> <p>On Piz Daint, EasyBuild software and modules will be installed by default under the following folder: <pre><code>$HOME/easybuild/&lt;system-name&gt;/&lt;architecture&gt;\n</code></pre></p> <p>Here <code>&lt;architecture&gt;</code> will be either <code>haswell</code> or <code>broadwell</code>.</p>"},{"location":"2021-lust/cray/easybuild_at_cscs/#building-your-program","title":"Building your Program","text":"<p>After you load the EasyBuild environment as explained in the section above,  you will have the command eb available to build your code using EasyBuild. </p> <p>If you want to build the code using a given configuration <code>&lt;filename&gt;.eb</code> and resolving dependencies,  you will use the flag <code>-r</code> as in the example below: <pre><code>eb &lt;filename&gt;.eb -r\n</code></pre></p> <p>The build command just needs the configuration file name with the extension <code>.eb</code> and not the full path,  provided that the configuration file is in your search path: the command <code>eb --show-config</code> will print  the variable robot-paths that holds the search path. </p> <p>More options are available, please have a look at the short help message typing <code>eb -h</code>. </p> <p>For instance, you can check if any EasyBuild configuration file already exists for a given program name, using the search flag -S: <pre><code>eb -S &lt;program_name&gt;\n</code></pre></p> <p>Please note that on Cray systems you can use the configuration files that rely of a Cray toolchain,  which you will find in the configuration filename (<code>eb -S &lt;name&gt; | grep Cray</code>). </p> <p>You will be able to load the modules created by EasyBuild in the folder defined by the <code>EASYBUILD_PREFIX</code>  variable using the following commands: <pre><code>module use $EASYBUILD_PREFIX/modules/all\nmodule load &lt;modulename&gt;/version\n</code></pre></p> <p>The command module use will prepend the selected folder to your MODULEPATH environment variable,  therefore you will see the new modules with module avail. </p> <p>Please note that by default <code>EASYBUILD_PREFIX</code> is set to a folder inside your <code>$HOME</code>,  however the <code>$HOME</code> folder is by default not readable by other users. </p> <p>Therefore if you want to make your builds available to your group, then you need to allow read-only access  to other members of your group using the command <code>chmod g+rx $HOME</code>.</p>"},{"location":"2021-lust/cray/external_modules/","title":"Using external modules from the Cray PE","text":"<p>EasyBuild supports the use of modules that were not installed via EasyBuild is available.  We refer to such modules as external modules.</p> <p>This feature is used extensively on Cray systems, since several software modules are already provided by the  Cray PE: external modules can be used as dependencies, by including the module name in the dependencies list,  along with the <code>EXTERNAL_MODULE</code> constant marker.</p> <p>For example, to specify the module <code>cray-fftw</code> as a dependency, you should write the following in your easyconfig file: <pre><code>dependencies = [('cray-fftw', EXTERNAL_MODULE)]\n</code></pre></p> <p>For such dependencies, EasyBuild will:</p> <ul> <li> <p>load the module before initiating the software build and install procedure</p> </li> <li> <p>include a <code>module load</code> statement in the generated module file (for runtime dependencies)</p> </li> </ul> <p>Note</p> <p>The default version of the external module will be loaded unless a specific version is given as dependency</p> <p>If the specified module is not available, EasyBuild will exit with an error message stating that the dependency  can not be resolved because the module could not be found, without searching for a matching easyconfig file.</p> <p>We show in the next sections the main external modules used as dependencies in the Cray PE.</p> <p>Note</p> <p>Component specific manpages are available only when the associated module is loaded.</p>"},{"location":"2021-lust/cray/external_modules/#compilers","title":"Compilers","text":"<p>Cray PE supports multiple compilers, Cray and third party compilers as well: AOCC, Cray, Intel, GNU. </p> <p>Users can access the compilers loading the modules <code>PrgEnv-cray</code> (loaded by default at login), <code>PrgEnv-gnu</code>, <code>PrgEnv-intel</code> and <code>PrgEnv-aocc</code>.</p> <p>The corresponding compilers and their respective dependencies will be available, including wrappers and mapping  (for example, mapping <code>cc</code> to <code>gcc</code> in <code>PrgEnv-gnu</code>).</p> <p>The commands to invoke compiler wrappers are <code>ftn</code> (Fortran), <code>cc</code> (C), <code>CC</code> (C++).</p> <p>The online help can be accessed with the <code>-help</code> option. E.g.: <code>cc -help</code>, <code>CC -help</code>. One of the most frequently used options of the compiler wrappers is <code>-craype-verbose</code>: <pre><code> ftn -help | grep verbose -A 1 \n   -craype-verbose              Print the command which is forwarded \n                                to compiler invocation\n</code></pre> More information is available with the <code>info</code> or <code>man</code> commands.  E.g.: both <code>info cc</code> or <code>man cc</code> will display the man page of the C compiler wrapper.</p> <p>The compiler wrappers call the correct compiler in the currently loaded programming environment, with appropriate options to build and link applications with relevant libraries, as required by the modules loaded. </p> <p>Therefore compiler wrappers should replace direct calls to compiler drivers in Makefiles and build scripts.</p> <p>Note</p> <p>Only dynamic linking is supported by compiler wrappers on the Cray EX system</p>"},{"location":"2021-lust/cray/external_modules/#cray-compiling-environment-cce","title":"Cray Compiling Environment (CCE)","text":"<p>The Cray Compiling Environment is set by the module <code>PrgEnv-cray</code>, which is loaded by default at login.</p> <p>Compiler-specific manpages can be accessed on the system with <code>man crayftn</code>, <code>man craycc</code> or <code>man crayCC</code>.</p> <p>More details are given in the Cray Fortran Reference Manual and the Cray Compiling Environment Release available on Cray Pubs.  The Clang Compiler User\u2019s Manual  is another source of information for the Cray C and C++ Clang compilers.</p> <p>The Cray Compiling Environment (CCE) provides Fortran, C and C++ compilers that perform substantial analysis during compilation and automatically generate highly optimized code. </p> <p>For more information about compiler pragmas and directives, see <code>man intro_directives</code> on the system.</p>"},{"location":"2021-lust/cray/external_modules/#third-party-compilers","title":"Third-Party Compilers","text":""},{"location":"2021-lust/cray/external_modules/#aocc","title":"AOCC","text":"<p>The module <code>PrgEnv-aocc</code> loads the default AMD Optimizing C/C++ Compiler  and sets the corresponding programming environment.</p> <p>Compiler-specific documentation is available in the AOCC User Guide.</p> <p>Cray provides a bundled package of support libraries to install into the PE environment to enable AOCC,  and Cray PE utilities such as debuggers and performance tools work with AOCC.</p>"},{"location":"2021-lust/cray/external_modules/#gnu","title":"GNU","text":"<p>The module <code>PrgEnv-gnu</code> loads the default GNU Compiler  and sets the corresponding programming environment:  the Cray PE bundles and enables the open-source GNU Compiler Collection (GCC). </p> <p>Compiler-specific manpages can be accessed on the system with <code>man gfortran</code>, <code>man gcc</code> or <code>man g++</code>.</p> <p>More details are provided by the GCC online documentation.</p>"},{"location":"2021-lust/cray/external_modules/#intel","title":"Intel","text":"<p>The module <code>PrgEnv-intel</code> loads the default Intel Compiler and sets the corresponding programming environment:  the Cray PE enables the Intel\u00ae oneAPI compiler and tools. </p> <p>The documentation is available in the Intel\u00ae oneAPI Programming Guide</p> <p>Cray provides a bundled package of support libraries to install into the Cray PE to enable the Intel compiler, allowing utilities such as debuggers and performance tools to work with it. </p>"},{"location":"2021-lust/cray/external_modules/#cray-scientific-and-math-library","title":"Cray Scientific and Math Library","text":"<ul> <li> <p>Modules: <code>cray-libsci</code>, <code>cray-fftw</code></p> </li> <li> <p>Manpages: <code>intro_libsci</code>, <code>intro_fftw3</code></p> </li> </ul> <p>The Cray Scientific and Math Libraries (CSML, also known as LibSci) are a collection of numerical routines optimized for best performance on Cray systems. </p> <p>These libraries satisfy dependencies for many commonly used applications on Cray systems for a wide variety of domains. </p> <p>When the module for a CSML package (such as <code>cray-libsci</code> or <code>cray-fftw</code>) is loaded,  all relevant headers and libraries for these packages are added to the compile  and link lines of the <code>cc</code>, <code>ftn</code>, and <code>CC</code> compiler wrappers.</p>"},{"location":"2021-lust/cray/external_modules/#scientific-libraries-provided-by-csml","title":"Scientific Libraries provided by CSML","text":"<p>The CSML collection contains the following Scientific Libraries:</p> <ul> <li>BLAS (Basic Linear Algebra Subroutines)</li> <li>BLACS (Basic Linear Algebra Communication Subprograms)</li> <li>CBLAS (Collection of wrappers providing a C interface to the Fortran BLAS library)</li> <li>IRT (Iterative Refinement Toolkit)</li> <li>LAPACK (Linear Algebra Routines)</li> <li>LAPACKE (C interfaces to LAPACK Routines)</li> <li>ScaLAPACK (Scalable LAPACK)</li> <li><code>libsci_acc</code> (library of Cray-optimized BLAS, LAPACK, and ScaLAPACK routines)</li> <li>NetCDF (Network Common Data Format)</li> <li>FFTW3 (the Fastest Fourier Transforms in the West, release 3)</li> </ul>"},{"location":"2021-lust/cray/external_modules/#cray-mpich","title":"Cray MPICH","text":"<ul> <li>Modules: <code>cray-mpich</code></li> <li>Manpages: <code>intro_mpi</code></li> <li>Website: https://www.mpi-forum.org</li> </ul> <p>MPI is a widely used parallel programming model that establishes a practical, portable, efficient,  and flexible standard for passing messages between ranks in parallel processes. </p> <p>Cray MPI is derived from Argonne National Laboratory MPICH and implements the MPI-3.1 standard  as documented by the MPI Forum in MPI: A Message Passing Interface Standard, Version 3.1.</p> <p>Support for MPI varies depending on system hardware. To see which functions and environment variables the system supports, please have a look at the corresponding man pages with <code>man intro_mpi</code> on the system.</p>"},{"location":"2021-lust/cray/external_modules/#dsmml","title":"DSMML","text":"<ul> <li>Modules: <code>cray-dsmml</code></li> <li>Manpages: <code>intro_dsmml</code></li> <li>Website: https://pe-cray.github.io/cray-dsmml</li> </ul> <p>Distributed Symmetric Memory Management Library (DSMML) is a HPE Cray proprietary memory management library.</p> <p>DSMML is a standalone memory management library for maintaining distributed shared symmetric memory heaps for top-level PGAS languages and libraries like Coarray Fortran, UPC, and OpenSHMEM. </p> <p>DSMML allows user libraries to create multiple symmetric heaps and share information with other libraries. </p> <p>Through DSMML, interoperability can be extracted between PGAS programming models.</p> <p>Further details are available in the man page on the system with <code>man intro_dsmml</code>.</p>"},{"location":"2021-lust/cray/external_modules/#easybuild-metadata","title":"EasyBuild Metadata","text":"<p>Metadata  can be supplied to EasyBuild for external modules: using the <code>--external-modules-metadata</code>  configuration option, the location of one or more metadata files can be specified.</p> <p>The files are expected to be in INI format, with a section per module name  and key-value assignments specific to that module.</p> <p>The external modules metadata file can be also defined with the corresponding environment variable: <pre><code>echo $EASYBUILD_EXTERNAL_MODULES_METADATA \n/apps/common/UES/jenkins/production/easybuild/cpe_external_modules_metadata-21.04.cfg\n</code></pre></p> <p>The following keys are  supported by EasyBuild:</p> <ul> <li>name: software name(s) provided by the module</li> <li>version: software version(s) provided by the module</li> <li>prefix: installation prefix of the software provided by the module</li> </ul> <p>For instance, the external module version loaded by the dependency <code>cray-fftw</code> can be specified as follows: <pre><code>[cray-fftw]\nname = FFTW\nprefix = FFTW_DIR/..\nversion = 3.3.8.10\n</code></pre></p> <p>The environment variable <code>$EBROOTFFTW</code> will also be defined according to the <code>prefix</code> specified in the metadata file.</p>"},{"location":"2021-lust/cray/external_modules/#cpe-meta-module","title":"CPE meta-module","text":"<p>The Cray PE on the EX system provides the meta-module <code>cpe</code>: the purpose of the meta-module is similar to the scope of the <code>cdt</code> and <code>cdt-cuda</code> meta-modules available on the XC systems.</p> <pre><code>$ module show cpe\n--------------------------------------------------------------------------------------------------------------------------------\n   /opt/cray/pe/lmod/modulefiles/core/cpe/21.04.lua:\n--------------------------------------------------------------------------------------------------------------------------------\nsetenv(\"LMOD_MODULERCFILE\",\"/opt/cray/pe/cpe/21.04/modulerc.lua\")\nunload(\"PrgEnv-cray\")\nload(\"PrgEnv-cray/8.0.0\")\nunload(\"craype\")\nload(\"craype/2.7.6\")\nunload(\"cray-libsci\")\nload(\"cray-libsci/21.04.1.1\")\nunload(\"cce\")\nload(\"cce/11.0.4\")\nunload(\"cray-mpich\")\nload(\"cray-mpich/8.1.4\")\nunload(\"perftools-base\")\nload(\"perftools-base/21.02.0\")\nunload(\"cray-dsmml\")\nload(\"cray-dsmml/0.1.4\")\n</code></pre> <p>The meta-module loads the correct default versions of the modules with the selected Cray PE version,  as defined by the corresponding <code>LMOD_MODULERCFILE</code> referenced in the module.</p> <p>A site can create custom versions of the meta-module, in order to to override the module defaults.</p> <p>[next: Custom Toolchains]</p>"},{"location":"2021-lust/cray/introduction/","title":"Introduction to the Cray Programming Environment","text":"<p>The Cray Programming Environment (PE) provides tools designed to maximize developer productivity, application  scalability, and code performance, including compilers, analyzers, optimized libraries, and debuggers. </p>"},{"location":"2021-lust/cray/introduction/#cray-pe-components","title":"Cray PE Components","text":"<ul> <li>Cray Compiling Environment (CCE):</li> </ul> <p>CCE consists of Cray compilers performing code analysis during compilation to generate highly optimized code.    Supported languages include Fortran, C and C++, and UPC (Unified Parallel C).</p> <ul> <li>Cray Scientific and Mathematical Libraries: </li> </ul> <p>A set of high performance libraries providing portability for scientific applications, sparse and dense linear   algebra (BLAS, LAPACK, ScaLAPACK) and fast Fourier transforms (FFTW).</p> <ul> <li>Cray Message Passing Toolkit:</li> </ul> <p>A collection of software libraries used to perform data transfers between nodes running in parallel applications.    It includes the Message Passing Interface (MPI) and OpenSHMEM parallel programming models. </p> <ul> <li>Cray Environment Setup and Compiling Support:</li> </ul> <p>Libraries supporting code compilation and setting up the development environment, including compiler drivers.</p> <ul> <li>Cray Performance and Analysis Tools:</li> </ul> <p>Tools to analyze the performance and behavior of programs that are run on Cray systems, and a Performance API (PAPI).</p> <ul> <li>Cray Debugging Support Tools:</li> </ul> <p>Debugging tools, including <code>gdb4hpc</code> and <code>Valgrind4hpc</code>.</p>"},{"location":"2021-lust/cray/introduction/#modules","title":"Modules","text":"<p>Modules enable users to modify their environment dynamically by using modulefiles:  the <code>module</code> command provides a user interface to the Environment Modules package. </p> <p>The module command interprets modulefiles, which contain Tool Command Language (Tcl) code,  and dynamically modifies shell environment variables such as <code>PATH</code> and <code>MANPATH</code>.</p> <p>Cray sites can alternately enable Lmod to handle modules with the  Cray Programming Environment on Cray EX Systems. </p> <p>Both module systems use the same module names and syntax shown in command-line examples.</p> <p>Note</p> <p>Environment Modules and Lmod are mutually exclusive and cannot both run on the same system.</p> <p>The configuration files <code>/etc/cray-pe.d/cray-pe-configuration.sh</code> and <code>/etc/cray-pe.d/cray-pe-configuration.csh</code>  allow sites to customize the default environment. </p> <p>To support customer-specific needs, the system administrator  can create modulefiles for a product set for the users: </p> <ul> <li>for more information about the Environment Modules software package see the help screen <code>module -h</code>.</li> </ul>"},{"location":"2021-lust/cray/introduction/#programming-environment-meta-modules","title":"Programming Environment meta-modules","text":"<p>Programming Environment modules are organized into meta-modules, where each supports a different compiler suite. </p> <p>These modules are <code>PrgEnv-aocc</code>, <code>PrgEnv-cray</code>, <code>PrgEnv-gnu</code> and <code>PrgEnv-intel</code>. </p> <p>Meta-modules provide wrappers (<code>cc</code>, <code>CC</code>, <code>ftn</code>) for both Cray and third-party compiler drivers.</p> <p>The main purposes of using the Cray wrappers are the following:</p> <ol> <li> <p>call the correct compiler with appropriate options to build and link applications </p> </li> <li> <p>link relevant libraries as required by modules loaded, with only dynamic linking supported </p> </li> <li> <p>replace direct calls to compiler drivers in Makefiles and build scripts</p> </li> </ol>"},{"location":"2021-lust/cray/introduction/#lmod","title":"Lmod","text":"<p>In addition to the default Environment Modules system, Cray PE offers support  for Lmod as an alternative module management system.</p> <p>Lmod is a Lua-based module system that loads and unloads modulefiles, handles path variables, and manages library and header files.</p> <p>The Cray PE implementation of Lmod is hierarchical, managing module dependencies and ensuring any module a user has access to is compatible with other loaded modules. </p> <p>Lmod loads related compiler, network, CPU, and MPI modules adding dynamic module paths to the Lmod hierarchy:</p> <ul> <li>\"families\" of modules are used to flag circular conflicts, for instance: </li> <li>when module details are displayed through <code>module show</code></li> <li> <p>when users attempt to load conflicting modules</p> </li> <li> <p>a default set of modules is loaded automatically: the default set includes compiler, network, CPU and MPI modules</p> </li> <li> <p>Users may choose to load a different module set,  defining user collections</p> </li> </ul> <p>Environment Modules and Lmod modules use the same names in the Cray Programming Environment,  therefore all command examples work the same whether using Environment Modules or Lmod.</p> <p>For more information, please refer to the User Guide for Lmod.</p>"},{"location":"2021-lust/cray/introduction/#documentation","title":"Documentation","text":"<p>Cray Pubs is the documentation portal of HPE/Cray  and the main source of the information provided in this tutorial. </p> <p>Documentation on the Cray Programming Environment (PE) can be found under  the PE-Tile.  The page provides links to the following content:</p> <ul> <li> <p>PE Release Announcements</p> </li> <li> <p>PE Installation &amp; Configuration</p> </li> <li> <p>Cray Compiling Environment (CCE)</p> </li> <li> <p>PE User Procedures (including Cray Programming Environment User Guides)</p> </li> </ul> <p>The GitHub project PE-Cray provides additional documentation:</p> <ul> <li> <p>Whitepapers are available at https://github.com/PE-Cray/whitepapers</p> </li> <li> <p>Documentation for cray-openshmemx</p> </li> <li> <p>Information on cray-dsmml</p> </li> </ul> <p>[next: External Modules]</p>"},{"location":"2022-isc22/","title":"ISC'22 EasyBuild tutorial","text":""},{"location":"2022-isc22/#maintaining-a-modern-scientific-software-stack-made-easy-with-easybuild","title":"Maintaining a Modern Scientific Software Stack Made Easy with EasyBuild","text":"<p>The EasyBuild tutorial at ISC'22 takes place on Sunday 29 May 2022, 14:00-18:00 CEST.</p> <p>To attend the live tutorial, you must be registered to ISC'22 (more information here).</p> <p>All tutorial content will remain afterwards.</p>"},{"location":"2022-isc22/#slides","title":"Slides","text":"<p>The most recent version of the presentation slides are available here.</p>"},{"location":"2022-isc22/#agenda","title":"Agenda","text":"<p>(all times are CEST)</p> <ul> <li>[14:00-14:10] Practical info w.r.t. prepared environment for hands-on</li> <li>[14:10-14:30] Introduction to EasyBuild: scope and terminology</li> <li>[14:30-14:50] Installing, configuring and basic usage of   EasyBuild</li> <li>[14:50-15:30] Installing software + troubleshooting</li> <li>[15:30-16:00] Adding support for additional software</li> <li>[16:00-16:30] (coffee break)</li> <li>[16:30-16:50] Module naming schemes (incl. hierarchical)</li> <li>[16:50-17:30] Integration of EasyBuild in JSC, EESSI, and LUMI</li> <li>[17:30-17:45] The EasyBuild community + contributing to EasyBuild</li> <li>[17:45-18:00] Q&amp;A + closing remarks (incl. quick comparison with other tools)</li> </ul>"},{"location":"2022-isc22/adding_support_additional_software/","title":"Adding support for additional software","text":"<p>We already know how to install easyconfig files that are included with EasyBuild, but what about installing software for which no easyconfig is available yet?</p> <p>To do this we will need to create additional easyconfig files, since every software installation performed by EasyBuild is done based on an easyconfig file.</p> <p>In this part of the tutorial we will look at the guts of easyconfig files and even create some ourselves!</p>"},{"location":"2022-isc22/adding_support_additional_software/#easyconfigs-vs-easyblocks","title":"Easyconfigs vs easyblocks","text":"<p>Before we dive into writing easyconfig files, let's take a brief look at how they relate to easyblocks.</p> <p>As we discussed earlier, an easyconfig file (<code>*.eb</code>) is required for each installation performed by EasyBuild. It specifies the details of the installation (which software version, toolchain, dependencies including their versions, etc.),  while the installation procedure is implemented in an easyblock (a Python module that leverages the EasyBuild framework).</p> <p>When can we leverage a generic easyblock, perhaps via a \"fat\" easyconfig file that includes a lot of carefully defined easyconfig parameters, and when should we use a minimal easyconfig file together with a custom software-specific easyblock?</p> <p>This is not an easy question to answer in general, since it depends on several factors: the complexity of the software you want to get installed, how much flexibility you want, how \"intelligent\" the implementation of the installation procedure should be with respect to the compiler toolchain and dependencies that are used for the installation, etc.</p> <p>In a nutshell, custom software-specific easyblocks are \"do once and forget\": they are central  solution to peculiarities in the installation procedure of a particular software package.</p> <p>Reasons to consider implementing a software-specific easyblock rather than using a generic easyblock include:</p> <ul> <li>'critical' values for easyconfig parameters required to make installation succeed;  <ul> <li>For example, the easyblock for bowtie2   defines a number of variables used in the Makefile on the make command line to ensure that the right   compilers are used (look for the <code>build_step</code> in the easyblock).</li> </ul> </li> <li>toolchain-specific aspects of the build and installation procedure (e.g., configure options);<ul> <li>For example, the easyblock for CP2K    will add several compiler options when compiling with gcc and gfortran, including the infamous   <code>-fallow-argument-mismatch</code> which is required from gfortran 10 on for many older codes.</li> </ul> </li> <li>custom (configure) options for dependencies;  <ul> <li>For example, the easyblock for VMD   will add configure options depending on the dependency list of the package.</li> </ul> </li> <li>interactive commands that need to be run;  <ul> <li>For example: The easyblock for maple    responds to a number of interactive questions.</li> </ul> </li> <li>having to create or adjust specific (configuration) files;  <ul> <li>For example, the easyblock for Siesta   edits one of the configuration files through regular expressions.</li> </ul> </li> <li>'hackish' usage of a generic easyblock;</li> <li>complex or very non-standard installation procedure;  <ul> <li>For example, the easyblock to install the gcc compilers from source,   bootstrapping with the system compiler and then re-installing with itself.</li> </ul> </li> </ul> <p>Implementing easyblocks is out of scope for this basic tutorial, for more information please consult the EasyBuild documentation, or a more extensive version of the EasyBuild tutorial.</p>"},{"location":"2022-isc22/adding_support_additional_software/#writing-easyconfig-files","title":"Writing easyconfig files","text":"<p>Writing an easyconfig file boils down to defining a set of easyconfig parameters in a text file, which we give a '<code>.eb</code>' extension by convention. The name of an easyconfig file doesn't matter when using it directly to install software, but it does matter when EasyBuild needs to find it to resolve a dependency for example (EasyBuild will then derive the name of the easyconfig from the name, version, version suffix and toolchain specified for the dependency so the file name needs to adhere to a specific convention as we discussed earlier).</p> <p>The syntax for easyconfig files is Python syntax: you are basically defining a bunch of Python variables that correspond to easyconfig parameters.</p> <p>The order in which the easyconfig parameters are defined doesn't matter, but we generally try to strick to a particular order which roughly corresponds to the order in which the easyconfig parameters are used during the installation. That is mostly helpful for humans staring at easyconfig files or comparing them.</p>"},{"location":"2022-isc22/adding_support_additional_software/#mandatory-parameters","title":"Mandatory parameters","text":"<p>A limited number of easyconfig parameters are mandatory, they must be defined in every easyconfig file:</p> <ul> <li><code>name</code>: the name of the software to install;</li> <li><code>version</code>: the version of the software to install;</li> <li><code>homepage</code>: a URL to the website of the software;</li> <li><code>description</code>: a short description of the software;</li> <li><code>toolchain</code>: the compiler toolchain to use for the installation;</li> </ul> <p><code>name</code>, <code>version</code></p> <p>It should be no surprise that specifying the name and version of the software you want to install is mandatory. This information may influence the value of several other easyconfig parameters (like the name of the source file),  and is also used to the determine the name of the module file to install.</p> <pre><code>name = 'example'\nversion = '1.0'\n</code></pre> <p><code>homepage</code>, <code>description</code></p> <p>The homepage and description are included in the generated module file for the installation. That way the \"<code>module show</code>\" command provides some useful high-level information about the installation.</p> <pre><code>homepage = 'https://example.org'\ndescription = \"This is just an example.\"\n</code></pre> <p>Usually it does not matter whether you use single or double quotes to specify string values, but you will often see that single quotes are used for values that don't have spaces (words) and double quotes for values that do have spaces (sentences). There is no technical reason for this, it just feels more natural to some people. There are cases where it is important to use the right type of quotes however, we will get back to that later (keep it in mind for the exercises!).</p> <p>For multi-line descriptions, you will need to use \"triple quoting\" (which is standard Python syntax):</p> <pre><code>description = \"\"\"This is an example\n of a multi-line description.\n It is spread across multiple lines.\"\"\"\n</code></pre> <p><code>toolchain</code></p> <p>EasyBuild also requires that the compiler toolchain is specified, via the <code>toolchain</code> easyconfig parameter.</p> <p>This can either be the <code>system</code> toolchain, for which a constant named <code>SYSTEM</code> is available:</p> <pre><code>toolchain = SYSTEM\n</code></pre> <p>Usually we specify a 'proper' toolchain like the compiler-only toolchain GCC 11.2.0 which we used before, or the full toolchain <code>foss</code> 2021b. The name and version of the toolchain can be specified using a small Python dictionary, for example:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '11.2.0'}\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#commonly-used-parameters","title":"Commonly used parameters","text":"<p>You will often need to specify additional easyconfig parameters to get something useful done. We will cover the most commonly used ones here, in the order in which you would usually specify them in the easyconfig file, but keep in mind that these are not mandatory.</p> <p>A full overview of all known easyconfig parameters can be obtained via \"<code>eb --avail-easyconfig-params</code>\" or just \"<code>eb -a</code>\" for short, or can be consulted in the EasyBuild documentation.</p>"},{"location":"2022-isc22/adding_support_additional_software/#easyblock","title":"Easyblock","text":"<p>The easyblock that should be used for the installation can be specified via the <code>easyblock</code> easyconfig parameter.</p> <p>This is not mandatory however, because by default EasyBuild will determine the easyblock to use based on the name of the software. If '<code>example</code>' is specified as software name, EasyBuild will try to locate a software-specific easyblock named <code>EB_example</code> (in a Python module named <code>example.py</code>). Software-specific easyblocks follow the convention that the class name starts with <code>'EB_</code>', followed by the software name (where some characters are replaced, like '<code>-</code>' with '<code>_minus_</code>').</p> <p>Generic easyblocks</p> <p>Usually the <code>easyblock</code> value is the name of a generic easyblock, if it is specified. The name of a generic easyblock does not start with '<code>EB_</code>', so you can easily distinguish it from a software-specific easyblock.</p> <p>Here are a couple of commonly used generic easyblocks:</p> <ul> <li><code>ConfigureMake</code>: implements the standard <code>./configure</code>, <code>make</code>, <code>make install</code> installation procedure;</li> <li><code>CMakeMake</code>: same as <code>ConfigureMake</code>, but with <code>./configure</code> replaced with <code>cmake</code> for the configuration step;</li> <li><code>PythonPackage</code>: implements the installation procedure for a single Python package, by default using    \"<code>python setup.py install</code>\" but other methods like using \"<code>pip install</code>\" are also supported;</li> <li><code>Bundle</code>: a simple generic easyblock to bundle a set of software packages together in a single installation directory;</li> <li><code>PythonBundle</code>: a customized version of the <code>Bundle</code> generic easyblock to install a bundle of Python packages   in a single installation directory;</li> </ul> <p>A full overview of the available generic easyblocks is available in the EasyBuild documentation. You can also consult the output of <code>eb --list-easyblocks</code>, which gives an overview of all known easyblocks, and how they relate to each other.</p> <p>Custom easyconfig parameters</p> <p>Most generic easyblocks provide additional easyconfig parameters to steer their behaviour. You can consult these via \"<code>eb -a --easyblock</code>\" or just \"<code>eb -a -e</code>\", which results in an additional \"<code>EASYBLOCK-SPECIFIC</code>\" section to be added. See the (partial) output of this command for example:</p> <pre><code>$ eb -a -e ConfigureMake\nAvailable easyconfig parameters (* indicates specific to the ConfigureMake easyblock):\n...\nEASYBLOCK-SPECIFIC\n------------------\nbuild_cmd*              Build command to use [default: \"make\"]\nbuild_type*             Value to provide to --build option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\nconfigure_cmd*          Configure command to use [default: \"./configure\"]\nconfigure_cmd_prefix*   Prefix to be glued before ./configure [default: \"\"]\nhost_type*              Value to provide to --host option of configure script, e.g., x86_64-pc-linux-gnu (determined by config.guess shipped with EasyBuild if None, False implies to leave it up to the configure script) [default: None]\ninstall_cmd*            Build command to use [default: \"make install\"]\nprefix_opt*             Prefix command line option for configure script ('--prefix=' if None) [default: None]\ntar_config_opts*        Override tar settings as determined by configure. [default: False]\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#version-suffix","title":"Version suffix","text":"<p>In some cases you may want to build a particular software package in different configurations,  or include a label in the module name to highlight a particular aspect of the installation.</p> <p>The <code>versionsuffix</code> easyconfig parameter can be used for this purpose.  The name of this parameter implies that this label will be added after the software version (and toolchain label) in the standard module naming scheme.</p> <p>If you are configuring the software to build with a particular non-default value, you can indicate this as follows for example:</p> <pre><code>versionsuffix = '-example-label'\n</code></pre> <p>This mechanism is used frequently to indicate that a software installation depends on a particular version of Python, where the <code>%(pyver)s</code> template comes in useful again:</p> <pre><code>versionsuffix = '-Python-%(pyver)s'\n...\ndependencies = [('Python', '2.7.18')]\n</code></pre> <p>Even though Python 2 is officially dead and buried some scientific software still requires it, and mixing modules where some use Python 2 and other use Python 3 doesn't work well. The <code>versionsuffix</code> label is helpful to inform the user that a particular Python version is required by the installation.</p>"},{"location":"2022-isc22/adding_support_additional_software/#sources-patches-and-checksums","title":"Sources, patches, and checksums","text":"<p>In most easyconfig files you will see that a list of source files is specified via the <code>sources</code> easyconfig parameter, usually combined with one or more URLs where these sources can be downloaded specified via <code>source_urls</code>. There also may be patch files listed (specified via <code>patches</code>), and checksums for both the source files and patches (specified via <code>checksums</code>).</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>Here is an example of how these easyconfig parameters can be specified:</p> <pre><code>source_urls = [\n    'https://example.org/download/',\n    'https://example.org/download/archive/',\n]\nsources = ['example-1.0-src.tar.gz']\npatches = ['example-fix.patch']\nchecksums = [\n    '9febae18533d035ac688d977cb2ca050e6ca8379311d7a14490ad1ef948d45fa',\n    '864395d648ad9a5b75d1a745c8ef82b78421d571584037560a22a581ed7a261c',\n]\n</code></pre> <p>Each of these require a list of values, so even if there is only a single source file or download URL you must use square brackets as shown in the example. The default value for each of these is an empty list (<code>[]</code>).</p> <p>Some things worth pointing out here:</p> <ul> <li>The download URLs specified via <code>source_urls</code> do not include the name of the file, that is added   automatically by EasyBuild when it tries to download the file (only if it's not available already.)</li> <li>If multiple download URLs are specified, they are each tried once in order until the download of the source file was   successful. This can be useful to include backup locations where source files can be downloaded from.</li> <li>Names of source files and patches should not include hardcoded software versions, they usually use a   template value like <code>%(version)s</code> instead:   <pre><code>sources = ['example-%(version)s-src.tar.gz']\n</code></pre>   EasyBuild will use the value of the <code>version</code> easyconfig parameter to determine the actual name of the source   file. This way the software version is only specified in one place and the easyconfig file is easier to   update to other software versions. A list of template values can be consulted via the EasyBuild command   line via the <code>--avail-easyconfig-templates</code> option, or in the EasyBuild documentation.</li> <li>Source files can also be specified in ways other than just using a filename, see the EasyBuild documentation for more information.</li> <li>Specified checksums are usually SHA256 checksum values, but other types are also supported.</li> </ul>"},{"location":"2022-isc22/adding_support_additional_software/#dependencies","title":"Dependencies","text":"<p>You will often need to list one or more dependencies that are required to install or run the software. We distinguish between two main different types of dependencies: runtime dependencies and build dependencies.</p> <p>Runtime dependencies are required for using the installed software, and may also have to be available during the installation. These dependencies can be specified via the <code>dependencies</code> easyconfig parameter. EasyBuild will load the modules for these dependencies when setting up the build environment, and will include load statements for them in the generated module file.</p> <p>Build dependencies are only required during the installation of the software, not for using the software once it is installed. The modules for these dependencies will be loaded in the build environment set up by EasyBuild during the installation, but they will not be loaded by the generated module file. You can specify build dependencies via the <code>builddependencies</code> easyconfig parameter. One typical example of a build dependency is <code>CMake</code>, which is only needed for configuring the build.</p> <p>Here is a simple example of specifying dependencies:</p> <pre><code>builddependencies = [('CMake', '3.22.1')]\n\ndependencies = [\n    ('Python', '3.9.6'),\n    ('HDF5', '1.12.1'),\n    ('SciPy-bundle', '2021.10', '-Python-%(pyver)s'),\n]\n</code></pre> <p>Both <code>builddependencies</code> and <code>dependencies</code> require a list of tuples, each of which specifying one dependency. The name and version of a dependency is specified with a 2-tuple (a tuple with two string values).</p> <p>In some cases additional information may have to be provided, as is shown in the example above for the <code>SciPy-bundle</code> dependency where a 3rd value is specified corresponding to the <code>versionsuffix</code> value of this dependency. If this is not specified, it is assumed to be the empty string (<code>''</code>).</p> <p>Note how we use the '<code>%(pyver)s'</code> template value in the <code>SciPy-bundle</code> dependency specification, to avoid hardcoding the Python version in different places.</p> <p>See also the EasyBuild documentation for additional options on specifying dependencies.</p>"},{"location":"2022-isc22/adding_support_additional_software/#customizing-configure-build-test-and-install-commands","title":"Customizing configure, build, test, and install commands","text":"<p>When using a generic easyblock like <code>ConfigureMake</code> or <code>CMakeMake</code>, you will often find yourself having to specify options to the configure, build, test, or install commands,  or to inject additional commands right before them.</p> <p>For this the following standard easyconfig parameters are available:</p> <ul> <li><code>preconfigopts</code>: string value that is glued before the configure command;</li> <li><code>configopts</code>: string value that is added after the configure command, which can be used to specify configuration options;</li> </ul> <p>Equivalent easyconfig parameters are available for the <code>build</code>, <code>test</code> and <code>install</code> steps:  <code>prebuildopts</code>, <code>buildopts</code>, <code>pretestopts</code>, <code>testopts</code>, <code>preinstallopts</code>, and <code>installopts</code>.</p> <p>Here is a fictitious example of how they can be used:</p> <pre><code>easyblock = 'ConfigureMake'\n...\ndependencies = [('HDF5', '1.12.1')]\n...\nconfigopts = '--enable-hdf5-support'\n\nprebuildopts = 'export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp; '\n\ninstallopts = \"PREFIX='%(installdir)s'\"\n</code></pre> <p>Here we are:</p> <ul> <li> <p>adding the <code>--enable-hdf5-support</code> configure option, to convince the <code>ConfigureMake</code> easyblock to run the following   command during the configure step:   <pre><code>./configure --prefix ... --enable-hdf5-support\n</code></pre>   The '<code>...</code>' represents the path to installation directory where the software should be installed.   The <code>--prefix</code> option is included automatically by the <code>ConfigureMake</code> easyblock.</p> </li> <li> <p>specifying that an additional command has to be run before running <code>make</code> in the build step. We use '<code>&amp;&amp;</code>' to glue the   command to the <code>make</code> command, so <code>make</code> will only be run if the command we specified ran correctly.    So, the build step will run something like:   <pre><code>export HDF5_PREFIX=\"$EBROOTHDF5\" &amp;&amp;  make -j 4\n</code></pre>   The '<code>4</code>' value passed to the <code>-j</code> option shown here, which specifies how many commands <code>make</code> can run in parallel,    is automatically determined by EasyBuild based on the number of available cores (taking into account <code>ulimit</code> settings, and cpuset and cgroup restrictions).</p> </li> <li> <p>passing the location where the software should be installed via the <code>PREFIX</code> argument to the <code>make install</code> command during the installation step. This results in the   following command being run:   <pre><code>make install PREFIX=...\n</code></pre>   (where the '<code>...</code>' again represents the path to installation directory).   Even though the   installation directory is already specified in the configure command, it is   apparently blatantly ignored by the software we are installing here, and we are expected to specify it   this way instead. How rude!</p> </li> </ul> <p>The <code>$EBROOTHDF5</code> environment variable that we are using in <code>prebuildopts</code> corresponds to the path of the installation directory of the HDF5 dependency. EasyBuild includes a statement to define an <code>$EBROOT*</code> environment variable like this in every environment module file it generates (see the output of \"<code>module show HDF5</code>\").</p>"},{"location":"2022-isc22/adding_support_additional_software/#sanity-check","title":"Sanity check","text":"<p>One seemingly trivial yet important aspect of the installation procedure that EasyBuild performs is the sanity check step.</p> <p>By default EasyBuild does a simple sanity check that verifies whether there is a non-empty <code>bin</code> subdirectory in the installation, next to a non-empty <code>lib</code> or <code>lib64</code> directory (either is sufficient).</p> <p>It is recommended to customize the sanity check and check for something more specific, like a particular binary or directory, or making sure that a trivial command (like <code>example -V</code> or <code>example --help</code>) runs correctly.</p> <p>To specify a custom set of files and/or directories to check, you can use the <code>sanity_check_paths</code> easyconfig parameter. The expected value is Python dictionary with two keys: <code>files</code> and <code>dirs</code>. For example:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/example'],\n    'dirs': ['examples/one', 'examples/two'],\n}\n</code></pre> <p>In addition, you can specify one or more commands that should be working without a problem (that is, have a zero exit status) via the <code>sanity_check_commands</code> easyconfig parameter. These commands will be run just like a user would: after loading the module that was generated for this installation. Here is an example:</p> <pre><code>sanity_check_commands = [\n    \"example --version\",\n    \"example --help\",\n]\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#module-class","title":"Module class","text":"<p>Finally, you will usually see the <code>moduleclass</code> easyconfig parameter to be defined as well, for example:</p> <pre><code>moduleclass = 'lib'\n</code></pre> <p>This is done to categorize software, and it is used to group the generated module files into smaller sets  (remember what we saw when installing software earlier).</p>"},{"location":"2022-isc22/adding_support_additional_software/#generating-tweaked-easyconfigs","title":"Generating tweaked easyconfigs","text":"<p>Sometimes you may want to install software that differs only slightly from an existing easyconfig file, like a newer software version or using a different compiler toolchain. Do we need to create an easyconfig file for this too?</p> <p>We do, but EasyBuild does provide some help so you don't need to manually create the easyconfig file. You can use one of the <code>--try-*</code> options provided by the <code>eb</code> command to make EasyBuild generate a new easyconfig file based on an existing one.</p> <p>For example, to try installing a different software version you can use the <code>--try-software-version</code> option:</p> <pre><code>eb example-1.2.3.eb --try-software-version 1.2.4\n</code></pre> <p>Or, to try using a different compiler toolchain you can use <code>--try-toolchain</code>:</p> <pre><code>eb example-1.2.3-foss-2021b.eb --try-toolchain intel,2021b\n</code></pre> <p>There is also an option to change other eashyconfig parameters,  <code>--try-amend=VAR=Value[,VALUE]</code>. </p> <pre><code>eb example-123-foss-2021b-DP.eb --try-amend=versionsuffix='-test'\n</code></pre> <p>This option can be used multiple times to make additional amendments. </p> <p>It is important to keep in mind the \"try\" aspect here: while easyconfigs that are generated by EasyBuild via a <code>--try-*</code> option often do work fine, there is no strong guarantee they will. Newer software versions may come with changes to the installation procedure, additional dependencies that are required, etc. Using a different compiler toolchain may be as simple as just switching one for another, but it may require additional changes to be made to configure options, for example.</p> <p>The easyconfig files modified in this way will be stored in the <code>easybuild</code> subdirectory of the software installation directory and in the easyconfig archive that EasyBuild creates.</p>"},{"location":"2022-isc22/adding_support_additional_software/#copying-easyconfigs","title":"Copying easyconfigs","text":"<p>One additional handy command line option we want to highlight is <code>--copy-ec</code>, which can be used to copy easyconfig files to a specific location. That may sound trivial, but keep in mind that you can specify easyconfigs to the <code>eb</code> command using only the filename, and letting the robot search mechanism locate them.</p> <p>So to copy an easyconfig file, we would have to use <code>eb --search</code> first to get the full location to it, copy-paste that, and then use the <code>cp</code> command.</p> <p>It is a lot easier with <code>--copy-ec</code>:</p> <pre><code>$ eb --copy-ec SAMtools-1.11-GCC-11.2.0.eb SAMtools.eb\n...\nSAMtools-1.10-GCC-11.2.0.eb copied to SAMtools.eb\n</code></pre> <p>If you omit the target location, the easyconfig file will simply be copied to the current working directory, retaining the original filename.</p> <p>You can copy multiple easyconfig files at once, as long as the target location is an existing directory.</p>"},{"location":"2022-isc22/adding_support_additional_software/#example","title":"Example","text":"<p>By means of example, we are going to puzzle together an easyconfig file to install the example software package <code>eb-tutorial</code>.</p> <p>The sources for <code>eb-tutorial</code> version 1.0.1 are available at:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.0.1.tar.gz\n</code></pre> <p>You can consult the unpacked sources at https://github.com/easybuilders/easybuild-tutorial/tree/main/docs/files/eb-tutorial-1.0.1.</p>"},{"location":"2022-isc22/adding_support_additional_software/#preparation","title":"Preparation","text":"<p>Make sure EasyBuild is properly configured before you start:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>and that the installed software in <code>/easybuild</code> is available:</p> <pre><code>module use /easybuild/modules/all\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#mandatory-parameters_1","title":"Mandatory parameters","text":"<p>Let's start by getting the mandatory easyconfig parameters defined in the easyconfig file.</p> <p>We will use <code>GCC/11.2.0</code> as toolchain, since we know it is already installed in <code>/easybuild</code> in the prepared environment,  so we define the <code>toolchain</code> easyconfig parameter:</p> <pre><code>name = 'eb-tutorial'\nversion = '1.0.1'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\ntoolchain = {'name': 'GCC', 'version': '11.2.0'}\n</code></pre> <p>In addition, we'll also specify the <code>moduleclass</code>. This is not required, but it is usually set to a sensible value:</p> <pre><code>moduleclass = 'tools'\n</code></pre> <p>The default value is '<code>base</code>', at least '<code>tools</code>' has some meaning.</p>"},{"location":"2022-isc22/adding_support_additional_software/#easyblock_1","title":"Easyblock","text":"<p>Let us see what happens if we take our current easyconfig file for a spin:</p> <pre><code>$ eb example.eb\n== temporary log file in case of crash /tmp/eb-8_vxjfn7/easybuild-k3aaoan2.log\nERROR: Failed to process easyconfig /home/example/example.eb:\nNo software-specific easyblock 'EB_eb_minus_tutorial' found for eb-tutorial\n</code></pre> <p>That didn't get us very far...</p> <p>The error shows that there is no software-specific easyblock available for installing the software with the name '<code>eb-tutorial</code>'. Does that mean we have to implement an easyblock?</p> <p>In this simple case it doesn't, since we can leverage one of the available generic easyblocks. But, which one?</p> <p>Build instructions are usually included in a <code>README</code> file, or in the documentation. In this case, there's indeed a minimal <code>README</code> file available, which tells us that we should use the <code>cmake</code> command to configure the installation, followed by <code>make</code> and <code>make install</code>.</p> <p>We briefly discussed a generic easyblock that does exactly this: <code>CMakeMake</code>.</p> <pre><code>easyblock = 'CMakeMake'\n</code></pre> <p>The \"<code>easyblock =</code>\" line is usually at the top of the easyconfig file, but strictly speaking the order of the parameter definitions doesn't matter (unless one is defined in terms of another one).</p>"},{"location":"2022-isc22/adding_support_additional_software/#cmake-build-dependency","title":"CMake build dependency","text":"<p>Does using the <code>CMakeMake</code> generic easyblock help at all?</p> <pre><code>$ eb example.eb\n== temporary log file in case of crash /tmp/eb-yutbor1p/easybuild-4jc9v1u9.log\n== found valid index for /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs, so using it...\n== processing EasyBuild easyconfig /home/example/example.eb\n== building and installing eb-tutorial/1.0.1-GCC-11.2.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== patching...\n== preparing...\n== configuring...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-11.2.0):\nbuild failed (first 300 chars): cmd \" cmake -DCMAKE_INSTALL_PREFIX=/home/example/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER='gcc' -DCMAKE_C_FLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno' -DCMAKE_CXX_COMPILER='g++' -DCMAKE_CXX_FLAGS='-O2 -ftree-vectorize -march=native  (took 0 sec)\n</code></pre> <p>It did help: EasyBuild made an attempt to configure the build using the <code>cmake</code> command, but that failed almost instantly. We need to dive into the log file to see the actual reason. By starting at the end of the log file and scrolling up, you should be able to locate the following error message:</p> <pre><code>/bin/bash: cmake: command not found\n</code></pre> <p>Ah, that explains it, <code>cmake</code> isn't even installed on this system. Or is it?</p> <pre><code>$ module avail CMake\n\n--------------------------- /easybuild/modules/all ----------------------------\n   CMake/3.22.1-GCCcore-11.2.0\n</code></pre> <p>Since a module is available for <code>CMake</code> that is compatible with the toolchain we are using (GCC 11.2.0), we can use it as a dependency for the installation. It is only needed for building the software, not for running it, so it's only a build dependency:</p> <pre><code>builddependencies = [('CMake', '3.22.1')]\n</code></pre> <p>There is usually no need to specify toolchain for (build) dependencies, EasyBuild will automatically consider subtoolchains compatible with the specified toolchain to locate module for the dependencies.</p> <p>You can verify this via <code>eb -D</code> (equivalent with <code>eb --dry-run</code>):</p> <pre><code>$ eb example.eb -D\n ...\n * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/g/GCC/GCC-11.2.0.eb (module: GCC/11.2.0)\n * [x] /easybuild/software/EasyBuild/4.3.3/easybuild/easyconfigs/c/CMake/CMake-3.22.1-GCCcore-11.2.0.eb (module: CMake/3.22.1-GCCcore-11.2.0)\n * [ ] /home/example/example.eb (module: eb-tutorial/1.0.1-GCC-11.2.0)\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#sources","title":"Sources","text":"<p>If you try again after adding <code>CMake</code> as a build dependency, you will see the installation fail again in the configuration step. Inspecting the log file reveals this:</p> <pre><code>CMake Error: The source directory \"/tmp/example/ebtutorial/1.0.1/GCC-11.2.0\" does not appear to contain CMakeLists.txt.\n</code></pre> <p>Wait, but there is a <code>CMakeLists.txt</code>, we can see it in the unpacked sources!</p> <p>Let's inspect the build directory:</p> <pre><code>$ ls /tmp/$USER/ebtutorial/1.0.1/GCC-11.2.0\neasybuild_obj\n$ ls /tmp/$USER/ebtutorial/1.0.1/GCC-11.2.0/easybuild_obj\n$\n</code></pre> <p>There's nothing there at all! And that's not strange because we didn't actually specify any sources in our easyconfig file...</p> <p>The <code>sources</code> easyconfig parameter is commonly defined but it is not mandatory, because some easyconfig files only specify bundles of software packages and hence only serve to generate a module file.</p> <p>So we need to specify one or more source files that should be used, via the <code>sources</code> easyconfig parameter which specifies a list of names of source files:</p> <pre><code>sources = ['eb-tutorial-1.0.1.tar.gz']\n</code></pre> <p>We can avoid hardcoding the version number here by using a template value:</p> <pre><code>sources = ['eb-tutorial-%(version)s.tar.gz']\n</code></pre> <p>And since this is a standard way of naming software files, there's even a constant available that we can use:</p> <pre><code>sources = [SOURCE_TAR_GZ]\n</code></pre> <p>That way, we only have the software version specified once in the easyconfig file, via the <code>version</code> easyconfig parameter. That will come in useful later (see Exercise E.2)...</p> <p>If now we try installing the easyconfig file again, EasyBuild complains that it can't find the specified source file anywhere:</p> <pre><code>Couldn't find file eb-tutorial-1.0.1.tar.gz anywhere, and downloading it didn't work either...\n</code></pre> <p>To let EasyBuild automatically download the source file if it is not available yet, we have to specify where it can be downloaded. This is done via <code>source_urls</code>:</p> <pre><code>source_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#required-configure-option","title":"Required configure option","text":"<p>With <code>sources</code> and <code>source_urls</code> defined, we can try again. Yet again we see the configure step fail. Is this a ruse to make you hate CMake with a passion? Maybe...</p> <p>Here's what we find in the log file:</p> <pre><code>CMake Error at CMakeLists.txt:7 (message):\n  EBTUTORIAL_MSG is not set!\n</code></pre> <p>Apparently the <code>eb-tutorial</code> software has a required configure option. It's almost as if that was done on purpose, how silly!</p> <p>Options to the configure command can be specified by the <code>configopts</code> easyconfig parameter. To define the value of a CMake option, we need to use <code>-DNAME_OF_OPTION</code>, so:</p> <pre><code>configopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n</code></pre> <p>We need to be a little bit careful with quotes here. If we use outer double quotes, we have to use single quotes to specify the actual value for the <code>EBTUTORIAL_MSG</code> configure option. That works fine here, but that's not always the case! In some cases we will have to use inner doubles quotes, for example to get environment variables expanded when the configure command is run (see Exercise E.1).</p>"},{"location":"2022-isc22/adding_support_additional_software/#sanity-check_1","title":"Sanity check","text":"<p>Hopefully that brings us closer to getting the installation to work...</p> <pre><code>$ eb example.eb\n....\n== sanity checking...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/ebtutorial/1.0.1/GCC-11.2.0): build failed (first 300 chars):\nSanity check failed: no (non-empty) directory found at 'lib' or 'lib64' in /home/easybuild/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0 (took 2 sec)\n</code></pre> <p>It got all the way to the sanity check step, that's great!</p> <p>The sanity check failed because no '<code>lib</code>' or <code>'lib64'</code> directory was found. Indeed:</p> <pre><code>$ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0\nbin\n$ ls $HOME/easybuild/software/eb-tutorial/1.0.1-GCC-11.2.0/bin\neb-tutorial\n</code></pre> <p>There is only a binary named <code>eb-tutorial</code> in the <code>bin</code> subdirectory. So we need to customize the standard sanity check:</p> <pre><code>sanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n</code></pre> <p>Since we want to obtain a working installation, we might as well try to run this <code>eb-tutorial</code> command as well:</p> <pre><code>sanity_check_commands = ['eb-tutorial']\n</code></pre> <p>Let us now retry, but use <code>--module-only</code> rather than redoing the whole installation. <code>--module-only</code> still sanity checks the installation, so if it creates a module, we know it will work as expected. By enabling trace mode via <code>--trace</code> we can get some more information too:</p> <pre><code>$ eb example.eb --module-only --trace\n...\n== sanity checking...\n  &gt;&gt; file 'bin/eb-tutorial' found: OK\n  &gt;&gt; running command 'eb-tutorial' ...\n  &gt;&gt; result for command 'eb-tutorial': OK\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> <p>Yes, great success!</p> <p>To convince yourself that the installation works as intended, try to load the <code>eb-tutorial</code> module and run the <code>eb-tutorial</code> command yourself:</p> <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial\n$ eb-tutorial\nHello from the EasyBuild tutorial!\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#complete-easyconfig","title":"Complete easyconfig","text":"<p>Here is the complete easyconfig we puzzled together for this example:</p> <pre><code>easyblock = 'CMakeMake'\n\nname = 'eb-tutorial'\nversion = '1.0.1'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial example\"\n\ntoolchain = {'name': 'GCC', 'version': '11.2.0'}\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9']\n\nbuilddependencies = [('CMake', '3.22.1')]\n\nconfigopts = \"-DEBTUTORIAL_MSG='Hello from the EasyBuild tutorial!' \"\n\nsanity_check_paths = {\n    'files': ['bin/eb-tutorial'],\n    'dirs': [],\n}\n\nsanity_check_commands = ['eb-tutorial']\n\nmoduleclass = 'tools'\n</code></pre> <p>One additional easyconfig parameter we defined here is <code>checksums</code>, which specifies SHA256 checksums for source (and patch) files, so EasyBuild can verify them before performing an installation.</p> <p>You can let EasyBuild determine and inject these SHA256 checksums automatically via <code>eb --inject-checksums</code>:</p> <pre><code>$ eb example.eb --inject-checksums\n...\n== injecting sha256 checksums for sources &amp; patches in example.eb...\n== * eb-tutorial-1.0.1.tar.gz: d6cec2ea298f4092cb1b880cb017220ab191561da941e9e480639cf3354b7ef9\n</code></pre>"},{"location":"2022-isc22/adding_support_additional_software/#exercises","title":"Exercises","text":"<p>Exercise E.1 - Making <code>eb-tutorial</code> a bit more personal</p> <p>Change the easyconfig file for <code>eb-tutorial</code> to make the message printed by the <code>eb-tutorial</code> command a bit more personal: include the username of the account that was used to install the software in it (using the <code>$USER</code> environment variable).</p> (click to show solution) <p>For this we need to change the value that is passed to the <code>EBTUTORIAL_MSG</code> configure option: <pre><code>configopts = '-DEBTUTORIAL_MSG=\"Hello from the EasyBuild tutorial! I was installed by $USER.\" '\n</code></pre> Here we have to use inner double quotes, to ensure that the <code>$USER</code> environment variable is expanded by the shell when running the <code>cmake</code> configure command.</p> <p>When you run the <code>eb-tutorial</code> command yourself, you should get output like this (not a message that includes a literal '<code>$USER</code>' string):</p> <pre><code>Hello from the EasyBuild tutorial! I was installed by example.\n</code></pre> <p>To re-install the <code>example.eb</code> easyconfig, you will need to use <code>eb --rebuild</code> or <code>eb --force</code> (or the short form <code>eb -f</code>).</p> <p>Exercise E.2 - Installing eb-tutorial version 1.1.0</p> <p>Install version 1.1.0 of the <code>eb-tutorial</code> example software, which is a trivial version bump compared to version 1.0.1.</p> <p>The sources are available via:</p> <pre><code>https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/eb-tutorial-1.1.0.tar.gz\n</code></pre> <p>You can leverage the <code>eb-tutorial</code> easyconfig file we have composed in the example above, but you should not make any manual changes to it!</p> (click to show solution) <p>You can use the <code>--try-software-version</code> option for this: <pre><code>$ eb example.eb --try-software-version 1.1.0\n...\n== building and installing eb-tutorial/1.1.0-GCC-11.2.0...\n...\n== COMPLETED: Installation ended successfully (took 4 sec)\n</code></pre> To test: <pre><code>$ module use $HOME/easybuild/modules/all\n$ module load eb-tutorial/1.1.0-GCC-11.2.0\n$ eb-tutorial\nI have a message for you:\nHello from the EasyBuild tutorial!\n</code></pre> (<code>eb-tutorial</code> version 1.0.1 doesn't print \"<code>I have a message for you:</code>\")</p> <p>If you check the easyconfig file that was generated (which is saved as  <code>$EASYBUILD_PREFIX/ebfiles_repo/eb-tutorial/eb-tutorial-1.1.0-GCC-11.2.0.eb</code>), you will see that that file now contains a lot of data from the build. This can be safely deleted, but EasyBuild will also simply ignore it if you try to build from that file. You will also notice that the checksum went missing. EasyBuild was clever enough to delete the checksum when it changed the version to ensure that the build would not fail after downloading the new sources.</p> <p>You can always copy the generated easyconfig to your working directory, clean up  the mess at the end, and then add a checksum again using <pre><code>eb eb-tutorial-1.1.0-GCC-11.2.0.eb --inject-checksums\n</code></pre> to get a fully-featured easyconfig again.</p> <p>Exercise E.3 - Installing py-eb-tutorial 1.0.0</p> <p>Try composing an easyconfig file for the <code>py-eb-tutorial</code> example software, which is a tiny Python package. The source tarball can be downloaded from this link:  py-eb-tutorial-1.0.0.tar.gz.</p> <p>A couple of tips:</p> <ul> <li> <p>There is a generic easyblock available for installing Python packages, which will come in useful here.</p> </li> <li> <p>By default EasyBuild performs an <code>import</code> check when installing Python packages,    using a Python module name that is derived from the software name by default, which    will be incorrect in this case. You can specify the correct name to use in the import    check by specifying it via the <code>options</code>   easyconfig parameter in your easyconfig file:   <pre><code>options = {'modulename': 'example'}\n</code></pre>   (you will need to change '<code>example</code>' here, of course)</p> </li> <li> <p>Leverage the software that is already pre-installed in <code>/easybuild</code> in the prepared environment.   Remember that some already installed modules may be a bundle of a couple of other software packages.</p> </li> </ul> <p>Please also take this into account:</p> <ul> <li> <p>Unfortunately this software doesn't come with documentation. That is done to make it an example that   is representative for software that you may run into in the wild (it's not because   we were lazy when preparing the exercises, really!).   You can inspect the sources of this software    here.    Definitely take a look at the <code>setup.py</code> file, it includes some clues   about the requirements to get this software installed.</p> </li> <li> <p>Make sure the installation actually works, by checking that the <code>py-eb-tutorial</code> command runs correctly.   Maybe you will need to make sure other required software is available as well, for it to work correctly...</p> </li> </ul> (click to show solution) <p>Here is a complete working easyconfig file for <code>py-eb-tutorial</code>: <pre><code>easyblock = 'PythonPackage'\n\nname = 'py-eb-tutorial'\nversion = '1.0.0'\nversionsuffix = '-Python-%(pyver)s'\n\nhomepage = 'https://easybuilders.github.io/easybuild-tutorial'\ndescription = \"EasyBuild tutorial Python example\"\n\nsource_urls = ['https://github.com/easybuilders/easybuild-tutorial/raw/main/docs/files/']\nsources = [SOURCE_TAR_GZ]\nchecksums = ['fcf73a9efc65527a210b993e8889d41ebf05977eef1f6a65ebac3188152cd496']\n\ntoolchain = {'name': 'foss', 'version': '2021b'}\n\ndependencies = [\n    ('Python', '3.9.6'),\n    ('SciPy-bundle', '2021.10'),\n    ('eb-tutorial', '1.0.1'),\n]\n\nuse_pip = True\n\noptions = {'modulename': 'eb_tutorial'}\n\nsanity_check_paths = {\n    'files': ['bin/py-eb-tutorial'],\n    'dirs': ['lib/python%(pyshortver)s/site-packages'],\n}\n\nsanity_check_commands = [\"py-eb-tutorial\"]\n\nmoduleclass = 'tools'\n</code></pre></p> <p>Some remarks:</p> <ul> <li> <p>We used the <code>PythonPackage</code> generic easyblock. There is also a <code>PythonBundle</code> easyblock for installing   bundles of Python packages, which is used for <code>SciPy-bundle</code> for example. But we don't need that here,   since we are only dealing with a single Python package.</p> </li> <li> <p>The <code>versionsuffix</code> is not strictly needed, but it's common to tag Python packages with the Python version   for which they were installed.</p> </li> <li> <p>The SHA256 checksum for the source tarball was added automatically via <code>eb py-eb-tutorial.eb --inject-checksums</code>.</p> </li> <li> <p><code>py-eb-tutorial</code> only wants to be installed with <code>pip install</code>, so we had to set <code>use_pip = True</code>.   You can consult the custom easyconfig parameters supported by the <code>PythonPackage</code> easyblock via   \"<code>eb -a -e PythonPackage</code>\", see the <code>EASYBLOCK-SPECIFIC</code> part of the output.   Even when the default installation mechanism used by <code>PythonPackage</code>   (which consists of running <code>python setup.py install</code>) works fine,   it is recommended to instruct EasyBuild to use <code>pip install</code> instead.</p> </li> <li> <p>By default EasyBuild will try to import <code>py_eb_tutorial</code>, while the actual name of the Python package   provided by <code>py-eb-tutorial</code> is just <code>eb_tutorial</code>. We fixed this by specifying the correct Python module name to   use via <code>options</code>.</p> </li> <li> <p>Strictly speaking we don't need to specify a custom <code>sanity_check_paths</code>, since the default used   by the <code>PythonPackage</code> easyblock is already pretty decent (it will check for a non-empty <code>lib/python3.9/site-packages</code>   directory in the installation). We also want to make sure the <code>py-eb-tutorial</code> command is available in   the <code>bin</code> subdirectory however. Hardcoding to <code>python3.9</code> can be avoided using the <code>%(pyshortver)s</code>   template value.</p> </li> <li> <p>A good way to check whether the <code>py-eb-tutorial</code> command works correctly is by running it as a sanity check   command. If the <code>eb-tutorial</code> command is not available the <code>py-eb-tutorial</code> command will fail,   since it basically just runs the <code>eb-tutorial</code> command. So we need to include <code>eb-tutorial</code> as a (runtime)   dependency in the <code>py-eb-tutorial</code> easyconfig file.</p> </li> </ul> <p>next: Module naming schemes - (back to overview page)</p>"},{"location":"2022-isc22/basic_usage/","title":"Basic usage of Easybuild","text":"<p>Now that we have installed and configured EasyBuild, we can start using it for what it is intended for: getting scientific software installed without breaking a sweat, or having to resist the urge to shout out four-letter words.</p> <p>We will look at the high-level workflow first, and then cover each aspect in more detail.</p> <p>A couple of exercises are available at the end to help to make you more familiar with the EasyBuild command line interface, so pay attention!</p>"},{"location":"2022-isc22/basic_usage/#overall-workflow","title":"Overall workflow","text":"<p>Installing software with EasyBuild is as easy as specifying to the <code>eb</code> command what we want to install, and then sitting back to enjoy a coffee or tea (or whatever beverage you prefer).</p> <p>This is typically done by specifying the name of one or more easyconfig files, often combined with the <code>--robot</code> option to let EasyBuild also install missing dependencies. Alternatively one can specify the name of an easystack file that specifies a collection of software to install, but this feature is currently still marked as * experimental* meaning that it may fail or that may change in incompatible ways in future versions of EasyBuild.</p> <p>It is recommended to first assess the current situation before letting EasyBuild install the software, and to check which dependencies are already installed and which are still missing. In addition, you may want to inspect the specifics of the installation procedure that will be performed by EasyBuild, and ensure that the active EasyBuild configuration is what it should be.</p>"},{"location":"2022-isc22/basic_usage/#specifying-easyconfigs","title":"Specifying easyconfigs","text":"<p>Letting EasyBuild know what should be installed can be done by specifying one or more easyconfig files, which is also the most common way. Alternative methods like using the <code>--software-name</code> option won't be covered in this tutorial, since they are not commonly used.</p> <p>Arguments passed to the <code>eb</code> command, being anything that is not an option (which starts with <code>-</code> or <code>--</code>) or is a value for a preceding configuration option, are assumed to refer to easyconfig files (with some exceptions). These could be:</p> <ul> <li>the (absolute or relative) path to an easyconfig file;</li> <li>the name of an easyconfig file;</li> <li>the path to a directory containing easyconfig files;</li> <li>an easystack file to specify a whole stack of software to install at once (via <code>eb --easystack</code>);</li> </ul> <p>Specified paths to files must of course point to existing files; if not, EasyBuild will print an appropriate error message:</p> <pre><code>$ eb /tmp/does_not_exist.eb\nERROR: Can't find path /tmp/does_not_exist.eb\n</code></pre> <p>When only the name of an easyconfig file is specified, EasyBuild will automatically try and locate it. First, it will consider the current directory. If no file with the specified name is found there, EasyBuild will search for the easyconfig file in the robot search path.</p> <p>If the path to an existing directory is provided, EasyBuild will walk through the entire directory (including all subdirectories), retain all files of which the name ends with <code>.eb</code>, and (try to) use these as easyconfig files.</p>"},{"location":"2022-isc22/basic_usage/#example-command","title":"Example command","text":"<p>Suppose we have the current situation in our home directory:</p> <ul> <li>two (easyconfig) files named <code>example1.eb</code> and <code>example2.eb</code>;</li> <li>a subdirectory named <code>some_deps</code>, which has two easyconfig files <code>dep1.eb</code> and <code>dep2.eb</code>   alongside a text file named <code>list.txt</code>;</li> <li>a subdirectory named <code>more_deps</code> located in the <code>some_deps</code> subdirectory,   which contains another easyconfig file <code>dep3.eb</code>;</li> </ul> <p>Or, visually represented:</p> <pre><code>example1.eb\nexample2.eb\nsome_deps/\n|-- dep1.eb\n|-- dep2.eb\n|-- list.txt\n|-- more_deps/\n    |-- dep3.eb\n</code></pre> <p>In this context, we run the following EasyBuild command from our home directory:</p> <pre><code>eb example1.eb bzip2-1.0.6.eb $HOME/example2.eb some_deps\n</code></pre> <p>EasyBuild will interpret each of these arguments as follows:</p> <ul> <li><code>example1.eb</code> is the name of a file in the current directory, so it can be used directly;</li> <li><code>bzip2-1.0.6.eb</code> is the name of an easyconfig file to locate via the robot search path   (since it does not exist in the current directory);</li> <li><code>$HOME/example2.eb</code> specifies the full path to an existing file, which can be used directly;</li> <li><code>some_deps</code> is the relative path to an existing directory, so EasyBuild will scan it and find three   easyconfig files: <code>some_deps/dep1.eb</code>, <code>some_deps/dep2.eb</code> and <code>some_deps/more_deps/dep3.eb</code>,   The <code>list.txt</code> file will be ignored since its name does not end with <code>.eb</code>.</li> </ul>"},{"location":"2022-isc22/basic_usage/#easyconfig-filenames","title":"Easyconfig filenames","text":"<p>Note that the <code>eb</code> command does not care how easyconfig files are named, at least to some extent: the <code>.eb</code> file extension does matter when easyconfig files are being picked up in subdirectories.</p> <p>File names for easyconfigs being mostly irrelevant is only correct with respect to the arguments passed to the <code>eb</code> command however. As we will learn soon, the name of easyconfig files does matter (a lot) when EasyBuild needs to locate easyconfigs that can be used to resolve a specified dependency (see here).</p> <p>This explains why easyconfig files usually adhere to a very specific naming scheme, corresponding to <code>&lt;name&gt;-&lt;version&gt;-&lt;toolchain&gt;&lt;versionsuffix&gt;.eb</code>, where:</p> <ul> <li><code>&lt;name&gt;</code> represents the software name;</li> <li><code>&lt;version&gt;</code> represents the software version;</li> <li><code>&lt;toolchain&gt;</code> represents the toolchain used in the easyconfig file, which consists of the toolchain name   and version separated with a dash (<code>-</code>), and which is omitted (including the preceding <code>-</code>) when the   <code>system</code> toolchain is used;</li> <li><code>&lt;versionsuffix&gt;</code> represents the value of the <code>versionsuffix</code> easyconfig parameter,   which is sometimes used to distinguish multiple variants of particular software installations   (and is empty by default);</li> </ul>"},{"location":"2022-isc22/basic_usage/#searching-for-easyconfigs","title":"Searching for easyconfigs","text":"<p>You will frequently need to determine the exact name of an easyconfig file you want to install, or just check which easyconfigs are available for a given software package.  This can be done by searching for easyconfigs using <code>eb --search</code> or <code>eb -S</code>.</p> <p>By default all directories listed in the robot search path will be searched. If you want to search in additional directories without changing the robot search path, you can use the <code>search-paths</code> configuration setting, or you can change the robot search path via either the <code>robot</code> or <code>robot-paths</code> configuration options.</p> <p>Both the <code>--search</code> and <code>-S</code> options trigger the same search operation, but yield different output: <code>eb --search</code> will print the full path to each easyconfig file that matches the specified search pattern, while <code>eb -S</code> produces a more concise output.</p> <p>For example, let's check which easyconfig files are available for OpenFOAM 8 with a <code>foss</code> toolchain:</p> <pre><code>$ eb --search openfoam-8-foss\n * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020a.eb\n * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b-20210316.eb\n * /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM/OpenFOAM-8-foss-2020b.eb\n</code></pre> <p>The output is a bit more condensed when using <code>eb -S</code>:</p> <pre><code>$ eb -S openfoam-8-foss\nCFGS1=/home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/o/OpenFOAM\n * $CFGS1/OpenFOAM-8-foss-2020a.eb\n * $CFGS1/OpenFOAM-8-foss-2020b-20210316.eb\n * $CFGS1/OpenFOAM-8-foss-2020b.eb\n</code></pre> <p>Note that the search is performed case-insensitive.</p> <p>The search pattern can include wildcards like <code>.*</code> and/or character groups like <code>[0-9]</code>, or other special characters like <code>^</code> or <code>$</code> to mark the start/end of the filename, but you need to be careful that <code>bash</code> does not expand these before the <code>eb</code> command is started, so it is recommended to wrap the search pattern in single quotes (<code>'...'</code>) when using wildcards.</p> <p>For example, to check which easyconfigs are available to install TensorFlow 2.6.0 with the <code>2021a</code> version of a toolchain:</p> <pre><code>$ eb -S '^tensorflow-2.6.0.*2021a'\nCFGS1=/home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/t/TensorFlow\n * $CFGS1/TensorFlow-2.6.0-foss-2021a-CUDA-11.3.1.eb\n * $CFGS1/TensorFlow-2.6.0-foss-2021a.eb\n</code></pre>"},{"location":"2022-isc22/basic_usage/#search-index","title":"Search index","text":"<p>When searching for easyconfig files, you may see a message like this pop up:</p> <pre><code>== found valid index for &lt;path&gt;, so using it...\n</code></pre> <p>This indicates that a search index was used for this particular directory which significantly speeds up the search procedure, especially when the easyconfig files are located on a shared filesystem where metadata operations involving lots of (small) files can be slow.</p> <p>For the easyconfig files included with an EasyBuild release, a search index is readily provided. For other directories, you can create a search index using <code>eb --create-index &lt;path&gt;</code>. See the EasyBuild documentation for more information.</p>"},{"location":"2022-isc22/basic_usage/#inspecting-easyconfigs","title":"Inspecting easyconfigs","text":"<p>Once you have determined the name of the easyconfig file that corresponds to the software you want to install, you may want to take a closer look at its contents before employing it.</p> <p>Since easyconfig files are simple text files (in Python syntax), you could use the ubiquitous <code>cat</code> command or your favorite text editor (<code>vim</code>, what else). To avoid that you need to locate the easyconfig file first and copy-paste the full path to it, you can use <code>eb --show-ec</code>.</p> <p>For example, let's inspect the contents of the <code>bzip2-1.0.6.eb</code> easyconfig file:</p> <pre><code>$ eb --show-ec bzip2-1.0.8.eb\n== temporary log file in case of crash /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log\n== Contents of /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/b/bzip2/bzip2-1.0.6.eb:\nname = 'bzip2'\nversion = '1.0.8'\n\nhomepage = 'https://sourceware.org/bzip2'\ndescription = \"\"\"\n bzip2 is a freely available, patent free, high-quality data compressor. It\n typically compresses files to within 10% to 15% of the best available\n techniques (the PPM family of statistical compressors), whilst being around\n twice as fast at compression and six times faster at decompression.\n\"\"\"\n\ntoolchain = SYSTEM\ntoolchainopts = {'pic': True}\n\nsource_urls = ['https://sourceware.org/pub/%(name)s/']\nsources = [SOURCE_TAR_GZ]\npatches = ['bzip2-%(version)s-pkgconfig.patch']\nchecksums = [\n'ab5a03176ee106d3f0fa90e381da478ddae405918153cca248e682cd0c4a2269',  # bzip2-1.0.8.tar.gz\n'9299e8ee4d014ea973777b6ea90661fe329dfa991f822add4c763ea9ddb9aab1',  # bzip2-1.0.8-pkgconfig.patch\n]\n\nbuilddependencies = [\n('binutils', '2.37'),\n]\n\nbuildopts = \"CC=gcc CFLAGS='-Wall -Winline -O3 -fPIC -g $(BIGFILES)'\"\n\n# building of shared libraries doesn't work on OS X (where 'gcc' is actually Clang...)\nwith_shared_libs = OS_TYPE == 'Linux'\n\nmoduleclass = 'tools'\n\n== Temporary log file(s) /tmp/eb-jnpzclhl/easybuild-e37cbrj1.log* have been removed.\n== Temporary directory /tmp/eb-jnpzclhl has been removed.\n</code></pre> <p>We'll get back to what all of this means later...</p>"},{"location":"2022-isc22/basic_usage/#checking-dependencies","title":"Checking dependencies","text":"<p>Note</p> <p>In some of the examples below, we assume that some software is already installed with EasyBuild.</p> <p>If you are following hands-on in a prepared environment, make sure these installations are visible in the output of \"<code>module avail</code>\" by informing the modules tool about the pre-installed software stack in <code>/easybuild</code>:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>Before kicking off an installation, it is good practice to check which of the required dependencies are already installed, and which ones are still missing.</p> <p>This can be helpful to ensure that your EasyBuild configuration is set up correctly, and to prevent from accidentally installing an entirely new software stack from scratch in an unintended location (like <code>$HOME/.local/easybuild</code>, the default installation path).</p>"},{"location":"2022-isc22/basic_usage/#dry-run","title":"Dry run","text":"<p>To get a complete overview of all required dependencies, and see which ones are already installed and which ones aren't yet, you can use <code>eb --dry-run</code>.</p> <p>Since <code>--dry-run</code> produces rather verbose output including the full path to each easyconfig file, there is a more concise equivalent available as well: <code>eb --dry-run-short</code>, which is equivalent with <code>eb -D</code>.</p> <p>For example, to check which of the required dependencies for <code>SAMtools-1.11-GCC-10.2.0.eb</code> are already installed:</p> <pre><code>$ eb SAMtools-1.14-GCC-11.2.0.eb -D\n== temporary log file in case of crash /tmp/eb-x4qofiph/easybuild-ehhi9fb1.log\n== found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it...\nDry run: printing build status of easyconfigs and dependencies\nCFGS=/home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs\n ...\n * [x] $CFGS/b/bzip2/bzip2-1.0.8-GCCcore-11.2.0.eb (module: bzip2/1.0.8-GCCcore-11.2.0)\n* [x] $CFGS/x/XZ/XZ-5.2.5-GCCcore-11.2.0.eb (module: XZ/5.2.5-GCCcore-11.2.0)\n* [x] $CFGS/g/GCC/GCC-11.2.0.eb (module: GCC/11.2.0)\n* [x] $CFGS/n/ncurses/ncurses-6.2-GCCcore-11.2.0.eb (module: ncurses/6.2-GCCcore-11.2.0)\n* [x] $CFGS/p/pkg-config/pkg-config-0.29.2.eb (module: pkg-config/0.29.2)\n* [x] $CFGS/o/OpenSSL/OpenSSL-1.1.eb (module: OpenSSL/1.1)\n* [x] $CFGS/c/cURL/cURL-7.78.0-GCCcore-11.2.0.eb (module: cURL/7.78.0-GCCcore-11.2.0)\n* [ ] $CFGS/s/SAMtools/SAMtools-1.14-GCC-11.2.0.eb (module: SAMtools/1.14-GCC-11.2.0)\n</code></pre> <p>(We've trimmed the output a bit here, for the sake of brevity.)</p> <p>This output tells us that all dependencies required by <code>SAMtools-1.14-GCC-11.2.0.eb</code> are already installed, since they are all marked with <code>[x]</code>, whereas the easyconfig for <code>SAMtools</code> itself is not installed yet, as indicated by lack of an <code>x</code> in <code>[ ]</code>.</p>"},{"location":"2022-isc22/basic_usage/#missing-dependencies","title":"Missing dependencies","text":"<p>If you are only interested in which dependencies are still missing, you can consult the output of <code>eb --missing</code>, or the equivalent <code>eb -M</code>.</p> <p>For example, let's see which dependencies are missing in order to get version 3.6.1 of the PyTables Python package installed using the <code>2021b</code> version of the <code>foss</code> toolchain:</p> <pre><code>$ eb PyTables-3.6.1-foss-2021b.eb -M\n\n3 out of 69 required modules missing:\n\n* LZO/2.10-GCCcore-11.2.0 (LZO-2.10-GCCcore-11.2.0.eb)\n* Blosc/1.21.1-GCCcore-11.2.0 (Blosc-1.21.1-GCCcore-11.2.0.eb)\n* PyTables/3.6.1-foss-2021b (PyTables-3.6.1-foss-2021b.eb)\n</code></pre> <p>That should be pretty self-explanatory: out of the 69 required dependencies (which includes the <code>foss</code> toolchain and everything needed to install it), only 3 dependencies are missing. Great!</p>"},{"location":"2022-isc22/basic_usage/#inspecting-install-procedures","title":"Inspecting install procedures","text":"<p>Finally, before actually installing something you may want to assess how exactly EasyBuild is going to install the software.</p> <p>Perhaps you don't trust EasyBuild yet (you will eventually though, hopefully), or maybe you just want to double check that you have made the right choice before going through with the actual installation.</p> <p>Using <code>eb --extended-dry-run</code>, or just <code>eb -x</code> for short, you can get a detailed overview of the installation procedure that would be performed by EasyBuild, in a matter of seconds.</p> <p>By means of example, let's inspect some parts of the installation procedure for <code>Boost-1.74.0-GCC-10.2.0.eb</code>:</p> <pre><code>$ eb Boost-1.77.0-GCC-11.2.0.eb -x\n...\n\npreparing... [DRY RUN]\n\n[prepare_step method]\nDefining build environment, based on toolchain (options) and specified dependencies...\n\nLoading toolchain module...\n\nmodule load GCC/11.2.0\n\nLoading modules for dependencies...\n\nmodule load bzip2/1.0.8-GCCcore-11.2.0\nmodule load zlib/1.2.11-GCCcore-11.2.0\nmodule load XZ/5.2.5-GCCcore-11.2.0\n\n...\n\nDefining build environment...\n\n  ...\n  export CXX='g++'\nexport CXXFLAGS='-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC'\n...\n\nconfiguring... [DRY RUN]\n\n[configure_step method]\nrunning command \"./bootstrap.sh --with-toolset=gcc --prefix=/tmp/example/Boost/1.77.0-GCC-11.2.0 --without-libraries=python,mpi\"\n(in /tmp/example/build/Boost/1.77.0/GCC-11.2.0/Boost-1.77.0)\n\n...\n\n[sanity_check_step method]\nSanity check paths - file ['files']\n* lib/libboost_system-mt-x64.so\n  * lib/libboost_system.so\n  * lib/libboost_thread-mt-x64.so\nSanity check paths - (non-empty) directory ['dirs']\n* include/boost\nSanity check commands\n  (none)\n\n...\n</code></pre> <p>We've obviously trimmed the generated output a bit, but it should be sufficient to explain what all this output means.</p> <p>An overview of the installation procedure is shown, following the installation steps as they would be performed by EasyBuild. The output above shows:</p> <ul> <li>how the build environment will be set up during the <code>prepare</code> step, by loading the module for both the   toolchains and the dependencies, and defining a set of environment variables like <code>$CXX</code>, <code>$CXXFLAGS</code>, etc.</li> <li>which command will be executed during the configuration step, and in which directory;</li> <li>the list of files and directories that will be checked during the sanity check step;</li> </ul> <p>If you were concerned about EasyBuild being too much of a black box, that is hopefully resolved now.</p> <p>Note</p> <p>It is important to highlight here that the reported installation procedure may not be 100% correct, since the easyblock can change its mind based on the output of shell commands that were executed, or based on the contents of a file that was generated during the installation. Since all \"actions\" that would be performed during the installation are actually skipped when using <code>eb -x</code>, the reported installation procedure could be partially incorrect.</p> <p>In addition, the easyblock may trip over the fact that the installation procedure is not actually being executed, which sometimes leads to an unexpected error. These situations are handled gracefully by <code>eb -x</code> though, which will report any errors that occurred and then continue anyway with inspecting the remainder of the installation procedure. Although this obviously limits the value of the generated output, it doesn't make it completely useless.</p>"},{"location":"2022-isc22/basic_usage/#exercises","title":"Exercises","text":"<p>Guidelines</p> <p>Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself!</p> <p>Please do not share solutions with others before they have been discussed by the tutorial organisers.</p> <p>The exercises are based on the easyconfig files included with EasyBuild 4.5.4.</p> <p>Exercise U.0 - Making installed software available</p> <p>Before working on the exercises for this part of the tutorial, make sure that the software that is already installed in the prepared environment is available.</p> <p>We will assume that you have a small software stack installed using the <code>2021b</code> version of the <code>foss</code> toolchain.</p> <p>Tip: execute a \"<code>module use</code>\" command, and verify with \"<code>module avail</code>\" that a bunch of software modules are available for loading.</p> (click to show solution) <p>Use the following command to make the modules for the software available that is pre-installed in the prepared environment: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>If software is installed in a different location than <code>/easybuild/</code> in your environment, you should adjust the command accordingly.</p> <p>To verify that the pre-installed software is available, check whether the <code>foss/2020b</code> module is available: <pre><code>$ module avail foss/\n\n--------------------- /easybuild/modules/all ---------------------\n  foss/2021b\n</code></pre></p> <p>Exercise U.1 - Searching easyconfigs</p> <p>See if EasyBuild provides any easyconfig files for installing GROMACS version 2021.5.</p> (click to show solution) <p>To check for available easyconfig files, we can use <code>eb --search</code> or <code>eb -S</code>: <pre><code>$ eb -S gromacs-2021.5\n== found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it...\nCFGS1=//home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2021.5-foss-2021b-CUDA-11.4.1.eb\n * $CFGS1/GROMACS-2021.5-foss-2021b.eb\n * $CFGS1/GROMACS-2021.5_fix_threads_gpu_Gmxapitests.patch\n</code></pre> This actually shows two easyconfig files but also a patch file. We can also search specifically for GROMACS 2021.5 in the <code>foss</code> and <code>fosscuda</code> toolchains using <pre><code>$ eb -S gromacs-2021.5-foss\n== found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it...\nCFGS1=/home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/g/GROMACS\n * $CFGS1/GROMACS-2021.5-foss-2021b-CUDA-11.4.1.eb\n * $CFGS1/GROMACS-2021.5-foss-2021b.eb\n</code></pre> and now we find just the two easyconfig files.  </p> <p>Exercise U.2 - Checking dependencies</p> <p>Check which dependencies are missing to install QuantumESPRESSO version 6.8 with the <code>2021b</code> version of the <code>foss</code> toolchain.</p> (click to show solution) <p>First, we need to determine the name of the easyconfig file for QuantumESPRESSO version 6.6: <pre><code>$ eb -S 'QuantumESPRESSO-6.8.*foss-2021b'\n== found valid index for /home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs, so using it...\nCFGS1=/home/example/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/q/QuantumESPRESSO\n * $CFGS1/QuantumESPRESSO-6.8-foss-2021b.eb\n</code></pre> To determine which dependencies are missing to install this QuantumESPRESSO easyconfig file, we can use <code>--missing</code>: <pre><code>$ eb QuantumESPRESSO-6.8-foss-2021b.eb --missing\n\n3 out of 65 required modules missing:\n\n* libxc/5.1.6-GCC-11.2.0 (libxc-5.1.6-GCC-11.2.0.eb)\n* ELPA/2021.05.001-foss-2021b (ELPA-2021.05.001-foss-2021b.eb)\n* QuantumESPRESSO/6.8-foss-2021b (QuantumESPRESSO-6.8-foss-2021b.eb)\n</code></pre> (some nonessential output removed).</p> <p>Exercise U.3 - Performing a dry run</p> <p>Figure out which command EasyBuild would use to compile the software provided by the <code>Bowtie2-2.4.4-GCC-11.2.0.eb</code> easyconfig file, without actually installing <code>Bowtie2</code>.</p> <p>Also, which binaries will EasyBuild check for to sanity check the installation?</p> (click to show solution) <p>To inspect the installation procedure, we can use <code>eb -x Bowtie2-2.4.4-GCC-11.2.0.eb</code>.</p> <p>The output for the build step shows the actual compilation command that would be performed (<code>make ...</code>):</p> <pre><code>[build_step method]\n&gt;&gt; running command:\n    [started at: 2021-03-08 20:15:08]\n[working dir: /tmp/eb-0006djcd/__ROOT__/tmp/example/Bowtie2/2.4.4/GCC-11.2.0/Bowtie2-2.4.4]\n[output logged in /tmp/eb-0006djcd/easybuild-run_cmd-haojzisn.log]\nmake -j 8  CC=\"gcc\"  CPP=\"g++\" CXX=\"g++\"  RELEASE_FLAGS=\"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\"\nrunning command \"make  -j 16  CC=\"gcc\"  CPP=\"g++\" CXX=\"g++\"  RELEASE_FLAGS=\"-O2 -ftree-vectorize -march=native -fno-math-errno -fPIC -std=gnu++98\"\"\n(in /tmp/example/Bowtie2/2.4.4/GCC-11.2.0/Bowtie2-2.4.4)\n</code></pre> <p>If the output you get is less detailed, you may not have set <code>export EASYBUILD_TRACE=1</code>.</p> <p>The output for the sanity check step shows which binaries are expected to be installed: <pre><code>[sanity_check_step method]\nSanity check paths - file ['files']\n  * bin/LICENSE\n  * bin/MANUAL\n  * bin/MANUAL.markdown\n  * bin/NEWS\n  * bin/bowtie2\n  * bin/bowtie2-align-l\n  * bin/bowtie2-align-s\n  * bin/bowtie2-build\n  * bin/bowtie2-build-l\n  * bin/bowtie2-build-s\n  * bin/bowtie2-inspect\n  * bin/bowtie2-inspect-l\n  * bin/bowtie2-inspect-s\n</code></pre></p> <p>next: Installing software - (back to overview page)</p>"},{"location":"2022-isc22/community/","title":"The EasyBuild community","text":"<p>EasyBuild has grown into a community project since it was first released publicy in 2012, and is used and developed by hundreds of HPC centres and consortia worldwide.</p> <p>Since 2016, the EasyBuild community has gathered for a yearly EasyBuild User Meeting, which is an open and highly interactive event that provides a great opportunity to meet fellow EasyBuild users, developers, and maintainers, and to discuss related topics, learn about new aspects of the tool, and how other HPC sites leverage it and integrate it with other tools like Jenkins, Ansible, CernVM-FS, ReFrame etc.</p> <p>The map below shows from which cities the EasyBuild documentation has been visited in the period June 1st 2020 - June 1st 2021, and how often.</p> <p>HPC sites, consortia, and companies that use EasyBuild include (but are not limited to):</p> <p> </p>"},{"location":"2022-isc22/community/#getting-help","title":"Getting help","text":""},{"location":"2022-isc22/community/#documentation","title":"Documentation","text":"<p>If you have any questions about EasyBuild, make sure to check the EasyBuild documentation first, which is available at https://docs.easybuild.io.</p> <p>It is not unlikely that an answer to your question is available there already. The search box on the top left may be helpful.</p>"},{"location":"2022-isc22/community/#github","title":"GitHub","text":"<p>You can open an issue in one of the EasyBuild repositories in the <code>easybuilders</code> GitHub organisation to ask questions, report problems or share suggestions and ideas for additional improvements.</p> <p>Please try to post the issue in the most suitable repository. If you are not sure which repository is most suited just go ahead and open the issue anyway, the EasyBuild maintainers can move your issue if deemed appropriate.</p> <p>Also here you can use the search box on the top left, to see if somebody else has already asked a similar question or reported a similar problem.</p>"},{"location":"2022-isc22/community/#mailing-list","title":"Mailing list","text":"<p>Feel free to ask any questions or provide feedback via the EasyBuild mailing list <code>easybuild@lists.ugent.be</code>.</p> <p>Keep in mind that you must be subscribed to the mailing list in order to post messages there! You can subscribe via this link.</p> <p>In 2016-2017 over 1,000 messages were posted to the EasyBuild mailing list. More recently this has decreased to about 700 messages per year, mostly due to the EasyBuild Slack channel.</p>"},{"location":"2022-isc22/community/#slack","title":"Slack","text":"<p>The EasyBuild Slack is a quick and easy way to get in touch with the EasyBuild community. Over 600 people have joined it so far, and there is usually somebody awake in there who may be able to help you out.</p> <p>To join the EasyBuild Slack request an invitation via https://easybuild.io/join-slack.</p> <p>If you are not a big fan of Slack, you can also consider joining the <code>#easybuild</code> IRC channel (available on the Libera IRC network). A bot relays messages between this IRC channel and the <code>#general</code> channel in the EasyBuild Slack.</p> <p>Note</p> <p>A dedicated <code>#tutorial-isc22</code> channel was created for this tutorial in the EasyBuild Slack.</p> <p>If you have any questions that are specific to this tutorial, please post them there!</p>"},{"location":"2022-isc22/community/#conference-calls","title":"Conference calls","text":"<p>Every other week on Wednesday an EasyBuild conference call is set up to discuss recent developments, provide an outlook to the next EasyBuild release, and provide answers to questions that can be raised by the people attending the call.</p> <p>These conference calls are open to anyone interested in the EasyBuild project, and have been organised since November 2013.</p> <p>More information, including the dates and times of the next calls, is available here.</p> <p>next: Contributing to EasyBuild - (back to overview page)</p>"},{"location":"2022-isc22/comparison_other_tools/","title":"Comparison with other tools","text":"<p>The project that most compares with EasyBuild is Spack, a flexible package manager for HPC systems.</p> <p>It was created by Todd Gamblin at Lawrence Livermore National Lab (LLNL) in California, USA.</p> <p>In several ways it looks similar to EasyBuild:</p> <ul> <li>implemented in Python, compatible with Python 2.7 and 3.5+</li> <li>open source software, development on GitHub</li> <li>similar high-level structure (core + packages)</li> <li>supports installing (scientific) software without admin privileges</li> <li>strong focus on HPC and performance</li> <li>highly configurable</li> <li>well documented (see https://spack.readthedocs.io/)</li> <li>generates environment modules files</li> <li>worldwide community</li> <li>broad spectrum of supported software (6000+ mainline packages)</li> </ul> <p>In other ways, EasyBuild and Spack are quite different. Spack is released under a more permissive open source license (MIT/Apache 2.0 dual license), and  whereas EasyBuild supports Linux and Cray PE, Spack also provides good support for macOS out-of-the-box.</p> <p>The Spack command line interface is quite different from EasyBuild: it supports subcommands (like \"<code>spack install</code>\"), and provides a flexible interface for specifying an abstract specification of what to install. Here is an example:</p> <pre><code>spack install mpileaks@3.3 ^mpich@3.2 %gcc@4.9.3\n</code></pre> <p>This tells Spack to install <code>mpileaks</code> version 3.3 on top of MPICH version 3.2, using GCC 4.9.3 as compiler.</p> <p>This abstract specification is then passed to a concretization algorithm which fills in the blanks: it will pick versions of other required dependencies, determine which compiler flags to use, and so on. This information is fed to the Spack package (which is the equivalent of an easyblock in EasyBuild) to perform the actual installation.</p> <p>There are many other differences between EasyBuild and Spack as well, too many for this document to cover in detail. See the \"Installing software for scientists on a multi-user HPC system\" recorded talk at FOSDEM'18 and the Spack documentation for more information (though it should be noticed that all those packages have evolved a lot since that talk was given).</p> <p> </p> <p>Nix and GNU Guix are both purely functional package managers, which strongly focus on the reproducibility of software installations.</p> <p>In Nix packages are expressed as Nix expressions (a custom DSL), and software installations are usually done in the Nix store, a dedicated installation directory, each in a specific subdirectory that includes a unique identifier for that installation. For example:</p> <pre><code>/nix/store/b6gvzjyb2pg0kjfwrjmg1vfhh54ad73z-firefox-33.1/\n</code></pre> <p>Guix is very similar to Nix, but is a separate project entirely. There is a dedicated Guix HPC community that focuses on the use of Guix in an HPC context. Packages in Guix are implemented in Guile Scheme, and many advanced features like transactional upgrades and rollbacks are supported.</p> <p>To the best of our knowledge, neither of these tools have seen wide adoption in the HPC community to date.</p> <p></p> <p>Conda is a package manager that runs on Windows, macOS and Linux, and is very popular in the scientific community.</p> <p>It focuses on quick installation of software and ease of use, and lets users create a conda environment in which they can install one or more packages. These packages are usually pre-built generic binaries however, which may significantly impact the performance of the installations.</p> <p>Despite wide adoption in the scientific community <code>conda</code> is not a good fit for HPC systems for a number of reasons, including poor support for multi-user environments, a lack of focus on performance, heavily relying on the home directory (which usually is limited in size on HPC systems), and more. There is also no guarantee that it will install libraries that are compatible with the hardware of the cluster you're working on, so the Conda-installed software may  not always talk properly to the cluster interconnect or resource manager. See this link for a more detailed discussion.</p> <p>In addition, software installed via <code>conda</code> usually does not mix well with software installed through environment modules.</p> <p>(back to overview page)</p>"},{"location":"2022-isc22/configuration/","title":"Configuring EasyBuild","text":"<p>After installing EasyBuild, you should configure it.</p> <p>EasyBuild should work fine out-of-the-box if you use Lmod as your modules tool. If you are not using Lmod, please see here for more information.</p> <p>Nevertheless, we strongly recommend you to inspect the default configuration, and to configure EasyBuild according to your preferences and the system on which you will use it.</p>"},{"location":"2022-isc22/configuration/#available-configuration-settings","title":"Available configuration settings","text":"<p>One of the central policies in the EasyBuild project is to avoid hardcoded settings in the codebase. While this significantly increases the ability to configure EasyBuild to your liking, it also results in a large amount of available configuration settings.</p> <p>The full list of configuration settings can be consulted via <code>eb --help</code>, which shows the corresponding command line option accompanied by a short description. At the time of writing, about 270 different configuration settings are supported by EasyBuild.</p> <p>For the sake of this tutorial we will focus on a specific subset of configuration settings, and cover only the most prominent and important ones.</p> <p>We will refer to EasyBuild configuration settings using the names as they appears in the output of <code>eb --help</code>, and omit the leading dashes (<code>--</code>) for the sake of clarity.</p> <p>Keep in mind that every configuration setting can be defined in 3 different ways, see below for more details.</p>"},{"location":"2022-isc22/configuration/#overall-prefix","title":"Overall prefix","text":"<p>(default: <code>$HOME/.local/easybuild</code>)</p> <p>The <code>prefix</code> configuration setting specifies the overall prefix that EasyBuild should use, which determines the default value for various other configuration settings:</p> <ul> <li><code>installpath</code>: <code>&lt;prefix&gt;</code></li> <li><code>buildpath</code>: <code>&lt;prefix&gt;/build</code></li> <li><code>sourcepath</code>: <code>&lt;prefix&gt;/sources</code></li> <li><code>repositorypath</code> (easyconfigs archive): <code>&lt;prefix&gt;/ebfiles_repo</code></li> <li><code>containerpath</code>: <code>&lt;prefix&gt;/containers</code></li> </ul> <p>Here, <code>&lt;prefix&gt;</code> represents the value of the <code>prefix</code> configuration setting.</p> <p>If one of the configuration settings affected by <code>prefix</code> is defined specifically, the <code>prefix</code> value becomes irrelevant for that specific configuration setting.</p>"},{"location":"2022-isc22/configuration/#install-path","title":"Install path","text":"<p>(default: <code>&lt;prefix&gt;</code>)</p> <p>The location for both the software installation directories and generated module files can be controlled via the <code>installpath</code> configuration setting. Software installation directories will be placed in <code>&lt;installpath&gt;/software</code>, while <code>&lt;installpath&gt;/modules/all</code> will be used for generated module files.</p> <p>The <code>installpath</code> location is usually set to a directory on a shared filesystem when installing software for an HPC cluster. Of course, software can also be installed on a local filesystem, which can be useful to test and evaluate software installations.</p> <p>Separate configuration settings are available for both software and modules locations, as well as for controlling the name of the <code>software</code> and <code>modules/all</code> subdirectories.</p> <p>We recommend to only change the <code>installpath</code> configuration setting to control the location of software installations and accompanying module files, such that the software and modules directories are located in the same parent directory, and the default <code>software</code> and <code>modules/all</code> names for the subdirectories are used.</p>"},{"location":"2022-isc22/configuration/#build-path","title":"Build path","text":"<p>(default: <code>&lt;prefix&gt;/build</code>)</p> <p>For each installation it performs, EasyBuild creates a separate build directory where software will be compiled before installing it. This directory is cleaned up automatically when the installation is successfully completed. To control the location where these build directories are created, you can use the <code>buildpath</code> configuration setting.</p> <p>Keep in mind that build directories may grow out to several GBs in size during an installation, and that the commands that run in there can be fairly I/O-intensive since they may involve manipulating lots of small files. In addition, a build directory that corresponds to a failing installation is not cleaned up automatically, but it will be cleaned up and recycled when the same installation is re-attempted. Running out of disk space in the location where build directories are created will result in failing installations.</p> <p>It is strongly recommend to use the path to a directory on a local filesystem for the value of the <code>buildpath</code> configuration setting, since using a shared filesystem like Lustre or GPFS is known to cause problems when building certain software packages. Using an in-memory location (like <code>/dev/shm/$USER</code>) can significantly speed up the build process, but may also lead to problems (due to space limitations, or specific mount options like <code>noexec</code>).</p> <p>Use a directory on a local filesystem for <code>buildpath</code> for this tutorial. In addition, try to ensure you use a path that will not be used by other users on the same system, so set <code>buildpath</code> to <code>/tmp/$USER</code>, for example.</p>"},{"location":"2022-isc22/configuration/#source-path","title":"Source path","text":"<p>(default: <code>&lt;prefix&gt;/sources</code>)</p> <p>For most supported software, EasyBuild can automatically download the source files required for the installation. Before trying to download a source file, EasyBuild will first check if it is already present in the source path.</p> <p>The locations considered by EasyBuild when checking for available source files, as well as the location to store downloaded source files, can be controlled via the <code>sourcepath</code> configuration setting.</p> <p>The <code>sourcepath</code> value is a colon (<code>:</code>) separated list of directory paths. Each of these paths will be considered in turn when checking for available source files, until one of them provides the desired source file. Searching for source files is done based on filename, and a couple of subdirectories are considered. For example, for a software package named '<code>Example</code>', EasyBuild will consider locations like <code>&lt;sourcepath&gt;/e/Example/</code>, <code>&lt;sourcepath&gt;/Example/</code>, and so on.</p> <p>The first path listed in <code>sourcepath</code> is the location where EasyBuild will store downloaded source files, organised by software name through subdirectories, so EasyBuild expects to have write permissions to this path. For the other paths listed in <code>sourcepath</code> only read permissions are required.</p> <p>Make sure you have write permissions to the first path listed in <code>sourcepath</code>, so EasyBuild is able to store downloaded files there. Feel free to list additional paths if you already have a cache of downloaded files available somewhere.</p>"},{"location":"2022-isc22/configuration/#easyconfigs-archive","title":"Easyconfigs archive","text":"<p>(default: <code>&lt;prefix&gt;/ebfiles_repo</code>)</p> <p>EasyBuild keeps track of the easyconfig files that were used for installations in the easyconfigs archive, the location of which is specified by the <code>repositorypath</code> configuration setting.</p> <p>By default the specified path is assumed to be a regular directory, but using a Git repository as easyconfigs archive is also supported (for more details, see the EasyBuild documentation).</p> <p>For the sake of this tutorial we recommend using a regular directory, and sticking to the default location as a subdirectory of the <code>prefix</code> configuration setting.</p>"},{"location":"2022-isc22/configuration/#modules-tool-module-syntax","title":"Modules tool &amp; module syntax","text":"<p>(default: <code>Lmod</code> as modules tool, <code>Lua</code> as module syntax)</p> <p>By default, EasyBuild assumes you are using Lmod as modules tool. In addition, it will generate module files in Lua syntax, as supported by Lmod (next to <code>Tcl</code> syntax).</p> <p>To diverge from this, you can define the <code>modules-tool</code> configuration setting to indicate you are using a different modules tool; see the output of <code>eb --avail-modules-tools</code> for a list of supported modules tools. Note that for anything other than Lmod, you must make sure that the actual modules tool binary command is available through <code>$PATH</code> (more information on this in the EasyBuild documentation).</p> <p>If you prefer that EasyBuild generates module files in Tcl syntax, you can instruct it to do so via the <code>module-syntax</code> configuration setting. Note that this is required if you are using a modules tool other than Lmod, since only Lmod supports module files in <code>Lua</code> syntax.</p> <p>We recommend using EasyBuild with the defaults settings: Lmod as modules tool, and Lua as module syntax.</p>"},{"location":"2022-isc22/configuration/#robot-search-path","title":"Robot search path","text":"<p>(default: <code>robot-paths</code> specifies the location to the easyconfig files included with EasyBuild installation; dependency resolution is not enabled)</p> <p>When EasyBuild needs to locate one or more easyconfig files, it will do so via the robot search path. This applies to both easyconfig files that were specified using only their filename as an argument to the <code>eb</code> command, as well as to easyconfigs required to resolve dependencies (more on that later).</p> <p>To control the robot search path, two configuration settings are available: <code>robot</code> and <code>robot-paths</code>. Both accept a colon-separated list of locations to consider when looking for easyconfig files, with <code>robot</code> overriding <code>robot-paths</code>.</p> <p>The key difference between these two configuration settings is that defining <code>robot</code> also enables dependency resolution, and hence makes EasyBuild install missing dependencies, alongside specifying a list of paths to consider when searching for easyconfig files. On the other hand, defining <code>robot-paths</code> does not have the side effect of enabling dependency resolution.</p> <p>In addition, you can use the <code>--robot</code> command line option without specifying any paths to it, to only enable dependency resolution.</p> <p>Note</p> <p>Keep in mind that when either of the <code>robot</code> (with paths) or <code>robot-paths</code> configuration settings are defined, the default value corresponding to the location of easyconfigs included with the EasyBuild is no longer considered.</p> <p>There are ways around this however, which are outside of the scope of this tutorial.</p> <p>For more information, see the EasyBuild documentation.</p>"},{"location":"2022-isc22/configuration/#module-naming-scheme","title":"Module naming scheme","text":"<p>(default: <code>EasyBuildMNS</code>)</p> <p>EasyBuild will use a specific naming scheme for the module files it generates for each of the software installations. This ensures consistency, regardless of who uses EasyBuild to perform the installation.</p> <p>Different types of module naming schemes are supported (flat, hierarchical, ...) and you can provide an implementation of your own custom module naming scheme if desired. A number of different naming schemes are included with EasyBuild, which you can consult via <code>eb --avail-module-naming-schemes</code>.</p> <p>The default <code>EasyBuildMNS</code> module naming scheme roughly corresponds to the filename of easyconfig files, and consists of the software name followed by a combination of the software version, toolchain and an optional label (which corresponds to the value of the <code>versionsuffix</code> easyconfig parameter): <code>&lt;name&gt;/&lt;version&gt;&lt;-toolchain&gt;&lt;versionsuffix&gt;</code>. Just like with names of easyconfig files, the <code>&lt;-toolchain&gt;</code> part is omitted when the <code>system</code> toolchain is used, and the <code>&lt;versionsuffix&gt;</code> value is empty by default.</p>"},{"location":"2022-isc22/configuration/#configuration-levels","title":"Configuration levels","text":"<p>Configuring EasyBuild can be done in different ways:</p> <ul> <li>through one or more configuration files;</li> <li>via <code>$EASYBUILD_*</code> environment variables;</li> <li>using <code>eb</code> command line options;</li> </ul> <p>Each of the methods corresponds to a configuration level.</p> <p>Every configuration setting can be defined via one of these mechanisms, without exception!</p>"},{"location":"2022-isc22/configuration/#configuration-level-hierarchy","title":"Configuration level hierarchy","text":"<p>There is a strict hierarchy between the different configuration levels supported by EasyBuild.</p> <p>Settings defined via a configuration file only override default values.</p> <p>A configuration setting that is defined via the corresponding <code>$EASYBUILD_*</code> environment variable takes precedence over the value specified in a configuration file (if any).</p> <p>Finally, values specified through <code>eb</code> command line options always win, regardless of whether the corresponding configuration setting was already defined some other way, be it via a configuration file or an environment variable.</p> <p>For example, let us consider a fictional configuration setting named <code>magic</code>:</p> <ul> <li>If a value for <code>magic</code> is specified in an EasyBuild configuration file,   then this value will only be used if the corresponding environment variable   (<code>$EASYBUILD_MAGIC</code>) is not defined and if the <code>--magic</code> command line option is not used;</li> <li>If the <code>$EASYBUILD_MAGIC</code> environment variable is defined however, then its value   will be used for the <code>magic</code> configuration setting;</li> <li>Unless the <code>--magic</code> command line option is used,   since in that case the value provided as an argument there will be used instead.</li> </ul>"},{"location":"2022-isc22/configuration/#configuration-files","title":"Configuration files","text":"<p>Configuration files are the most basic way of configuring EasyBuild. Two types of are supported by EasyBuild: user-level and system-level configuration files. The output of <code>eb --show-default-configfiles</code> tells you which locations are considered, and whether any configuration files were found.</p> <p>EasyBuild configuration files are written in the standard INI format, and the configuration settings are grouped into different sections.</p> <p>To create an EasyBuild configuration file, the output of <code>eb --confighelp</code> is very useful: it produces the list of all supported configuration settings which are readily grouped in sections and with every entry commented out, along with accompanying descriptive comments mentioning the default values, and in the correct syntax.</p> <p>Configuration files are the recommended mechanism to define configuration settings that should always be in place, regardless of the software you are installing.</p>"},{"location":"2022-isc22/configuration/#easybuild-configuration-files-vs-easyconfig-files","title":"EasyBuild configuration files vs easyconfig files","text":"<p>EasyBuild configuration files are sometimes confused with easyconfig files, due to the similar name. However, these are two entirely different concepts!</p> <p>EasyBuild configuration files (usually <code>*.cfg</code>) are a way of configuring the general behaviour of EasyBuild across different software installations. They define configuration settings, such as the location where software should be installed, or the syntax that should be used when generating module files.</p> <p>An easyconfig file (<code>*.eb</code>) on the other hand specifies the details for one particular software installation. It does this by defining a set of easyconfig parameters, which tell EasyBuild the name and version of the software to install, which toolchain and easyblock to use, etc.</p> <p>For each software installation performed by EasyBuild, there is a corresponding easyconfig file. There typically are only a handful of configuration files used however, for example a system-level configuration file, perhaps combined with a user-level one. Or there may be no configuration files involved at all, since EasyBuild can also be configured through other mechanisms: environment variables and command line options.</p>"},{"location":"2022-isc22/configuration/#easybuild_-environment-variables","title":"<code>$EASYBUILD_*</code> environment variables","text":"<p>A particularly easy way to configure EasyBuild is through environment variables.</p> <p>At startup, EasyBuild will pick up any environment variable of which the name starts with '<code>EASYBUILD_</code>'. For each of these, it will determine the corresponding configuration setting (or exit with an error if none was found).</p> <p>Mapping the name of a configuration setting to the name of the corresponding environment variable is straightforward: use capital letters, replace dashes (<code>-</code>) with underscores (<code>_</code>), and prefix with <code>EASYBUILD_</code>.</p> <p>For example: the <code>module-syntax</code> configuration setting can be specified by defining the <code>$EASYBUILD_MODULE_SYNTAX</code> environment variable:</p> <pre><code>export EASYBUILD_MODULE_SYNTAX=Tcl\n</code></pre> <p>Configuring via environment variables is especially practical for controlling the EasyBuild configuration in a more dynamic way. For example, you can implement a simple shell script that defines <code>$EASYBUILD_*</code> environment variables based on the current context (user, hostname, other environment variables), and configure EasyBuild through sourcing it.</p> <p>Note</p> <p>Keep in mind that environment variables are only defined for the shell session you are currently working in. If you want to configure EasyBuild through environment variables in a more persistent way, you can leverage one of the shell startup scripts (for example <code>$HOME/.bash_profile</code> or <code>$HOME/.bashrc</code>).</p>"},{"location":"2022-isc22/configuration/#eb-command-line-options","title":"<code>eb</code> command line options","text":"<p>Finally, you can also configure EasyBuild by specifying one or more options to the <code>eb</code> command.</p> <p>As mentioned earlier, the values for configuration settings defined this way override the value that is specified through any other means. So if you want to be sure that a particular configuration setting is defined the way you want it to be, you can use the corresponding command line option.</p> <p>There are various configuration settings for which it only makes sense to use the command line option. An example of this is letting the <code>eb</code> command print the EasyBuild version (via <code>eb --version</code>). Although you could configure EasyBuild to always print its version and then exit whenever the <code>eb</code> command is run, that would not be very useful...</p> <p>Command line options are typically used to define configuration settings that are only relevant to that particular EasyBuild session. One example is doing a test installation into a temporary directory:</p> <pre><code>eb --installpath /tmp/$USER example.eb\n</code></pre>"},{"location":"2022-isc22/configuration/#inspecting-the-current-configuration-show-config","title":"Inspecting the current configuration (<code>--show-config</code>)","text":"<p>Given the large amount of available configuration settings in EasyBuild and the different configuration levels, you can easily lose track of exactly how EasyBuild is configured.</p> <p>Through the <code>--show-config</code> command line option you can easily inspect the currently active EasyBuild configuration.</p> <p>The output of <code>--show-config</code> includes a sorted list of all configuration settings that are defined to a non-default value, along with a couple of important ones that are always shown (like <code>buildpath</code>, <code>installpath</code>, <code>sourcepath</code>, and so on). In addition, it also indicates at which configuration level each setting was defined, so you can trace down where it was defined if needed.</p> <p>This is the output produced by <code>eb --show-config</code> for the default EasyBuild configuration, where EasyBuild was installed via <code>pip install --user</code> (which affects the value shown for the <code>robot-paths</code> configuration setting):</p> <pre><code>#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (D) = /home/example/.local/easybuild/build\ncontainerpath  (D) = /home/example/.local/easybuild/containers\ninstallpath    (D) = /home/example/.local/easybuild\nrepositorypath (D) = /home/example/.local/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (D) = /home/example/.local/easybuild/sources\n</code></pre> <p>As shown here, all configuration settings shown follow the default <code>prefix</code> value (<code>$HOME/.local/easybuild</code>), and none of the values diverge from the default value, since all entries are marked with <code>(D)</code> for \"default value\").</p> <p>Example</p> <p>Now let us do some basic configuring and inspect the resulting output of <code>eb --show-config</code>.</p> <p>First, create a user-level EasyBuild configuration file to define the <code>prefix</code> configuration setting:</p> <pre><code>mkdir -p $HOME/.config/easybuild\necho '[config]' &gt; $HOME/.config/easybuild/config.cfg\necho 'prefix=/apps' &gt;&gt; $HOME/.config/easybuild/config.cfg\n</code></pre> <p>In addition, define the <code>buildpath</code> configuration setting using the corresponding environment variable:</p> <pre><code>export EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Then run <code>eb --show-config</code> while you specify that the <code>installpath</code> configuration setting should be defined as <code>/tmp/$USER</code>:</p> <pre><code>$ eb --show-config --installpath=/tmp/$USER\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath      (E) = /tmp/easybuild\ncontainerpath  (F) = /apps/containers\ninstallpath    (C) = /tmp/easybuild\npackagepath    (F) = /apps/packages\nprefix         (F) = /apps\nrepositorypath (F) = /apps/ebfiles_repo\nrobot-paths    (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath     (F) = /apps/sources\n</code></pre> <p>The output indicates that the <code>installpath</code> setting was specified through a command line option (indicated with <code>(C)</code>), that the <code>buildpath</code> setting was defined via an environment variable (indicated with <code>(E)</code>), that the <code>robot-paths</code> setting still has the default value (indicated with <code>(D)</code>), and that all other configuration settings were specified via a configuration file, some of which indirectly through the <code>prefix</code> value (indicated with <code>(F)</code>).</p>"},{"location":"2022-isc22/configuration/#exercises","title":"Exercises","text":"<p>Exercise C.1 - Configure EasyBuild</p> <p>Configure EasyBuild to use the <code>easybuild</code> subdirectory in your home directory for everything, except for:</p> <ul> <li>The location of the build directories: use <code>/tmp/$USER</code> for this;</li> <li>The locations that should be considered when searching for source files:   include both <code>$HOME/easybuild/sources</code> and <code>/easybuild/sources</code>, but make   sure that source files that are downloaded by EasyBuild are stored in   <code>$HOME/easybuild/sources</code>.</li> </ul> <p>Leave other configuration settings set to their default value.</p> (click to show solution) <p>This is pretty straightforward.</p> <p>Here we just define the corresponding environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\nexport EASYBUILD_SOURCEPATH=$HOME/easybuild/sources:/easybuild/sources\n</code></pre> <p>The location where EasyBuild should download source files to must be listed first in the <code>sourcepath</code> configuration setting.</p> <p>The output of <code>--show-config</code> should look like this (assuming that <code>$USER</code> is set to <code>example</code>):</p> <pre><code>buildpath      (E) = /tmp/example\ncontainerpath  (E) = /home/example/easybuild/containers\ninstallpath    (E) = /home/example/easybuild\npackagepath    (E) = /home/example/easybuild/packages\nprefix         (E) = /home/example/easybuild\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths    (D) = /home/example/easybuild/software/EasyBuild/4.4.0/easybuild/easyconfigs\nsourcepath     (E) = /home/example/easybuild/sources:/easybuild/sources\n</code></pre> <p>Exercise C.2 - Install a trivial software package with EasyBuild</p> <p>Try running the following command:</p> <pre><code>eb bzip2-1.0.6.eb\n</code></pre> <p>Where do you expect to find the installation?</p> (click to show solution) <p>The software was installed in <code>$HOME/easybuild</code>, since that's how we configured EasyBuild in Exercise 3.1:</p> <pre><code>$ ls $HOME/easybuild\nebfiles_repo  modules  software  sources\n</code></pre> <p>The actual installation is in <code>$HOME/easybuild/software</code>, while the module file was generated in <code>$HOME/easybuild/modules/all</code>:</p> <pre><code>$ ls $HOME/easybuild/software\nbzip2  EasyBuild\n$ ls $HOME/easybuild/software/bzip2\n1.0.6\n$ ls $HOME/easybuild/software/bzip2/1.0.6\nbin  easybuild  include  lib  man\n</code></pre> <pre><code>$ ls $HOME/easybuild/modules/all\nbzip2  EasyBuild\n$ ls $HOME/easybuild/modules/all/bzip2\n1.0.6.lua\n</code></pre> <p>The source file for bzip2 1.0.6 was downloaded to <code>$HOME/easybuild/sources</code>:</p> <pre><code>$ ls $HOME/easybuild/sources/b/bzip2\nbzip2-1.0.6.tar.gz\n</code></pre> <p>We will discuss this in more detail in the next part of the tutorial.</p> <p>Make sure EasyBuild is configured as instructed in exercise 3.1 before you continue with the rest of this tutorial.</p> <p>next: Basic usage - (back to overview page)</p>"},{"location":"2022-isc22/contributing/","title":"Contributing to EasyBuild","text":"<p>To contribute changes to the EasyBuild code (framework or easyblocks) or easyconfigs, you will need to be a bit familiar with Git and GitHub. Or maybe not?</p>"},{"location":"2022-isc22/contributing/#manual-contribution-procedure","title":"Manual contribution procedure","text":"<p>0) Create and setup a GitHub account (and register your SSH public key);</p> <p>1) Clone and fork the appropriate GitHub repository, for example when contributing an easyconfig file:</p> <pre><code>git clone git@github.com:easybuilders/easybuild-easyconfigs.git\ncd easybuild-easyconfigs\ngit remote add my_fork git@github.com:your_github_account/easybuild-easyconfigs.git\n</code></pre> <p>You should change '<code>your_github_account</code>' in the last line to your own GitHub user name!</p> <p>2) Create and check out a new branch, starting from the (up-to-date) <code>develop</code> branch:</p> <pre><code>git checkout develop\ngit pull origin develop\ngit checkout -b example\n</code></pre> <p>3) Stage the changes you want to contribute, after you make sure that your easyconfig file has the correct filename, and that it's located in the appropriate directory.</p> <pre><code>mkdir -p easybuild/easyconfigs/e/example/\nmv example.eb easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb\ngit add easybuild/easyconfigs/e/example/example-1.2.3-GCC-9.3.0.eb\n</code></pre> <p>4) Commit those changes with a sensible commit message:</p> <pre><code>git commit -m \"This is just an example\"\n</code></pre> <p>5) Push your branch to your fork of the repository on GitHub:</p> <pre><code>git push my_fork example\n</code></pre> <p>6) Open the pull request through the GitHub web interface, making sure that:</p> <ul> <li>the target branch is correct (should be <code>develop</code>);</li> <li>an appropriate title is used;</li> <li>a short description of the changes is provided;</li> <li>the changes are indeed the ones you want to propose;</li> <li>clicking the (correct) green button;</li> </ul> <p>That didn't exactly motivate you to contribute, did it...</p>"},{"location":"2022-isc22/contributing/#github-integration-features","title":"Github integration features","text":"<p>Over the years we noticed that some people were keen on contributing to EasyBuild, but they were not very familiar with Git or GitHub. That meant they had to overcome a relatively steep learning curve before they could contribute...</p> <p>In addition, the contribution workflow can be a bit daunting and time consuming, even if you're already familiar with the procedure. You will have dozens of branches flying around in no time, and if you get stuck in a weird corner with <code>git</code> you may quickly end up demotivated.</p> <p>This is frustrating not only for the people who wanted to contribute but also for the EasyBuild maintainers, and it doesn't agree with the philosophy of a project that aims to automate tedious software installation procedures.</p> <p>At the end of 2015 efforts were made to tackle this issue by implementing GitHub integration features in EasyBuild, which automate the contribution workflow by running <code>git</code> commands and interacting with the GitHub API.</p> <p>We will briefly go over some of these features here, but they are also covered in detail in the EasyBuild documentation.</p>"},{"location":"2022-isc22/contributing/#requirements-configuration","title":"Requirements &amp; configuration","text":"<p>First of all, the GitHub integration features impose a couple of additional requirements and configuration.</p> <p>Additional dependencies</p> <p>Both the <code>GitPython</code> and <code>keyring</code> Python packages as well as the <code>keyrings.cryptfile</code> add-on package must be installed. In the prepared environment, you can do this via:</p> <pre><code>pip3 install --user GitPython keyring keyrings.cryptfile\n</code></pre> <p>Note</p> <p>You may experiences problems installing the <code>cryptography</code> Python packages, which is a dependency of keyring. The underlying cause is that you need to have the <code>Rust</code> compiler installed to install the latest version of <code>cryptography</code> (see here).</p> <p>You can work around this issue using:</p> <pre><code>pip3 install --user 'cryptography&lt;3.4'\n</code></pre> <p>SSH public key in GitHub account</p> <p>You need to have a GitHub account that has your SSH public key registered in it (via https://github.com/settings/keys).</p> <p>If you need to generate an SSH key pair, you can run the following command:</p> <pre><code>ssh-keygen -a 100 -t ed25519\n</code></pre> <p>You can copy the SSH public key from the output of this command:</p> <pre><code>cat .ssh/id_ed25519.pub\n</code></pre> <p>Forked repository in GitHub</p> <p>In addition, you must have forked the EasyBuild repository you want to contribute to (for example https://github.com/easybuilders/easybuild-easyconfigs).</p> <p>EasyBuild configuration, incl. GitHub token</p> <p>You also have to configure EasyBuild a bit more, so it knows about your GitHub user name and has a GitHub token available in order to perform actions in GitHub with your credentials.</p> <p>To do this, you should define the <code>github-user</code> configuration option and run the \"<code>eb --install-github-token</code>\" command:</p> <pre><code># replace 'ebtutorial' with your own GitHub username!\n$ export EASYBUILD_GITHUB_USER=ebtutorial\n$ eb --install-github-token\n</code></pre> <p>To create a GitHub token:</p> <ul> <li>Visit https://github.com/settings/tokens.</li> <li>Click \"Personal access tokens\".</li> <li>Click followed by \"Generate new token\".</li> <li>Give the token a name (for example \"Token for EasyBuild\").</li> <li>Select both the '<code>public_repo</code>' (in the '<code>repo</code>' section) and '<code>gist</code>' scopes.</li> <li>Click the green \"Generate token\" button.</li> <li>Copy the generated token.</li> <li>Paste the token when asked by <code>--install-github-token</code> (and hit Enter).</li> <li>Enter a password to encrypt your GitHub token.</li> </ul> <p>The output should look something like this:</p> <pre><code>$ eb --install-github-token\n== temporary log file in case of crash /tmp/eb-9z0bdve9/easybuild-hfpti62w.log\nToken: \nValidating token...\nToken seems to be valid, installing it.\nPlease set a password for your new keyring: \nPlease confirm the password:\nToken 'fed..987' installed!\n</code></pre> <p>Checking status of GitHub integration</p> <p>You can check the status of the GitHub integration using \"<code>eb --check-github</code>\":</p> <pre><code>$ eb --check-github\n== temporary log file in case of crash /tmp/eb-4ckdlyfy/easybuild-gp69ev2w.log\n\nChecking status of GitHub integration...\n\nMaking sure we're online...OK\n\n* GitHub user...ebtutorial =&gt; OK\nPlease enter password for encrypted keyring:\n* GitHub token...fed..987 (len: 40) =&gt; OK (validated)\n* git command...OK (\"git version 1.8.3.1; \")\n* GitPython module...OK (GitPython version 3.1.3)\n* push access to ebtutorial/easybuild-easyconfigs repo @ GitHub...OK\n* creating gists...OK\n* location to Git working dirs... not found (suboptimal)\n\nAll checks PASSed!\n\nStatus of GitHub integration:\n* --from-pr: OK\n* --new-pr: OK\n* --review-pr: OK\n* --update-pr: OK\n* --upload-test-report: OK\n</code></pre> <p>If you see '<code>OK</code>' for each of the status checks, you're all set to try out the GitHub integration features!</p> <p>Note</p> <p>If your SSH private key is protected with a password, you may need to enter your password a couple of times when running \"<code>eb --check-github</code>\".</p> <p>You can avoid this by using an SSH agent.</p> <p>Note</p> <p>If you see the <code>push access</code> check fail with <code>Failed to fetch branch 'main'</code>, you will need to rename the <code>master</code> branch in your fork of the <code>easybuild-easyconfigs</code> repository from <code>master</code> to <code>main</code> (this is required since EasyBuild v4.3.3).</p> <p>This can be done via the pencil icon at https://github.com/YOUR_GITHUB_ACCOUNT/easybuild-easyconfigs/branches (replace <code>YOUR_GITHUB_ACCOUNT</code> with the name of your GitHub account in this URL).</p>"},{"location":"2022-isc22/contributing/#creating-pull-requests","title":"Creating pull requests","text":"<p>The GitHub integration in EasyBuild allows you to create pull requests using the <code>eb</code> command, without even leaving your shell environment. How cool is that\u203d</p> <p>To create a pull request to the <code>easybuild-easyconfigs</code> repository, you can either do it in a single go by running \"<code>eb --new-pr</code>\" and passing it one or more easyconfig files to add into the pull request.</p> <p>The more detailed option is to first create a branch in your repository fork in GitHub via \"<code>eb --new-branch-github</code>\" and then later open the pull request via \"<code>eb --new-pr-from-branch</code>\". This method can be useful when preparing multiple interdependent pull requests, or to check whether your changes pass the unit tests (which are run automatically in the GitHub Actions CI environment for all branches pushed to your fork).</p> <p>The <code>--new-pr</code> option can also be used to open pull requests to the easyblocks and framework repositories, and it will even automatically determine the target repository based on the contents of the files you provide. Whoa!</p> <p>You can control the target repository for your pull request using <code>--pr-target-account</code> (default is <code>easybuilders</code>) and <code>--pr-target-repo</code>.</p> <p>If you want you can carefully double check your work before actually opening the pull request by doing a dry run via \"<code>eb --dry-run --new-pr</code>\" or \"<code>eb -D --new-pr</code>\".</p> <p>Finally, you can use \"<code>eb --preview-pr</code>\" to see how the easyconfig files for which you plan to create a pull request differ from existing easyconfig files.</p>"},{"location":"2022-isc22/contributing/#updating-pull-requests","title":"Updating pull requests","text":"<p>To update an existing pull request with additional changes you can use \"<code>eb --update-pr</code>\" and pass the pull request ID, alongside the paths to the updated files.</p> <p>If you have only created a branch (for example via <code>eb --new-branch-github</code>) you can update it via <code>--update-branch-github</code> in the same way, passing the branch name instead of a pull request ID.</p>"},{"location":"2022-isc22/contributing/#using-a-pull-request","title":"Using a pull request","text":"<p>Next to creating and updating branches and pull requests you can also use easyconfig files and easyblocks from a pull request, regardless of its status (open, merged, or closed). This is particularly useful when testing contributions, or to install software for which  support is not yet included in the latest EasyBuild release.</p> <p>Using the <code>--from-pr</code> option you can install easyconfig files from the pull request with specified ID. By default all easyconfig files that are touched by the pull request will be installed, but you can specify particular ones to use as well. It is generally advised to also use the <code>--robot</code> option to ensure that the easyconfig files are installed in the correct order with respect to dependencies.</p> <p>Similarly, using a new or updated easyblock from a pull request is as simple as using the <code>--include-easyblocks-from-pr</code> option. And of course you can combine it with <code>--from-pr</code>!</p> <p>Via <code>--upload-test-report</code> you can let EasyBuild submit a comment into the easyconfig pull request to show that the installation worked on your system. This is useful for others to know, in particular EasyBuild maintainers, since the comment will include information about your system (OS, processor, etc.) and your EasyBuild configuration.</p>"},{"location":"2022-isc22/contributing/#demo","title":"Demo","text":"<p>That is a lot to digest, so let us make this a bit more concrete with an example: we will open a pull request for the <code>eb-tutorial</code> example software to a fork of the <code>easybuild-easyconfigs</code> repository using the <code>eb</code> command, and submit a test report in it.</p> <p>Note</p> <p>Make sure that you have correctly configured the GitHub integration, see above.</p>"},{"location":"2022-isc22/contributing/#creating-pull-request","title":"Creating pull request","text":"<p>We first configure EasyBuild to target the <code>ebtutorial</code> GitHub account rather than the default <code>easybuilders</code> GitHub organisation, by defining the <code>pr-target-account</code> configuration setting:</p> <pre><code>export EASYBUILD_PR_TARGET_ACCOUNT=ebtutorial\n</code></pre> <p>In the output of \"<code>eb --show-config</code>\" you should see a line like this:</p> <pre><code>pr-target-account (E) = ebtutorial\n</code></pre> <p>We only do this to avoid that lots of pull requests for the <code>eb-tutorial</code> example software are opened in the central easyconfigs repository.</p> <p>Opening a pull request is as simple as running \"<code>eb --new-pr</code>\" and passing the easyconfig file:</p> <pre><code>$ eb --new-pr example.eb\n== temporary log file in case of crash /tmp/eb-ggr6scbq/easybuild-hnk271xj.log\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n== fetching branch 'develop' from https://github.com/ebtutorial/easybuild-easyconfigs.git...\n== copying files to /tmp/eb-ggr6scbq/git-working-dirxwk1fzaw/easybuild-easyconfigs...\n== pushing branch '20200622095415_new_pr_eb-tutorial100' to remote 'github_ebtutorial_qgtfU' (git@github.com:ebtutorial/easybuild-easyconfigs.git)\nEnter passphrase for key '/home/example/.ssh/id_rsa': \nPlease enter password for encrypted keyring:\n\nOpening pull request\n* target: ebtutorial/easybuild-easyconfigs:develop\n* from: ebtutorial/easybuild-easyconfigs:20200622095415_new_pr_eb-tutorial100\n* title: \"{tools}[GCC/11.2.0] eb-tutorial v1.0.1\"\n* labels: new\n* description:\n\"\"\"\n(created using `eb --new-pr`)\n\n\"\"\"\n* overview of changes:\n easybuild/easyconfigs/e/eb-tutorial/eb-tutorial-1.0.1-GCC-11.2.0.eb | 26 ++++++++++++++++++++++++++\n 1 file changed, 26 insertions(+)\n\nOpened pull request: https://github.com/ebtutorial/easybuild-easyconfigs/pull/\n== Temporary log file(s) /tmp/eb-ggr6scbq/easybuild-hnk271xj.log* have been removed.\n== Temporary directory /tmp/eb-ggr6scbq has been removed.\n</code></pre> <p>Take a moment to grasp what we did here: we ran a single <code>eb</code> command which took care of the whole contribution procedure for us, including:</p> <ul> <li>Cloning the <code>easybuilders/easybuild-easyconfigs</code> repository and checking out the <code>develop</code> branch (in a temporary   directory);</li> <li>Picking a sensible name for a branch and creating it;</li> <li>Adding the <code>eb-tutorial</code> easyconfig file to the branch, in the correct location   (<code>easybuild/easyconfigs/e/eb-tutorial/</code>) and with the correct filename (<code>eb-tutorial-1.0.1-GCC-11.2.0.eb</code>);</li> <li>Pushing the branch to our fork (<code>example/easybuild-easyconfigs</code>);</li> <li>Actually opening the pull request, using an informative title.</li> </ul> <p>That is so... easy!</p> <p>This feature not only significantly lowers the bar for contributing, it also saves quite a bit of time since you don't need to double check various details (like targeting the <code>develop</code> branch) or spend time on coming up with a nice looking title or funny branch name (although you still can if you really want to).</p> <p>There are a couple of nice side effects too, like not having any local branches to tidy up on once the pull request gets merged (since <code>--new-pr</code> created the branch only in a temporary directory).</p> <p>If many contributions are made via <code>--new-pr</code> it also simplifies the task of EasyBuild maintainers, since pull requests opened this way have a particular structure to them and thus are easier to digest because they look familiar.</p>"},{"location":"2022-isc22/contributing/#uploading-test-report","title":"Uploading test report","text":"<p>After opening the pull request, we should also upload a test report to show that the installation is working. This is just as easy as creating the pull request.</p> <p>First make sure that the pre-installed software in the prepared environment is available, since the required dependencies for <code>eb-tutorial</code> are already installed there:</p> <pre><code>module use /easybuild/modules/all\n</code></pre> <p>You can verify which dependencies are still missing using <code>--from-pr</code> combined with <code>--missing</code>:</p> <pre><code># change '1' to the ID of your own pull request (see output of --new-pr)\n$ eb --from-pr 123 --missing\n== temporary log file in case of crash /tmp/eb-ioi9ywm1/easybuild-e3v0xa1b.log\nPlease enter password for encrypted keyring:\n== found valid index for /home/example/.local/easybuild/easyconfigs, so using it...\n\n1 out of 20 required modules missing:\n\n* eb-tutorial/1.0.1-GCC-11.2.0 (eb-tutorial-1.0.1-GCC-11.2.0.eb)\n</code></pre> <p>Uploading a test report boils down to combining <code>--from-pr</code> with <code>--upload-test-report</code>:</p> <pre><code># change '1' to the ID of your own pull request (see output of --new-pr)\n$ eb --rebuild --from-pr 123 --upload-test-report\nPlease enter password for encrypted keyring:\n...\n== processing EasyBuild easyconfig /tmp/eb-bnb1pv3n/files_pr65/e/eb-tutorial/eb-tutorial-1.0.1-GCC-11.2.0.eb\n== building and installing eb-tutorial/1.0.1-GCC-11.2.0...\n...\n== COMPLETED: Installation ended successfully (took 2 sec)\n...\nAdding comment to easybuild-easyconfigs issue #65: 'Test report by @ebtutorial\n**SUCCESS**\nBuild succeeded for 1 out of 1 (1 easyconfigs in this PR)\nexample - Linux centos linux 8.5, x86_64, Intel(R) Core(TM) E5-2660 v4 @ 2.00GHz (broadwell), Python 3.6.8\nSee https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 for a full test report.'\n== Test report uploaded to https://gist.github.com/f7c74159c809029afd99e30e4d994ef1 and mentioned in a comment in easyconfigs PR#1\n</code></pre> <p>Note that we may need to use <code>--rebuild</code> here since <code>eb-tutorial</code> may already be installed.</p> <p>This results in a comment being added to the pull request:</p> <p>The gist linked from this comment provides more detailed information:</p> <p>next: Comparison with other tools - (back to overview page)</p>"},{"location":"2022-isc22/installation/","title":"Installing EasyBuild","text":"<p>Before deep diving into the wonderful world of EasyBuild and getting your hands dirty with the hands on exercises coming up in this tutorial, you will need to install EasyBuild.</p> <p>In this section we outline a couple of different ways of doing this, and also the things you should pay attention to. By the end, you will have a functional EasyBuild installation that you can use for the remainder of this tutorial.</p> <p>Summary</p> <ul> <li>Requirements: Linux, Python 2.7 or 3.5+, environment modules tool (Lmod is recommended).</li> <li>Installation methods:<ul> <li><code>pip install easybuild</code></li> <li>installing EasyBuild with EasyBuild</li> <li>development setup</li> </ul> </li> <li>Verify EasyBuild installation by running <code>eb</code> commands.</li> </ul>"},{"location":"2022-isc22/installation/#requirements","title":"Requirements","text":""},{"location":"2022-isc22/installation/#linux","title":"Linux","text":"<p>The main target platform for EasyBuild is Linux, since it is heavily focused on installing software on HPC system where Linux is dominant operating system (to the point where 100% of the current Top500 list of supercomputers are running Linux).</p> <p>EasyBuild is also compatible with macOS, but the included easyconfig files are heavily focused on Linux so most software installations supported by EasyBuild won't work out-of-the-box on macOS. You can still use the EasyBuild command line interface on macOS for other tasks though, like development or contributing back to the project.</p>"},{"location":"2022-isc22/installation/#python","title":"Python","text":"<p>EasyBuild is implemented in Python, and is compatible with both Python 2.7 and Python 3.5+ (that is, Python 3.5 or a newer version of Python 3).</p> <p>To check which Python version you have, use:</p> <pre><code>python -V\n</code></pre> <p>Note</p> <p>It is possible that the <code>python</code> command is not available, which will trigger an error like:</p> <pre><code>-bash: python: command not found\n</code></pre> <p>If that is the case, consider using the <code>python3</code> command (or similar) instead.</p> <p>No additional Python packages are required by EasyBuild, the ones that come with the standard Python distribution are sufficient. Some additional Python packages can be leveraged for specific features. More on that later.</p>"},{"location":"2022-isc22/installation/#environment-modules-tool","title":"Environment modules tool","text":"<p>An environment modules tool is required for using EasyBuild.</p> <p>We strongly recommend using Lmod, a Lua-based modern environment modules implementation and the most commonly used modules tool in the EasyBuild community. Other implementations, like the original Tcl-based one, are also supported.</p> <p>To check if you have a modules tool installed, use:</p> <pre><code>module --version\n</code></pre> <p>If this produces output that starts with something like \"<code>Modules based on Lua: Version 8.2.5</code>\" you have Lmod installed, which is the default modules tool used by EasyBuild, and you are all set for installing and using EasyBuild. Any sufficiently recent Lmod version (8.x or even 7.x) should be fine. </p> <p>If you see output that starts with a line like \"<code>VERSION=3.2.10</code>\" or \"<code>Modules Release 4.5.0</code>\", you have the original Tcl-based environment modules tool installed and EasyBuild will need to be configured to use it after installation.</p> <p>If the <code>module</code> function is not defined either you do not have a modules tool installed or your environment is not properly set up to use it. In this case, please refer to the EasyBuild documentation here for more information.</p>"},{"location":"2022-isc22/installation/#easybuild-as-a-python-package","title":"EasyBuild as a Python package","text":"<p>EasyBuild consists of a number of interdependent Python packages, and is available via both GitHub at https://github.com/easybuilders, as well as via the standard Python Package Index (PyPI) at https://pypi.org/project/easybuild.</p> <p>As you may be aware the Python packaging ecosystem is bit convoluted, which is reflected in the many different ways in which you can install a Python package. In addition, EasyBuild is packaged in 3 components (framework, easyblocks, easyconfigs) which slightly complicates the installation.</p> <p>Nevertheless, you don't need to be a rocket scientist to install EasyBuild (and even if you are, that's OK too), so don't worry.</p> <p>You can install EasyBuild just like you can install any other Python software that is released via the standard Python Package Index (PyPI), through one of the standard Python installation tools (like <code>pip</code>, <code>virtualenv</code>, <code>pipenv</code>, ...). And since EasyBuild is a software installation tool in its own right, we actually have a couple of additional tricks up our sleeve!</p>"},{"location":"2022-isc22/installation/#python-2-or-python-3","title":"Python 2 or Python 3?","text":"<p>For EasyBuild it does not matter whether you install it on top of Python 2 or Python 3. The functionality provided is identical. However, since Python 2 is end-of-life, we strongly recommend using Python 3 if you have the choice.</p> <p>By default EasyBuild will use the <code>python</code> command to run, but you can control this if needed via <code>$EB_PYTHON</code>.</p>"},{"location":"2022-isc22/installation/#installing-easybuild_1","title":"Installing EasyBuild","text":"<p>We present three methods for installing EasyBuild. It is up to you which one you prefer, both result a fully functional EasyBuild installation.</p> <p>Time to get your hands dirty!</p> <ul> <li>Method 1: Using <code>pip</code></li> <li>Method 2: installing EasyBuild with EasyBuild</li> <li>Method 3: Development setup</li> </ul>"},{"location":"2022-isc22/installation/#method-1-using-pip","title":"Method 1: Using <code>pip</code>","text":"<p>Since EasyBuild is released as a Python package on PyPI you can install it using <code>pip</code>, the most commonly used tool for installing Python packages.</p> <p>You may need to take additional steps after the installation, depending on the exact installation command.</p> <p>Note</p> <p>There are various other ways of installing Python packages, which we won't cover here. If you are familiar with other tools like <code>virtualenv</code> or <code>pipenv</code>, feel free to use those instead to install EasyBuild.</p>"},{"location":"2022-isc22/installation/#running-pip-install","title":"Running <code>pip install</code>","text":"<p>Installing EasyBuild with <code>pip</code> is as simple as running the following command:</p> <pre><code>pip install easybuild\n</code></pre> <p>However, you may need to slightly change this command depending on the context and your personal preferences:</p> <ul> <li> <p>To install EasyBuild system-wide, you can use <code>sudo</code> (if you have admin privileges):   <pre><code>sudo pip install easybuild\n</code></pre></p> </li> <li> <p>To install EasyBuild in your personal home directory, you can use the <code>--user</code> option:   <pre><code>pip install --user easybuild\n</code></pre>   This will result in an EasyBuild installation in <code>$HOME/.local/</code>.</p> </li> <li> <p>To install EasyBuild in a specific directory you can use the <code>--prefix</code> option:   <pre><code>pip install --prefix _PREFIX_ easybuild\n</code></pre>   In this command, you should replace '<code>_PREFIX_</code>' with the location where you want to have EasyBuild installed   (for example, <code>$HOME/tools</code> or <code>/tmp/$USER</code>).</p> </li> </ul>"},{"location":"2022-isc22/installation/#pip-vs-pip3","title":"<code>pip</code> vs <code>pip3</code>","text":"<p>On systems where both Python 2 and Python 3 are installed you may also have different <code>pip</code> commands available. Or maybe <code>pip</code> is not available at all, and only \"versioned\" <code>pip</code> commands like <code>pip3</code> are available.</p> <p>If you (only) have <code>pip3</code> available, you can replace <code>pip</code> with <code>pip3</code> in any of the <code>pip install</code> commands above.</p> <p>If you want to ensure that you are using the <code>pip</code> installation that corresponds to the Python 3 installation that you intend to use, you can use <code>python3 -m pip</code> rather than <code>pip3</code>.</p>"},{"location":"2022-isc22/installation/#updating-your-environment","title":"Updating your environment","text":"<p>If you used the <code>--user</code> or <code>--prefix</code> option in the <code>pip install</code> command, or if you installed EasyBuild with a <code>pip</code> version that does not correspond to your default Python installation, you will need to update your environment to make EasyBuild ready for use. This is not required if you did a system-wide installation in a standard location with the default Python version.</p> <p>Note</p> <p>Keep in mind that you will have to make these environment changes again if you start a new shell session. To avoid this, you can update the <code>.bashrc</code> shell startup script in your home directory.</p>"},{"location":"2022-isc22/installation/#updating-path","title":"Updating <code>$PATH</code>","text":"<p>Update the <code>$PATH</code> environment variable to make sure the <code>eb</code> command is available: <pre><code>export PATH=_PREFIX_/bin:$PATH\n</code></pre> Replace '<code>_PREFIX_</code>' in this command with the directory path where EasyBuild was installed into (use <code>$HOME/.local</code> if you used <code>pip install --user</code>).</p> <p>This is not required if you installed EasyBuild in a standard system location.</p> <p>You can check with the \"<code>which eb</code>\" command to determine whether or not you need to update the <code>$PATH</code> environment variable.</p>"},{"location":"2022-isc22/installation/#updating-pythonpath","title":"Updating <code>$PYTHONPATH</code>","text":"<p>If you installed EasyBuild to a non-standard location using <code>pip install --prefix</code>, you also need to update the Python search path environment variable <code>$PYTHONPATH</code> to instruct Python where it can find the EasyBuild Python packages.</p> <p>This is not required if you used the <code>--user</code> option, since Python will automatically consider <code>$HOME/.local</code> when searching for installed Python packages, or if you installed EasyBuild in a standard system-wide location.</p> <p>Update <code>$PYTHONPATH</code> by running a command like:</p> <pre><code>export PYTHONPATH=_PREFIX_/lib/pythonX.Y/site-packages:$PYTHONPATH\n</code></pre> <p>Here, you need to replace the <code>X</code> and <code>Y</code> with the major and minor version of your Python installation, which you can determine by running <code>python -V</code>. For example, if you are using Python 3.6, make sure you are using <code>/python3.6/</code> in the command to update <code>$PYTHONPATH</code>.</p> <p>And of course, you again need to replace '<code>_PREFIX_</code>' with the installation prefix where EasyBuild was installed into.</p> <p>For example:</p> <pre><code># update $PYTHONPATH if EasyBuild was installed in $HOME/tools with Python 3.6\nexport PYTHONPATH=$HOME/tools/lib/python3.6/site-packages:$PYTHONPATH\n</code></pre>"},{"location":"2022-isc22/installation/#setting-eb_python","title":"Setting <code>$EB_PYTHON</code>","text":"<p>If you want to control which Python version is used to run EasyBuild, you can specify the name or the full path to the <code>python</code> command that should be used by the <code>eb</code> command via the <code>$EB_PYTHON</code> environment variable.</p> <p>This may be required when you installing EasyBuild with a version of <code>pip</code> that does not correspond with the default Python version.</p> <p>For example, to ensure that the <code>eb</code> command uses <code>python3.6</code>:</p> <pre><code>export EB_PYTHON=python3.6\n</code></pre>"},{"location":"2022-isc22/installation/#setting-eb_verbose","title":"Setting <code>$EB_VERBOSE</code>","text":"<p>To determine which <code>python</code> commands are being considered by the <code>eb</code> command, you can define the <code>$EB_VERBOSE</code> environment variable. For example:</p> <pre><code>$ EB_VERBOSE=1 eb --version\n&gt;&gt; Considering 'python3'...\n&gt;&gt; 'python3' version: 3.6.8, which matches Python 3 version requirement (&gt;= 3.5)\n&gt;&gt; 'python3' is able to import 'easybuild.main', so retaining it\n&gt;&gt; Selected Python command: python3 (/usr/bin/python3)\n&gt;&gt; python3 -m easybuild.main --version\nThis is EasyBuild 4.5.4 (framework: 4.5.4, easyblocks: 4.5.4) on host example\n</code></pre>"},{"location":"2022-isc22/installation/#method-2-installing-easybuild-with-easybuild","title":"Method 2: Installing EasyBuild with EasyBuild","text":"<p>Note</p> <p>This section covers an alternative method for installing EasyBuild.</p> <p>If you already have EasyBuild installed through <code>pip</code>, you can skip ahead to the next section.</p> <p>If you prefer having EasyBuild available through an environment module file, you can consider installing EasyBuild with EasyBuild. This can be done in 3 steps:</p> <ul> <li>Step 1: Installing EasyBuild with <code>pip</code> into a temporary location (only needed if EasyBuild is not installed yet)</li> <li>Step 2: Using EasyBuild to install EasyBuild as a module</li> <li>Step 3: Loading the EasyBuild module</li> </ul>"},{"location":"2022-isc22/installation/#step-1-installing-easybuild-into-a-temporary-location","title":"Step 1: Installing EasyBuild into a temporary location","text":"<p>If you don't have EasyBuild installed yet, you need to install it in a temporary location first. The recommended way of doing this is using <code>pip</code>.</p> <p>For example, to install EasyBuild into a subdirectory <code>/tmp/$USER</code> using the default Python 3 version:</p> <pre><code># pick installation prefix, and install EasyBuild into it\nexport EB_TMPDIR=/tmp/$USER/eb_tmp\npython3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild\n</code></pre> <pre><code># update environment to use this temporary EasyBuild installation\nexport PATH=$EB_TMPDIR/bin:$PATH\nexport PYTHONPATH=$(/bin/ls -rtd -1 $EB_TMPDIR/lib*/python*/site-packages | tail -1):$PYTHONPATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2022-isc22/installation/#step-2-using-easybuild-to-install-easybuild","title":"Step 2: Using EasyBuild to install EasyBuild","text":"<p>Once you have a working (recent) temporary EasyBuild installation, you can use it to install EasyBuild as a module. Usually this is done in the location where you would like to install other software too.</p> <p>You can use the <code>eb --install-latest-eb-release</code> command for this, combined with the <code>--prefix</code> option to control which directories are used by EasyBuild for the installation.</p> <p>For example, to install the latest version of EasyBuild as a module into <code>$HOME/easybuild</code>:</p> <pre><code>eb --install-latest-eb-release --prefix $HOME/easybuild\n</code></pre> <p>Note</p> <p>You may see a harmless deprecation warning popping up when performing this installation, just ignore it.</p>"},{"location":"2022-isc22/installation/#step-3-loading-the-easybuild-module","title":"Step 3: Loading the EasyBuild module","text":"<p>Once step 2 is completed, you should be able to load the module that was generated alongside the EasyBuild installation. You will need to do this every time you start a new shell session.</p> <p>First, make the module available by running the following command (which will update the module search path environment variable <code>$MODULEPATH</code>):</p> <pre><code>module use _PREFIX_/modules/all\n</code></pre> <p>Replace '<code>_PREFIX_</code>' with the path to the directory that you used when running step 2 (for example, <code>$HOME/easybuild</code>).</p> <p>Then, load the <code>EasyBuild</code> module to update your environment and make EasyBuild available for use:</p> <pre><code>module load EasyBuild\n</code></pre> <p>Note that in this case, we don't need to make any changes to our environment for EasyBuild to work correctly. The environment module file that was generated by EasyBuild specifies all changes that need to be made.</p>"},{"location":"2022-isc22/installation/#method-3-development-setup","title":"Method 3: Development setup","text":"<p>If you are planning to make changes to EasyBuild, or if you prefer using the latest bleeding edge version of EasyBuild that is being developed, you can consider cloning the 3 main EasyBuild repositories from GitHub, and updating your environment to run EasyBuild from there.</p> <p>This can be done as follows (into <code>$HOME/easybuild</code>):</p> <pre><code>mkdir -p $HOME/easybuild\ncd $HOME/easybuild\n</code></pre> <p><pre><code># clone EasyBuild repositories from GitHub\ngit clone https://github.com/easybuilders/easybuild-framework.git\ngit clone https://github.com/easybuilders/easybuild-easyblocks.git\ngit clone https://github.com/easybuilders/easybuild-easyconfigs.git\n</code></pre> <pre><code># update environment for running EasyBuild from there\nexport PATH=$HOME/easybuild/easybuild-framework:$PATH\nexport PYTHONPATH=$HOME/easybuild/easybuild-framework:$HOME/easybuild/easybuild-easyblocks:$HOME/easybuild/easybuild-easyconfigs:$PYTHONPATH\n\n# control which Python command is used to run EasyBuild\nexport EB_PYTHON=python3\n</code></pre></p>"},{"location":"2022-isc22/installation/#verifying-the-installation","title":"Verifying the installation","text":"<p>Regardless of how EasyBuild was installed, you can now run a couple of basic commands to verify the installation:</p>"},{"location":"2022-isc22/installation/#checking-the-version","title":"Checking the version","text":"<p>To check which EasyBuild version you have installed, run:</p> <pre><code>eb --version\n</code></pre> <p>The output should match with the latest EasyBuild version.</p>"},{"location":"2022-isc22/installation/#consulting-the-help-output","title":"Consulting the help output","text":"<p>You can consult the help output of the <code>eb</code> command, which produces a long list of available options along with a short informative message.</p> <pre><code>eb --help\n</code></pre>"},{"location":"2022-isc22/installation/#showing-the-default-easybuild-configuration","title":"Showing the default EasyBuild configuration","text":"<p>To inspect the current EasyBuild configuration, you can use this command:</p> <pre><code>eb --show-config\n</code></pre> <p>This should tell you that EasyBuild (ab)uses <code>$HOME/.local/easybuild</code> as a default location. More on configuring EasyBuild in the next part of the tutorial.</p>"},{"location":"2022-isc22/installation/#system-information","title":"System information","text":"<p>You ask EasyBuild to collect and print some information about the system you are using it on (OS, CPU, Python, etc.) using this command:</p> <pre><code>eb --show-system-info\n</code></pre>"},{"location":"2022-isc22/installation/#updating-easybuild","title":"Updating EasyBuild","text":"<p>Before we wrap up here, a brief word about updating EasyBuild.</p> <p>Once you have EasyBuild installed, the easiest way to update to a newer version is by instructing EasyBuild to install the latest available version as a module:</p> <pre><code>eb --install-latest-eb-release\n</code></pre> <p>This will result in a new EasyBuild installation, which is entirely separate from the EasyBuild installation you are currently using (so it is not an in-place update). The location where this new EasyBuild version will be installed is determined by the active EasyBuild configuration.</p> <p>If you have installed EasyBuild through <code>pip</code>, and you prefer updating that installation, you can use <code>pip install --upgrade easybuild</code> (perhaps with additional options like <code>--user</code> or <code>--prefix</code>).</p>"},{"location":"2022-isc22/installation/#exercise","title":"Exercise","text":"<p>Install EasyBuild in your home directory.</p> <p>Make sure that the EasyBuild installation uses the <code>python3</code> command to run, rather than the standard <code>python</code> command.</p> <p>Choose your own adventure, or try all these installation methods!</p> <ul> <li>install EasyBuild with <code>pip</code> (or another very similar command...) using either the <code>--user</code> or <code>--prefix</code> option;</li> <li>perform a (manual) \"bootstrap\" installation into <code>$HOME/easybuild</code>, as outlined in installation method 2;</li> <li>set up a development installation;</li> </ul> <p>Check that the installation works by running the verification commands outlined above.</p> <p>Make sure you have a working EasyBuild installation before proceeding with the rest of the tutorial!</p> <p>next: Configuring EasyBuild - (back to overview page)</p>"},{"location":"2022-isc22/installing_software/","title":"Installing software with EasyBuild","text":"<p>You should now be able to make an informed decision on which easyconfig file you should use to make EasyBuild install the software you require.</p> <p>As mentioned before, installing an easyconfig is as simple as passing it to the <code>eb</code> command.</p> <p>So, let's try to install SAMtools version 1.14:</p> <pre><code>$ eb SAMtools-1.14-GCC-11.2.0.eb\n== Temporary log file in case of crash /tmp/eb-os2fd8gv/easybuild-yda39z4b.log\n== processing EasyBuild easyconfig /home/achilles/easybuild/easybuild-easyconfigs/easybuild/easyconfigs/s/SAMtools/SAMtools-1.14-GCC-11.2.0.eb\n== building and installing SAMtools/1.14-GCC-11.2.0...\n== fetching files...\n== creating build dir, resetting environment...\n== unpacking...\n== ... (took 1 secs)\n== patching...\n== preparing...\n== ... (took 3 secs)\n== configuring...\n== ... (took 6 secs)\n== building...\n== ... (took 46 secs)\n== testing...\n== installing...\n== taking care of extensions...\n== restore after iterating...\n== postprocessing...\n== sanity checking...\n== ... (took 1 secs)\n== cleaning up...\n== creating module...\n== ... (took 1 secs)\n== permissions...\n== packaging...\n== COMPLETED: Installation ended successfully (took 1 min 0 secs)\n== Results of the build can be found in the log file(s) /project/def-maintainers/achilles/Rocky8/zen2/software/SAMtools/1.14-GCC-11.2.0/easybuild/easybuild-SAMtools-1.14-20220502.121241.log\n== Build succeeded for 1 out of 1\n== Temporary log file(s) /tmp/eb-os2fd8gv/easybuild-yda39z4b.log* have been removed.\n== Temporary directory /tmp/eb-os2fd8gv has been removed.\n</code></pre> <p>That was... easy. Is that really all there is to it? Well, almost...</p>"},{"location":"2022-isc22/installing_software/#enabling-dependency-resolution","title":"Enabling dependency resolution","text":"<p>The SAMtools installation worked like a charm, but remember that all required dependencies were already available (see the section on checking dependencies).</p> <p>If we try this with the <code>BCFtools-1.14-GCC-11.2.0.eb</code>, for which the required <code>GSL</code> and <code>HTSlib</code> dependencies are not available yet, it's less successful:</p> <pre><code>$ eb BCFtools-1.14-GCC-11.2.0.eb -M\n\n3 out of 23 required modules missing:\n\n* GSL/2.7-GCC-11.2.0 (GSL-2.7-GCC-11.2.0.eb)\n* HTSlib/1.14-GCC-11.2.0 (HTSlib-1.14-GCC-11.2.0.eb)\n* BCFtools/1.14-GCC-11.4.0 (BCFtools-1.14-GCC-11.2.0.eb)\n</code></pre> <pre><code>$ eb BCFtools-1.14-GCC-11.2.0.eb\n...\n== preparing...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/build/BCFtools/1.14/GCC-11.2.0): build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0 (took 1 secs)\n== Results of the build can be found in the log file(s) /tmp/eb-66a5glv6/easybuild-BCFtools-1.14-20220502.145732.ElHDN.log\nERROR: Build of /easybuild/software/EasyBuild/20220501-dev/easybuild/easyconfigs/b/BCFtools/BCFtools-1.14-GCC-11.2.0.eb failed (err: 'build failed (first 300 chars): Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0')\n</code></pre> <p>Oh my, what's this all about?</p> <p>If we filter the output a bit and focus on the actual error, the problem is clear:</p> <pre><code>Missing modules for dependencies (use --robot?): HTSlib/1.14-GCC-11.2.0, GSL/2.7-GCC-11.2.0\n</code></pre> <p>The required dependencies <code>HTSlib/1.14-GCC-11.2.0</code> and <code>GSL/2.7-GCC-11.2.0</code> are not installed yet, and EasyBuild does not automatically install missing dependencies unless it is told to do so.</p> <p>It helpfully suggests to use the <code>--robot</code> command line option, so let's try that:</p> <pre><code>$ eb BCFtools-1.14-GCC-11.2.0.eb --robot\n...\n== resolving dependencies ...\n...\n== building and installing HTSlib/1.14-GCC-11.2.0...\n...\n== COMPLETED: Installation ended successfully (took 14 sec)\n...\n== building and installing GSL/2.7-GCC-11.2.0...\n...\n== COMPLETED: Installation ended successfully (took 1 min 10 sec)\n...\n== building and installing BCFtools/1.14-GCC-11.2.0...\n...\n== COMPLETED: Installation ended successfully (took 8 sec)\n...\n== Build succeeded for 3 out of 3\n</code></pre> <p>With dependency resolution enabled the <code>HTSlib</code> and <code>GSL</code> modules get installed first, before EasyBuild proceeds with installing <code>BCFtools</code>. Great!</p>"},{"location":"2022-isc22/installing_software/#trace-output","title":"Trace output","text":"<p>As you may have noticed if you tried the previous example hands-on, some installations take a while. An installation can be spending quite a bit of time during the build step, but what is actually going on there?</p> <p>To provide some more feedback as the installation progresses, you can enable the \"<code>trace</code>\" configuration setting. Let's do this by defining the <code>$EASYBUILD_TRACE</code> environment variable, just to avoid having to type <code>--trace</code> over and over again.</p> <p>We will redo the installation of <code>BCFtools-1.14-GCC-11.2.0.eb</code> by passing the <code>--rebuild</code> option to the <code>eb</code> command (try yourself what happens if you don't use the <code>--rebuild</code> option!):</p> <pre><code>$ export EASYBUILD_TRACE=1\n$ eb BCFtools-1.14-GCC-11.2.0.eb --rebuild\n...\n== configuring...                                                                                                                    &gt;&gt; running command:                                                                                                                [started at: 2022-05-02 15:05:42]                                                                                            [working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14]                                                     [output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-mjc8gj6x.log]                                                           /home/easybuild/.local/easybuild/sources/generic/eb_v4.5.5.dev0/ConfigureMake/config.guess                                   &gt;&gt; command completed: exit 0, ran in &lt; 1s                                                                                          &gt;&gt; running command:                                                                                                                [started at: 2022-05-02 15:05:42]                                                                                            [working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14]                                                     [output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-cv6vncds.log]                                                           ./configure --prefix=/home/example/easybuild/software/BCFtools/1.14-GCC-11.2.0  --build=x86_64-pc-linux-gnu  --host=x86_64-pc-linux-gnu --with-htslib=$EBROOTHTSLIB --enable-libgsl                                                                      &gt;&gt; command completed: exit 0, ran in 00h00m01s                                                                         == ... (took 1 secs)                                                                                                                 == building...                                                                                                                       &gt;&gt; running command:                                                                                                                [started at: 2022-05-02 15:05:43]                                                                                            [working dir: /tmp/example/build/BCFtools/1.14/GCC-11.2.0/bcftools-1.14]                                                     [output logged in /tmp/eb-tus8o1g4/easybuild-run_cmd-wtsxpxf2.log]                                                           make  -j 8                                                                                                                   &gt;&gt; command completed: exit 0, ran in 00h00m03s\n</code></pre> <p>That's a bit more comforting to stare at...</p> <p>During the configure step, the <code>./configure</code> command is run with option to enable support for leveraging <code>HTSlib</code> and <code>GSL</code>.</p> <p>During the build step, the software is actually being compiled by running the <code>make</code> command. EasyBuild automatically uses the available cores on the system (in this case 8).</p> <p>We even get a pointer to a log file that contains the output of the command being run, so we can use <code>tail -f</code> to see in detail how it progresses.</p> <p>Once the <code>make</code> command completes, we get a message that the command completed with a exit code 0 (implying success), and that it took 3 seconds to run. That's good to know.</p> <p>Later during the installation, we now also see this output during the sanity check step:</p> <pre><code>== sanity checking...\n  &gt;&gt; file 'bin/bcftools' found: OK\n  &gt;&gt; file 'bin/plot-vcfstats' found: OK\n  &gt;&gt; file 'bin/vcfutils.pl' found: OK\n  &gt;&gt; (non-empty) directory 'libexec/bcftools' found: OK\n</code></pre> <p>Thanks to enabling trace mode, EasyBuild tells us which files &amp; directories it is checking for in the installation, before declaring it a success. Nice!</p> <p>The extra output you get when trace mode is enabled is concise and hence not overwhelming, while it gives a better insight into what is going on during the installation. It may also help to spot unexpected actions being taken during the installation early on, so you can interrupt the installation before it completes, if deemed necessary.</p>"},{"location":"2022-isc22/installing_software/#using-installed-software","title":"Using installed software","text":"<p>So far, we have already installed 4 different software packages (SAMtools, HTSlib, GSL, and BCFtools); we even installed BCFtools twice!</p> <p>A lot was going on underneath the covers: locating and unpacking the source tarballs, setting up the build environment, configuring the build, compiling, creating and populating the installation directory, performing a quick sanity check on the installation, cleaning things up, and finally generated the environment module file corresponding to the installation.</p> <p>That's great, but how do we now actually use these installations?</p> <p>This is where the generated module files come into play: they form the access portal to the software installations, and we'll use the ubiquitous <code>module</code> command to digest them.</p> <p>First, we need to make sure that the modules tool is aware of where the module files for our installations are located. If you're unsure where EasyBuild is installing stuff at this point, check the output of <code>eb --show-config</code>; the value of the <code>installpath</code> configuration setting is what we are interested in now:</p> <pre><code>$ eb --show-config\n...\ninstallpath    (E) = /home/example/easybuild\n...\nrepositorypath (E) = /home/example/easybuild/ebfiles_repo\n...\nsourcepath     (E) = /home/example/easybuild/sources\n...\n</code></pre> <p>So, what's in this directory?</p> <pre><code>$ ls -l $HOME/easybuild\ntotal 16\ndrwxrwxr-x 5 example example 4096 Jun 10 20:11 ebfiles_repo\ndrwxrwxr-x 5 example example 4096 Jun 10 20:10 modules\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 software\ndrwxrwxr-x 6 example example 4096 Jun 10 20:10 sources\n</code></pre> <p>The <code>ebfiles_repo</code> and <code>sources</code> directories correspond to the <code>repositorypath</code> and <code>sourcepath</code> configuration settings, respectively. The <code>modules</code> and <code>software</code> directories are what we need now.</p> <p>The <code>modules</code> subdirectory consists of multiple subdirectories:</p> <pre><code>$ ls $HOME/easybuild/modules\nall  bio  devel  numlib  tools\n</code></pre> <p>Directories like <code>bio</code> and <code>numlib</code> correspond to different software categories, and contain symbolic links to the module files in the <code>all</code> directory, which contains all actual module files for software installed in this EasyBuild installation path. We'll ignore these separate category directories for now.</p> <p>Let's inform the modules tool about the existence of these module files using <code>\"module use\"</code>:</p> <pre><code>module use $HOME/easybuild/modules/all\n</code></pre> <p>This command does little more that updating the <code>$MODULEPATH</code> environment variable, which contains a list of paths that the modules tool should consider when looking for module files.</p> <p>Now the modules tool should be aware of our brand new installations:</p> <pre><code>$ module avail\n\n---------------------- /home/example/easybuild/modules/all -----------------------\n   BCFtools/1.14-GCC-11.2.0    GSL/2.7-GCC-11.2.0       SAMtools/1.14-GCC-11.2.0\n   EasyBuild/4.5.4             HTSlib/1.14-GCC-11.2.0   bzip2/1.0.8\n\n---------------------------- /easybuild/modules/all -----------------------------\n    ...\n</code></pre> <p>This output shows both the modules for our own installations as well as the \"central\" installations in <code>/easybuild</code> (which we omitted above for brevity).</p> <p>Now we can load these modules and start using these software installations.</p> <p>Let's test this for BCFtools. In our current environment, the <code>bcftools</code> command is not available yet:</p> <pre><code>$ module list\nNo modules loaded\n\n$ bcftools\n-bash: bcftools: command not found\n</code></pre> <p>Loading the module for BCFtools changes that:</p> <pre><code>$ module load BCFtools/1.14-GCC-11.2.0\n\n$ module list\nCurrently Loaded Modules:\n  1) EasyBuild/4.5.4                7) XZ/5.2.5-GCCcore-11.2.0\n  2) GCCcore/11.2.0                 8) OpenSSL/1.1\n  3) zlib/1.2.11-GCCcore-11.2.0     9) cURL/7.78.0-GCCcore-11.2.0\n  4) binutils/2.37-GCCcore-11.2.0  10) HTSlib/1.14-GCC-11.2.0\n  5) GCC/11.2.0                    11) GSL/2.7-GCC-11.2.0\n  6) bzip2/1.0.8-GCCcore-11.2.0    12) BCFtools/1.14-GCC-11.2.0\n\n$ bcftools --version\nbcftools 1.14\nUsing htslib 1.14\n...\n</code></pre> <p>Note that the modules for the required dependencies, including the compiler toolchain (which provides runtime libraries like <code>libstdc++.so</code>), are loaded automatically. The \"<code>module load</code>\" command changes the active environment, by updating environment variables like <code>$PATH</code> for example, to make the software available for use.</p>"},{"location":"2022-isc22/installing_software/#resetting-your-environment","title":"Resetting your environment","text":"<p>To restore your environment to a pristine state in which no modules are loaded, you can either unload the loaded modules one by one using \"<code>module unload</code>\", or you can unload all of them at once using \"<code>module purge</code>\".</p> <p>If you are using an EasyBuild installation provided by a module, don't forget to load the <code>EasyBuild</code> module again after running \"<code>module purge</code>\".</p>"},{"location":"2022-isc22/installing_software/#stacking-software","title":"Stacking software","text":"<p>Maybe you have overlooked how the software we are playing around with was not only installed across multiple different installation directories per software, we are also \"stacking\" our own installations (in <code>$HOME/easybuild</code>) on top of installations that are provided in a totally different location (<code>/easybuild</code>).</p> <p>EasyBuild doesn't care where software is installed: as long as the module file that provides access to it is available, it is happy to pick it up and use it when required.</p> <p>This implies that end users of an HPC system can easily install their own small software stack on top of what is provided centrally by the HPC support team, for example. They can even \"replace\" a central software installation for their purposes if they need to, since the modules tool will load the first module file that matches the request being made (there are some caveats with this, but we won't go into those here).</p>"},{"location":"2022-isc22/installing_software/#exercises","title":"Exercises","text":"<p>Guidelines</p> <p>Do yourself a favor: don't peek at the solution until you have made an attempt to solve the exercise yourself!</p> <p>Please do not spoil solutions for others before they have been discussed by the tutorial organisers.</p> <p>The exercises are based on the easyconfig files included with EasyBuild 4.5.4.</p> <p>Exercise S.1 - Installing software</p> <p>Install version 3.6.0 of the <code>h5py</code> Python package and all missing dependencies, using the <code>foss/2021b</code> toolchain, into <code>/tmp/$USER/easybuild</code>, while leveraging the already installed software available from <code>/easybuild</code>.</p> <p>Enable trace output so you can see which parts of the installation take a while.</p> (click to show solution) <p>First, determine the easyconfig file we can use for this: <pre><code>$ eb -S 'h5py-3.6.0.*foss-2021b'\nCFGS1=/home/easybuilder/easybuild/software/EasyBuild/4.5.4/easybuild/easyconfigs/h/h5py\n* $CFGS1/h5py-3.6.0-foss-2021b.eb\n</code></pre></p> <p>Make sure the pre-installed software in <code>/easybuild/</code> is available: <pre><code>module use /easybuild/modules/all\n</code></pre></p> <p>Check which dependencies are missing to install this <code>h5py</code> easyconfig: <pre><code>$ eb h5py-3.6.0-foss-2021b.eb --missing\n\n2 out of 63 required modules missing:\n\n* pkgconfig/1.5.5-GCCcore-11.2.0-python (pkgconfig-1.5.5-GCCcore-11.2.0-python.eb)\n* h5py/3.6.0-foss-2021b (h5py-3.6.0-foss-2021b.eb)\n</code></pre></p> <p>Install <code>h5py</code> by specifying the easyconfig file and enabling dependency resolution via <code>--robot</code>, while indicating that we want to install the software into <code>/tmp/$USER/easybuild</code> using the <code>--installpath</code> option. Also make sure that trace mode is enabled by defining the <code>$EASYBUILD_TRACE</code> environment variable. <pre><code>$ export EASYBUILD_TRACE=1\n$ eb h5py-3.6.0-foss-2021b.eb --robot --installpath /tmp/$USER/easybuild\n...\n== building and installing pkgconfig/1.5.5-GCCcore-11.2.0-python...\n...\n== building and installing h5py/3.6.0-foss-2021b...\n...\n== installing...\n  &gt;&gt; running command:\n        [started at: 2022-05-02 13:38:37]\n[working dir: /tmp/example/h5py/3.6.0/foss-2021b/h5py-3.6.0]\n[output logged in /tmp/eb-rjjkbqe1/easybuild-run_cmd-d_dkc4iz.log]  HDF5_MPI=ON HDF5_DIR=\"$EBROOTHDF5\" H5PY_SETUP_REQUIRES=0  pip install --prefix=/tmp/achilles/easybuild/software/h5py/3.6.0-foss-2021b  --no-deps --ignore-installed  --no-index  --no-build-isolation  .\n  &gt;&gt; command completed: exit 0, ran in 00h01m43s\n...\n== COMPLETED: Installation ended successfully (took 2 min 0 sec)\n...\n== Build succeeded for 2 out of 2\n</code></pre></p> <p>The trace output shows that most time is spent in the installing command, which runs <code>pip install</code>.</p> <p>Exercise S.2 - Using installed software</p> <p>Using the <code>h5py</code> installation from the previous exercise to create an empty HDF5 file, using the following Python statements:</p> <pre><code>import h5py\nf = h5py.File(\"empty.hdf5\", \"w\")\nf.close()\n</code></pre> <p>Check the resulting file using the <code>h5stat</code> command.</p> (click to show solution) <p>First, we need to make the modules tool aware of the module files that were installed into <code>/tmp/$USER/easybuild</code>: <pre><code>module use /tmp/$USER/easybuild/modules/all\n</code></pre></p> <p>Then we can check the <code>h5py</code> module is available, and load it: <pre><code>$ module avail h5py\n------------ /tmp/example/easybuild/modules/all ------------\nh5py/3.6.0-foss-2021b\n</code></pre></p> <pre><code>module load h5py/3.6.0-foss-2021b\n</code></pre> <p>The Python code snippet can be run directly on the command line using \"<code>python -c '...'</code>\", since it's tiny: <pre><code>python -c 'import h5py; f = h5py.File(\"empty.hdf5\", \"w\"); f.close()'\n</code></pre> Of course you can also copy the Python code snippet in a file named <code>test_h5py.py</code>, and then run it with <code>python test_h5py.py</code>.</p> <p>Checking with the <code>h5stat</code> command shows that the resulting <code>empty.hdf5</code> is indeed a valid HDF5 file: <pre><code>$ ls -l empty.hdf5 \n-rw-rw-r-- 1 example example 800 Mai 2 15:48 empty.hdf5\n\n$ h5stat empty.hdf5\nFilename: empty.hdf5\nFile information\n        # of unique groups: 1\n# of unique datasets: 0\n...\n</code></pre></p> <p>If you've made it through the hands-on exercises, congratulations!</p> <p>If not, don't worry too much about it. We covered a lot of ground here, and it's a lot to take in at once, take your time...</p> <p>Feel free to ask questions in the <code>#tutorial-isc22</code> channel in the EasyBuild Slack, we're happy to help!</p> <p>next: Troubleshooting - (back to overview page)</p>"},{"location":"2022-isc22/integration_eessi/","title":"Integration of EasyBuild in EESSI","text":"<p>The European Environment for Scientific Software Installations (EESSI) is a collaborative project, by and for the computational science community, with the main goal being to provide a shared central stack of (optimized) scientific software installations that can be used on a variety of systems, ranging from personal workstations to HPC system and cloud infrastructure, through supporting different CPUs, accelerators (such as GPUs), network interconnects, and operating systems.</p>"},{"location":"2022-isc22/integration_eessi/#high-level-overview","title":"High-level overview","text":"<p>In order to achieve this ambitious goal, the project consists of three inter-operating and stacked layers that each serve a different purpose:</p> <p></p> <ul> <li> <p>The filesystem layer is responsible for distributing the software installations provided by EESSI   repository from centrally managed servers to client systems. This is done by using CernVM-FS,   a read-only, globally distributed filesystem that is optimized for distributing software.   From the point of view of an end user this results in a transparent experience where software installations are   downloaded to the client system (and cached there) on-demand, as they are being used.</p> </li> <li> <p>The compatibility layer provides operating system libraries that are required by the scientific software   installations. It ensures that the software installations provided by EESSI work on different (versions of) operating   systems, as it alleviates relying on libraries provided by the operating system of the client. We use   Gentoo Prefix to build the compatibility layer,   since it is a Linux distribution that can be built from source in a given path (a 'prefix').</p> </li> <li> <p>The software layer consists of the actual scientific software installations, which are optimised for different   types and generations of microprocessors, and are built on top of the compatibility layer. These installations   were installed with EasyBuild, and corresponding environment modules are included so   Lmod can be used to easily access the software installations.   The archspec Python library is used to auto-detect the CPU microarchitecture   of the client system so that the best suited subset of software installations can be selected, which typically   significantly benefits performance.</p> </li> </ul>"},{"location":"2022-isc22/integration_eessi/#getting-access","title":"Getting access","text":"<p>To get access to EESSI on a client system, it suffices to install CernVM-FS and the EESSI configuration package. For a production-quality setup, especially when using multiple client systems, additional configuration of CernVM-FS should be done to enjoy the benefits of a multi-level caching hierarchy.</p> <p>Once CernVM-FS is installed and configured for EESSI, you can prepare your environment for using the software provided by EESSI, load the modules for the software you need, and start running your workloads:</p> <pre><code>$ source /cvmfs/pilot.eessi-hpc.org/latest/init/bash\n[EESSI pilot 2021.12] $ module load GROMACS\n[EESSI pilot 2021.12] $ gmx mdrun ...\n</code></pre> <p>For more information, see the Getting Started with EESSI talk at the 7th EasyBuild User Meeting (EUM'22).</p>"},{"location":"2022-isc22/integration_eessi/#inspiration","title":"Inspiration","text":"<p>The design of the EESSI project is heavily influenced by the central software stack provided by the Advanced Research Computing (ARC) component of the Digital Research Alliance of Canada, (formerly Compute Canada), where a similar approach is used to build a shared software stack that can be leveraged on the different Canadian HPC systems (and beyond). EESSI is significantly more ambitious however, by aiming to support a broader range of system architectures (incl. Arm, POWER, and eventually also RISC-V CPUs), and by intending to work together with the broader computational science community in building the shared software stack.</p>"},{"location":"2022-isc22/integration_eessi/#use-cases","title":"Use cases","text":"<p>The primary goal of the EESSI project is to provide a software stack of optimized scientific software installations that can be used on a wide variety of platforms, including HPC clusters, cloud, servers, and laptops.</p> <p>The EESSI project also intends to go several steps further, by building a test suite to verify the correctness of the provided software installations and facilitate performance evaluation, and by working together with the developers of the scientific software that is included in EESSI, with the intent to have the software installations vetted.</p>"},{"location":"2022-isc22/integration_eessi/#more-information","title":"More information","text":"<ul> <li>EESSI website: https://www.eessi-hpc.org</li> <li>EESSI @ GitHub: https://github.com/EESSI</li> <li>EESSI documentation: https://eessi.github.io/docs</li> <li>recorded talk at EUM'21: Introduction to EESSI</li> <li>recorded talk at EUM'22: Getting Started with EESSI</li> <li>paper: EESSI: A cross-platform ready-to-use optimised scientific software stack</li> </ul> <p>next: Integration of EasyBuild in LUMI - (back to overview page)</p>"},{"location":"2022-isc22/integration_jsc/","title":"Integration of EasyBuild at J\u00fclich Supercomputing Centre","text":"<p>(author: Alan O'Cais, J\u00fclich Supercomputing Centre;           Sebastian Achilles, J\u00fclich Supercomputing Centre)</p>"},{"location":"2022-isc22/integration_jsc/#general-info","title":"General info","text":"<p>The J\u00fclich Supercomputing Centre (JSC, https://www.fz-juelich.de/ias/jsc) at  Forschungszentrum J\u00fclich has been operating the first German supercomputing centre since 1987, and with the J\u00fclich Institute for Advanced Simulation it is continuing the long tradition of scientific computing at J\u00fclich. JSC operates one of the most powerful supercomputers in Europe (JUWELS), and computing time at the highest performance level is made available to researchers in Germany and Europe by means of an independent peer-review process.</p>"},{"location":"2022-isc22/integration_jsc/#staff-user-base","title":"Staff &amp; user base","text":"<p>About 250 experts and contacts for all aspects of supercomputing and simulation sciences work at JSC. JSC's research and development concentrates on mathematical modelling and numerical simulation, especially parallel algorithms for quantum chemistry, molecular dynamics and Monte-Carlo simulations. The focus in the computer sciences is on cluster computing, performance analysis of parallel programs, visualization, computational steering and federated data services.</p> <p>In cooperation with hardware and software vendors like IBM, ATOS, Intel, NVIDIA and ParTec, JSC meets the challenges that arise from the development of exaflop systems - the computers of the next supercomputer generation. As a member of the German Gauss Centre for Supercomputing, JSC has also coordinated the construction of the European research infrastructure \"PRACE - Partnership for Advanced Computing in Europe\" since 2008.</p>"},{"location":"2022-isc22/integration_jsc/#resources","title":"Resources","text":"<p>JSC currently manages 3 primary systems (in addition to a number of other development clusters):</p> <p>JUWELS is a milestone on the road to a new generation of ultra-flexible modular supercomputers targeting a broader range of tasks. It currently has 10.6 (CPU) + 1.7 (GPU) Petaflop per second peak performance on the cluster module and an NVIDIA GPU booster module providing an additional 73 Petaflops. The booster module makes JUWELS the most powerful supercomputer in Europe.</p> <p>JURECA is the precursor system to JUWELS and currently has 2 modules: the JURECA DC Module with 3.54 (CPU, AMD EPYC) + 14.98 (GPU, NVIDIA A100) Petaflop per second peak performance, and the JURECA Booster Module with 5 (KNL) Petaflop per second peak performance. </p> <p>JUSUF combines an HPC cluster and a cloud platform in a single system with homogeneous hardware such that resources can be flexibly shifted between the partitions. The JUSUF compute nodes are equipped with two AMD EPYC Rome CPUs, each with 64 cores. One third of the compute nodes are furthermore equipped with one NVIDIA V100 GPU. The JUSUF cluster partition will provide HPC resources for interactive workloads and batch jobs. The cloud partition will enable co-location of (web) services with these resources to enable new workflows and support community platforms.</p>"},{"location":"2022-isc22/integration_jsc/#usage-of-easybuild-within-jsc","title":"Usage of EasyBuild within JSC","text":"<p>As a large site with multiple systems and diverse requirements, JSC takes advantage of how easily EasyBuild can be extensively configured according to site policies, ranging from the software installation prefix to all aspects of the module naming scheme being used for the modules being generated.</p> <p>JSC maintains a public repository of the customisations and development environment for EasyBuild that we use in our production environment. Below we highlight some particular cases of these customisations.</p>"},{"location":"2022-isc22/integration_jsc/#custom-toolchains","title":"Custom toolchains","text":"<p>As of June 2022, there are a total of 16 unique toolchain definitions in use at JSC, which reflect multiple combinations of compilers (<code>GCCcore</code>, <code>GCC</code>, <code>Intel</code> and <code>NVHPC</code>), MPI runtimes (<code>ParaStationMPI</code>, <code>OpenMPI</code> and <code>IntelMPI</code>) and mathematical libraries (<code>MKL</code>).</p> <p>Given the proliferation of toolchains required at our site, JSC has put a lot of effort into increasing the capabilities of the <code>--try-toolchain</code> option and introduced the <code>--try-update-deps</code> experimental option to more easily adopt upstream changes and adapt them to our environment. </p>"},{"location":"2022-isc22/integration_jsc/#custom-module-naming-scheme","title":"Custom module naming scheme","text":"<p>By default EasyBuild includes both the flat and hierarchical module naming schemes and these can be leveraged as examples for custom schemes. JSC employs such a custom scheme (based closely on the standard hierarchical scheme) to control the exact structure of the hierarchy and the naming of some specific modules (such as the compilers and MPI runtimes).</p>"},{"location":"2022-isc22/integration_jsc/#custom-easyconfigs","title":"Custom easyconfigs","text":"<p>The upgrade cycle for our software stack does not exactly match that of EasyBuild (see below for context on this). This means that the versions of software and dependencies that we provide may be slightly different than what is in the main repository (due to critical updates, releases of important software, etc.). Arising from this and the custom toolchains that we use, we maintain our own reference easyconfig repository (our Golden repository).</p> <p>We are actively trying to minimise the differences between the two (see our usage of hooks below) as we recognise that this introduces an additional maintenance burden for us, and inhibits our ability to easily contribute back our easyconfigs to EasyBuild.</p>"},{"location":"2022-isc22/integration_jsc/#hiding-dependencies","title":"Hiding dependencies","text":"<p>While we provide an extensive set of software, we try to minimize the packages exposed to the users by hiding a large set of dependencies which users are unlikely to require directly (via the <code>hide-deps</code> configuration setting). There are currently over 200 such hidden dependencies.  </p> <p>While hidden dependencies are not visible in the <code>module</code> view by default, users can expose them by the use of the <code>--show-hidden</code> argument in <code>Lmod</code>: <pre><code>module --show-hidden avail\n</code></pre></p>"},{"location":"2022-isc22/integration_jsc/#usage-of-hooks","title":"Usage of hooks","text":"<p>The relatively new hooks feature of EasyBuild provides JSC with an opportunity to track upstream developments more closely.</p> <p>We have integrated, and continue to develop, a hook that provides a lot of useful functionality:</p> <ul> <li>Facilitates userspace installations alongside system provided installations</li> <li>EasyBuild is configured to allow both shared installations for a group and private     installations (group installations are automatically picked up by Lmod for other     members of the group)</li> <li>Restricts users from installing non-supported compilers (in particular we don't want     people to install their own <code>GCCcore</code> since this would likely lead to an avalanche     of required dependencies) and MPI runtimes (since MPI installations     are heavily customised)</li> <li>Restricts users to only resolve dependencies from our Golden repository (as well     as from     their own installed software) but allows them to search in the upstream repositories<ul> <li>if they try to install something from the upstream repository, the hook advises   them how to do this correctly for our systems</li> </ul> </li> <li>Customises the final module files</li> <li>Customises the names of some modules (such as <code>Intel</code> over <code>iccifort</code> and     <code>IntelMPI</code> over <code>impi</code>)</li> <li>Injects an Lmod family in the modules of our compilers and MPI runtimes</li> <li>Adds Lmod properties for GPU enabled applications and user installed software so     that they can be easily identified in the <code>module</code> view</li> <li>Adds a <code>site_contact</code> for all modules</li> <li>Updates the Lmod cache when an installation is made system-wide</li> </ul> <p>We see potential in the use of hooks as a great way of encouraging, documenting and automating \"correct\" installation processes for our system.</p>"},{"location":"2022-isc22/integration_jsc/#upgrading-and-retiring-software","title":"Upgrading and retiring software","text":"<p>The expected lifetime of a system like JURECA is roughly five years. Within that period one can expect updates to compilers every few months and updates to MPI implementations as the latest standards are integrated. This would mean that the entire software stack will require frequent upgrades. During such upgrades it is natural to expect that one would install the latest version of any particular software package.</p> <p>The project cycles at JSC lasts 12 months with two cycles per year. When new users get access to the machine, we want them to only be exposed to the latest software with the latest compilers. Originally, we had chosen six months as our upgrade period but found this to be cumbersome as the number of supported systems and toolchains grew, our upgrade period is now every 12 months. We chose to retire outdated software versions with the same frequency. We call these software upgrades \"stages\". For each 'stage', we select the toolchains that we will support and rebuild the latest versions of our supported software with these toolchains. We chose a prototype toolchain as a template and, once fully populated, migrate the changes to our other toolchains.</p> <p>We expect members of the support team to contribute to software installations since it is common that application software requires specific knowledge to be installed and tested appropriately. A common workflow is to create a personal installation of a package that can be tweaked, then a group installation for others to try out. Once a software package has been successfully built and tested, it is added to a Golden repository to be used in production.</p> <p>The default stage visible to users is controlled by a symbolic link. Stage upgrades are prepared in a separate environment to this default. Once the upgrade has been implemented, users are given three weeks notice and the symbolic link is updated during a maintenance window. Users are provided with the capability of continuing to use a retired stage if they wish to do so. However, additional software requests are (typically) only accepted for the current default stage.</p> <p>While stage upgrades may introduce some overhead for existing users (they may need to recompile their code and modules may be named differently in particular cases), there are clear benefits to using the latest compilers and software stack. In addition, these upgrades provide us with the opportunity to potentially change our module hierarchy or introduce new features related to Lmod.</p> <p>next: Integration of EasyBuild in EESSI - (back to overview page)</p>"},{"location":"2022-isc22/integration_lumi/","title":"Integration of EasyBuild in LUMI","text":""},{"location":"2022-isc22/integration_lumi/#general-information","title":"General information","text":"<p>LUMI, installed in a CSC data centre (Finland)), is one of the three planned  EuroHPC pre-exascale systems  meant to be installed in 2022-2023,  together with Leonardo (installed at Cineca) and MareNostrum5 (installed at BSC). LUMI, which stands for Large Unified Modern Infrastructure, is hosted by the LUMI consortium, a consortium of 10 countries: Finland, Belgium, Czech Republic, Denmark, Estonia, Iceland,  Norway, Poland, Sweden, and Switzerland. It was supposed to be installed by the end of 2021, but the global shortage of components and some technical problems have delayed the installation. The final hardware should be installed before mid 2022.</p> <p> </p> <p>LUMI is an HPE Cray EX supercomputer with several partitions targeted for different use cases. It is also possible to run heterogeneous jobs across multiple partitions.</p> <ul> <li> <p>The main compute power is provided by the LUMI-G GPU compute partition consisting of 2,560 nodes.     The LUMI-G node is a revolutionary compute node in the x86+GPU-world.      It is also truly a \"GPU first\" system.</p> <p>Each GPU compute node has a single 64 core AMD EPYC 7A53 \"Trento\" CPU and 4 MI250X GPUs.  Each MI250X package contains two GPU compute dies connected to each other via AMD's InfinityFabric interconnect and 8 HBM2e memory stacks, 4 per die. The GPUs and CPU are all connected through AMD's InfinityFabric interconnect, creating a cache coherent unified memory space in each node. The Trento CPU is a Zen3 generation product but with an optimised I/O die that can run the InfinityFabric interconnect at a higher speed than standard Milan CPUs.</p> <p>Each node also has 4 200Gbit/s SlingShot 11 interconnect cards, each connected directly to  a different GPU package. Each node has 512GB HBM2e RAM spread evenly across the GPU dies and  512 GB of regular DDR4 DRAM connected to the CPU. The nodes are diskless nodes. The (very) theoretical peak performance of a GPU node is around 200 Tflops for FP64 vector operations or 400 TFlops for FP64 matrix operations.</p> </li> <li> <p>The main CPU partition, called LUMI-C, consists of 1,536 nodes with two 64-core AMD     EPYC 7,763 CPUs. Most nodes have 256 GB of RAM memory, but there are 128 nodes with     512 GB of RAM and 32 nodes with 1 TB of RAM. In the final system, each node will be equipped     with one 200 Gbit/s SlingShot 11 interconnect card. These nodes are diskless nodes.</p> </li> <li> <p>A section mostly meant for interactive data analysis consists of 8 nodes with two 64-core     AMD EPYC 7742 CPUs and 4 TB of RAM per node. These nodes are connected to the interconnect     through two 100 Gbit/s SlingShot 10 links.</p> </li> <li> <p>The second part of LUMI-D, the data visualisation section, consists of 8 nodes with two     64-core AMD EPYC 7742 CPUs and 8 NVIDIA A40 GPUs each. Each node has 2 TB of RAM and is     connected to the interconnect through two 100 Gbit/s SlingShot 10 links.</p> </li> <li> <p>LUMI-K will be an OpenShift/Kubernetes container cloud platform for running microservices     with roughly 50 nodes.</p> </li> <li> <p>LUMI also has an extensive storage system</p> <ul> <li>There is a 7 PB flash-based storage system with 2 TB/s of bandwidth and high IOPS     capability using the Lustre parallel file system and Cray ClusterStor E1000 technology.</li> <li>The main disk based storage contains of four 20 PB storage systems based on regular hard     disks and also using the Lustre parallel file system.</li> <li>A 30 PB Ceph-based encrypted object storage system for storing, sharing and staging data     will become available at a later date.</li> </ul> </li> </ul>"},{"location":"2022-isc22/integration_lumi/#challenges","title":"Challenges","text":"<ul> <li> <p>LUMI comes with the HPE Cray Programming Environment (PE) with the Cray Compiling Environment     (a fully Clang/LLVM-based C/C++ compiler and a Fortran compiler using a Cray frontend but     LLVM-based backend) and GNU and AMD compilers repackaged by Cray. The HPE Cray PE uses     an MPICH-based MPI implementation (with libfabric backend on SlingShot 11) and also comes      with its own optimised mathematics libraries containing all the usual suspects you expect      from an EasyBuild toolchain. The HPE Cray PE environment is managed outside EasyBuild, but     EasyBuild has a mechanism to integrate with it.</p> <p>Due to the specific hardware and software setup of LUMI using the EasyBuild common toolchains is anything but straightforward. Getting Open MPI, a key component of the foss toolchain, to work  is a bit of a challenge at the moment. The Intel compilers are not a very good match with  AMD CPUs. One needs to be very careful when choosing the target architecture for code optimisation (<code>-xHost</code> will not generate AVX/AVX2 code), most recent versions of MKL have performance problems and sometimes produce wrong results and some recent MPI versions also cause problems with AMD CPUs.</p> </li> <li> <p>LUMI has only a small central support team of 9 FTE. It is obvious that we cannot give the same     level of support for software installations as some of the big sites such as JSC can do. Moreover,     due to the nature of the LUMI environment with its Cray PE and novel AMD GPUs, installing software     is more challenging than on your typical Intel + NVIDIA GPU cluster with NVIDIA/Mellanox     interconnect. Given that the technology is very new, one can also expect a rapid evolution of     the programming environment with a risk of breaking compatibility with earlier versions,     and a need for frequent software updates in the initial years of operation to work around bugs     or make new and important features available. So the maintenance cost of a the user application     stack is certainly higher than on clusters based on more conventional technology. Early experience     has also shown that we need to be prepared for potentially breaking changes on very short notice.</p> <p>It also means that we have to be very agile when it comes to maintaining the software stack and that it is also impossible to thoroughly test all installations, so we must be able to make corrections quickly. This goes against a big central software stack, as in a central software stack it is nearly impossible to replace an installation that fails for some users outside maintenance intervals.</p> </li> <li> <p>The central support team may be small (the above 9 FTE), but the      LUMI consortium agreement states that the      consortium countries also have to assist in providing support. Given that neither the      LUMI User Support Team members nor the local support teams are employees of CSC this      also means that much of the application support has to be delivered with very little     rights on the system (at most a working directory that is readable for all users and writable for     support people). So we      need a setup where it is possible to help users installing applications while having     only regular user rights on the system.</p> </li> <li> <p>Due to the exploitation model and the small size of the central support team, license management     is a pain. Users come to LUMI through 11 different channels (some with subchannels). Moreover it     is the responsibility of the PI to invite users to a project and to ensure that they are eligible     for LUMI use (taking into account, e.g., the European and USA export restrictions). At the central     level we have no means to check who can use which software license. Hence we need a     solution to distribute that responsibility also.</p> </li> <li> <p>LUMI software support is based on the idea that users really want a customised software stack. They may say they want      a central stack but only as long as it contains the software they need and not much more as they      also do not want to search through long lists of modules. Nobody is waiting for 20 different     configurations of a package, but the reality is that different users will want different versions     with sometimes conflicting configurations, or compiled with different compilers. </p> <p>We also note that some communities forego centrally installed software which may have better optimised binaries to build their own custom setup using tools such as Conda. </p> <p>And even though modules go a long way in managing dependencies and helping to avoid conflicts, we expect that with the explosion of software used on HPC machines and the poor maintenance of that software, it will become increasingly difficult to find versions of dependencies that work for  a range of programs, leading to cases where we may simply need to install a software package with different sets of dependencies simply because users want to use it together with other  packages that have restrictions on the versions of those dependencies. Experienced Python users without doubt know what a mess this can create and how even a single user sometimes needs different virtual environments with different installations to do their work.</p> </li> </ul>"},{"location":"2022-isc22/integration_lumi/#solution-with-easybuild-and-lmod","title":"Solution with EasyBuild and Lmod","text":"<p>On LUMI we selected EasyBuild as our primary software installation tool, but also offer some limited support for Spack. EasyBuild was selected as there is already a lot of experience with EasyBuild in several of the LUMI consortium countries, and as it is a good fit with the goals of the EuroHPC JU as they want to establish a European HPC ecosystem with a European technology option at every level. The developers of EasyBuild are also very accessible and it helps that the lead developer and several of the maintainers are from LUMI consortium countries.</p> <p>We use Lmod as the module tool.  We basically had the choice between Lmod and the old C implementation of TCL Environment Modules as HPE Cray does not support the more modern  Environment Modules 4 or 5 developed in France. Support for Lmod is excellent in EasyBuild and Spack, and Lua is also a more modern language to work with than TCL.</p>"},{"location":"2022-isc22/integration_lumi/#software-stacks","title":"Software stacks","text":"<p>On LUMI we offer users the choice between multiple software stacks, offered through hand-written Lmod modules.</p> <ul> <li> <p>The CrayEnv stack is really just a small layer on top of the HPE Cray PE in which we provide     a few additional tools and help the user with managing the environment for the HPE Cray PE.</p> <p>The HPE Cray PE works with a universal compiler wrapper that sets some optimisation options for the supported compilers and sets the flags to compile and link with the MPI, optimised scientific libraries and some other libraries provided with the PE. It does so based on which modules are loaded. The CPU and GPU targets and the MPI fabric library are selected through so-called target modules, typically loaded during shell initialisation, while compiler, MPI and scientific libraries are typically loaded through the so-called <code>PrgEnv-*</code>  modules (one for each supported compiler). The CrayEnv software stack module will take care of ensuring that a proper set of target modules is loaded depending on the node type on which the module is loaded, and  also ensure that the proper set of target modules is reloaded after a <code>module purge</code>. </p> <p>The environment is also enriched with a number of build tools that are not installed in the OS image or only in an older version. These tools are often build with EasyBuild with the <code>SYSTEM</code> toolchain though we do not make EasyBuild itself available to users in that stack.</p> </li> <li> <p>The LUMI stack is a software stack which is mostly managed with EasyBuild. The stack is versioned     based on the version of the HPE Cray PE which makes it easy to retire a whole stack when the compilers     are retired from the system. If we need the same software in two different stacks, it is simply compiled     twice, even if it is only installed with the system compilers, to make retiring software easier without     having to track dependencies (we now simply have to remove a few directories to remove a whole     software stack which will not have an impact on the other stacks). The     exception are a few packages installed from binaries that are installed in a separate area and available across all     software stacks (e.g., ARM Forge and Vampir). The LUMI stack provides optimised binaries for each node     type of LUMI, but some software that is not performance-critical is compiled only once. To this end we      have a partition corresponding to each node type, but also a common partition which is included with      the software of all other partitions. Software in that common partition can only have dependencies      in the common partition though.</p> <p>For now we keep the central LUMI software stack very small, but we provide an easy and fully transparent mechanism for the user to install software in their project directory that integrates fully with the LUMI stack. The user only needs to set an environment variable pointing to the project space.</p> </li> </ul> <p>In the future we envision that more software stacks may become available on LUMI as at least one local support organisation wants to build their own stack. We also hope to find a solution to get the foss toolchain working on at least the CPU nodes of LUMI with minimal changes in a future collaboration with HPE.</p>"},{"location":"2022-isc22/integration_lumi/#easybuild-for-software-management","title":"EasyBuild for software management","text":"<p>The second component to our solution is EasyBuild. EasyBuild can give a very precise description of all the steps needed to build a package while the user needs to give very few arguments to the <code>eb</code> command to actually do the installation. It is also robust enough that with a proper module to configure EasyBuild, an installation done by one user on LUMI will reproduce easily in the environment of another user.  The fact that each easyconfig file contains a very precise list of dependencies, including versions and not only the names of the dependencies, is both a curse and a blessing. It is a curse when we need to upgrade to a new compiler and also want to upgrade versions of certain dependencies, as a lot of easyconfig files need to be checked and edited. In those cases the automatic concretiser of Spack may help to get running quicker.</p> <p>However, that very precise description is also a blessing when communicating with users as you can communicate with them through EasyBuild recipes (and possibly an easystack file, which defines a list of  easyconfig files to install) rather than having a part of the specification in command line options of the tool. So a user doesn't need to copy long command lines and as a support person you know exactly what EasyBuild will do, so this leaves less room for errors and difficult to solve support tickets. (Though note that with Spack environments you can also give a full specification in an Environment manifest.)</p>"},{"location":"2022-isc22/integration_lumi/#offering-easybuild-in-the-lumi-stacks","title":"Offering EasyBuild in the LUMI stacks","text":"<p>The LUMI software stack is implemented as an Lmod hierarchy with two levels. On top of it EasyBuild is used with a flat naming scheme (though we did consider a hierarchical one as well).</p> <p>The modules that load a specific version of the software stack are hand-written in Lua. The first level (a module called <code>LUMI</code>) is the version of the software stack,  the second level (a module called <code>partition</code>) then choses the particular set of hardware to optimise for. The <code>LUMI</code> module will autoload the most suited <code>partition</code> module for the hardware, but users can overwrite this choice, e.g., for cross-compiling which is a common practice on HPE Cray systems but not without difficulties and hence not always possible.</p> <p>The <code>LUMI</code> and <code>partition</code> module combo also check a default location for the user software stack, and an environment variable that is used to point to a different location for the user software stack.  If a user software stack is found, its modules are automatically added to the stack. There are also some <code>partition</code> modules that do not correspond to particular hardware but are only used during software installation, to install software in \"special\" locations. E.g., the module <code>partition/common</code> is used to install some software for all partitions without binaries optimised specifically for each partition.  On LUMI, a selection of build and version control tools is currently installed that way.</p> <p>The <code>LUMI</code> and <code>partition</code> modules are both implemented in a generic way. Instances in the module tree are symbolic links to the generic implementations, and so-called Lmod introspection functions are used by the modules to determine their function from the location in the module tree. This makes it easy to correct bugs and extend the module files without having to go over different implementations in different locations.</p> <p>To enable all this functionality, including the common partition, a double module structure was needed to ensure the proper working of the Lmod hierarchy. The infrastructure tree is implemented following all proper rules for an Lmod hierarchy. It houses the <code>LUMI</code> and <code>partition</code> modules among others, but also the toolchain modules so that they can be configured specifically for each version of the <code>LUMI</code>  software stack and <code>partition</code>. The software module tree contains all software installed through  EasyBuild, with room to expand to manually installed software or software installed with Spack should this turn out to be necessary and safe to combine with EasyBuild-managed software.</p> <p>EasyBuild is configured through some configuration modules that set a range of <code>EASYBUILD_*</code> variables to configure EasyBuild. There is again only a single EasyBuild configuration module implemented in Lua, but it appears with three different names in multiple locations in the infrastructure module tree,  and again Lmod introspection functions are used by the module to determine its specific function.  There are three configurations for EasyBuild: One for installation in the infrastructure module tree, one for installation in the main software tree and one for installation in the user software tree. By using just a single implementation for all three functions, we ensure that the different configurations remains consistent. This is important, e.g., to guarantee that the user configuration builds correctly upon the centrally installed stack, so any change to the structure of the latter should also propagate to the configuration of the former.</p>"},{"location":"2022-isc22/integration_lumi/#easybuild-on-lumi","title":"EasyBuild on LUMI","text":""},{"location":"2022-isc22/integration_lumi/#custom-toolchains","title":"Custom toolchains","text":"<p>The LUMI EasyBuild solution is not based on the common toolchains as the HPE Cray Programming Environment is the primary development environment on LUMI for which we also obtain support from HPE and as the common toolchains both post problems on LUMI. So far we have not yet succeeded to ensure proper operation of  Open MPI on LUMI which is a showstopper for working with the FOSS toolchain hierarchy. There is also no support yet for AMD GPUs in the common toolchains. Moreover, the FOSS toolchain is becoming a very powerful vehicle by the inclusion of FlexiBLAS and now also efforts to build an Open MPI configuration that supports both CPU nodes and NVIDIA GPU nodes but the downside of this is that it has also become a very complicated  setup to adapt if you need something else, as we do on LUMI. The Intel toolchain also has its problems.  Intel does not support oneAPI on AMD processors. Though Intel MPI can in principle run on SlingShot as it is also based on libfabric and will be used on Aurora, a USA exascale system build by Intel with HPE Cray as a subcontractor for the hardware, users of AMD systems have reported problems with recent versions. MKL does not only have performance problems, but several sources also report correctness problem, especially in computational chemistry DFT codes.</p> <p>Instead we employ toolchains specific for the three (soon four) versions of the HPE Cray Programming Environment: HPE Cray's own Cray Compiler Environment compilers with a C/C++ compiler based on Clang/LLVM with some vendor-specific plugins and a Fortran compiler that compiles HPE Cray's frontend with a backend based on LLVM, the GNU Compiler Collection with its C/C++ and Fortran compiler, the AMD Optimizing C/C++ and Fortran Compilers (AOCC) and soon also a version employing the AMD ROCm compilers for the  AMD GPU compute nodes. The toolchains used on LUMI are a further evolution of the toolchains used at CSCS with many bug corrections in the AOCC-based toolchain and better support for toolchain options specified through <code>toolchainopts</code>. They should however be largely compatible with the EasyConfigs in the CSCS repository.</p> <p>The toolchains are loaded through modules, generated with EasyBuild and a custom EasyBlock, that replace the top <code>PrgEnv</code> modules from the HPE Cray Programming Environment. These modules then use the modules provided by HPE Cray to load the actual compilers, compiler wrappers, MPI libraries and scientific libraries, and the target modules that determine how the main modules work. So contrary to many other EasyBuild toolchains, the compilers, MPI and scientific libraries are not installed through EasyBuild.</p>"},{"location":"2022-isc22/integration_lumi/#external-modules","title":"External modules","text":"<p>EasyBuild supports the use of modules that were not installed via EasyBuild.  We refer to such modules as external modules. External modules do not define the <code>EBROOT*</code> and <code>EBVERSION*</code> environment variables that are present in EasyBuild-generated modules and that EasyBuild uses internally in some easyblocks and easyconfigs,  and they also have no corresponding easyconfig file that can tell EasyBuild about further dependencies.</p> <p>External modules are used extensively on Cray systems to interface with the Cray PE (which comes with its own modules and cannot be installed via EasyBuild): external modules can be used as dependencies,  by including the module name in the dependencies list,  along with the <code>EXTERNAL_MODULE</code> constant marker.</p> <p>As an example, the Cray PE contains its own FFTW module, called <code>cray-fftw</code>. To use this module as a dependency, you should write the following in your easyconfig file: <pre><code>dependencies = [('cray-fftw', EXTERNAL_MODULE)]\n</code></pre> (for the default version).</p> <p>For such dependencies, EasyBuild will:</p> <ul> <li> <p>load the module before initiating the software build and install procedure</p> </li> <li> <p>include a <code>module load</code> statement in the generated module file (for runtime dependencies)</p> </li> <li> <p>but it will not go looking for a matching easyconfig file.</p> </li> </ul> <p>Note</p> <p>The default version of the external module will be loaded unless a specific version is given as dependency, and here that version needs to be given as part of the name of the module and not as the second element in the tuple.</p> <pre><code>dependencies = [('cray-fftw/3.3.8.12', EXTERNAL_MODULE)]\n</code></pre> <p>If the specified module is not available, EasyBuild will exit with an error message stating that the dependency  can not be resolved because the module could not be found, without searching for a matching easyconfig file from which it could generate the module.</p> <p>The metadata for external modules can be supplied through one or more metadata files, pointed to by the <code>--external-modules-metadata</code>  configuration option (or corresponding environment variable). These files are expected to be in INI format, with a section per module name  and key-value assignments specific to that module.</p> <p>The following keys are  supported by EasyBuild:</p> <ul> <li>name: software name(s) provided by the module</li> <li>version: software version(s) provided by the module</li> <li>prefix: installation prefix of the software provided by the module</li> </ul> <p>For instance, the external module version loaded by the dependency <code>cray-fftw</code> can be specified as follows: <pre><code>[cray-fftw]\nname = FFTW\nprefix = FFTW_DIR/..\nversion = 3.3.8.10\n</code></pre></p> <p>This will then ensure that EasyBuild knows the equivalent EasyBuild name(s), version(s) and root of the  software installation for use in easyblocks. It will also create the corresponding <code>$EBROOT*</code> and <code>$EBVERSION*</code> environment variables in the build environment after loading the external module so that the module resembles more a regular EasyBuild-generated module and so that these environment variables can be used, e.g., in options to <code>configure</code> or <code>cmake</code>. </p> <p>EasyBuild also includes a default metadata file that will be used, but that one can be very much out-of-date. And if no information for a  particular module is present in the metadata files, EasyBuild will even try to extract the information out of certain environment variables that are used by several Cray PE modules.</p> <p>On LUMI, users in generally don't need to be too concerned about the metadata file as the <code>EasyBuild-user</code> and other  EasyBuild configuration modules take care of pointing to the right metadata file, which is specific for each version of the Cray PE and hence each version of the LUMI software stack.</p>"},{"location":"2022-isc22/integration_lumi/#software-specific-easyblocks","title":"Software-specific easyblocks","text":"<p>EasyBuild comes with a lot of software-specific easyblocks. These have only been tested with the common toolchains in the automated EasyBuild test procedures. As a result, many of those easyblocks will fail with the Cray toolchains (and with many other custom toolchains). A common problem is that they don't recongnise the compilers as they test  for the presence of certain modules and hence simply stop with an error message that the compiler is not  recognised, but there may also be more subtle problems, like explicitly checking for the name of a dependency rather than for the presence of the corresponding <code>EBROOT</code> and <code>EBVERSION</code> environment variables through the EasyBuild API. Hence it may fail to recognise external modules that have a different name than the name that EasyBuild uses for the package.</p> <p>For this reason we (and CSCS) tend to use the generic easyblocks more often, specifying configuration and build options by hand in the corresponding easyconfig parameters rather than relying on the logic in an easyblock to set the parameter for us based on the dependencies that are present. In some cases, the easyblocks are adapted, but this poses a maintenance problem. Contributing the modified easyblock back to the EasyBuild community is no guarantee that it remains compatible as the Cray-specific code cannot currently be tested in the automated test procedures due to lack of access to the Cray PE and lack of suitable easyconfig files to do the tests. However, keeping the code in our own repositories is no full solution either as the easyblock may need maintenance when a new version of EasyBuild with an updated easyblock appears.</p>"},{"location":"2022-isc22/integration_lumi/#other-lumi-specific-easybuild-settings","title":"Other LUMI-specific EasyBuild settings","text":"<p>On LUMI, we do use a slightly customised version of the flat naming scheme but that is mostly because we are not interested in the categorisation of modules in module classes as this categorisation is too arbitrary. There are simply too many  modules that could be put in multiple classes, something which is currently not supported. We decided to remove that level altogether from the module directory tree.</p>"},{"location":"2022-isc22/integration_lumi/#further-reading-and-information","title":"Further reading and information","text":"<ul> <li>LUMI web site</li> <li>LUMI user documentation web site</li> <li>So far most LUMI trainings were done by HPE Cray and their training materials cannot be distributed     freely, but there is some additional training material from the LUMI User Support Team.</li> <li>This EasyBuild training web site also contains:<ul> <li>A training given to the LUMI User Support Team in the spring and summer of '21</li> <li>A training for CSC and Local Organisations from May 2022</li> </ul> </li> <li>LUMI GitHub repositories:<ul> <li>LUMI-SoftwareStack     is the repository that contains all our Lmod modules, custom easyblocks and the easyconfigs of software that has      already made it into the central stack. Its structure is inspired on that of the      CSCS repository.     The repository also contains ample technical information on our implementation which can     also be browsed through the lumi-supercomputer GitHub pages.</li> <li>LUMI-EasyBuild-contrib is our main repository     of easyconfig files for installation in the user space. Many of these may require more testing or support for     more configurations. Most subdirectories with easyconfig files also contain a <code>README.md</code> file that explains     the choices we made when implementing the easyconfig file.</li> </ul> </li> <li>Other sites with Cray hardware that also use EasyBuild<ul> <li>CSCS GitHub repository</li> </ul> </li> </ul> <p>next: The EasyBuild community - (back to overview page)</p>"},{"location":"2022-isc22/introduction/","title":"Introduction to EasyBuild","text":""},{"location":"2022-isc22/introduction/#what-is-easybuild","title":"What is EasyBuild?","text":"<p>EasyBuild is a software build and installation framework that manages (scientific) software in an efficient way, without compromising on performance. EasyBuild is especially tailored towards High Performance Computing (HPC) systems, and provides a command-line interface to facilitate the installation and management of a scientific software stack.</p>"},{"location":"2022-isc22/introduction/#history","title":"History","text":"<p>EasyBuild as a project was conceived in 2008 by the HPC team at Ghent University (Belgium). The first public release of EasyBuild was made available early 2012. EasyBuild v1.0.0 was released in November 2012, during the Supercomputing 2012 conference.</p> <p>Following the public release and the project's introduction into the HPC community, other sites started to use EasyBuild and actively contribute to the project. Over the years EasyBuild has grown into a community project, which is used and developed by hundreds of HPC centres and consortia worldwide.</p> <p> </p>"},{"location":"2022-isc22/introduction/#easybuild-in-a-nutshell","title":"EasyBuild in a nutshell","text":"<p>EasyBuild intends to relieve HPC support teams from manually managing software installations while at the same time providing a consistent and well performing scientific software stack to end users of HPC systems.</p> <p>It serves as a uniform interface for installing scientific software and saves valuable time (and frustration) by the automation of tedious, boring and repetitive tasks.</p> <p>In addition, EasyBuild can empower scientific researchers to self-manage their software stack, and it can serve as a tool that can be leveraged for building optimized container images.</p> <p>The project has grown to become a platform for collaboration among HPC sites worldwide, and has become an \"expert system\" for installing scientific software on HPC systems.</p>"},{"location":"2022-isc22/introduction/#key-features","title":"Key features","text":"<p>EasyBuild is capable of fully autonomously installing (scientific) software, including making sure that all necessary dependencies are installed, and automatically generating environment module files.</p> <p>No admin privileges are required: it is sufficient to have write permissions to the preferred software installation prefix.</p> <p>EasyBuild is highly configurable via configuration files, environment variables, and command line options. The functionality can be dynamically extended via plugins, and hooks are available for further site-specific customizations.</p> <p>The installation procedure executed by EasyBuild is thoroughly logged, and is fully transparent via support for dry runs and tracing the software installation procedure as it is performed.</p> <p>EasyBuild supports using a custom module naming scheme, allows for hierarchical module naming schemes, and integrates with various other tools ranging from  resource managers (Slurm and GC3Pie), container tools (Singularity and Docker), packaging tools (FPM), and so on.</p>"},{"location":"2022-isc22/introduction/#focus-points","title":"Focus points","text":"<p>EasyBuild was created specifically for installing scientific software on HPC systems, which is reflected in some of the design choices that were made.</p>"},{"location":"2022-isc22/introduction/#performance","title":"Performance","text":"<p>EasyBuild strongly prefers to build software from source code, whenever possible.</p> <p>This is important to ensure that the binaries that are installed can maximally exploit the capabilities of the system architecture on which the software will be run.</p> <p>For that same reason, EasyBuild optimizes software for the processor architecture of the build host by default, via compiler options like <code>-march=native</code> (GCC), <code>-xHost</code> (Intel compilers), etc. This behaviour can be changed via the <code>--optarch</code> configuration setting.</p>"},{"location":"2022-isc22/introduction/#reproducibility","title":"Reproducibility","text":"<p>In addition to performance, reproducibility of installations is a core aspect of EasyBuild.</p> <p>Most software installations performed with EasyBuild use a particular compiler toolchain, with which we aim to be in control over the build environment and avoid relying on tools and libraries provided by the operating system. For similar reasons, we try to provide all required dependencies through EasyBuild as well, with a few notable exceptions, like <code>OpenSSL</code> for security reasons, and Infiniband and GPU drivers which are too closely intertwined with the operating system.</p> <p>For both toolchains and dependencies, fixed software versions are specified in the easyconfig files. That way, easyconfig files can easily be shared with others: if they worked for you it is very likely that they will work for others too, because the vast majority of the software stack is controlled by EasyBuild.</p>"},{"location":"2022-isc22/introduction/#community-effort","title":"Community effort","text":"<p>In a number of different ways, we try to encourage EasyBuild users to collaborate and help each other out.</p> <p>We actively recommend people to report problems and bugs, to submit ideas for additional features and improvements, and to contribute back when possible, by opening pull requests to the GitHub repositories or the documentation.</p> <p>Through the <code>foss</code> and <code>intel</code> common toolchains, we try to focus the efforts of the EasyBuild community a bit to specific toolchains, which increases the usefulness of the easyconfig files we collect in the central repository.</p> <p>Last but not least, EasyBuild provides various GitHub integration features that greatly facilitate the contribution process: opening, updating, and testing pull requests, reviewing incoming contributions, and much more can all be done directly from the EasyBuild command line. This not only saves time, effort, brain cycles, and mouse clicks for contributors, but it also makes the review process for maintainers significantly easier. All together this leads to improved stability and consistency.</p>"},{"location":"2022-isc22/introduction/#what-easybuild-is-not","title":"What EasyBuild is not","text":"<p>EasyBuild is not YABT (Yet Another Build Tool): it does not replace established build tools like CMake or <code>make</code>, it wraps around them. If the installation procedure of a software package involves running some unholy trinity of tools while whispering the correct magic incantations, EasyBuild automates this process for you.</p> <p>It is not a replacement for traditional Linux package managers like <code>yum</code>, <code>dnf</code> or <code>apt</code>. EasyBuild relies on certain tools and libraries provided by the operating system. This includes glibc, OpenSSL, drivers for Infiniband and GPUs, and so on. It is required that these tools are installed and managed by other means. This is typically done via the package management tool that comes with your Linux distribution.</p> <p>Finally, EasyBuild is not a magic solution to all your (software installation) problems. You may, and probably still will occasionally, run into compiler errors unless somebody has already taken care of the problem for you.</p> <p>next: Terminology - (back to overview page)</p>"},{"location":"2022-isc22/module_naming_schemes/","title":"Module naming schemes","text":"<p>Up until now we have used EasyBuild's default module naming scheme (<code>EasyBuildMNS</code>), which produces module files with names that closely resemble to the names of the corresponding easyconfig files. For example, when installing <code>h5py-3.6.0-foss-2021b.eb</code> the generated module was named <code>h5py/3.6.0-foss-2021b</code>.</p> <p>EasyBuild supports several different module naming schemes:</p> <pre><code>$ eb --avail-module-naming-schemes\nList of supported module naming schemes:\n        EasyBuildMNS\n        MigrateFromEBToHMNS\n        HierarchicalMNS\n        CategorizedHMNS\n        CategorizedModuleNamingScheme\n</code></pre> <p>In this part of the tutorial we will take a closer look at <code>HierarchicalMNS</code>, which is the standard hierarchical module naming scheme included with EasyBuild.</p> <p>We will also take a quick look at implementing our own custom module naming scheme.</p>"},{"location":"2022-isc22/module_naming_schemes/#flat-vs-hierarchical","title":"Flat vs hierarchical","text":"<p>The default module naming scheme <code>EasyBuildMNS</code> is an example of regular \"flat\" module naming scheme, which is characterized by:</p> <ul> <li>all module files are directly available for loading;</li> <li>each module name uniquely identifies a particular installation;</li> </ul> <p>In contrast, a hierarchical module naming scheme consists of a hierarchy of module files.</p> <p>The typical module hierarchy has 3 levels:</p> <ul> <li>a core level, where module files for software that was installed using the   <code>system</code> toolchain are kept;</li> <li>a compiler level, where module files for software that was installed using a compiler-only toolchain are stored;</li> <li>and an MPI level, which houses module files for software that was installed using a toolchain that includes (at least) a compiler and MPI component;</li> </ul> <p>Here is a simple example of such a 3-level module hierarchy:</p> <p>In this example the core level only includes a single module <code>GCC/11.2.0</code>, while  the compiler level includes two modules: <code>OpenMPI/4.1.1</code> and <code>MPICH/3.4.2</code>. In the MPI level, three modules are available: one for <code>FFTW</code>, one for <code>ScaLAPACK</code>, and one for <code>HDF5</code>.</p> <p>Initially only the modules on the top level of a module hierarchy are available for loading. If you run \"<code>module avail</code>\" with the example module hierarchy, you will only see the <code>GCC/11.2.0</code> module.</p> <p>Some modules in the top level of the hierarchy act as a \"gateway\" to modules in the next level below. To make additional modules available for loading one of these gateway modules has to be loaded. In our example, loading the <code>GCC/11.2.0</code> module results in two additional modules coming into view from the compiler level, as indicated by the arrows: the modules for <code>OpenMPI</code> and <code>MPICH</code>. These correspond to installations of <code>OpenMPI</code> and <code>MPICH</code> that were built using <code>GCC/11.2.0</code> as a (compiler-only) toolchain.</p> <p>Similarly, the <code>OpenMPI/4.1.1</code> module serves as a gateway to the three modules in the MPI level. Only by loading the <code>OpenMPI</code> module will these additional three modules become available for loading. They correspond to software installations built using the <code>gompi/2021b</code> toolchain that consists of the <code>GCC/11.2.0</code> compiler module and the <code>OpenMPI/4.1.1</code> MPI module. Software installed using <code>foss/2021b</code> (which is a full toolchain that also includes OpenBLAS, FFTW and ScaLAPACK) would also be stored in this level of the module hierarchy.</p> <p>The characteristics of a module hierarchy are:</p> <ul> <li>not all module files are directly available for loading;</li> <li>some modules serve as a gateway to more modules;</li> <li>to access some software installations you will first need to load one or more gateway modules in order   to use them;</li> </ul> <p>You can probably think of other ways to organize module files in a hierarchical module tree, but here we will stick to the standard <code>Core</code>-<code>Compiler</code>-<code>MPI</code> hierarchy.</p>"},{"location":"2022-isc22/module_naming_schemes/#pros-cons","title":"Pros &amp; cons","text":"<p>So why go through all this trouble of organizing modules hierarchically?</p> <p>There are a couple of advantages to this approach:</p> <ul> <li>shorter module names;</li> <li>less overwhelming list of available modules;</li> <li>only compatible modules can be loaded together;</li> </ul> <p>However, the are some minor disadvantages too:</p> <ul> <li>not all existing modules are directly visible;</li> <li>gateway modules may have little meaning to end users;</li> </ul>"},{"location":"2022-isc22/module_naming_schemes/#length-of-module-names","title":"Length of module names","text":"<p>When using a flat module naming scheme, module names can be fairly long and perhaps confusing. For our <code>HDF5</code> installation for example, we have <code>HDF5/1.12.1-gompi-2021b</code> as module name. The <code>-gompi-2021b</code> part of the name refers to the toolchain that was used for this installation, but it may be confusing to some people (what kind of Pok\u00e9mon is a \"gompi\"?!).</p> <p>In the example module hierarchy shown above, the module for <code>HDF5</code> is named <code>HDF5/1.12.1</code> which is basically the bare essentials: software name and version. That's way better, nice and clean!</p>"},{"location":"2022-isc22/module_naming_schemes/#amount-of-available-modules","title":"Amount of available modules","text":"<p>The output of \"<code>module avail</code>\" can be quite overwhelming if lots of module files are installed and a flat module naming scheme is used, since all modules are always available. EasyBuild makes it very easy to install lots of software, so the number of installed modules can easily grow into the hundreds or even thousands...</p> <p>This often explosive growth of modules is less of an issue when using a hierarchical module naming scheme, since initially only a small set of modules are available, and relatively limited groups of additional modules become available as gateway modules are loaded.</p>"},{"location":"2022-isc22/module_naming_schemes/#loading-compatible-modules","title":"Loading compatible modules","text":"<p>Since all modules are available at once when using a flat module naming scheme, you can easily load modules together that are not compatible with each other.</p> <p>Imagine loading two modules that were built with a different compiler toolchain (different compiler, different MPI library). That's likely to end in tears, unless you have the necessary technical expertise to fully understand what is going on, and you are being very careful...</p> <p>In a module hierarchy this can be prevented, since modules for software that were installed with a different compiler and/or a different MPI library are located in a different part of the module hierarchy, and so these modules can not be loaded together easily.</p>"},{"location":"2022-isc22/module_naming_schemes/#visibility-of-existing-modules","title":"Visibility of existing modules","text":"<p>One downside of a module hierarchy is that not all existing modules are directly available for loading or are even visible to the user, since the output of \"<code>module avail</code>\" only shows a subset of all modules.</p> <p>Lmod has a solution for this though: it provides a separate \"<code>module spider</code>\" command to search for module files throughout the entire module hierarchy. So as long as the end users are aware of this additional command, it should not be difficult to discover which software installations exist and how they can be accessed. The \"<code>module spider</code>\" command will inform the user which of the gateway modules need to be loaded in order to load a specific module file.</p>"},{"location":"2022-isc22/module_naming_schemes/#semantics-of-gateway-modules","title":"Semantics of gateway modules","text":"<p>An additional potential problem of a module hierarchy is that the semantics of the gateway modules may not be clear to end users. They may wonder why they need to pick a specific compiler and MPI library, or which of the available options is the best one. Maybe there are not even be aware what exactly a \"compiler\" is, or how it is relevant to the software they need in their bioinformatics pipeline...</p> <p>This can be partially resolved by loading a default compiler and MPI module so a particular set of modules is available right after login, which could be the ones used in the most recent toolchain, or the recommended versions. More experienced users could then leverage the \"<code>module spider</code>\" command to navigate the module hierarchy.</p>"},{"location":"2022-isc22/module_naming_schemes/#using-a-custom-module-naming-scheme","title":"Using a custom module naming scheme","text":"<p>Next to the module naming schemes that are included with EasyBuild, you can also define your own module naming scheme (MNS), and configure EasyBuild to use it.</p>"},{"location":"2022-isc22/module_naming_schemes/#implementation","title":"Implementation","text":"<p>To use a custom module naming scheme, you need to implement a Python module file, where you define a Python class that derives from the general <code>ModuleNamingScheme</code> class.</p> <p>For a flat module naming scheme, it is sufficient to implement the <code>det_full_module_name</code> method, which should return a string value (the full module name). You may also need to customize the <code>is_short_modname_for</code> method, which verifies whether a given (short) module name is for the software with a particular given name (or not).</p> <p>The argument provided to <code>det_full_module_name</code> can be a small Python dictionary which only specifies the value of a handful of easyconfig parameters (<code>name</code>, <code>version</code>, <code>toolchain</code>, and <code>versionsuffix</code>), or an <code>EasyConfig</code> instance which represents a parsed easyconfig file and contains values for all known easyconfig parameters.</p> <p>For simple module naming schemes, just have <code>name</code>, <code>version</code>, <code>toolchain</code>, and <code>versionsuffix</code> available is sufficient. If it is not, you can list which additional easyconfig parameters are required for your module naming scheme via a class constant <code>REQUIRED_KEYS</code>.</p> <p>A fairly straightforward example of a flat module name scheme is the default EasyBuild module naming scheme <code>EasyBuildMNS</code>.</p> <p>For a hierarchical module naming scheme, various additional methods have to be implemented.</p> <p>Some of these, like <code>det_module_subdir</code> and <code>det_short_module_name</code>, determine which part of the (full) module name determines the location of the module in the module hierarchy, and which part is the user-facing (or \"short\") module name. Others, like <code>det_modpath_extensions</code>, determine which modules are gateway modules that open up an additional level of the hierarchy (by extending the <code>$MODULEPATH</code>).</p> <p>A typical example of a hierarchical module naming scheme is <code>HierarchicalMNS</code> that comes with EasyBuild (which is quite complex because it includes quite a bit of special handling for particular compiler toolchains), which implements the traditional <code>Core</code>-<code>Compiler</code>-<code>MPI</code> module hierarchy we discussed above.</p>"},{"location":"2022-isc22/module_naming_schemes/#configuring-easybuild","title":"Configuring EasyBuild","text":"<p>To let EasyBuild use a custom module naming scheme, you need to:</p> <ul> <li> <p>specify the path to the Python module file implementing it via the <code>include-module-naming-schemes</code>   EasyBuild configuration option;</p> </li> <li> <p>indicate that you also want to use this custom module naming scheme via the <code>module-naming-scheme</code>   EasyBuild configuration option.</p> </li> </ul> <p>For example:</p> <pre><code>export EASYBUILD_INCLUDE_MODULE_NAMING_SCHEMES=$HOME/easybuild/example_mns.py\nexport EASYBUILD_MODULE_NAMING_SCHEME=ExampleMNS\n</code></pre>"},{"location":"2022-isc22/module_naming_schemes/#example-custom-module-naming-scheme","title":"Example custom module naming scheme","text":"<p>Here is an example of a custom module naming scheme, where:</p> <ul> <li>the <code>versionsuffix</code> goes directly after the <code>version</code>;</li> <li>all dashes are replaced by underscores;</li> <li>all module names are lowercase;</li> </ul> <p>Note that we also need to customise the <code>is_short_modname_for</code> method, to make sure it returns <code>True</code> when the EasyBuild framework checks whether <code>scipy_bundle/2021.10_foss_2021b</code> is a module name for <code>SciPy-bundle</code>.</p> <pre><code>import os\n\nfrom easybuild.tools.module_naming_scheme.mns import ModuleNamingScheme\n\n\nclass ExampleMNS(ModuleNamingScheme):\n\n    REQUIRED_KEYS = ['name', 'version', 'versionsuffix', 'toolchain']\n\n    def det_full_module_name(self, ec):\n\"\"\"\n        Determine full module name:\n        - all lowercase\n        - replace all dashes with underscores\n        \"\"\"\n        parts = [ec['version']]\n\n        # versionsuffix directly after version (but only if it's not empty)\n        if ec['versionsuffix']:\n            parts.append(ec['versionsuffix'])\n\n        # only add toolchain name/version for non-system toolchain\n        tc = ec['toolchain']\n        if tc['name'].lower() != 'system':\n            parts.extend([tc['name'], tc['version']])\n\n        modname = ec['name'] + '/' + '_'.join(parts)\n\n        modname = modname.replace('-', '_').replace('__', '_')\n\n        return modname.lower()\n\n    def is_short_modname_for(self, short_modname, name):\n\"\"\"Determine whether short module name is a module for the software with specified name.\"\"\"\n        return short_modname.startswith(name.lower().replace('-', '_') + '/')\n</code></pre> <p>We can see what the module names with this module naming scheme would like like via <code>eb -D</code>:</p> <pre><code>$ eb SciPy-bundle-2021.10-foss-2021b-Python-2.7.18.eb -D\n ...\n * [ ] $CFGS/g/GCC/GCC-11.2.0.eb (module: gcc/11.2.0)\n ...\n * [ ] $CFGS/p/Python/Python-2.7.18-GCCcore-11.2.0.eb (module: python/2.7.18_gcccore_11.2.0)\n ...\n * [ ] $CFGS/o/OpenMPI/OpenMPI-4.1.1-GCC-11.2.0.eb (module: openmpi/4.1.1_gcc_11.2.0)\n ...\n * [ ] $CFGS/s/SciPy-bundle/SciPy-bundle-2021.10-foss-2021b-Python-2.7.18.eb (module: scipy_bundle/2021.10_python_2.7.18_foss_2021b)\n</code></pre>"},{"location":"2022-isc22/module_naming_schemes/#example-module-hierarchy-hdf5","title":"Example module hierarchy: HDF5","text":"<p>Now that we know more about hierarchical module naming schemes, let us see how EasyBuild can help us with generating a hierarchical module tree.</p> <p>In this example we will use EasyBuild to generate modules organised in a hierarchy for some of the software that is already installed in the prepared environment.</p> <p>The good news is that the existing installations can be reused. There is absolutely no need to reinstall the software, we are just creating a different \"view\" on these software installations.</p>"},{"location":"2022-isc22/module_naming_schemes/#preparing-the-environment","title":"Preparing the environment","text":"<p>Before running EasyBuild to generate a hierarchical module tree, we have to be a bit careful with preparing our environment.</p> <p>We must absolutely avoid mixing modules from a flat and hierarchical module naming scheme!</p> <p>Some module files will have the same name in both module trees (like <code>GCC/11.2.0</code> for example), but their contents will be different. Mixing modules from a flat and hierarchical module tree will trigger problems...</p> <p>So we have to make sure that the module files we already have in <code>/easybuild</code> are not visible. The easiest way to do this is to unload all modules (using \"<code>module purge</code>\") and resetting the module search path to be empty, which we can do with \"<code>module unuse $MODULEPATH</code>\".</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> <p>In this part of the tutorial, we are assuming you are not using an EasyBuild installation provided through a module. We have just made all modules unavailable, so we would have to first install EasyBuild again in our hierarchical module tree before we can continue.</p> <p>We strongly recommend using an EasyBuild installation that was installed via \"<code>pip install</code>\" or \"<code>pip3 install</code>\" in this part of the tutorial.</p> <p>An easy way to do this is in the prepared environment is to run:</p> <pre><code>unset PIP_PREFIX\npip3 install --user easybuild\nexport PATH=$HOME/.local/bin:$PATH\nexport EB_PYTHON=python3\n</code></pre>"},{"location":"2022-isc22/module_naming_schemes/#configuring-easybuild_1","title":"Configuring EasyBuild","text":"<p>First of all, we need to make sure that EasyBuild is properly configured. We can do this by defining this set of environment variables:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER/easybuild\nexport EASYBUILD_INSTALLPATH_SOFTWARE=/easybuild/software\nexport EASYBUILD_MODULE_NAMING_SCHEME=HierarchicalMNS\nexport EASYBUILD_INSTALLPATH_MODULES=$HOME/hmns/modules\nexport EASYBUILD_LOCKS_DIR=$HOME/easybuild/locks\n</code></pre> <p>To make sure we didn't make any silly mistakes, we double check using <code>eb --show-config</code>:</p> <pre><code>$ eb --show-config\n#\n# Current EasyBuild configuration\n# (C: command line argument, D: default value, E: environment variable, F: configuration file)\n#\nbuildpath            (E) = /tmp/example/easybuild\ncontainerpath        (E) = /home/example/easybuild/containers\ninstallpath          (E) = /home/example/easybuild\ninstallpath-modules  (E) = /home/example/hmns/modules\ninstallpath-software (E) = /easybuild/software\nlocks-dir            (E) = /home/example/easybuild/locks\nmodule-naming-scheme (E) = HierarchicalMNS\npackagepath          (E) = /home/example/easybuild/packages\nprefix               (E) = /home/example/easybuild\nrepositorypath       (E) = /home/example/easybuild/ebfiles_repo\nrobot-paths          (D) = /home/example/.local/easybuild/easyconfigs\nsourcepath           (E) = /home/example/easybuild/sources\n</code></pre> <p>There are a couple of things worth pointing out here:</p> <ul> <li>We have defined the <code>module-naming-scheme</code> configuration setting to <code>HierarchicalMNS</code>,   which makes EasyBuild use the included standard hierarchical module naming scheme (the classic   core / compiler / MPI one we discussed above).</li> <li>We have specified different locations for the software (via <code>installpath-software</code>)   and the module files (via <code>installpath-modules</code>). This is important because we want to   reuse the software that is already installed in <code>/easybuild/software</code> while we want to   generate an entirely new module tree for it (in <code>$HOME/hmns/modules</code>).</li> </ul> <p>The other configuration settings are the same as before, and mostly irrelevant for this example.</p>"},{"location":"2022-isc22/module_naming_schemes/#generating-modules-for-hdf5","title":"Generating modules for HDF5","text":"<p>Let's now generate a hierarchical module tree for <code>HDF5</code> and all of its dependencies, including the toolchain. That sounds complicated, and it sort of is since there are a lot of details you have to get right for the module hierarchy to works as intended, but EasyBuild can do all the hard work for us.</p> <p>The steps we will have to go through are:</p> <ul> <li>Tell EasyBuild we want to \"install\" the <code>HDF5-1.12.1-gompi-2021b.eb</code> easyconfig file;</li> <li>Enable dependency resolution via <code>--robot</code>;</li> <li>Instruct EasyBuild to only generate the module files, not to install the software (since it is   there already in <code>/easybuild/software</code>), via the <code>--module-only</code> option.</li> </ul> <p>These steps translate to this single <code>eb</code> command:</p> <pre><code>$ eb HDF5-1.12.1-gompi-2021b.eb --robot --module-only\n...\n== building and installing MPI/GCC/11.2.0/OpenMPI/4.1.1/HDF5/1.12.1...\n...\n== sanity checking...\n== cleaning up [skipped]\n== creating module...\n...\n== COMPLETED: Installation ended successfully (took 17 sec)\n...\n== Build succeeded for 42 out of 42\n</code></pre> <p>This should take a couple of minutes in total, for generating 42 modules. Remember that this also includes generating module files for the toolchain and all of its components.</p> <p>In addition, there is a bit more going on one that just generating module files, since the sanity check step is still being run for each of the installations when using <code>--module-only</code> to ensure the installation is actually functional. After all, there is no point in generating a module for an obviously broken installation...</p>"},{"location":"2022-isc22/module_naming_schemes/#loading-the-hdf5-module","title":"Loading the HDF5 module","text":"<p>After generating the hierarchical module tree for HDF5, how do we access the HDF5 installation through it?</p> <p>Here's what the module tree looks like on disk:</p> <pre><code>$ ls $HOME/hmns/modules/all\nCompiler  Core  MPI\n</code></pre> <p>Those are basically the 3 levels in the module hierarchy we showed in our example earlier.</p> <p>The starting point is the top level of the module hierarchy named <code>Core</code>:</p> <pre><code>module use $HOME/hmns/modules/all/Core\n</code></pre> <p>Let's see what that gives us in terms of available modules:</p> <pre><code>$ module avail\n\n------------------------ /home/easybuild/hmns/modules/all/Core -------------------------\n   binutils/2.37    GCC/11.2.0        gompi/2021b    OpenSSL/1.1\n   Bison/3.8.2      GCCcore/11.2.0    M4/1.4.19      pkg-config/0.29.2\n   flex/2.6.4       gettext/0.21      ncurses/6.2    zlib/1.2.11\n</code></pre> <p>Nice and short module names, but only a limited set of them.</p> <p>We know a module file exists for <code>HDF5</code>, but we can't see it yet (and hence we can't load it either).</p> <pre><code>$ module avail HDF5\nNo module(s) or extension(s) found!\nUse \"module spider\" to find all possible modules and extensions.\n</code></pre> <p>Let's see if <code>module spider</code> is of any help, as \"<code>module avail</code>\" so kindly suggests:</p> <pre><code>$ module spider HDF5\n...\n\n    You will need to load all module(s) on any one of the lines below\n    before the \"HDF5/1.12.1\" module is available to load.\n\n      GCC/11.2.0  OpenMPI/4.1.1\n</code></pre> <p>This tells us we need to load two gateway modules before we can load the module for HDF5.</p> <p>Let's start with loading the <code>GCC</code> compiler module:</p> <pre><code>module load GCC/11.2.0\n</code></pre> <p>And then check again which modules are available:</p> <pre><code>$ module avail\n\n--------------------------- /home/easybuild/hmns/modules/all/Compiler/GCC/11.2.0 ---------------------------\n   OpenMPI/4.1.1\n\n------------------------- /home/easybuild/hmns/modules/all/Compiler/GCCcore/11.2.0 -------------------------\n   Autoconf/2.71               flex/2.6.4        (D)    libreadline/8.1        pkg-config/0.29.2  (D)\n   Automake/1.16.4             groff/1.22.4             libtool/2.4.6          PMIx/4.1.0\n   Autotools/20210726          help2man/1.48.3          libxml2/2.9.10         Szip/2.1.1\n   binutils/2.37      (L,D)    hwloc/2.5.0              M4/1.4.19       (D)    UCX/1.11.2\n   Bison/3.7.6                 libevent/2.1.12          ncurses/6.2     (D)    xorg-macros/1.19.3\n   DB/18.1.40                  libfabric/1.13.2         numactl/2.0.14         XZ/5.2.5\n   expat/2.4.1                 libpciaccess/0.16        Perl/5.34.0            zlib/1.2.11        (L,D)\n\n---------------------------------- /home/easybuild/hmns/modules/all/Core -----------------------------------\n   binutils/2.37        GCC/11.2.0     (L)    gompi/2021b    OpenSSL/1.1\n   Bison/3.8.2   (D)    GCCcore/11.2.0 (L)    M4/1.4.19      pkg-config/0.29.2\n   flex/2.6.4           gettext/0.21          ncurses/6.2    zlib/1.2.11\n</code></pre> <p>Good news, we now have additional modules available!</p> <p>The compiler level of our hierarchy actually consists of two directories here: <code>Compiler/GCCcore/11.2.0</code> and <code>Compiler/GCC/11.2.0</code>. The modules in the <code>GCCcore</code> directory are ones we can use in other compiler toolchains that use GCC 11.2.0 as a base compiler (the details of that are out of scope here).</p> <p>The module we are interested in is <code>OpenMPI/4.1.1</code>, which is another gateway module.</p> <p>Remember that the \"<code>module spider</code>\" output told us that there does indeed exist a module for <code>HDF5</code>, but that we need to load both the <code>GCC/11.2.0</code> and <code>OpenMPI/4.1.1</code> modules first.</p> <p>So, let us do exactly that (remember that <code>GCC/11.2.0</code> is already loaded):</p> <pre><code>module load OpenMPI/4.1.1\n</code></pre> <p>If you now check the output of \"<code>module avail</code>\" again, you should see the <code>HDF5/1.12.1</code> module:</p> <pre><code>$ module avail\n\n-------- /home/easybuild/hmns/modules/all/MPI/GCC/11.2.0/OpenMPI/4.1.1 -------\n   HDF5/1.12.1\n\n------------ /home/easybuild/hmns/modules/all/Compiler/GCC/11.2.0 ------------\n   OpenMPI/4.1.1 (L)\n\n...\n</code></pre> <p>To use HDF5, we need to load this <code>HDF5/1.12.1</code> module. We can verify that the installation works using one of the commands provided by HDF5, <code>h5dump</code> for example:</p> <pre><code>module load HDF5/1.12.1\n</code></pre> <pre><code>$ h5dump --version\nh5dump: Version 1.12.1\n</code></pre> <p>If you now check which modules are loaded via \"<code>module list</code>\", you will notice that all module names and nice and short now, which is one of the advantages of using a hierarchical module tree:</p> <pre><code>$ module list\n\nCurrently Loaded Modules:\n  1) GCCcore/11.2.0   5) numactl/2.0.14      9) hwloc/2.5.0      13) libfabric/1.13.2  17) HDF5/1.12.1\n  2) zlib/1.2.11      6) XZ/5.2.5           10) OpenSSL/1.1      14) PMIx/4.1.0\n  3) binutils/2.37    7) libxml2/2.9.10     11) libevent/2.1.12  15) OpenMPI/4.1.1\n  4) GCC/11.2.0       8) libpciaccess/0.16  12) UCX/1.11.2       16) Szip/2.1.1\n</code></pre>"},{"location":"2022-isc22/module_naming_schemes/#exercise","title":"Exercise","text":"<p>Now it is your turn!</p> <p>Try to get a feeling for how a hierarchical module tree works by:</p> <ul> <li>installing the missing modules for the <code>SciPy-bundle-2021.10-foss-2021b.eb</code> in the module hierarchy we   generated for HDF5;</li> <li>figure out where the <code>SciPy-bundle</code> module is located in the hierarchy, and then also load it;</li> </ul> <p>You can verify your work by running this command (since <code>pandas</code> is one of the Python packages included in the <code>SciPy-bundle</code> installation):</p> <pre><code>python -c 'import pandas; print(pandas.__version__)'\n</code></pre> <p>Start from a clean slate, by first running:</p> <pre><code>module purge\nmodule unuse $MODULEPATH\n</code></pre> (click to show solution) <ul> <li> <p>Step 0: check which modules are still missing, using <code>--missing</code> or <code>-M</code>:   <pre><code>eb SciPy-bundle-2021.10-foss-2021b.eb -M\n</code></pre>   The output should tell you that 24 out of 64 required modules are still missing.</p> </li> <li> <p>Install the missing modules in the module hierarchy we have generated in <code>$HOME/hmns/modules</code>:   <pre><code>eb SciPy-bundle-2021.10-foss-2021b.eb --robot --module-only\n</code></pre>   Don't forget to use both <code>--robot</code> (to enable dependency resolution) and <code>--module-only</code>   (to only run the sanity check and generate module files, not install the software again).</p> </li> <li> <p>Start at the top of the module hierarchy (the <code>Core</code> level),   and run module spider to check which gateway modules to load to make <code>SciPy-bundle</code> available:   <pre><code>module use $HOME/hmns/modules/all/Core\nmodule spider SciPy-bundle/2021.10\n</code></pre></p> </li> <li>Load the gateway modules:   <pre><code>module load GCC/11.2.0 OpenMPI/4.1.1\n</code></pre></li> <li>Check that the <code>SciPy-bundle</code> module is available, and load it:   <pre><code>$ module avail SciPy-bundle\n----- /home/example/hmns/modules/all/MPI/GCC/11.2.0/OpenMPI/4.1.1 ------\n   SciPy-bundle/2021.10\n</code></pre> <pre><code>module load SciPy-bundle/2021.10\n</code></pre></li> <li>Run the test command:   <pre><code>$ python -c 'import pandas; print(pandas.__version__)'\n1.3.4\n</code></pre></li> </ul> <p>next: EasyBuild at J\u00fclich Supercomputing Centre - (back to overview page)</p>"},{"location":"2022-isc22/practical_info/","title":"Practical info for the ISC'22 EasyBuild tutorial","text":"<p>This page explains how you can prepare for the EasyBuild tutorial that takes place at ISC'22 (registration required!).</p>"},{"location":"2022-isc22/practical_info/#prepared-environment","title":"Prepared environment","text":"<p>Tutorial attendees will be able to log in to a prepared environment where they can follow along with hands-on examples, or solve the tutorial exercises.</p> <p>You can create an account for the prepared environment by filling out the account form. The accounts will not be approved until the day before the event, so please remember to keep a record of your username and password.</p> <p>Once the account is approved, you will be able to access the system at https://isc22.learnhpc.eu/, or via <code>ssh</code>:</p> <pre><code>ssh isc22.learnhpc.eu\n</code></pre>"},{"location":"2022-isc22/practical_info/#slack","title":"Slack","text":"<p>We strongly recommend joining the #tutorial-isc22 channel in the EasyBuild Slack.</p> <p>In this channel, you can:</p> <ul> <li>raise questions both during the live tutorial session, and afterwards;</li> <li>get help with following the hands-on examples or solving the exercises;</li> </ul> <p>The <code>#tutorial-isc22</code> channel will remain available after the live tutorial session.</p> <p>You can self-request an invitation to join the EasyBuild Slack via https://easybuild.io/join-slack.</p> Reproducing the tutorial environment at home (after the workshop): (click to show steps) <p>Warning</p> <p>These steps might need to be tweaked for your system. Please reach out to us on Slack if you run into problems.</p> <p>The prepared environment remains available during the conference. If after the conference you want to go through the tutorial and try the exercises on your home system, you can follow this procedure while working your way through the tutorial:</p> <ul> <li> <p>EasyBuild has a set of requirements     and dependencies     that it expects to find on your system (such as <code>make</code>, <code>patch</code>,... as well as a system C++ compiler to be     able to build GCC), you will need to ensure that these are available. </p> </li> <li> <p>Install EasyBuild. We recommend to use the      \"Installing EasyBuild with EasyBuild\" method,     but choosing a different directory for the <code>--prefix</code> argument. That directory should     then be used wherever <code>/easybuild</code> is used in the tutorial text.</p> <p>Assume that the installation directory is stored in <code>$_PREFIX_</code>. The series of commands to install EasyBuild and make the EasyBuild module available are <pre><code>module unuse $MODULEPATH\nexport EB_TMPDIR=/tmp/$USER/eb_tmp\npython3 -m pip install --ignore-installed --prefix $EB_TMPDIR easybuild\nexport PATH=$EB_TMPDIR/bin:$PATH\nexport PYTHONPATH=$(/bin/ls -rtd -1 $EB_TMPDIR/lib*/python*/site-packages | tail -1):$PYTHONPATH\nexport EB_PYTHON=python3\neb --install-latest-eb-release --prefix $_PREFIX_\nmodule use $_PREFIX_/modules/all\n</code></pre> The first line (the <code>module unuse</code> command) cleans the environment and assures that modules already installed on the system will not screw up the installation that you intend to do.</p> <p>Alternatively, when newer versions of EasyBuild are available than the version 4.5.4 used to prepare this tutorial, the line with <code>eb --install-latest-eb-release</code> can be replaced with <pre><code>eb EasyBuild-4.5.4.eb --prefix $_PREFIX_\n</code></pre> to install the version of EasyBuild used for the preparation of this tutorial.</p> </li> <li> <p>Install the software needed for the tutorial in the same directory structure as EasyBuild.     This can be done in a single command (after loading the EasyBuild module). The workings of this command is explained in the     \"Configuring EasyBuild\" and \"Basic usage of EasyBuild\"     sections:     <pre><code>module load EasyBuild\neb CMake-3.22.1-GCCcore-11.2.0.eb SciPy-bundle-2021.10-foss-2021b.eb --prefix $_PREFIX_ --robot\n</code></pre></p> </li> </ul> <p>Note that the installation can take a few hours and that some steps require a lot of CPU time (e.g., the testing done when installing SciPy), so you may not be able to do it on the login nodes of a cluster.</p> <p>next: Introduction - (back to overview page)</p>"},{"location":"2022-isc22/terminology/","title":"EasyBuild terminology","text":"<p>Over the years, we have come up with some terminology specific to EasyBuild to refer to particular components, which we use alongside established terminology relevant to the context of building and installing software on HPC systems.</p> <p>It is important to be familiar with these terms, so we will briefly cover them one by one.</p>"},{"location":"2022-isc22/terminology/#framework","title":"Framework","text":"<p>The EasyBuild framework consists of a set of Python modules organised in packages (<code>easybuild.framework</code>, <code>easybuild.toolchains</code>, <code>easybuild.tools</code>, etc.) that collectively form the core of EasyBuild, and is developed in the <code>easybuild-framework</code> repository on GitHub.</p> <p>It implements the common functionality that you need when building software from source, and provides functions for unpacking source files, applying patch files, collecting the output produced by shell commands that are being run and checking their exit code, generating environment module files, etc.</p> <p>The EasyBuild framework does not implement any specific installation procedure, it only provides the necessary functionality to facilitate this.</p>"},{"location":"2022-isc22/terminology/#easyblocks","title":"Easyblocks","text":"<p>An easyblock is a Python module that implements a specific software installation procedure, and can be viewed as a plugin to the EasyBuild framework. Easyblocks can be either generic or software-specific.</p> <p>A generic easyblock implements an installation procedure that can be used for multiple different software packages. Commonly used examples include the <code>ConfigureMake</code> easyblock which implements the ubiquitous <code>configure</code>-<code>make</code>-<code>make install</code> procedure, and the <code>PythonPackage</code> easyblock that can be used to install a Python package.</p> <p>A software-specific easyblock implements an installation procedure that is specific to a particular software package. Infamous examples include the easyblocks we have for <code>GCC</code>, <code>OpenFOAM</code>, <code>TensorFlow</code>, <code>WRF</code>, ...</p> <p>The installation procedure performed by an easyblock can be controlled by defining easyconfig parameters in an easyconfig file.</p> <p>A collection of (generic and software-specific) easyblocks is developed by the EasyBuild community in the <code>easybuild-easyblocks</code> repository on GitHub.</p>"},{"location":"2022-isc22/terminology/#easyconfig-parameters","title":"Easyconfig parameters","text":"<p>An easyconfig parameter specifies a particular aspect of a software installation that should be performed by EasyBuild.</p> <p>Some easyconfig parameters are mandatory. The following parameters must be defined in every easyconfig file:</p> <ul> <li><code>name</code> and <code>version</code>, which specify the name and version of the software to install;</li> <li><code>homepage</code> and <code>description</code>, which provide key metadata for the software;</li> <li><code>toolchain</code>, which specifies the compiler toolchain to use to install the software (see   <code>toolchains</code> section);</li> </ul> <p>Other easyconfig parameters are optional: they can be used to provide required information, or to control specific aspects of the installation procedure performed by the easyblock.</p> <p>Some commonly used optional easyconfig parameters include:</p> <ul> <li><code>easyblock</code>, which specifies the (generic) easyblock that EasyBuild should use for the installation;</li> <li><code>sources</code> and <code>source_urls</code>, which specify the list of source files and where to download them;</li> <li><code>dependencies</code> and <code>builddependencies</code>, which specify the list of (build) dependencies;</li> <li><code>configopts</code>, <code>buildopts</code>, and <code>installopts</code>, which specify options for the configuration/build/install commands, respectively;</li> </ul> <p>If no value is specified for an optional easyconfig parameter, the corresponding default value will be used.</p> <p>There are two groups of easyconfig parameters. General easyconfig parameters can be defined for any software package, and (usually) control a specific aspect of the installation. Custom easyconfig parameters are only supported by certain easyblocks, and only make sense for particular (types of) software.</p>"},{"location":"2022-isc22/terminology/#easyconfig-files","title":"Easyconfig files","text":"<p>Easyconfig files (or easyconfigs for short), are simple text files written in Python syntax that specify what EasyBuild should install. Each easyconfig file defines the set of easyconfig parameters that collectively form a complete specification for a particular software installation.</p> <p>The filename of an easyconfig file usually ends with the <code>.eb</code> extension. In some contexts the filename is expected to be determined by the value of a handful of key easyconfig parameters: <code>name</code>, <code>version</code>, <code>toolchain</code> and <code>versionsuffix</code>. The general format for the filename of an easyconfig file is: <code>&lt;name&gt;-&lt;version&gt;&lt;toolchain&gt;&lt;versionsuffix&gt;.eb</code>, where the toolchain part is omitted when the <code>system</code> toolchain is used, and the <code>&lt;versionsuffix&gt;</code> can be empty.</p> <p>The filename of easyconfig files is particularly relevant when EasyBuild is searching for easyconfig files to resolve dependencies, since it does this purely based on filenames: interpreting the contents of every (potential) easyconfig file it encounters would be too expensive.</p> <p>In the <code>easybuild-easyconfigs</code> repository on GitHub, the EasyBuild community maintains a large (and growing) collection of easyconfig files, for a wide range of (scientific) software.</p>"},{"location":"2022-isc22/terminology/#easystack-files","title":"Easystack files","text":"<p>Easystack files are a relatively new concept in EasyBuild, providing a way to define a software stack that should be installed by EasyBuild.</p> <p>They are written in YAML syntax, and include a list of software specifications which correspond to a list of easyconfig files, with support for providing specific EasyBuild configuration options for particular software packages, and including or excluding specific software packages based on labels.</p> <p>The support for using easystack files is currently marked as experimental, which means it is subject to change in future EasyBuild releases, and may be prone to errors.</p>"},{"location":"2022-isc22/terminology/#extensions","title":"Extensions","text":"<p>Extensions is the collective term we use for additional software packages that can be installed on top of another software package. Common examples are Python packages, R libraries, and Perl modules.</p> <p>As you can tell the common terminology here is a bit messy, so we came up with extensions as a unifying term.</p> <p>Extensions can be installed in different ways:</p> <ul> <li>stand-alone, as a separate installation on top of one or more other installations;</li> <li>as a part of a bundle of extensions that collectively form a separate installation;</li> <li>or as an actual extension to a specific installation to yield a \"batteries included\"   type of installation (for examples by adding a bunch of Python packages from PyPI into   an installation of Python);</li> </ul>"},{"location":"2022-isc22/terminology/#dependencies","title":"Dependencies","text":"<p>A dependency is a common term in the context of software. It refers to a software package that is either strictly required by other software, or that can be leveraged to enhance other software (for example to support specific features).</p> <p>There are three main types of software dependencies:</p> <ul> <li>a build dependency is only required when building/installing a software package;   once the software package is installed, it is no longer needed to use that software   (examples: <code>CMake</code>, <code>pkg-config</code>);</li> <li>a run-time dependency (often referred to simply as dependency) is a software package that is   required to use (or run) another software package (example: <code>Python</code>);</li> <li>a link-time dependency is somewhere in between a build and runtime dependency:   it is only needed when linking a software package; it can become either a build or runtime   dependency, depending on exactly how the software is installed (example: <code>OpenBLAS</code>);</li> </ul> <p>The distinction between link-time and run-time dependencies is mostly irrelevant for this tutorial, but we will discriminate build-only dependencies.</p>"},{"location":"2022-isc22/terminology/#toolchains","title":"Toolchains","text":"<p>A compiler toolchain (or just toolchain for short) is a set of compilers, which are used to build software from source, together with a set of additional libraries that provide further core functionality.</p> <p>We refer to the different parts of a toolchain as toolchain components.</p> <p>The compiler component typically consists of C, C++, and Fortran compilers in the context of HPC, but additional compilers (for example, a CUDA compiler for GPGPU software) can also be included.</p> <p>Additional toolchain components are usually special-purpose libraries:</p> <ul> <li>an MPI library to support distributed computations (for example, Open MPI);</li> <li>libraries providing efficient linear algebra routines (BLAS,   LAPACK);</li> <li>a library supporting computing Fast Fourier Transformations (for example, FFTW);</li> </ul> <p>A toolchain that includes all of these libraries is referred to as a full toolchain, while a subtoolchain is a toolchain that is missing one or more of these libraries. A compiler-only toolchain only consists of compilers (no additional libraries).</p>"},{"location":"2022-isc22/terminology/#system-toolchain","title":"System toolchain","text":"<p>The <code>system</code> toolchain is a special case which corresponds to using the compilers and libraries provided by the operating system, rather than using toolchain components that were installed using EasyBuild.</p> <p>It is used sparingly, mostly to install software where no actual compilation is done or to build a set of toolchain compilers and its dependencies, since the versions of the system compilers and libraries are beyond the control of EasyBuild, which could affect the reproducibility of the installation.</p>"},{"location":"2022-isc22/terminology/#common-toolchains","title":"Common toolchains","text":"<p>The <code>foss</code> and <code>intel</code> toolchains are also known as the common toolchains, because they are widely adopted by the EasyBuild community.</p> <p>The <code>foss</code> toolchain consists of all open source components (hence the name: \"FOSS\" stands for Free &amp; Open Source Software): GCC, Open MPI, FlexiBLAS with OpenBLAS as default backend, ScaLAPACK and FFTW.</p> <p>The <code>intel</code> toolchain consists of the Intel C, C++ and Fortran compilers (on top of a <code>GCC</code> version controlled through EasyBuild) alongside the Intel MPI and Intel MKL libraries.</p> <p>Roughly every 6 months, a new version of these common toolchains is agreed upon in the EasyBuild community, after extensive testing.</p> <p>More information on these toolchains is available in the EasyBuild documentation.</p>"},{"location":"2022-isc22/terminology/#modules","title":"Modules","text":"<p>Module is a massively overloaded term in (scientific) software and IT in general (kernel modules, Python modules, and so on). In the context of EasyBuild, the term 'module' usually refers to an environment module (file).</p> <p>Environment modules is a well established concept on HPC systems: it is a way to specify changes that should be made to one or more environment variables in a shell-agnostic way. A module file is usually written in either Tcl or Lua syntax, and specifies which environment variables should be updated, and how (append, prepend, (re)define, undefine, etc.) upon loading the environment module. Unloading an environment module will restore the shell environment to its previous state, by reverting the changes that were made to the environment when it was loaded.</p> <p>Environment module files are processed via a modules tool, of which there are several conceptually similar yet slightly different implementations. The Tcl-based Environment Modules implementation, and Lmod, a more recent Lua-based implementation (which also supports module files written in Tcl syntax), are the most commonly used ones.</p> <p>Environment module files are automatically generated for each software installation by EasyBuild, and loading a module results in changes being made to the environment of the current shell session such that the corresponding software installation can be used.</p>"},{"location":"2022-isc22/terminology/#bringing-it-all-together","title":"Bringing it all together","text":"<p>The EasyBuild framework leverages easyblocks to automatically build and install (scientific) software, potentially including additional extensions, using a particular compiler toolchain, as specified in easyconfig files which each define a set of easyconfig parameters.</p> <p>EasyBuild ensures that the specified (build) dependencies are in place, and automatically generates a set of (environment) modules that facilitate access to the installed software.</p> <p>An easystack file can be used to specify a collection of software to install with EasyBuild.</p> <p>next: Installing EasyBuild - (back to overview page)</p>"},{"location":"2022-isc22/troubleshooting/","title":"Troubleshooting","text":"<p>When installing scientific software you are bound to run into problems that make the installation fail sooner or later, even when using EasyBuild...</p> <p>In this part we take a look at how you can troubleshoot a failing installation, and focus on a couple of EasyBuild aspects that can be helpful in that context, like the error messages produced by EasyBuild, the detailed log file that is available for the installation and the build directory where most software is being compiled before it actually gets installed.</p> <p>At the end of this part an exercise is available in which you get to fix a failing installation, so pay attention!</p>"},{"location":"2022-isc22/troubleshooting/#easybuild-error-messages","title":"EasyBuild error messages","text":"<p>When EasyBuild detects that something went wrong, it will usually produce a short (and hopefully helpful) error message.</p> <p>Things that could go wrong during an installation include:</p> <ul> <li>missing source or patch files;</li> <li>a checksum error on a downloaded source or patch file;</li> <li>required dependencies that are not specified in the easyconfig file;</li> <li>failing shell commands;</li> <li>running out of available memory or disk space;</li> <li>a segmentation fault caused by a flipped bit triggered by a cosmic ray (really, it happens!);</li> </ul> <p>Unfortunately this is not an exhaustive list, there are plenty of other potential problems that could result in a failing installation...</p> <p>For each of the shell commands that EasyBuild executes during an installation, it will check the exit status. If the exit status is zero, EasyBuild will usually assume that the shell command ran correctly, and it will continue with the rest of the installation procedure.</p> <p>If the exit status of the shell command is anything but zero, EasyBuild will assume that a problem has occurred, and the installation will be interrupted.</p>"},{"location":"2022-isc22/troubleshooting/#example","title":"Example","text":"<p>Here is an example of an EasyBuild error message (slightly reformatted for clarity):</p> <pre><code>$ eb example.eb\n...\n== building...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-11.2.0):\nbuild failed (first 300 chars): cmd \"make\" exited with exit code 2 and output:\n/usr/bin/g++ -O2 -ftree-vectorize -march=native -fno-math-errno -std=c++14 -c -o core.o core.cpp\ng++: error: unrecognized command line option '-std=c++14' (took 1 sec)\n== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log\nERROR: Build of /home/easybuild/subread.eb failed (err: ...)\n</code></pre> <p>Let's break this down a bit: during the <code>build</code> step of the installation procedure EasyBuild was running <code>make</code> as a shell command, which failed (exit code 2, so not zero). The <code>make</code> command tripped over the compilation of <code>core.cpp</code> that failed because <code>-std=c++14</code> is not a known option to the <code>g++</code> command.</p> <p>OK fine, but now what? Can you spot something suspicious here? Wait a minute... Why is <code>make</code> using <code>/usr/bin/g++</code> for the compilation?! That's not where our toolchain compiler is installed, that's somewhere under <code>/easybuild/software</code>.</p> <p>Let's see what <code>/usr/bin/g++</code> is:</p> <pre><code>$ /usr/bin/g++ --version\ng++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44)\n</code></pre> <p>Oh my that's pretty ancient (GCC 4.8.5 was released in June 2015). That could definitely explain why it doesn't know about the C++14 standard yet...</p> <p>Your next step in this case should probably be figuring out why <code>/usr/bin/g++</code> is being used rather than just <code>g++</code>, which would result in using the right compiler version because EasyBuild sets up the build environment carefully.</p> <p>This is a imaginary example of course, but hopefully it gives you a feeling of how errors that occur during the installation are handled.</p>"},{"location":"2022-isc22/troubleshooting/#easybuild-log-files","title":"EasyBuild log files","text":"<p>Finding the cause of a problem that made the installation fail is, unfortunately, not always that straightforward...</p> <p>EasyBuild includes (only) the first 300 characters of the output produced by a failing shell command in the error message, which is a simple way to try include actionable information in the error message while not flooding your terminal with the full output of the command that failed.</p> <p>In some cases there won't be any useful information in there however, since the actual error message(s) could only appear way later, perhaps even after the command was already running for several minutes.</p> <p>In that case, you will have the dive into the log file that is created by EasyBuild for every installation, which is located in the unique temporary directory for the EasyBuild session.</p> <p>See for example this output line from our earlier example error message:</p> <pre><code>== Results of the build can be found in the log file(s) /tmp/eb-dbobppfh/easybuild-example-1.0-20200613.145414.aUEJA.log\n</code></pre> <p>You can open this file with your favorite text editor or a tool like <code>less</code> to take a look at the information collected in the log file, which includes things like:</p> <ul> <li>informative messages produced by both the EasyBuild framework and the easyblock   describing how the installation is progressing;</li> <li>how the build environment was set up: which modules were loaded, which environment variables were set;</li> <li>the exact shell commands that were executed, and in which directory they were run;</li> <li>the full output produced by these commands, and their exit code;</li> </ul> <p>Note that the installation log is also copied into each software installation directory for successful installation, into the <code>easybuild</code> subdirectory. For example:</p> <pre><code>/easybuild/software/HDF5/1.10.7-gompi-2020b/easybuild/easybuild-HDF5-1.10.7-20210616.055237.log\n</code></pre>"},{"location":"2022-isc22/troubleshooting/#last-log","title":"Last log","text":"<p>The <code>eb</code> command supports a handy little option that prints the location to the most recently updated build log. You can leverage this to quickly open the build log of the last failed EasyBuild session in an editor:</p> <pre><code>vim $(eb --last-log)\n</code></pre>"},{"location":"2022-isc22/troubleshooting/#navigating-log-files","title":"Navigating log files","text":"<p>Usually you want to go to the end of the log file and then work your way up, either by scrolling or by searching for specific patterns. Here are a couple of suggestions of patterns you can use to locate errors:</p> <ul> <li><code>ERROR</code></li> <li><code>Error 1</code></li> <li><code>error:</code></li> <li><code>failure</code></li> <li><code>not found</code></li> <li><code>No such file or directory</code></li> <li><code>bazel</code></li> <li><code>Segmentation fault</code></li> </ul> <p>Using \"<code>error</code>\" as a search pattern is not very useful: you will hit a lot of log lines that are not actually errors at all (like the compilation of an <code>error.c</code> file), and you will miss others that do include errors but mention <code>ERROR</code> or <code>Error</code> rather than <code>error</code>.</p> <p>When using <code>less</code> to view a log file, you can navigate it by:</p> <ul> <li>hitting '<code>$</code>' followed by '<code>G</code>' to go to the end of the log file;</li> <li>using your arrow keys to scroll up/down;</li> <li>typing '<code>?</code>' followed by some text and Enter to search backwards for a particular pattern ('<code>/</code>' to search forwards, '<code>n</code>' for next match);</li> <li>hitting '<code>q</code>' to exit;</li> </ul> <p>It can also be helpful to zoom in on a specific step of the installation procedure, which you can do by looking for step markers like these:</p> <pre><code>== 2020-06-13 01:34:48,816 example INFO configuring...\n== 2020-06-13 01:34:48,817 example INFO Starting configure step\n...\n== 2020-06-13 01:34:48,823 main.EB_HPL INFO Running method configure_step part of step configure\n</code></pre> <p>If you want to look at the start of the output produced by a particular command, you can look for the log message that looks like this (this is from the installation log for <code>HDF5</code>):</p> <pre><code>== 2020-06-09 13:11:19,968 run.py:222 INFO running cmd:  make install\n== 2020-06-09 13:11:25,186 run.py:538 INFO cmd \" make install \" exited with exit code 0 and output:\nMaking install in src\nmake[1]: Entering directory `/tmp/example/HDF5/1.10.7/gompi-2020b/hdf5-1.10.7/src'\n...\n</code></pre> <p>It can be useful to look for the first error that occurred in the output of a command, since subsequent errors are often fallout from earlier errors. You can do this by first navigating to the start of the output for a command using \"<code>INFO running cmd</code>\" as a search pattern, and then looking for patterns like \"<code>error:</code>\" from there.</p>"},{"location":"2022-isc22/troubleshooting/#inspecting-the-build-directory","title":"Inspecting the build directory","text":"<p>When an installation fails the corresponding build directory is not cleaned up automatically, that is only done for successful installations. This allows you to dive in and check for clues in the files that are stored there.</p> <p>The location of the build directory is mentioned in the EasyBuild error message:</p> <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/example/1.0/GCC-11.2.0): ...\n</code></pre> <p>For software using a classic <code>configure</code> script, you may have to locate and inspect the <code>config.log</code> file in the build directory to determine the underlying cause of an error. For software using CMake as a configuration tool you often have to check in <code>CMakeOutput.log</code> or <code>CMakeError.log</code> for clues, which are sneakily hidden by CMake in a <code>CMakeFiles</code> subdirectory of the build directory.</p> <p>As a side note here: as EasyBuild does not clean out build directories for failed builds, you will need to eventually manually remove them from the <code>buildpath</code> directory.</p>"},{"location":"2022-isc22/troubleshooting/#exercise","title":"Exercise","text":"<p>Let's work our way through a less smooth software installation, using the easyconfig file that is provided below.</p> <p>Don't worry if most of this is still unclear to you, we'll get to writing easyconfig files from scratch later in this tutorial.</p> <pre><code>easyblock = 'MakeCp'\n\nname = 'Subread'\nversion = '2.0.3'\n\nhomepage = 'http://subread.sourceforge.net'\ndescription = \"High performance read alignment, quantification and mutation discovery\"\n\ntoolchain = {'name': 'GCC', 'version': '8.5.0'}\n\n# download from https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\nchecksums = ['56cef3a2f914d432713069d5c282f48831c3a1ecc89432ad5580caa322a5f56b']\n\nstart_dir = 'src'\n\n# -fcommon is required to compile Subread 2.0.3 with GCC 10,\n# which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html)\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"'\n\nfiles_to_copy = ['bin']\n\nsanity_check_paths = {\n    'files': ['bin/featureCounts', 'bin/subread-align'],\n    'dirs': ['bin/utilities'],\n}\n\nsanity_check_commands = [\"featureCounts --version\"]\n\nmoduleclass = 'bio'\n</code></pre> <p>Do you spot any potential problems yet with this easyconfig file?</p> <p>Preparation</p> <p>Start by copying the text above in a file named <code>subread.eb</code>, so you can gradually fix the problem you'll encounter.</p> <p>Also make sure that the pre-installed software stack is available, and that the EasyBuild module is loaded (unless you installed EasyBuild yourself):</p> <pre><code>module use /easybuild/modules/all\nmodule load EasyBuild\n</code></pre> <p>For this exercise, make sure EasyBuild is configured to use <code>$HOME/easybuild</code> as <code>prefix</code>, and to use <code>/tmp/$USER</code> as <code>buildpath</code>:</p> <pre><code>export EASYBUILD_PREFIX=$HOME/easybuild\nexport EASYBUILD_BUILDPATH=/tmp/$USER\n</code></pre> <p>Check your configuration via <code>eb --show-config</code>.</p> <p>Strictly speaking the configuration doesn't matter much for the sake of this exercise, but it may help with the step-wise approach we'll take and grasping the solutions.</p> <p>Note: If you run <code>eb --dry-run-short ...</code> you might first run into T.2 instead of T.1.</p> <p>Remember though: no peeking before you tried to solve each step yourself!</p> <p>Exercise T.1 - Sources</p> <p>Try to install the <code>subread.eb</code> easyconfig file, see what happens.</p> <p>Can you fix the problem you run into, perhaps without even changing the easyconfig file?</p> (click to show solution) <p>The installation fails because the source file <code>subread-2.0.3-source.tar.gz</code> is not found: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/example/Subread/2.0.3/GCC-8.5.0): build failed (first 300 chars):\nCouldn't find file subread-2.0.3-source.tar.gz anywhere, and downloading it didn't work either...\nPaths attempted (in order): ...\n</code></pre></p> <p>In this case, the problem is that the easyconfig file does not specify where the sources can be downloaded from. Not automatically at least, but there is a helpful comment included: <pre><code># download from https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre></p> <p>We can download the source tarball ourselves, and move it to the location where EasyBuild expects to find it (in the <code>sourcepath</code> directory): <pre><code>curl -OL https://download.sourceforge.net/subread/subread-2.0.3-source.tar.gz\nmv subread-2.0.3-source.tar.gz $HOME/easybuild/sources/s/Subread/\n</code></pre></p> <p>If downloading is problematic for some reason, the source tarball is also available in <code>/easybuild/sources/s/Subread</code>.</p> <p>Or, we can change the easyconfig file to specify the location where the easyconfig file can be downloaded from: <pre><code>source_urls = ['https://download.sourceforge.net/subread/']\nsources = ['subread-%(version)s-source.tar.gz']\n</code></pre> Note that the <code>source_urls</code> value is a list of candidate download URLs, without the filename of the source file itself.</p> <p>This way, EasyBuild will download the source file when running <code>eb subread.eb</code>.</p> <p>The source tarball is fairly large (23MB), so don't be alarmed if the download takes a little while.</p> <pre><code>$ ls -lh $HOME/easybuild/sources/s/Subread\ntotal 23M\n-rw-rw-r-- 1 easybuild easybuild 23M Mai 19 15:21 subread-2.0.3-source.tar.gz\n</code></pre> <p>Exercise T.2 - Toolchain</p> <p>After fixing the problem with missing source file, try the installation again.</p> <p>What's wrong now? How can you fix it quickly?</p> <p>Take into account that we just want to get this software package installed, we don't care too much about details like the version of the dependencies or the toolchain here...</p> (click to show solution) <p>The installation fails because the easyconfig specifies that GCC 8.5.0 should be used as toolchain: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-8.5.0): build failed (first 300 chars):\nNo module found for toolchain: GCC/8.5.0 (took 1 sec)\n</code></pre></p> <p>We don't have this GCC version installed as a module, but we do have GCC 11.2.0:</p> <pre><code>$ module avail GCC/\n----------------- /easybuild/modules/all ------------------\n   GCC/11.2.0\n</code></pre> <p>So let's try using that instead.</p> <p>Edit the easyconfig file so it contains this:</p> <pre><code>toolchain = {'name': 'GCC', 'version': '11.2.0'}\n</code></pre> <p>Exercise T.3 - Build step</p> <p>With the first two problems fixed, now we can actually try to build the software.</p> <p>Can you fix the next problem you run into?</p> (click to show solution) <p>The compilation fails, but the error message we see is incomplete due to EasyBuild truncating the command output (only the 300 first characters of the output are shown): <pre><code>== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-11.2.0): build failed (first 300 chars):\ncmd \" make -j 1 -f Makefile.Linux CFLAGS=\"-fast -fcommon\"\" exited with exit code 2 and output:\ngcc  -mtune=core2  -O3 -DMAKE_FOR_EXON  -D MAKE_STANDALONE -D SUBREAD_VERSION=\\\"\"2.0.3\"\\\"  -D_FILE_OFFSET_BITS=64    -fmessage-length=0  -ggdb  -fast -fcommon  -c -o core.o core.c\ngcc: error: unrecognized command line opti (took 1 sec)\n</code></pre></p> <p>If you open the log file and scroll to the end, the error is pretty obvious: <pre><code>gcc: error: unrecognized command line option -fast; did you mean -Ofast?\nmake: *** [core.o] Error 1\n</code></pre></p> <p>The easyconfig file hard specifies the <code>-fast</code> compiler flag via the <code>CFLAGS</code> argument to the build command: <pre><code># -fcommon is required to compile Subread 2.0.3 with GCC 10,\n# which uses -fno-common by default (see https://www.gnu.org/software/gcc/gcc-10/porting_to.html)\nbuildopts = '-f Makefile.Linux CFLAGS=\"-fast -fcommon\"'\n</code></pre></p> <p>EasyBuild sets up the build environment, so there should be no need to hard specify compiler flags (certainly not incorrect ones). The comment above the <code>buildopts</code> definition makes it clear that the <code>-fcommon</code> flag is required though, because GCC 10 became a bit stricter by using <code>-fno-common</code> by default. Note that we are using <code>-fcommon</code> as an escape mechanism here: it would be better to fix the source code and create a patch file instead.</p> <p>An easy way to fix this problem is to replace the <code>-fast</code> with <code>-Ofast</code>, as the compiler error suggests.</p> <p>In this case it is advised to change the <code>CFLAGS</code> argument that is added to be build command to replace the <code>-fast</code> with <code>$CFLAGS</code>, which is defined in the build environment by EasyBuild.</p> <pre><code>buildopts = '-f Makefile.Linux CFLAGS=\"$CFLAGS -fcommon\"'\n</code></pre> <p>Note that we need to be careful with quotes here: we use inner double quotes to ensure that <code>$CFLAGS</code> will be expanded to its value when the build command is run.</p> <p>Exercise T.4 - Sanity check</p> <p>After fixing the compilation issue, you're really close to getting the installation working, we promise!</p> <p>Don't give up now, try one last time and fix the last problem that occurs...</p> (click to show solution) <p>Now the installation itself works but the sanity check fails, and hence the module file does not get generated: <pre><code>$ eb subread.eb\n...\n== FAILED: Installation ended unsuccessfully (build directory: /tmp/easybuild/Subread/2.0.3/GCC-11.2.0): build failed (first 300 chars):\nSanity check failed: sanity check command featureCounts --version exited with code 255\n(output: featureCounts: unrecognized option '--version'\n...\n</code></pre></p> <p>If you look at the full output in the log file you can see that the correct option to check the version of the <code>featureCounts</code> command is \"<code>-v</code>\" rather than \"<code>--version</code>\", so we need to fix this in the easyconfig file.</p> <p>Make the following change in the easyconfig file: <pre><code>sanity_check_commands = [\"featureCounts -v\"]\n</code></pre></p> <p>After doing so, you don't have to redo the installation from scratch, you can use the <code>--module-only</code> option to only run the sanity check and generate the module file again: <pre><code>eb subread.eb --module-only\n</code></pre></p> <p>In the end, you should be able to install Subread 2.0.3 with the GCC 11.2.0 toolchain by fixing the problems with the <code>subread.eb</code> easyconfig file.</p> <p>Check your work by manually loading the module and checking the version via the <code>featureCounts</code> command, which should look like this:</p> <pre><code>$ featureCounts -v\nfeatureCounts v2.0.3\n</code></pre> <p>next: Adding support for additional software - (back to overview page)</p>"}]}